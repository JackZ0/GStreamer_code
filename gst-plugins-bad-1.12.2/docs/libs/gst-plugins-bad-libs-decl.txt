<MACRO>
<NAME>_</NAME>
#define _(String) dgettext (GETTEXT_PACKAGE, String)
</MACRO>
<MACRO>
<NAME>N_</NAME>
#define N_(String) gettext_noop (String)
</MACRO>
<MACRO>
<NAME>ngettext</NAME>
#define ngettext(Singular,Plural,Count) ((Count>1)?Plural:Singular)
</MACRO>
<MACRO>
<NAME>gettext</NAME>
# define gettext(Msgid) ((const char *) (Msgid))
</MACRO>
<MACRO>
<NAME>dgettext</NAME>
# define dgettext(Domainname, Msgid) ((const char *) (Msgid))
</MACRO>
<MACRO>
<NAME>dcgettext</NAME>
# define dcgettext(Domainname, Msgid, Category) ((const char *) (Msgid))
</MACRO>
<MACRO>
<NAME>ngettext</NAME>
# define ngettext(Msgid1, Msgid2, N) \
    ((N) == 1 ? (const char *) (Msgid1) : (const char *) (Msgid2))
</MACRO>
<MACRO>
<NAME>dngettext</NAME>
# define dngettext(Domainname, Msgid1, Msgid2, N) \
    ((N) == 1 ? (const char *) (Msgid1) : (const char *) (Msgid2))
</MACRO>
<MACRO>
<NAME>dcngettext</NAME>
# define dcngettext(Domainname, Msgid1, Msgid2, N, Category) \
    ((N) == 1 ? (const char *) (Msgid1) : (const char *) (Msgid2))
</MACRO>
<MACRO>
<NAME>textdomain</NAME>
# define textdomain(Domainname) ((const char *) (Domainname))
</MACRO>
<MACRO>
<NAME>bindtextdomain</NAME>
# define bindtextdomain(Domainname, Dirname) ((const char *) (Dirname))
</MACRO>
<MACRO>
<NAME>bind_textdomain_codeset</NAME>
# define bind_textdomain_codeset(Domainname, Codeset) ((const char *) (Codeset))
</MACRO>
<MACRO>
<NAME>gettext_noop</NAME>
#define gettext_noop(String) String
</MACRO>
<FUNCTION>
<NAME>gst_gl_framebuffer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_FRAMEBUFFER</NAME>
#define GST_TYPE_GL_FRAMEBUFFER             (gst_gl_framebuffer_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_FRAMEBUFFER</NAME>
#define GST_GL_FRAMEBUFFER(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_FRAMEBUFFER,GstGLFramebuffer))
</MACRO>
<MACRO>
<NAME>GST_GL_FRAMEBUFFER_CLASS</NAME>
#define GST_GL_FRAMEBUFFER_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_GL_FRAMEBUFFER,GstGLFramebufferClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_FRAMEBUFFER</NAME>
#define GST_IS_GL_FRAMEBUFFER(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_FRAMEBUFFER))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_FRAMEBUFFER_CLASS</NAME>
#define GST_IS_GL_FRAMEBUFFER_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_GL_FRAMEBUFFER))
</MACRO>
<MACRO>
<NAME>GST_GL_FRAMEBUFFER_CAST</NAME>
#define GST_GL_FRAMEBUFFER_CAST(obj)        ((GstGLFramebuffer*)(obj))
</MACRO>
<USER_FUNCTION>
<NAME>GstGLFramebufferFunc</NAME>
<RETURNS>gboolean </RETURNS>
gpointer stuff
</USER_FUNCTION>
<STRUCT>
<NAME>GstGLFramebuffer</NAME>
struct _GstGLFramebuffer
{
  /* <private> */
  GstObject             object;

  GstGLContext *context;

  guint fbo_id;
  GArray *attachments;

  gpointer          _padding[GST_PADDING];

  GstGLFramebufferPrivate  *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstGLFramebufferClass</NAME>
struct _GstGLFramebufferClass
{
  /* <private> */
  GstObjectClass object_class;

  gpointer          _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_framebuffer_new</NAME>
<RETURNS>GstGLFramebuffer  *      </RETURNS>
GstGLContext *context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_framebuffer_new_with_default_depth</NAME>
<RETURNS>GstGLFramebuffer  *      </RETURNS>
GstGLContext *context, guint width, guint height
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_framebuffer_get_id</NAME>
<RETURNS>guint                    </RETURNS>
GstGLFramebuffer * fb
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_framebuffer_attach</NAME>
<RETURNS>void                     </RETURNS>
GstGLFramebuffer * fb, guint attachment_point, GstGLBaseMemory * mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_framebuffer_bind</NAME>
<RETURNS>void                     </RETURNS>
GstGLFramebuffer * fb
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_clear_framebuffer</NAME>
<RETURNS>void                     </RETURNS>
GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_framebuffer_get_effective_dimensions</NAME>
<RETURNS>void                     </RETURNS>
GstGLFramebuffer * fb, guint * width, guint * height
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_check_framebuffer_status</NAME>
<RETURNS>gboolean                 </RETURNS>
GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_framebuffer_draw_to_texture</NAME>
<RETURNS>gboolean                 </RETURNS>
GstGLFramebuffer * fb, GstGLMemory * mem, GstGLFramebufferFunc func, gpointer user_data
</FUNCTION>
<STRUCT>
<NAME>GstGLFramebufferPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GL_DO_NOT_WARN_IF_MULTI_GL_VERSION_HEADERS_INCLUDED</NAME>
#   define GL_DO_NOT_WARN_IF_MULTI_GL_VERSION_HEADERS_INCLUDED
</MACRO>
<MACRO>
<NAME>GSTGLAPI</NAME>
#define GSTGLAPI WINAPI
</MACRO>
<ENUM>
<NAME>GstGLAPI</NAME>
typedef enum {
  GST_GL_API_NONE = 0,
  GST_GL_API_OPENGL = (1 << 0),
  GST_GL_API_OPENGL3 = (1 << 1),
  GST_GL_API_GLES1 = (1 << 15),
  GST_GL_API_GLES2 = (1 << 16),

  GST_GL_API_ANY = G_MAXUINT32
} GstGLAPI;
</ENUM>
<MACRO>
<NAME>GST_GL_API_OPENGL_NAME</NAME>
#define GST_GL_API_OPENGL_NAME "opengl"
</MACRO>
<MACRO>
<NAME>GST_GL_API_OPENGL3_NAME</NAME>
#define GST_GL_API_OPENGL3_NAME "opengl3"
</MACRO>
<MACRO>
<NAME>GST_GL_API_GLES1_NAME</NAME>
#define GST_GL_API_GLES1_NAME "gles1"
</MACRO>
<MACRO>
<NAME>GST_GL_API_GLES2_NAME</NAME>
#define GST_GL_API_GLES2_NAME "gles2"
</MACRO>
<ENUM>
<NAME>GstGLPlatform</NAME>
typedef enum
{
  GST_GL_PLATFORM_NONE = 0,
  GST_GL_PLATFORM_EGL = (1 << 0),
  GST_GL_PLATFORM_GLX = (1 << 1),
  GST_GL_PLATFORM_WGL = (1 << 2),
  GST_GL_PLATFORM_CGL = (1 << 3),
  GST_GL_PLATFORM_EAGL = (1 << 4),

  GST_GL_PLATFORM_ANY = G_MAXUINT32
} GstGLPlatform;
</ENUM>
<MACRO>
<NAME>GST_GL_EXT_BEGIN</NAME>
#define GST_GL_EXT_BEGIN(name, gl_availability, min_gl, maj_gl, gles_maj, \
    gles_min, ext_suf, ext_name)
</MACRO>
<MACRO>
<NAME>GST_GL_EXT_FUNCTION</NAME>
#define GST_GL_EXT_FUNCTION(ret, name, args) \
  ret (GSTGLAPI *name) args;
</MACRO>
<MACRO>
<NAME>GST_GL_EXT_END</NAME>
#define GST_GL_EXT_END()
</MACRO>
<FUNCTION>
<NAME>gst_gl_api_to_string</NAME>
<RETURNS>gchar  * </RETURNS>
GstGLAPI api
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_api_from_string</NAME>
<RETURNS>GstGLAPI  </RETURNS>
const gchar * api_s
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_platform_to_string</NAME>
<RETURNS>gchar  * </RETURNS>
GstGLPlatform platform
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_platform_from_string</NAME>
<RETURNS>GstGLPlatform  </RETURNS>
const gchar * platform_s
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_color_convert_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_COLOR_CONVERT</NAME>
#define GST_TYPE_GL_COLOR_CONVERT (gst_gl_color_convert_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_COLOR_CONVERT</NAME>
#define GST_GL_COLOR_CONVERT(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_COLOR_CONVERT,GstGLColorConvert))
</MACRO>
<MACRO>
<NAME>GST_GL_COLOR_CONVERT_CLASS</NAME>
#define GST_GL_COLOR_CONVERT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_DISPLAY,GstGLColorConvertClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_COLOR_CONVERT</NAME>
#define GST_IS_GL_COLOR_CONVERT(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_COLOR_CONVERT))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_COLOR_CONVERT_CLASS</NAME>
#define GST_IS_GL_COLOR_CONVERT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_COLOR_CONVERT))
</MACRO>
<MACRO>
<NAME>GST_GL_COLOR_CONVERT_CAST</NAME>
#define GST_GL_COLOR_CONVERT_CAST(obj) ((GstGLColorConvert*)(obj))
</MACRO>
<STRUCT>
<NAME>GstGLColorConvert</NAME>
struct _GstGLColorConvert
{
  /* <private> */
  GstObject        parent;

  GstGLContext    *context;

  /* input data */
  GstVideoInfo     in_info;
  GstVideoInfo     out_info;

  gboolean         initted;
  gboolean         passthrough;

  GstBuffer *    inbuf;
  GstBuffer *    outbuf;

  /* used for the conversion */
  GstGLFramebuffer *fbo;
  GstGLShader     *shader;

  /* <private> */
  GstGLColorConvertPrivate *priv;

  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLColorConvertClass</NAME>
struct _GstGLColorConvertClass
{
  /* <private> */
  GstObjectClass object_class;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<MACRO>
<NAME>GST_GL_COLOR_CONVERT_FORMATS</NAME>
#define GST_GL_COLOR_CONVERT_FORMATS "{ RGBA, RGB, RGBx, BGR, BGRx, BGRA, xRGB, " \
                               "xBGR, ARGB, ABGR, Y444, I420, YV12, Y42B, " \
                               "Y41B, NV12, NV21, YUY2, UYVY, AYUV, " \
                               "GRAY8, GRAY16_LE, GRAY16_BE, RGB16, BGR16 }"
</MACRO>
<MACRO>
<NAME>GST_GL_COLOR_CONVERT_VIDEO_CAPS</NAME>
#define GST_GL_COLOR_CONVERT_VIDEO_CAPS \
    "video/x-raw(" GST_CAPS_FEATURE_MEMORY_GL_MEMORY "), "              \
    "format = (string) " GST_GL_COLOR_CONVERT_FORMATS ", "              \
    "width = " GST_VIDEO_SIZE_RANGE ", "                                \
    "height = " GST_VIDEO_SIZE_RANGE ", "                               \
    "framerate = " GST_VIDEO_FPS_RANGE ", "                             \
    "texture-target = (string) { 2D, rectangle, external-oes } "        \
    " ; "                                                               \
    "video/x-raw(" GST_CAPS_FEATURE_MEMORY_GL_MEMORY ","                \
    GST_CAPS_FEATURE_META_GST_VIDEO_OVERLAY_COMPOSITION "), "           \
    "format = (string) " GST_GL_COLOR_CONVERT_FORMATS ", "              \
    "width = " GST_VIDEO_SIZE_RANGE ", "                                \
    "height = " GST_VIDEO_SIZE_RANGE ", "                               \
    "framerate = " GST_VIDEO_FPS_RANGE ", "                             \
    "texture-target = (string) { 2D, rectangle, external-oes }"
</MACRO>
<FUNCTION>
<NAME>gst_gl_color_convert_new</NAME>
<RETURNS>GstGLColorConvert  * </RETURNS>
GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_color_convert_transform_caps</NAME>
<RETURNS>GstCaps  *   </RETURNS>
GstGLContext * context, GstPadDirection direction, GstCaps * caps, GstCaps * filter
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_color_convert_fixate_caps</NAME>
<RETURNS>GstCaps  *   </RETURNS>
GstGLContext * context, GstPadDirection direction, GstCaps * caps, GstCaps * other
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_color_convert_set_caps</NAME>
<RETURNS>gboolean     </RETURNS>
GstGLColorConvert * convert, GstCaps           * in_caps, GstCaps           * out_caps
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_color_convert_decide_allocation</NAME>
<RETURNS>gboolean     </RETURNS>
GstGLColorConvert   * convert, GstQuery            * query
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_color_convert_perform</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstGLColorConvert * convert, GstBuffer * inbuf
</FUNCTION>
<MACRO>
<NAME>GST_GL_HAVE_OPENGL</NAME>
#define GST_GL_HAVE_OPENGL 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_GLES2</NAME>
#define GST_GL_HAVE_GLES2 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_GLES3</NAME>
#define GST_GL_HAVE_GLES3 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_WINDOW_X11</NAME>
#define GST_GL_HAVE_WINDOW_X11 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_WINDOW_COCOA</NAME>
#define GST_GL_HAVE_WINDOW_COCOA 0
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_WINDOW_WIN32</NAME>
#define GST_GL_HAVE_WINDOW_WIN32 0
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_WINDOW_WAYLAND</NAME>
#define GST_GL_HAVE_WINDOW_WAYLAND 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_WINDOW_ANDROID</NAME>
#define GST_GL_HAVE_WINDOW_ANDROID 0
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_WINDOW_DISPMANX</NAME>
#define GST_GL_HAVE_WINDOW_DISPMANX 0
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_WINDOW_EAGL</NAME>
#define GST_GL_HAVE_WINDOW_EAGL 0
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_WINDOW_VIV_FB</NAME>
#define GST_GL_HAVE_WINDOW_VIV_FB 0
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_PLATFORM_EGL</NAME>
#define GST_GL_HAVE_PLATFORM_EGL 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_PLATFORM_GLX</NAME>
#define GST_GL_HAVE_PLATFORM_GLX 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_PLATFORM_WGL</NAME>
#define GST_GL_HAVE_PLATFORM_WGL 0
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_PLATFORM_CGL</NAME>
#define GST_GL_HAVE_PLATFORM_CGL 0
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_PLATFORM_EAGL</NAME>
#define GST_GL_HAVE_PLATFORM_EAGL 0
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_DMABUF</NAME>
#define GST_GL_HAVE_DMABUF 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_VIV_DIRECTVIV</NAME>
#define GST_GL_HAVE_VIV_DIRECTVIV 0
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_GLEGLIMAGEOES</NAME>
#define GST_GL_HAVE_GLEGLIMAGEOES 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_GLCHAR</NAME>
#define GST_GL_HAVE_GLCHAR 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_GLSIZEIPTR</NAME>
#define GST_GL_HAVE_GLSIZEIPTR 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_GLINTPTR</NAME>
#define GST_GL_HAVE_GLINTPTR 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_GLSYNC</NAME>
#define GST_GL_HAVE_GLSYNC 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_GLUINT64</NAME>
#define GST_GL_HAVE_GLUINT64 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_GLINT64</NAME>
#define GST_GL_HAVE_GLINT64 1
</MACRO>
<MACRO>
<NAME>GST_GL_HAVE_EGLATTRIB</NAME>
#define GST_GL_HAVE_EGLATTRIB 1
</MACRO>
<FUNCTION>
<NAME>gst_gl_context_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_CONTEXT</NAME>
#define GST_TYPE_GL_CONTEXT         (gst_gl_context_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_TYPE_CONTEXT</NAME>
<DEPRECATED/>
#define GST_GL_TYPE_CONTEXT GST_TYPE_GL_CONTEXT
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT</NAME>
#define GST_GL_CONTEXT(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_CONTEXT, GstGLContext))
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_CLASS</NAME>
#define GST_GL_CONTEXT_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GST_TYPE_GL_CONTEXT, GstGLContextClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_CONTEXT</NAME>
#define GST_IS_GL_CONTEXT(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_CONTEXT))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_CONTEXT_CLASS</NAME>
#define GST_IS_GL_CONTEXT_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_CONTEXT))
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_GET_CLASS</NAME>
#define GST_GL_CONTEXT_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_CONTEXT, GstGLContextClass))
</MACRO>
<FUNCTION>
<NAME>gst_gl_context_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_GL_CONTEXT_ERROR</NAME>
#define GST_GL_CONTEXT_ERROR (gst_gl_context_error_quark ())
</MACRO>
<USER_FUNCTION>
<NAME>GstGLContextThreadFunc</NAME>
<RETURNS>void </RETURNS>
GstGLContext * context, gpointer data
</USER_FUNCTION>
<MACRO>
<NAME>GST_GL_CONTEXT_TYPE_CGL</NAME>
#define GST_GL_CONTEXT_TYPE_CGL "gst.gl.context.CGL"
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_TYPE_GLX</NAME>
#define GST_GL_CONTEXT_TYPE_GLX "gst.gl.context.GLX"
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_TYPE_EGL</NAME>
#define GST_GL_CONTEXT_TYPE_EGL "gst.gl.context.EGL"
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_TYPE_WGL</NAME>
#define GST_GL_CONTEXT_TYPE_WGL "gst.gl.context.WGL"
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_TYPE_EAGL</NAME>
#define GST_GL_CONTEXT_TYPE_EAGL "gst.gl.context.EAGL"
</MACRO>
<ENUM>
<NAME>GstGLContextError</NAME>
typedef enum
{
  GST_GL_CONTEXT_ERROR_FAILED,
  GST_GL_CONTEXT_ERROR_WRONG_CONFIG,
  GST_GL_CONTEXT_ERROR_WRONG_API,
  GST_GL_CONTEXT_ERROR_OLD_LIBS,
  GST_GL_CONTEXT_ERROR_CREATE_CONTEXT,
  GST_GL_CONTEXT_ERROR_RESOURCE_UNAVAILABLE,
} GstGLContextError;
</ENUM>
<STRUCT>
<NAME>GstGLContext</NAME>
struct _GstGLContext {
  /*< private >*/
  GstObject parent;

  GstGLDisplay *display;
  GstGLWindow  *window;

  /*< public >*/
  GstGLFuncs *gl_vtable;

  /*< private >*/
  GstGLContextPrivate *priv;

  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLContextClass</NAME>
struct _GstGLContextClass {
  GstObjectClass parent_class;

  guintptr      (*get_current_context) (void);
  guintptr      (*get_gl_context)     (GstGLContext *context);
  GstGLAPI      (*get_gl_api)         (GstGLContext *context);
  GstGLPlatform (*get_gl_platform)    (GstGLContext *context);
  gpointer      (*get_proc_address)   (GstGLAPI gl_api, const gchar *name);
  gboolean      (*activate)           (GstGLContext *context, gboolean activate);
  gboolean      (*choose_format)      (GstGLContext *context, GError **error);
  gboolean      (*create_context)     (GstGLContext *context, GstGLAPI gl_api,
                                       GstGLContext *other_context, GError ** error);
  void          (*destroy_context)    (GstGLContext *context);
  void          (*swap_buffers)       (GstGLContext *context);
  gboolean      (*check_feature)      (GstGLContext *context, const gchar *feature);
  void          (*get_gl_platform_version) (GstGLContext *context, gint *major, gint *minor);

  /*< private >*/
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_context_new</NAME>
<RETURNS>GstGLContext  * </RETURNS>
GstGLDisplay *display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_new_wrapped</NAME>
<RETURNS>GstGLContext  * </RETURNS>
GstGLDisplay *display, guintptr handle, GstGLPlatform context_type, GstGLAPI available_apis
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_activate</NAME>
<RETURNS>gboolean       </RETURNS>
GstGLContext *context, gboolean activate
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_get_thread</NAME>
<RETURNS>GThread  *     </RETURNS>
GstGLContext *context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_get_current</NAME>
<RETURNS>GstGLContext  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_get_display</NAME>
<RETURNS>GstGLDisplay  * </RETURNS>
GstGLContext *context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_get_proc_address</NAME>
<RETURNS>gpointer       </RETURNS>
GstGLContext *context, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_get_gl_platform</NAME>
<RETURNS>GstGLPlatform  </RETURNS>
GstGLContext *context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_get_gl_api</NAME>
<RETURNS>GstGLAPI       </RETURNS>
GstGLContext *context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_get_gl_context</NAME>
<RETURNS>guintptr       </RETURNS>
GstGLContext *context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_can_share</NAME>
<RETURNS>gboolean       </RETURNS>
GstGLContext * context, GstGLContext *other_context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_create</NAME>
<RETURNS>gboolean       </RETURNS>
GstGLContext *context, GstGLContext *other_context, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_destroy</NAME>
<RETURNS>void           </RETURNS>
GstGLContext *context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_default_get_proc_address</NAME>
<RETURNS>gpointer       </RETURNS>
GstGLAPI gl_api, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_get_proc_address_with_platform</NAME>
<RETURNS>gpointer       </RETURNS>
GstGLPlatform context_type, GstGLAPI gl_api, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_set_window</NAME>
<RETURNS>gboolean       </RETURNS>
GstGLContext *context, GstGLWindow *window
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_get_window</NAME>
<RETURNS>GstGLWindow  * </RETURNS>
GstGLContext *context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_get_gl_version</NAME>
<RETURNS>void           </RETURNS>
GstGLContext *context, gint *maj, gint *min
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_check_gl_version</NAME>
<RETURNS>gboolean       </RETURNS>
GstGLContext * context, GstGLAPI api, gint maj, gint min
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_check_feature</NAME>
<RETURNS>gboolean       </RETURNS>
GstGLContext *context, const gchar *feature
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_get_gl_platform_version</NAME>
<RETURNS>void           </RETURNS>
GstGLContext * context, gint * major, gint * minor
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_get_current_gl_context</NAME>
<RETURNS>guintptr       </RETURNS>
GstGLPlatform context_type
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_get_current_gl_api</NAME>
<RETURNS>GstGLAPI       </RETURNS>
GstGLPlatform platform, guint *major, guint *minor
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_is_shared</NAME>
<RETURNS>gboolean       </RETURNS>
GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_set_shared_with</NAME>
<RETURNS>void           </RETURNS>
GstGLContext * context, GstGLContext * share
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_fill_info</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLContext * context, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_thread_add</NAME>
<RETURNS>void  </RETURNS>
GstGLContext * context, GstGLContextThreadFunc func, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_WINDOW</NAME>
#define GST_TYPE_GL_WINDOW         (gst_gl_window_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_TYPE_WINDOW</NAME>
<DEPRECATED/>
#define GST_GL_TYPE_WINDOW GST_TYPE_GL_WINDOW
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW</NAME>
#define GST_GL_WINDOW(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_WINDOW, GstGLWindow))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_CLASS</NAME>
#define GST_GL_WINDOW_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GST_TYPE_GL_WINDOW, GstGLWindowClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW</NAME>
#define GST_IS_GL_WINDOW(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_WINDOW))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_CLASS</NAME>
#define GST_IS_GL_WINDOW_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_WINDOW))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_GET_CLASS</NAME>
#define GST_GL_WINDOW_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_WINDOW, GstGLWindowClass))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_LOCK</NAME>
#define GST_GL_WINDOW_LOCK(w) g_mutex_lock(&GST_GL_WINDOW(w)->lock)
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_UNLOCK</NAME>
#define GST_GL_WINDOW_UNLOCK(w) g_mutex_unlock(&GST_GL_WINDOW(w)->lock)
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_GET_LOCK</NAME>
#define GST_GL_WINDOW_GET_LOCK(w) (&GST_GL_WINDOW(w)->lock)
</MACRO>
<FUNCTION>
<NAME>gst_gl_window_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_GL_WINDOW_ERROR</NAME>
#define GST_GL_WINDOW_ERROR (gst_gl_window_error_quark ())
</MACRO>
<ENUM>
<NAME>GstGLWindowError</NAME>
typedef enum
{
  GST_GL_WINDOW_ERROR_FAILED,
  GST_GL_WINDOW_ERROR_OLD_LIBS,
  GST_GL_WINDOW_ERROR_RESOURCE_UNAVAILABLE,
} GstGLWindowError;
</ENUM>
<USER_FUNCTION>
<NAME>GstGLWindowCB</NAME>
<RETURNS>void </RETURNS>
gpointer data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstGLWindowResizeCB</NAME>
<RETURNS>void </RETURNS>
gpointer data, guint width, guint height
</USER_FUNCTION>
<MACRO>
<NAME>GST_GL_WINDOW_CB</NAME>
#define	GST_GL_WINDOW_CB(f)			 ((GstGLWindowCB) (f))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_RESIZE_CB</NAME>
#define	GST_GL_WINDOW_RESIZE_CB(f)		 ((GstGLWindowResizeCB) (f))
</MACRO>
<STRUCT>
<NAME>GstGLWindow</NAME>
struct _GstGLWindow {
  /*< private >*/
  GstObject parent;

  GMutex        lock;

  GstGLDisplay *display;
  GWeakRef      context_ref;

  /*< protected >*/
  gboolean      is_drawing;

  GstGLWindowCB         draw;
  gpointer              draw_data;
  GDestroyNotify        draw_notify;
  GstGLWindowCB         close;
  gpointer              close_data;
  GDestroyNotify        close_notify;
  GstGLWindowResizeCB   resize;
  gpointer              resize_data;
  GDestroyNotify        resize_notify;

  gboolean              queue_resize;

  GMainContext         *main_context; /* default main_context */

  /*< private >*/
  GstGLWindowPrivate *priv;

  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLWindowClass</NAME>
struct _GstGLWindowClass {
  GstObjectClass parent_class;

  guintptr (*get_display)        (GstGLWindow *window);
  void     (*set_window_handle)  (GstGLWindow *window, guintptr handle);
  guintptr (*get_window_handle)  (GstGLWindow *window);
  void     (*draw)               (GstGLWindow *window);
  void     (*run)                (GstGLWindow *window);
  void     (*quit)               (GstGLWindow *window);
  void     (*send_message)       (GstGLWindow *window, GstGLWindowCB callback, gpointer data);
  void     (*send_message_async) (GstGLWindow *window, GstGLWindowCB callback, gpointer data, GDestroyNotify destroy);

  gboolean (*open)               (GstGLWindow *window, GError **error);
  void     (*close)              (GstGLWindow *window);
  void     (*handle_events)      (GstGLWindow *window, gboolean handle_events);
  void     (*set_preferred_size) (GstGLWindow *window, gint width, gint height);
  void     (*show)               (GstGLWindow *window);
  gboolean (*set_render_rectangle)(GstGLWindow *window, gint x, gint y, gint width, gint height);
  void     (*queue_resize)       (GstGLWindow *window);

  /*< private >*/
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_window_new</NAME>
<RETURNS>GstGLWindow  * </RETURNS>
GstGLDisplay *display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_set_draw_callback</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow *window, GstGLWindowCB callback, gpointer data, GDestroyNotify destroy_notify
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_set_resize_callback</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow *window, GstGLWindowResizeCB callback, gpointer data, GDestroyNotify destroy_notify
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_set_close_callback</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow *window, GstGLWindowCB callback, gpointer data, GDestroyNotify destroy_notify
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_set_window_handle</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow *window, guintptr handle
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_get_window_handle</NAME>
<RETURNS>guintptr  </RETURNS>
GstGLWindow *window
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_run</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow *window
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_quit</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow *window
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_send_message</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow *window, GstGLWindowCB callback, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_send_message_async</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow *window, GstGLWindowCB callback, gpointer data, GDestroyNotify destroy
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_handle_events</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow * window, gboolean handle_events
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_send_key_event</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow * window, const char * event_type, const char * key_str
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_send_mouse_event</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow * window, const char * event_type, int button, double posx, double posy
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_queue_resize</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow *window
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_draw</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow *window
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_show</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow *window
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_set_preferred_size</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow * window, gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_get_surface_dimensions</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow * window, guint * width, guint * height
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_set_render_rectangle</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLWindow * window, gint x, gint y, gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_resize</NAME>
<RETURNS>void      </RETURNS>
GstGLWindow *window, guint width, guint height
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_get_context</NAME>
<RETURNS>GstGLContext  * </RETURNS>
GstGLWindow *window
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_get_display</NAME>
<RETURNS>guintptr        </RETURNS>
GstGLWindow *window
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_DISPLAY</NAME>
#define GST_TYPE_GL_DISPLAY             (gst_gl_display_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY</NAME>
#define GST_GL_DISPLAY(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_DISPLAY,GstGLDisplay))
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_CLASS</NAME>
#define GST_GL_DISPLAY_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_GL_DISPLAY,GstGLDisplayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DISPLAY</NAME>
#define GST_IS_GL_DISPLAY(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_DISPLAY))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DISPLAY_CLASS</NAME>
#define GST_IS_GL_DISPLAY_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_GL_DISPLAY))
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_CAST</NAME>
#define GST_GL_DISPLAY_CAST(obj)        ((GstGLDisplay*)(obj))
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_GET_CLASS</NAME>
#define GST_GL_DISPLAY_GET_CLASS(o)     (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_DISPLAY, GstGLDisplayClass))
</MACRO>
<ENUM>
<NAME>GstGLDisplayType</NAME>
typedef enum
{
  GST_GL_DISPLAY_TYPE_NONE = 0,
  GST_GL_DISPLAY_TYPE_X11 = (1 << 0),
  GST_GL_DISPLAY_TYPE_WAYLAND = (1 << 1),
  GST_GL_DISPLAY_TYPE_COCOA = (1 << 2),
  GST_GL_DISPLAY_TYPE_WIN32 = (1 << 3),
  GST_GL_DISPLAY_TYPE_DISPMANX = (1 << 4),
  GST_GL_DISPLAY_TYPE_EGL = (1 << 5),
  GST_GL_DISPLAY_TYPE_VIV_FB = (1 << 6),

  GST_GL_DISPLAY_TYPE_ANY = G_MAXUINT32
} GstGLDisplayType;
</ENUM>
<STRUCT>
<NAME>GstGLDisplay</NAME>
struct _GstGLDisplay
{
  /* <private> */
  GstObject             object;

  GstGLDisplayType      type;

  /* <protected> */
  GList                    *windows;        /* OBJECT lock */
  GMainContext             *main_context;
  GMainLoop                *main_loop;
  GSource                  *event_source;

  GstGLDisplayPrivate  *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstGLDisplayClass</NAME>
struct _GstGLDisplayClass
{
  GstObjectClass object_class;

  guintptr          (*get_handle)      (GstGLDisplay * display);
  GstGLWindow *     (*create_window)    (GstGLDisplay * display);

  /* <private> */
  gpointer _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_display_new</NAME>
<RETURNS>GstGLDisplay  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>gst_gl_display_lock</NAME>
#define gst_gl_display_lock(display)        GST_OBJECT_LOCK (display)
</MACRO>
<MACRO>
<NAME>gst_gl_display_unlock</NAME>
#define gst_gl_display_unlock(display)      GST_OBJECT_UNLOCK (display)
</MACRO>
<FUNCTION>
<NAME>gst_gl_display_get_handle</NAME>
<RETURNS>guintptr          </RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_get_handle_type</NAME>
<RETURNS>GstGLDisplayType  </RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_filter_gl_api</NAME>
<RETURNS>void              </RETURNS>
GstGLDisplay * display, GstGLAPI gl_api
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_get_gl_api</NAME>
<RETURNS>GstGLAPI          </RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_get_gl_api_unlocked</NAME>
<RETURNS>GstGLAPI          </RETURNS>
GstGLDisplay * display
</FUNCTION>
<MACRO>
<NAME>GST_GL_DISPLAY_CONTEXT_TYPE</NAME>
#define GST_GL_DISPLAY_CONTEXT_TYPE "gst.gl.GLDisplay"
</MACRO>
<FUNCTION>
<NAME>gst_context_set_gl_display</NAME>
<RETURNS>void      </RETURNS>
GstContext * context, GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_context_get_gl_display</NAME>
<RETURNS>gboolean  </RETURNS>
GstContext * context, GstGLDisplay ** display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_create_context</NAME>
<RETURNS>gboolean   </RETURNS>
GstGLDisplay * display, GstGLContext * other_context, GstGLContext ** p_context, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_get_gl_context_for_thread</NAME>
<RETURNS>GstGLContext  * </RETURNS>
GstGLDisplay * display, GThread * thread
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_add_context</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLDisplay * display, GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_create_window</NAME>
<RETURNS>GstGLWindow  *   </RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_remove_window</NAME>
<RETURNS>gboolean         </RETURNS>
GstGLDisplay * display, GstGLWindow * window
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_find_window</NAME>
<RETURNS>GstGLWindow  *   </RETURNS>
GstGLDisplay * display, gpointer data, GCompareFunc compare_func
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_upload_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_UPLOAD</NAME>
#define GST_TYPE_GL_UPLOAD (gst_gl_upload_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_UPLOAD</NAME>
#define GST_GL_UPLOAD(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_UPLOAD,GstGLUpload))
</MACRO>
<MACRO>
<NAME>GST_GL_UPLOAD_CLASS</NAME>
#define GST_GL_UPLOAD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_UPLOAD,GstGLUploadClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_UPLOAD</NAME>
#define GST_IS_GL_UPLOAD(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_UPLOAD))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_UPLOAD_CLASS</NAME>
#define GST_IS_GL_UPLOAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_UPLOAD))
</MACRO>
<MACRO>
<NAME>GST_GL_UPLOAD_CAST</NAME>
#define GST_GL_UPLOAD_CAST(obj) ((GstGLUpload*)(obj))
</MACRO>
<ENUM>
<NAME>GstGLUploadReturn</NAME>
typedef enum
{
  GST_GL_UPLOAD_DONE = 1,

  GST_GL_UPLOAD_ERROR = -1,
  GST_GL_UPLOAD_UNSUPPORTED = -2,
  GST_GL_UPLOAD_RECONFIGURE = -3,
  /* <private> */
  GST_GL_UPLOAD_UNSHARED_GL_CONTEXT = -100,
} GstGLUploadReturn;
</ENUM>
<STRUCT>
<NAME>GstGLUpload</NAME>
struct _GstGLUpload
{
  GstObject        parent;

  GstGLContext    *context;

  /* <private> */
  GstGLUploadPrivate *priv;

  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLUploadClass</NAME>
struct _GstGLUploadClass
{
  GstObjectClass object_class;

  /* <private> */
  gpointer _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_upload_get_input_template_caps</NAME>
<RETURNS>GstCaps  *     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_upload_new</NAME>
<RETURNS>GstGLUpload  * </RETURNS>
GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_upload_set_context</NAME>
<RETURNS>void           </RETURNS>
GstGLUpload * upload, GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_upload_transform_caps</NAME>
<RETURNS>GstCaps  *     </RETURNS>
GstGLUpload * upload, GstGLContext * context, GstPadDirection direction, GstCaps * caps, GstCaps * filter
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_upload_set_caps</NAME>
<RETURNS>gboolean       </RETURNS>
GstGLUpload * upload, GstCaps * in_caps, GstCaps * out_caps
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_upload_get_caps</NAME>
<RETURNS>void           </RETURNS>
GstGLUpload * upload, GstCaps ** in_caps, GstCaps ** out_caps
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_upload_propose_allocation</NAME>
<RETURNS>void           </RETURNS>
GstGLUpload * upload, GstQuery * decide_query, GstQuery * query
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_upload_perform_with_buffer</NAME>
<RETURNS>GstGLUploadReturn  </RETURNS>
GstGLUpload * upload, GstBuffer * buffer, GstBuffer ** outbuf_ptr
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_MEMORY_PBO_ALLOCATOR</NAME>
#define GST_TYPE_GL_MEMORY_PBO_ALLOCATOR (gst_gl_memory_pbo_allocator_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_gl_memory_pbo_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_IS_GL_MEMORY_PBO_ALLOCATOR</NAME>
#define GST_IS_GL_MEMORY_PBO_ALLOCATOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_GL_MEMORY_PBO_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_MEMORY_PBO_ALLOCATOR_CLASS</NAME>
#define GST_IS_GL_MEMORY_PBO_ALLOCATOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_GL_MEMORY_PBO_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_GL_MEMORY_PBO_ALLOCATOR_GET_CLASS</NAME>
#define GST_GL_MEMORY_PBO_ALLOCATOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_GL_MEMORY_PBO_ALLOCATOR, GstGLMemoryPBOAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_GL_MEMORY_PBO_ALLOCATOR</NAME>
#define GST_GL_MEMORY_PBO_ALLOCATOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_GL_MEMORY_PBO_ALLOCATOR, GstGLMemoryPBOAllocator))
</MACRO>
<MACRO>
<NAME>GST_GL_MEMORY_PBO_ALLOCATOR_CLASS</NAME>
#define GST_GL_MEMORY_PBO_ALLOCATOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_GL_MEMORY_PBO_ALLOCATOR, GstGLAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_GL_MEMORY_PBO_ALLOCATOR_CAST</NAME>
#define GST_GL_MEMORY_PBO_ALLOCATOR_CAST(obj)            ((GstGLMemoryPBOAllocator *)(obj))
</MACRO>
<STRUCT>
<NAME>GstGLMemoryPBO</NAME>
struct _GstGLMemoryPBO
{
  /* <private> */
  GstGLMemory      mem;

  GstGLBuffer          *pbo;

  gpointer                  _padding[GST_PADDING];
};
</STRUCT>
<MACRO>
<NAME>GST_GL_MEMORY_PBO_ALLOCATOR_NAME</NAME>
#define GST_GL_MEMORY_PBO_ALLOCATOR_NAME   "GLMemoryPBO"
</MACRO>
<FUNCTION>
<NAME>gst_gl_memory_pbo_init_once</NAME>
<RETURNS>void           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_is_gl_memory_pbo</NAME>
<RETURNS>gboolean       </RETURNS>
GstMemory * mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_pbo_download_transfer</NAME>
<RETURNS>void           </RETURNS>
GstGLMemoryPBO * gl_mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_pbo_upload_transfer</NAME>
<RETURNS>void           </RETURNS>
GstGLMemoryPBO * gl_mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_pbo_copy_into_texture</NAME>
<RETURNS>gboolean       </RETURNS>
GstGLMemoryPBO *gl_mem, guint tex_id, GstGLTextureTarget target, GstGLFormat tex_format, gint width, gint height, gint stride, gboolean respecify
</FUNCTION>
<STRUCT>
<NAME>GstGLMemoryPBOAllocator</NAME>
struct _GstGLMemoryPBOAllocator
{
  GstGLMemoryAllocator parent;

  /* <private> */
  gpointer             _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLMemoryPBOAllocatorClass</NAME>
struct _GstGLMemoryPBOAllocatorClass
{
  GstGLMemoryAllocatorClass parent_class;

  /* <private> */
  gpointer                  _padding[GST_PADDING];
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GLSL_STAGE</NAME>
#define GST_TYPE_GLSL_STAGE         (gst_glsl_stage_get_type())
</MACRO>
<MACRO>
<NAME>GST_GLSL_STAGE</NAME>
#define GST_GLSL_STAGE(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GLSL_STAGE, GstGLSLStage))
</MACRO>
<MACRO>
<NAME>GST_GLSL_STAGE_CLASS</NAME>
#define GST_GLSL_STAGE_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GLSL_STAGE, GstGLSLStageClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GLSL_STAGE</NAME>
#define GST_IS_GLSL_STAGE(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GLSL_STAGE))
</MACRO>
<MACRO>
<NAME>GST_IS_GLSL_STAGE_CLASS</NAME>
#define GST_IS_GLSL_STAGE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GLSL_STAGE))
</MACRO>
<MACRO>
<NAME>GST_GLSL_STAGE_GET_CLASS</NAME>
#define GST_GLSL_STAGE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GLSL_STAGE, GstGLSLStageClass))
</MACRO>
<STRUCT>
<NAME>GstGLSLStage</NAME>
struct _GstGLSLStage
{
  /*< private >*/
  GstObject parent;

  GstGLContext *context;

  GstGLSLStagePrivate *priv;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLSLStageClass</NAME>
struct _GstGLSLStageClass
{
  /* <private> */
  GstObjectClass parent;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_glsl_stage_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_stage_new</NAME>
<RETURNS>GstGLSLStage  * </RETURNS>
GstGLContext * context, guint type
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_stage_new_with_string</NAME>
<RETURNS>GstGLSLStage  * </RETURNS>
GstGLContext * context, guint type, GstGLSLVersion version, GstGLSLProfile profile, const gchar * str
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_stage_new_with_strings</NAME>
<RETURNS>GstGLSLStage  * </RETURNS>
GstGLContext * context, guint type, GstGLSLVersion version, GstGLSLProfile profile, gint n_strings, const gchar ** str
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_stage_new_default_fragment</NAME>
<RETURNS>GstGLSLStage  * </RETURNS>
GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_stage_new_default_vertex</NAME>
<RETURNS>GstGLSLStage  * </RETURNS>
GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_stage_get_handle</NAME>
<RETURNS>guint           </RETURNS>
GstGLSLStage * stage
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_stage_get_profile</NAME>
<RETURNS>GstGLSLProfile  </RETURNS>
GstGLSLStage * stage
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_stage_get_version</NAME>
<RETURNS>GstGLSLVersion  </RETURNS>
GstGLSLStage * stage
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_stage_get_shader_type</NAME>
<RETURNS>guint           </RETURNS>
GstGLSLStage * stage
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_stage_set_strings</NAME>
<RETURNS>gboolean        </RETURNS>
GstGLSLStage * stage, GstGLSLVersion version, GstGLSLProfile profile, gint n_strings, const gchar ** str
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_stage_compile</NAME>
<RETURNS>gboolean        </RETURNS>
GstGLSLStage * stage, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_GLSL_ERROR</NAME>
#define GST_GLSL_ERROR (gst_glsl_error_quark ())
</MACRO>
<ENUM>
<NAME>GstGLSLError</NAME>
typedef enum {
  GST_GLSL_ERROR_COMPILE,
  GST_GLSL_ERROR_LINK,
  GST_GLSL_ERROR_PROGRAM,
} GstGLSLError;
</ENUM>
<ENUM>
<NAME>GstGLSLVersion</NAME>
typedef enum
{
  GST_GLSL_VERSION_NONE = 0,

  GST_GLSL_VERSION_100 = 100, /* ES */
  GST_GLSL_VERSION_110 = 110, /* GL */
  GST_GLSL_VERSION_120 = 120, /* GL */
  GST_GLSL_VERSION_130 = 130, /* GL */
  GST_GLSL_VERSION_140 = 140, /* GL */
  GST_GLSL_VERSION_150 = 150, /* GL */
  GST_GLSL_VERSION_300 = 300, /* ES */
  GST_GLSL_VERSION_310 = 310, /* ES */
  GST_GLSL_VERSION_320 = 320, /* ES */
  GST_GLSL_VERSION_330 = 330, /* GL */
  GST_GLSL_VERSION_400 = 400, /* GL */
  GST_GLSL_VERSION_410 = 410, /* GL */
  GST_GLSL_VERSION_420 = 420, /* GL */
  GST_GLSL_VERSION_430 = 430, /* GL */
  GST_GLSL_VERSION_440 = 440, /* GL */
  GST_GLSL_VERSION_450 = 450, /* GL */
} GstGLSLVersion;
</ENUM>
<ENUM>
<NAME>GstGLSLProfile</NAME>
typedef enum
{
  /* XXX: maybe make GstGLAPI instead */
  GST_GLSL_PROFILE_NONE = 0,

  GST_GLSL_PROFILE_ES = (1 << 0),
  GST_GLSL_PROFILE_CORE = (1 << 1),
  GST_GLSL_PROFILE_COMPATIBILITY = (1 << 2),

  GST_GLSL_PROFILE_ANY = -1,
} GstGLSLProfile;
</ENUM>
<FUNCTION>
<NAME>gst_glsl_version_from_string</NAME>
<RETURNS>GstGLSLVersion  </RETURNS>
const gchar * string
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_version_to_string</NAME>
<RETURNS>const gchar  *  </RETURNS>
GstGLSLVersion version
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_profile_from_string</NAME>
<RETURNS>GstGLSLProfile  </RETURNS>
const gchar * string
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_profile_to_string</NAME>
<RETURNS>const gchar  *  </RETURNS>
GstGLSLProfile profile
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_version_profile_to_string</NAME>
<RETURNS>gchar  *        </RETURNS>
GstGLSLVersion version, GstGLSLProfile profile
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_version_profile_from_string</NAME>
<RETURNS>gboolean        </RETURNS>
const gchar * string, GstGLSLVersion * version, GstGLSLProfile * profile
</FUNCTION>
<FUNCTION>
<NAME>gst_glsl_string_get_version_profile</NAME>
<RETURNS>gboolean        </RETURNS>
const gchar *s, GstGLSLVersion * version, GstGLSLProfile * profile
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_version_to_glsl_version</NAME>
<RETURNS>GstGLSLVersion  </RETURNS>
GstGLAPI gl_api, gint maj, gint min
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_supports_glsl_profile_version</NAME>
<RETURNS>gboolean        </RETURNS>
GstGLContext * context, GstGLSLVersion version, GstGLSLProfile profile
</FUNCTION>
<ENUM>
<NAME>GstGLQueryType</NAME>
typedef enum
{
  GST_GL_QUERY_NONE,
  GST_GL_QUERY_TIME_ELAPSED,
  GST_GL_QUERY_TIMESTAMP,
} GstGLQueryType;
</ENUM>
<STRUCT>
<NAME>GstGLQuery</NAME>
struct _GstGLQuery
{
  /* <private> */
  GstGLContext *    context;
  guint             query_type;
  guint             query_id;
  gboolean          supported;

  gboolean          start_called;
  GstGLAsyncDebug   debug;

  /* <private> */
  gpointer          _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_query_init</NAME>
<RETURNS>void                 </RETURNS>
GstGLQuery * query, GstGLContext * context, GstGLQueryType query_type
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_query_unset</NAME>
<RETURNS>void                 </RETURNS>
GstGLQuery * query
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_query_new</NAME>
<RETURNS>GstGLQuery  *        </RETURNS>
GstGLContext * context, GstGLQueryType query_type
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_query_free</NAME>
<RETURNS>void                 </RETURNS>
GstGLQuery * query
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_query_start</NAME>
<RETURNS>void                 </RETURNS>
GstGLQuery * query
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_query_end</NAME>
<RETURNS>void                 </RETURNS>
GstGLQuery * query
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_query_counter</NAME>
<RETURNS>void                 </RETURNS>
GstGLQuery * query
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_query_result</NAME>
<RETURNS>guint64              </RETURNS>
GstGLQuery * query
</FUNCTION>
<MACRO>
<NAME>gst_gl_query_start_log_valist</NAME>
#define gst_gl_query_start_log_valist(query,cat,level,object,format,varargs) \
  G_STMT_START {    \
    GST_GL_ASYNC_CAT_LEVEL_LOG_valist (&(query)->debug, cat, level, object, format, varargs); \
    gst_gl_async_debug_freeze (&(query)->debug); \
    gst_gl_query_start (query); \
    gst_gl_async_debug_thaw (&(query)->debug); \
  } G_STMT_END
</MACRO>
<MACRO>
<NAME>gst_gl_query_counter_log_valist</NAME>
#define gst_gl_query_counter_log_valist(query,cat,level,object,format,varargs) \
  G_STMT_START {    \
    GST_GL_ASYNC_CAT_LEVEL_LOG_valist (&(query)->debug, cat, level, object, format, varargs); \
    gst_gl_async_debug_freeze (&(query)->debug); \
    gst_gl_query_counter (query); \
    gst_gl_async_debug_thaw (&(query)->debug); \
  } G_STMT_END
</MACRO>
<MACRO>
<NAME>gst_gl_query_start_log</NAME>
#define gst_gl_query_start_log(query,cat,level,object,format,...) \
  G_STMT_START {    \
    GST_GL_ASYNC_CAT_LEVEL_LOG (&(query)->debug, cat, level, object, format, __VA_ARGS__); \
    gst_gl_async_debug_freeze (&(query)->debug); \
    gst_gl_query_start (query); \
    gst_gl_async_debug_thaw (&(query)->debug); \
  } G_STMT_END
</MACRO>
<MACRO>
<NAME>gst_gl_query_counter_log</NAME>
#define gst_gl_query_counter_log(query,cat,level,object,format,...) \
  G_STMT_START {    \
    GST_GL_ASYNC_CAT_LEVEL_LOG (&(query)->debug, cat, level, object, format, __VA_ARGS__); \
    gst_gl_async_debug_freeze (&(query)->debug); \
    gst_gl_query_counter (query); \
    gst_gl_async_debug_thaw (&(query)->debug); \
  } G_STMT_END
</MACRO>
<FUNCTION>
<NAME>gst_gl_filter_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_FILTER</NAME>
#define GST_TYPE_GL_FILTER            (gst_gl_filter_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER</NAME>
#define GST_GL_FILTER(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_FILTER,GstGLFilter))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_FILTER</NAME>
#define GST_IS_GL_FILTER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_FILTER))
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER_CLASS</NAME>
#define GST_GL_FILTER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_FILTER,GstGLFilterClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_FILTER_CLASS</NAME>
#define GST_IS_GL_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_FILTER))
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER_GET_CLASS</NAME>
#define GST_GL_FILTER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_FILTER,GstGLFilterClass))
</MACRO>
<USER_FUNCTION>
<NAME>GstGLFilterRenderFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstGLFilter * filter, GstGLMemory * in_tex, gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GstGLFilter</NAME>
struct _GstGLFilter
{
  GstGLBaseFilter    parent;

  GstVideoInfo       in_info;
  GstVideoInfo       out_info;

  GstCaps           *out_caps;

  /* <protected> */
  GstGLFramebuffer  *fbo;

  /* <private> */
  gboolean           gl_result;
  GstBuffer         *inbuf;
  GstBuffer         *outbuf;

  GstGLShader       *default_shader;
  gboolean           valid_attributes;

  GLuint             vao;
  GLuint             vbo_indices;
  GLuint             vertex_buffer;
  GLint              draw_attr_position_loc;
  GLint              draw_attr_texture_loc;

  gpointer          _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLFilterClass</NAME>
struct _GstGLFilterClass
{
  GstGLBaseFilterClass parent_class;

  gboolean (*set_caps)          (GstGLFilter* filter, GstCaps* incaps, GstCaps* outcaps);
  gboolean (*filter)            (GstGLFilter *filter, GstBuffer *inbuf, GstBuffer *outbuf);
  gboolean (*filter_texture)    (GstGLFilter *filter, GstGLMemory *in_tex, GstGLMemory *out_tex);
  gboolean (*init_fbo)          (GstGLFilter *filter);

  GstCaps *(*transform_internal_caps) (GstGLFilter *filter,
    GstPadDirection direction, GstCaps * caps, GstCaps * filter_caps);

  /* <private> */
  gpointer                      _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_filter_filter_texture</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLFilter * filter, GstBuffer * inbuf, GstBuffer * outbuf
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_filter_render_to_target</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLFilter *filter, GstGLMemory * input, GstGLMemory * output, GstGLFilterRenderFunc func, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_filter_draw_fullscreen_quad</NAME>
<RETURNS>void  </RETURNS>
GstGLFilter *filter
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_filter_render_to_target_with_shader</NAME>
<RETURNS>void  </RETURNS>
GstGLFilter * filter, GstGLMemory * input, GstGLMemory * output, GstGLShader *shader
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_buffer_pool_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_BUFFER_POOL</NAME>
#define GST_TYPE_GL_BUFFER_POOL      (gst_gl_buffer_pool_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_GL_BUFFER_POOL</NAME>
#define GST_IS_GL_BUFFER_POOL(obj)   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_GL_BUFFER_POOL))
</MACRO>
<MACRO>
<NAME>GST_GL_BUFFER_POOL</NAME>
#define GST_GL_BUFFER_POOL(obj)      (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_GL_BUFFER_POOL, GstGLBufferPool))
</MACRO>
<MACRO>
<NAME>GST_GL_BUFFER_POOL_CAST</NAME>
#define GST_GL_BUFFER_POOL_CAST(obj) ((GstGLBufferPool*)(obj))
</MACRO>
<STRUCT>
<NAME>GstGLBufferPool</NAME>
struct _GstGLBufferPool
{
  GstBufferPool bufferpool;

  GstGLContext *context;

  /* <private> */
  GstGLBufferPoolPrivate *priv;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLBufferPoolClass</NAME>
struct _GstGLBufferPoolClass
{
  GstBufferPoolClass parent_class;

  /* <private> */
  gpointer _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_buffer_pool_new</NAME>
<RETURNS>GstBufferPool  *</RETURNS>
GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_config_get_gl_allocation_params</NAME>
<RETURNS>GstGLAllocationParams  * </RETURNS>
GstStructure * config
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_config_set_gl_allocation_params</NAME>
<RETURNS>void                     </RETURNS>
GstStructure * config, GstGLAllocationParams * params
</FUNCTION>
<MACRO>
<NAME>GST_GL_SYNC_META_API_TYPE</NAME>
#define GST_GL_SYNC_META_API_TYPE (gst_gl_sync_meta_api_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_SYNC_META_INFO</NAME>
#define GST_GL_SYNC_META_INFO     (gst_gl_sync_meta_get_info())
</MACRO>
<MACRO>
<NAME>GST_BUFFER_POOL_OPTION_GL_SYNC_META</NAME>
#define GST_BUFFER_POOL_OPTION_GL_SYNC_META "GstBufferPoolOptionGLSyncMeta"
</MACRO>
<STRUCT>
<NAME>GstGLSyncMeta</NAME>
struct _GstGLSyncMeta
{
  GstMeta parent;

  GstGLContext *context;

  gpointer      data;

  void (*set_sync) (GstGLSyncMeta * sync, GstGLContext * context);
  void (*set_sync_gl) (GstGLSyncMeta * sync, GstGLContext * context);
  void (*wait) (GstGLSyncMeta * sync, GstGLContext * context);
  void (*wait_gl) (GstGLSyncMeta * sync, GstGLContext * context);
  void (*wait_cpu) (GstGLSyncMeta * sync, GstGLContext * context);
  void (*wait_cpu_gl) (GstGLSyncMeta * sync, GstGLContext * context);
  void (*copy) (GstGLSyncMeta * src, GstBuffer * sbuffer, GstGLSyncMeta * dest, GstBuffer * dbuffer);
  void (*free) (GstGLSyncMeta * sync, GstGLContext * context);
  void (*free_gl) (GstGLSyncMeta * sync, GstGLContext * context);
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_sync_meta_api_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_sync_meta_get_info</NAME>
<RETURNS>const GstMetaInfo  * </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>gst_buffer_get_gl_sync_meta</NAME>
#define gst_buffer_get_gl_sync_meta(b) ((GstGLSyncMeta*)gst_buffer_get_meta((b),GST_GL_SYNC_META_API_TYPE))
</MACRO>
<FUNCTION>
<NAME>gst_buffer_add_gl_sync_meta</NAME>
<RETURNS>GstGLSyncMeta  *     </RETURNS>
GstGLContext * context, GstBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_add_gl_sync_meta_full</NAME>
<RETURNS>GstGLSyncMeta  *     </RETURNS>
GstGLContext * context, GstBuffer * buffer, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_sync_meta_set_sync_point</NAME>
<RETURNS>void                 </RETURNS>
GstGLSyncMeta * sync_meta, GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_sync_meta_wait</NAME>
<RETURNS>void                 </RETURNS>
GstGLSyncMeta * sync_meta, GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_sync_meta_wait_cpu</NAME>
<RETURNS>void                 </RETURNS>
GstGLSyncMeta * sync_meta, GstGLContext * context
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_RENDERBUFFER_ALLOCATOR</NAME>
#define GST_TYPE_GL_RENDERBUFFER_ALLOCATOR (gst_gl_renderbuffer_allocator_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_gl_renderbuffer_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_IS_GL_RENDERBUFFER_ALLOCATOR</NAME>
#define GST_IS_GL_RENDERBUFFER_ALLOCATOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_GL_RENDERBUFFER_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_RENDERBUFFER_ALLOCATOR_CLASS</NAME>
#define GST_IS_GL_RENDERBUFFER_ALLOCATOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_GL_RENDERBUFFER_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_GL_RENDERBUFFER_ALLOCATOR_GET_CLASS</NAME>
#define GST_GL_RENDERBUFFER_ALLOCATOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_GL_RENDERBUFFER_ALLOCATOR, GstGLRenderbufferAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_GL_RENDERBUFFER_ALLOCATOR</NAME>
#define GST_GL_RENDERBUFFER_ALLOCATOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_GL_RENDERBUFFER_ALLOCATOR, GstGLRenderbufferAllocator))
</MACRO>
<MACRO>
<NAME>GST_GL_RENDERBUFFER_ALLOCATOR_CLASS</NAME>
#define GST_GL_RENDERBUFFER_ALLOCATOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_GL_RENDERBUFFER_ALLOCATOR, GstGLRenderbufferAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_GL_RENDERBUFFER_ALLOCATOR_CAST</NAME>
#define GST_GL_RENDERBUFFER_ALLOCATOR_CAST(obj)            ((GstGLRenderbufferAllocator *)(obj))
</MACRO>
<MACRO>
<NAME>GST_GL_RENDERBUFFER_CAST</NAME>
#define GST_GL_RENDERBUFFER_CAST(obj) ((GstGLRenderbuffer *) obj)
</MACRO>
<MACRO>
<NAME>GST_GL_RENDERBUFFER_ALLOCATOR_NAME</NAME>
#define GST_GL_RENDERBUFFER_ALLOCATOR_NAME   "GLRenderbuffer"
</MACRO>
<STRUCT>
<NAME>GstGLRenderbuffer</NAME>
struct _GstGLRenderbuffer
{
  GstGLBaseMemory           mem;

  guint                     renderbuffer_id;
  GstGLFormat               renderbuffer_format;
  guint                     width;
  guint                     height;

  /* <protected> */
  gboolean                  renderbuffer_wrapped;

  /* <private> */
  gpointer                  _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLRenderbufferAllocator</NAME>
struct _GstGLRenderbufferAllocator
{
  GstGLBaseMemoryAllocator parent;

  /* <private> */
  gpointer                  _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLRenderbufferAllocatorClass</NAME>
struct _GstGLRenderbufferAllocatorClass
{
  GstGLBaseMemoryAllocatorClass             parent_class;

  /* <private> */
  gpointer                  _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_renderbuffer_allocation_params_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RENDERBUFFER_ALLOCATION_PARAMS</NAME>
#define GST_TYPE_RENDERBUFFER_ALLOCATION_PARAMS (gst_gl_renderbuffer_allocation_params_get_type)
</MACRO>
<FUNCTION>
<NAME>gst_gl_renderbuffer_allocation_params_new</NAME>
<RETURNS>GstGLRenderbufferAllocationParams  *     </RETURNS>
GstGLContext * context, GstAllocationParams * alloc_params, GstGLFormat renderbuffer_format, guint width, guint height
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_renderbuffer_allocation_params_new_wrapped</NAME>
<RETURNS>GstGLRenderbufferAllocationParams  *     </RETURNS>
GstGLContext * context, GstAllocationParams * alloc_params, GstGLFormat renderbuffer_format, guint width, guint height, gpointer gl_handle, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_renderbuffer_init_once</NAME>
<RETURNS>void             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_is_gl_renderbuffer</NAME>
<RETURNS>gboolean         </RETURNS>
GstMemory * mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_renderbuffer_get_width</NAME>
<RETURNS>gint                     </RETURNS>
GstGLRenderbuffer * gl_mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_renderbuffer_get_height</NAME>
<RETURNS>gint                     </RETURNS>
GstGLRenderbuffer * gl_mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_renderbuffer_get_format</NAME>
<RETURNS>GstGLFormat              </RETURNS>
GstGLRenderbuffer * gl_mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_renderbuffer_get_id</NAME>
<RETURNS>guint                    </RETURNS>
GstGLRenderbuffer * gl_mem
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_OVERLAY_COMPOSITOR</NAME>
#define GST_TYPE_GL_OVERLAY_COMPOSITOR (gst_gl_overlay_compositor_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_OVERLAY_COMPOSITOR</NAME>
#define GST_GL_OVERLAY_COMPOSITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_OVERLAY_COMPOSITOR,GstGLOverlayCompositor))
</MACRO>
<MACRO>
<NAME>GST_GL_OVERLAY_COMPOSITOR_CLASS</NAME>
#define GST_GL_OVERLAY_COMPOSITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_OVERLAY_COMPOSITOR,GstGLOverlayCompositorClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_OVERLAY_COMPOSITOR</NAME>
#define GST_IS_GL_OVERLAY_COMPOSITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_OVERLAY_COMPOSITOR))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_OVERLAY_COMPOSITOR_CLASS</NAME>
#define GST_IS_GL_OVERLAY_COMPOSITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_OVERLAY_COMPOSITOR))
</MACRO>
<MACRO>
<NAME>GST_GL_OVERLAY_COMPOSITOR_CAST</NAME>
#define GST_GL_OVERLAY_COMPOSITOR_CAST(obj) ((GstGLOverlayCompositor*)(obj))
</MACRO>
<FUNCTION>
<NAME>gst_gl_overlay_compositor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstGLOverlayCompositor</NAME>
struct _GstGLOverlayCompositor
{
  GstObject parent;

  GstGLContext *context;

  /* <private> */
  guint last_window_width;
  guint last_window_height;

  GList * overlays;
 
  GstGLShader *shader;
  GLint  position_attrib;
  GLint  texcoord_attrib;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLOverlayCompositorClass</NAME>
struct _GstGLOverlayCompositorClass
{
  GstObjectClass object_class;

  /* <private> */
  gpointer _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_overlay_compositor_new</NAME>
<RETURNS>GstGLOverlayCompositor  *</RETURNS>
GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_overlay_compositor_free_overlays</NAME>
<RETURNS>void  </RETURNS>
GstGLOverlayCompositor * compositor
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_overlay_compositor_upload_overlays</NAME>
<RETURNS>void  </RETURNS>
GstGLOverlayCompositor * compositor, GstBuffer * buf
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_overlay_compositor_draw_overlays</NAME>
<RETURNS>void  </RETURNS>
GstGLOverlayCompositor * compositor
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_overlay_compositor_add_caps</NAME>
<RETURNS>GstCaps  * </RETURNS>
GstCaps * caps
</FUNCTION>
<MACRO>
<NAME>GST_GL_TEXTURE_TARGET_2D_STR</NAME>
#define GST_GL_TEXTURE_TARGET_2D_STR "2D"
</MACRO>
<MACRO>
<NAME>GST_GL_TEXTURE_TARGET_RECTANGLE_STR</NAME>
#define GST_GL_TEXTURE_TARGET_RECTANGLE_STR "rectangle"
</MACRO>
<MACRO>
<NAME>GST_GL_TEXTURE_TARGET_EXTERNAL_OES_STR</NAME>
#define GST_GL_TEXTURE_TARGET_EXTERNAL_OES_STR "external-oes"
</MACRO>
<MACRO>
<NAME>GST_BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_2D</NAME>
#define GST_BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_2D "GstBufferPoolOptionGLTextureTarget2D"
</MACRO>
<MACRO>
<NAME>GST_BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_RECTANGLE</NAME>
#define GST_BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_RECTANGLE "GstBufferPoolOptionGLTextureTargetRectangle"
</MACRO>
<MACRO>
<NAME>GST_BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_EXTERNAL_OES</NAME>
#define GST_BUFFER_POOL_OPTION_GL_TEXTURE_TARGET_EXTERNAL_OES "GstBufferPoolOptionGLTextureTargetExternalOES"
</MACRO>
<ENUM>
<NAME>GstGLFormat</NAME>
typedef enum
{
  /* values taken from the GL headers */
  GST_GL_LUMINANCE                      = 0x1909,

  GST_GL_ALPHA                          = 0x1906,

  GST_GL_LUMINANCE_ALPHA                = 0x190A,

  GST_GL_RED                            = 0x1903,
  GST_GL_R8                             = 0x8229,

  GST_GL_RG                             = 0x8227,
  GST_GL_RG8                            = 0x822B,

  GST_GL_RGB                            = 0x1907,
  GST_GL_RGB8                           = 0x8051,
  GST_GL_RGB565                         = 0x8D62,

  GST_GL_RGBA                           = 0x1908,
  GST_GL_RGBA8                          = 0x8058,

  GST_GL_DEPTH_COMPONENT16              = 0x81A5,

  GST_GL_DEPTH24_STENCIL8               = 0x88F0,
} GstGLFormat;
</ENUM>
<FUNCTION>
<NAME>gst_gl_format_type_n_bytes</NAME>
<RETURNS>guint                    </RETURNS>
guint format, guint type
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_format_from_video_info</NAME>
<RETURNS>GstGLFormat              </RETURNS>
GstGLContext * context, GstVideoInfo * vinfo, guint plane
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_sized_gl_format_from_gl_format_type</NAME>
<RETURNS>guint                    </RETURNS>
GstGLContext * context, guint format, guint type
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_texture_target_from_string</NAME>
<RETURNS>GstGLTextureTarget       </RETURNS>
const gchar * str
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_texture_target_to_string</NAME>
<RETURNS>const gchar  *           </RETURNS>
GstGLTextureTarget target
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_texture_target_to_gl</NAME>
<RETURNS>guint                    </RETURNS>
GstGLTextureTarget target
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_texture_target_from_gl</NAME>
<RETURNS>GstGLTextureTarget       </RETURNS>
guint target
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_texture_target_to_buffer_pool_option</NAME>
<RETURNS>const gchar  *           </RETURNS>
GstGLTextureTarget target
</FUNCTION>
<ENUM>
<NAME>GstGLTextureTarget</NAME>
typedef enum
{
  GST_GL_TEXTURE_TARGET_NONE,
  GST_GL_TEXTURE_TARGET_2D,
  GST_GL_TEXTURE_TARGET_RECTANGLE,
  GST_GL_TEXTURE_TARGET_EXTERNAL_OES,
} GstGLTextureTarget;
</ENUM>
<STRUCT>
<NAME>GstGLFeatureFunction</NAME>
struct _GstGLFeatureFunction
{
  /* The name of the function without the "EXT" or "ARB" suffix */
  const char *name;
  /* The offset in the context of where to store the function pointer */
  unsigned int pointer_offset;
};
</STRUCT>
<STRUCT>
<NAME>GstGLFeatureData</NAME>
struct _GstGLFeatureData
{
  /* name of the feature */
  const char *feature_name;
  /* Flags specifying which versions of GL the feature is available
     in core in */
  GstGLAPI gl_availability;
  /* A minimum GL version which the functions should be defined in
     without needing an extension. Set to 255, 255 if it's only
     provided in an extension */
  int min_gl_major, min_gl_minor;
  /* A minimum GLES version which the functions should be defined in
     without needing an extension. Set to 255, 255 if it's only
     provided in an extension */
  int min_gles_major, min_gles_minor;
  /* \0 separated list of namespaces to try. Eg "EXT\0ARB\0" */
  const char *namespaces;
  /* \0 separated list of required extension names without the GL_EXT
     or GL_ARB prefix. Any of the extensions must be available for the
     feature to be considered available. If the suffix for an
     extension is different from the namespace, you can specify it
     with a ':' after the namespace */
  const char *extension_names;
  /* A list of functions required for this feature. Terminated with a
     NULL name */
  const GstGLFeatureFunction *functions;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_base_filter_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_BASE_FILTER</NAME>
#define GST_TYPE_GL_BASE_FILTER            (gst_gl_base_filter_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_BASE_FILTER</NAME>
#define GST_GL_BASE_FILTER(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_BASE_FILTER,GstGLBaseFilter))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_BASE_FILTER</NAME>
#define GST_IS_GL_BASE_FILTER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_BASE_FILTER))
</MACRO>
<MACRO>
<NAME>GST_GL_BASE_FILTER_CLASS</NAME>
#define GST_GL_BASE_FILTER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_BASE_FILTER,GstGLBaseFilterClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_BASE_FILTER_CLASS</NAME>
#define GST_IS_GL_BASE_FILTER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_BASE_FILTER))
</MACRO>
<MACRO>
<NAME>GST_GL_BASE_FILTER_GET_CLASS</NAME>
#define GST_GL_BASE_FILTER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_BASE_FILTER,GstGLBaseFilterClass))
</MACRO>
<STRUCT>
<NAME>GstGLBaseFilter</NAME>
struct _GstGLBaseFilter
{
  GstBaseTransform   parent;

  GstGLDisplay      *display;
  GstGLContext      *context;

  GstCaps           *in_caps;
  GstCaps           *out_caps;

  /* <private> */
  gpointer           _padding[GST_PADDING];

  GstGLBaseFilterPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstGLBaseFilterClass</NAME>
struct _GstGLBaseFilterClass
{
  GstBaseTransformClass parent_class;
  GstGLAPI supported_gl_api;

  gboolean (*gl_start)          (GstGLBaseFilter *filter);
  void     (*gl_stop)           (GstGLBaseFilter *filter);
  gboolean (*gl_set_caps)       (GstGLBaseFilter *filter, GstCaps * incaps, GstCaps * outcaps);

  /* <private> */
  gpointer _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLBaseFilter</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLBaseFilterClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLBaseFilterPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLBaseMemory</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLBaseMemoryAllocator</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLBaseMemoryAllocatorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLBuffer</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLBufferAllocator</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLBufferAllocatorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLBufferPool</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLBufferPoolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLBufferPoolPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLColorConvert</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLColorConvertClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLColorConvertPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLContext</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLContextClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLContextPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLDisplay</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLDisplayClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLDisplayPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLFilter</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLFilterClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLFramebuffer</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLFramebufferClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLMemory</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLMemoryAllocator</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLMemoryAllocatorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLMemoryEGL</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLMemoryEGLAllocator</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLMemoryEGLAllocatorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLMemoryPBO</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLMemoryPBOAllocator</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLMemoryPBOAllocatorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLOverlayCompositor</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLOverlayCompositorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLQuery</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLRenderbuffer</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLRenderbufferAllocator</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLRenderbufferAllocatorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLSLStage</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLSLStageClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLSLStagePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLShader</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLShaderClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLShaderPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLUpload</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLUploadClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLUploadPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLViewConvert</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLViewConvertClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLViewConvertPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLWindow</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLWindowClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGLWindowPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_GL_CHECK_GL_VERSION</NAME>
#define GST_GL_CHECK_GL_VERSION(driver_major, driver_minor, \
                                target_major, target_minor) \
  ((driver_major) > (target_major) || \
   ((driver_major) == (target_major) && (driver_minor) >= (target_minor)))
</MACRO>
<FUNCTION>
<NAME>gst_gl_check_extension</NAME>
<RETURNS>gboolean  </RETURNS>
const char *name, const gchar * ext
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_VIEW_CONVERT</NAME>
#define GST_TYPE_GL_VIEW_CONVERT            (gst_gl_view_convert_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_VIEW_CONVERT</NAME>
#define GST_GL_VIEW_CONVERT(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_VIEW_CONVERT,GstGLViewConvert))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_VIEW_CONVERT</NAME>
#define GST_IS_GL_VIEW_CONVERT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_VIEW_CONVERT))
</MACRO>
<MACRO>
<NAME>GST_GL_VIEW_CONVERT_CLASS</NAME>
#define GST_GL_VIEW_CONVERT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_VIEW_CONVERT,GstGLViewConvertClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_VIEW_CONVERT_CLASS</NAME>
#define GST_IS_GL_VIEW_CONVERT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_VIEW_CONVERT))
</MACRO>
<MACRO>
<NAME>GST_GL_VIEW_CONVERT_GET_CLASS</NAME>
#define GST_GL_VIEW_CONVERT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_VIEW_CONVERT,GstGLViewConvertClass))
</MACRO>
<MACRO>
<NAME>GST_TYPE_GL_STEREO_DOWNMIX_MODE_TYPE</NAME>
#define GST_TYPE_GL_STEREO_DOWNMIX_MODE_TYPE gst_gl_stereo_downmix_mode_get_type()
</MACRO>
<FUNCTION>
<NAME>gst_gl_stereo_downmix_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstGLStereoDownmix</NAME>
enum GstGLStereoDownmix {
  GST_GL_STEREO_DOWNMIX_ANAGLYPH_GREEN_MAGENTA_DUBOIS,
  GST_GL_STEREO_DOWNMIX_ANAGLYPH_RED_CYAN_DUBOIS,
  GST_GL_STEREO_DOWNMIX_ANAGLYPH_AMBER_BLUE_DUBOIS,
};
</ENUM>
<STRUCT>
<NAME>GstGLViewConvert</NAME>
struct _GstGLViewConvert
{
  GstObject object;

  GstGLContext *context;

  GstGLShader *shader;

  GstVideoMultiviewMode input_mode_override;
  GstVideoMultiviewFlags input_flags_override;
  GstVideoMultiviewMode output_mode_override;
  GstVideoMultiviewFlags output_flags_override;

  GstGLStereoDownmix downmix_mode;

  GstVideoInfo in_info;
  GstVideoInfo out_info;

  GstGLTextureTarget from_texture_target;
  GstGLTextureTarget to_texture_target;
  gboolean caps_passthrough;

  gboolean initted;
  gboolean reconfigure;

  GstGLFramebuffer *fbo;

  /* <private> */
  GstGLViewConvertPrivate *priv;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLViewConvertClass</NAME>
struct _GstGLViewConvertClass
{
  /* <private> */
  GstObjectClass object_class;

  gpointer                  _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_view_convert_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_view_convert_new</NAME>
<RETURNS>GstGLViewConvert  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_view_convert_set_caps</NAME>
<RETURNS>gboolean   </RETURNS>
GstGLViewConvert * viewconvert, GstCaps * in_caps, GstCaps * out_caps
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_view_convert_transform_caps</NAME>
<RETURNS>GstCaps  * </RETURNS>
GstGLViewConvert * viewconvert, GstPadDirection direction, GstCaps * caps, GstCaps * filter
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_view_convert_fixate_caps</NAME>
<RETURNS>GstCaps  * </RETURNS>
GstGLViewConvert *viewconvert, GstPadDirection direction, GstCaps * caps, GstCaps * othercaps
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_view_convert_submit_input_buffer</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstGLViewConvert *viewconvert, gboolean is_discont, GstBuffer * input
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_view_convert_get_output</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstGLViewConvert *viewconvert, GstBuffer ** outbuf_ptr
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_view_convert_perform</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstGLViewConvert * viewconvert, GstBuffer *inbuf
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_view_convert_reset</NAME>
<RETURNS>void  </RETURNS>
GstGLViewConvert * viewconvert
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_view_convert_set_context</NAME>
<RETURNS>void  </RETURNS>
GstGLViewConvert *viewconvert, GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_ensure_element_data</NAME>
<RETURNS>gboolean  </RETURNS>
gpointer element, GstGLDisplay **display_ptr, GstGLContext ** other_context_ptr
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_handle_set_context</NAME>
<RETURNS>gboolean  </RETURNS>
GstElement * element, GstContext * context, GstGLDisplay ** display, GstGLContext ** other_context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_handle_context_query</NAME>
<RETURNS>gboolean  </RETURNS>
GstElement * element, GstQuery * query, GstGLDisplay * display, GstGLContext * context, GstGLContext * other_context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_query_local_gl_context</NAME>
<RETURNS>gboolean  </RETURNS>
GstElement * element, GstPadDirection direction, GstGLContext ** context_ptr
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_get_plane_data_size</NAME>
<RETURNS>gsize  </RETURNS>
GstVideoInfo * info, GstVideoAlignment * align, guint plane
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_get_plane_start</NAME>
<RETURNS>gsize  </RETURNS>
GstVideoInfo * info, GstVideoAlignment * valign, guint plane
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_value_set_texture_target_from_mask</NAME>
<RETURNS>gboolean  </RETURNS>
GValue * value, GstGLTextureTarget target_mask
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_value_set_texture_target</NAME>
<RETURNS>gboolean  </RETURNS>
GValue * value, GstGLTextureTarget target
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_value_get_texture_target_mask</NAME>
<RETURNS>GstGLTextureTarget  </RETURNS>
const GValue * value
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_MEMORY_ALLOCATOR</NAME>
#define GST_TYPE_GL_MEMORY_ALLOCATOR (gst_gl_memory_allocator_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_gl_memory_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_IS_GL_MEMORY_ALLOCATOR</NAME>
#define GST_IS_GL_MEMORY_ALLOCATOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_GL_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_MEMORY_ALLOCATOR_CLASS</NAME>
#define GST_IS_GL_MEMORY_ALLOCATOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_GL_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_GL_MEMORY_ALLOCATOR_GET_CLASS</NAME>
#define GST_GL_MEMORY_ALLOCATOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_GL_MEMORY_ALLOCATOR, GstGLMemoryAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_GL_MEMORY_ALLOCATOR</NAME>
#define GST_GL_MEMORY_ALLOCATOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_GL_MEMORY_ALLOCATOR, GstGLMemoryAllocator))
</MACRO>
<MACRO>
<NAME>GST_GL_MEMORY_ALLOCATOR_CLASS</NAME>
#define GST_GL_MEMORY_ALLOCATOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_GL_MEMORY_ALLOCATOR, GstGLMemoryAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_GL_MEMORY_ALLOCATOR_CAST</NAME>
#define GST_GL_MEMORY_ALLOCATOR_CAST(obj)            ((GstGLMemoryAllocator *)(obj))
</MACRO>
<MACRO>
<NAME>GST_GL_MEMORY_CAST</NAME>
#define GST_GL_MEMORY_CAST(obj) ((GstGLMemory *) obj)
</MACRO>
<MACRO>
<NAME>GST_CAPS_FEATURE_MEMORY_GL_MEMORY</NAME>
#define GST_CAPS_FEATURE_MEMORY_GL_MEMORY "memory:GLMemory"
</MACRO>
<MACRO>
<NAME>GST_GL_MEMORY_VIDEO_FORMATS_STR</NAME>
#define GST_GL_MEMORY_VIDEO_FORMATS_STR \
    "{ RGBA, BGRA, RGBx, BGRx, ARGB, ABGR, xRGB, xBGR, RGB, BGR, RGB16, BGR16, " \
    "AYUV, I420, YV12, NV12, NV21, YUY2, UYVY, Y41B, Y42B, Y444, " \
    "GRAY8, GRAY16_LE, GRAY16_BE }"
</MACRO>
<STRUCT>
<NAME>GstGLMemory</NAME>
struct _GstGLMemory
{
  GstGLBaseMemory           mem;

  guint                     tex_id;
  GstGLTextureTarget        tex_target;
  GstGLFormat               tex_format;
  GstVideoInfo              info;
  GstVideoAlignment         valign;
  guint                     plane;
  gfloat                    tex_scaling[2];

  /* <protected> */
  gboolean                  texture_wrapped;
  guint                     unpack_length;
  guint                     tex_width;

  /* <private> */
  gpointer                  _padding[GST_PADDING];
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GL_VIDEO_ALLOCATION_PARAMS</NAME>
#define GST_TYPE_GL_VIDEO_ALLOCATION_PARAMS (gst_gl_video_allocation_params_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_gl_video_allocation_params_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_VIDEO</NAME>
#define GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_VIDEO (1 << 3)
</MACRO>
<STRUCT>
<NAME>GstGLVideoAllocationParams</NAME>
struct _GstGLVideoAllocationParams
{
  GstGLAllocationParams  parent;

  GstVideoInfo          *v_info;
  guint                  plane;
  GstVideoAlignment     *valign;
  GstGLTextureTarget     target;
  GstGLFormat            tex_format;

  /* <private> */
  gpointer               _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_video_allocation_params_init_full</NAME>
<RETURNS>gboolean         </RETURNS>
GstGLVideoAllocationParams * params, gsize struct_size, guint alloc_flags, GstGLAllocationParamsCopyFunc copy, GstGLAllocationParamsFreeFunc free, GstGLContext * context, GstAllocationParams * alloc_params, GstVideoInfo * v_info, guint plane, GstVideoAlignment * valign, GstGLTextureTarget target, GstGLFormat tex_format, gpointer wrapped_data, gpointer gl_handle, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_video_allocation_params_new</NAME>
<RETURNS>GstGLVideoAllocationParams  * </RETURNS>
GstGLContext * context, GstAllocationParams * alloc_params, GstVideoInfo * v_info, guint plane, GstVideoAlignment * valign, GstGLTextureTarget target, GstGLFormat tex_format
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_video_allocation_params_new_wrapped_data</NAME>
<RETURNS>GstGLVideoAllocationParams  * </RETURNS>
GstGLContext * context, GstAllocationParams * alloc_params, GstVideoInfo * v_info, guint plane, GstVideoAlignment * valign, GstGLTextureTarget target, GstGLFormat tex_format, gpointer wrapped_data, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_video_allocation_params_new_wrapped_texture</NAME>
<RETURNS>GstGLVideoAllocationParams  * </RETURNS>
GstGLContext * context, GstAllocationParams * alloc_params, GstVideoInfo * v_info, guint plane, GstVideoAlignment * valign, GstGLTextureTarget target, GstGLFormat tex_format, guint tex_id, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_video_allocation_params_new_wrapped_gl_handle</NAME>
<RETURNS>GstGLVideoAllocationParams  * </RETURNS>
GstGLContext * context, GstAllocationParams * alloc_params, GstVideoInfo * v_info, guint plane, GstVideoAlignment * valign, GstGLTextureTarget target, GstGLFormat tex_format, gpointer gl_handle, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_video_allocation_params_free_data</NAME>
<RETURNS>void             </RETURNS>
GstGLVideoAllocationParams * params
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_video_allocation_params_copy_data</NAME>
<RETURNS>void             </RETURNS>
GstGLVideoAllocationParams * src_vid, GstGLVideoAllocationParams * dest_vid
</FUNCTION>
<STRUCT>
<NAME>GstGLMemoryAllocator</NAME>
struct _GstGLMemoryAllocator
{
  /* <private> */
  GstGLBaseMemoryAllocator parent;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLMemoryAllocatorClass</NAME>
struct _GstGLMemoryAllocatorClass
{
  /* <private> */
  GstGLBaseMemoryAllocatorClass             parent_class;

  /* <public> */
  GstGLBaseMemoryAllocatorMapFunction       map;
  GstGLBaseMemoryAllocatorCopyFunction      copy;
  GstGLBaseMemoryAllocatorUnmapFunction     unmap;

  /* <private> */
  gpointer                                  _padding[GST_PADDING];
};
</STRUCT>
<MACRO>
<NAME>GST_GL_MEMORY_ALLOCATOR_NAME</NAME>
#define GST_GL_MEMORY_ALLOCATOR_NAME   "GLMemory"
</MACRO>
<FUNCTION>
<NAME>gst_gl_memory_init_once</NAME>
<RETURNS>void             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_is_gl_memory</NAME>
<RETURNS>gboolean         </RETURNS>
GstMemory * mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_init</NAME>
<RETURNS>void             </RETURNS>
GstGLMemory * mem, GstAllocator * allocator, GstMemory * parent, GstGLContext * context, GstGLTextureTarget target, GstGLFormat tex_format, GstAllocationParams *params, GstVideoInfo * info, guint plane, GstVideoAlignment *valign, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_copy_into</NAME>
<RETURNS>gboolean         </RETURNS>
GstGLMemory *gl_mem, guint tex_id, GstGLTextureTarget target, GstGLFormat tex_format, gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_copy_teximage</NAME>
<RETURNS>gboolean         </RETURNS>
GstGLMemory * src, guint tex_id, GstGLTextureTarget out_target, GstGLFormat out_tex_format, gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_read_pixels</NAME>
<RETURNS>gboolean         </RETURNS>
GstGLMemory * gl_mem, gpointer read_pointer
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_texsubimage</NAME>
<RETURNS>void             </RETURNS>
GstGLMemory * gl_mem, gpointer read_pointer
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_get_texture_width</NAME>
<RETURNS>gint                     </RETURNS>
GstGLMemory * gl_mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_get_texture_height</NAME>
<RETURNS>gint                     </RETURNS>
GstGLMemory * gl_mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_get_texture_format</NAME>
<RETURNS>GstGLFormat              </RETURNS>
GstGLMemory * gl_mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_get_texture_target</NAME>
<RETURNS>GstGLTextureTarget       </RETURNS>
GstGLMemory * gl_mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_get_texture_id</NAME>
<RETURNS>guint                    </RETURNS>
GstGLMemory * gl_mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_setup_buffer</NAME>
<RETURNS>gboolean                 </RETURNS>
GstGLMemoryAllocator * allocator, GstBuffer * buffer, GstGLVideoAllocationParams * params, GstGLFormat *tex_formats, gpointer *wrapped_data, gsize n_wrapped_pointers
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_allocator_get_default</NAME>
<RETURNS>GstGLMemoryAllocator  *  </RETURNS>
GstGLContext *context
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_BASE_MEMORY</NAME>
#define GST_TYPE_GL_BASE_MEMORY (gst_gl_base_memory_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_gl_base_memory_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_BASE_MEMORY_ALLOCATOR</NAME>
#define GST_TYPE_GL_BASE_MEMORY_ALLOCATOR (gst_gl_base_memory_allocator_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_gl_base_memory_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_IS_GL_BASE_MEMORY_ALLOCATOR</NAME>
#define GST_IS_GL_BASE_MEMORY_ALLOCATOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_GL_BASE_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_BASE_MEMORY_ALLOCATOR_CLASS</NAME>
#define GST_IS_GL_BASE_MEMORY_ALLOCATOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_GL_BASE_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_GL_BASE_MEMORY_ALLOCATOR_GET_CLASS</NAME>
#define GST_GL_BASE_MEMORY_ALLOCATOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_GL_BASE_MEMORY_ALLOCATOR, GstGLBaseMemoryAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_GL_BASE_MEMORY_ALLOCATOR</NAME>
#define GST_GL_BASE_MEMORY_ALLOCATOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_GL_BASE_MEMORY_ALLOCATOR, GstGLBaseMemoryAllocator))
</MACRO>
<MACRO>
<NAME>GST_GL_BASE_MEMORY_ALLOCATOR_CLASS</NAME>
#define GST_GL_BASE_MEMORY_ALLOCATOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_GL_BASE_MEMORY_ALLOCATOR, GstGLBaseMemoryAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_GL_BASE_MEMORY_ALLOCATOR_CAST</NAME>
#define GST_GL_BASE_MEMORY_ALLOCATOR_CAST(obj)            ((GstGLBaseMemoryAllocator *)(obj))
</MACRO>
<MACRO>
<NAME>GST_GL_BASE_MEMORY_CAST</NAME>
#define GST_GL_BASE_MEMORY_CAST(mem) ((GstGLBaseMemory *)mem)
</MACRO>
<FUNCTION>
<NAME>gst_gl_base_memory_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_GL_BASE_MEMORY_ERROR</NAME>
#define GST_GL_BASE_MEMORY_ERROR (gst_gl_base_memory_error_quark ())
</MACRO>
<ENUM>
<NAME>GstGLBaseMemoryError</NAME>
typedef enum
{
  GST_GL_BASE_MEMORY_ERROR_FAILED,
  GST_GL_BASE_MEMORY_ERROR_OLD_LIBS,
  GST_GL_BASE_MEMORY_ERROR_RESOURCE_UNAVAILABLE,
} GstGLBaseMemoryError;
</ENUM>
<ENUM>
<NAME>GstGLBaseMemoryTransfer</NAME>
typedef enum
{
  GST_GL_BASE_MEMORY_TRANSFER_NEED_DOWNLOAD   = (GST_MEMORY_FLAG_LAST << 0),
  GST_GL_BASE_MEMORY_TRANSFER_NEED_UPLOAD     = (GST_MEMORY_FLAG_LAST << 1)
} GstGLBaseMemoryTransfer;
</ENUM>
<MACRO>
<NAME>GST_MAP_GL</NAME>
#define GST_MAP_GL (GST_MAP_FLAG_LAST << 1)
</MACRO>
<STRUCT>
<NAME>GstGLBaseMemory</NAME>
struct _GstGLBaseMemory
{
  GstMemory             mem;

  GstGLContext         *context;

  /* <protected> */
  GMutex                lock;

  GstMapFlags           map_flags;       /* cumulative map flags */
  gint                  map_count;
  gint                  gl_map_count;

  gpointer              data;

  GstGLQuery           *query;

  /* <private> */
  gsize                 alloc_size;     /* because maxsize is used for mapping */
  gpointer              alloc_data;

  GDestroyNotify        notify;
  gpointer              user_data;

  gpointer              _padding[GST_PADDING];
};
</STRUCT>
<USER_FUNCTION>
<NAME>GstGLAllocationParamsCopyFunc</NAME>
<RETURNS>void </RETURNS>
GstGLAllocationParams * src, GstGLAllocationParams * dest
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstGLAllocationParamsFreeFunc</NAME>
<RETURNS>void </RETURNS>
gpointer params
</USER_FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_ALLOCATION_PARAMS</NAME>
#define GST_TYPE_GL_ALLOCATION_PARAMS (gst_gl_allocation_params_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_gl_allocation_params_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_ALLOC</NAME>
#define GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_ALLOC (1 << 0)
</MACRO>
<MACRO>
<NAME>GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_SYSMEM</NAME>
#define GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_SYSMEM (1 << 1)
</MACRO>
<MACRO>
<NAME>GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_GPU_HANDLE</NAME>
#define GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_GPU_HANDLE (1 << 2)
</MACRO>
<MACRO>
<NAME>GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_USER</NAME>
#define GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_USER (1 << 16)
</MACRO>
<STRUCT>
<NAME>GstGLAllocationParams</NAME>
struct _GstGLAllocationParams
{
  gsize                             struct_size;
  GstGLAllocationParamsCopyFunc     copy;
  GstGLAllocationParamsFreeFunc     free;

  guint                             alloc_flags;
  gsize                             alloc_size;
  GstAllocationParams              *alloc_params;
  GstGLContext                     *context;
  GDestroyNotify                    notify;
  gpointer                          user_data;

  /* GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_SYSMEM only */
  gpointer                          wrapped_data;
  /* GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_WRAP_GPU_HANDLE only */
  gpointer                          gl_handle;

  /* <private> */
  gpointer                          _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_allocation_params_init</NAME>
<RETURNS>gboolean                 </RETURNS>
GstGLAllocationParams * params, gsize struct_size, guint alloc_flags, GstGLAllocationParamsCopyFunc copy, GstGLAllocationParamsFreeFunc free, GstGLContext * context, gsize alloc_size, GstAllocationParams * alloc_params, gpointer wrapped_data, gpointer gl_handle, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_allocation_params_copy</NAME>
<RETURNS>GstGLAllocationParams  * </RETURNS>
GstGLAllocationParams * src
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_allocation_params_free</NAME>
<RETURNS>void                     </RETURNS>
GstGLAllocationParams * params
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_allocation_params_free_data</NAME>
<RETURNS>void                     </RETURNS>
GstGLAllocationParams * params
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_allocation_params_copy_data</NAME>
<RETURNS>void                     </RETURNS>
GstGLAllocationParams * src, GstGLAllocationParams * dest
</FUNCTION>
<USER_FUNCTION>
<NAME>GstGLBaseMemoryAllocatorAllocFunction</NAME>
<RETURNS>GstGLBaseMemory *</RETURNS>
GstGLBaseMemoryAllocator * allocator,
                                                                             GstGLAllocationParams * params
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstGLBaseMemoryAllocatorCreateFunction</NAME>
<RETURNS>gboolean </RETURNS>
GstGLBaseMemory * mem,
                                                                             GError ** error
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstGLBaseMemoryAllocatorMapFunction</NAME>
<RETURNS>gpointer </RETURNS>
GstGLBaseMemory * mem,
                                                                             GstMapInfo * info,
                                                                             gsize maxsize
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstGLBaseMemoryAllocatorUnmapFunction</NAME>
<RETURNS>void </RETURNS>
GstGLBaseMemory * mem,
                                                                             GstMapInfo * info
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstGLBaseMemoryAllocatorCopyFunction</NAME>
<RETURNS>GstGLBaseMemory *</RETURNS>
GstGLBaseMemory * mem,
                                                                             gssize offset,
                                                                             gssize size
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstGLBaseMemoryAllocatorDestroyFunction</NAME>
<RETURNS>void </RETURNS>
GstGLBaseMemory * mem
</USER_FUNCTION>
<STRUCT>
<NAME>GstGLBaseMemoryAllocator</NAME>
struct _GstGLBaseMemoryAllocator
{
  /*< private >*/
  GstAllocator parent;
  GstMemoryCopyFunction fallback_mem_copy;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLBaseMemoryAllocatorClass</NAME>
struct _GstGLBaseMemoryAllocatorClass
{
  GstAllocatorClass parent_class;

  GstGLBaseMemoryAllocatorAllocFunction         alloc;

  GstGLBaseMemoryAllocatorCreateFunction        create;
  GstGLBaseMemoryAllocatorMapFunction           map;
  GstGLBaseMemoryAllocatorUnmapFunction         unmap;
  GstGLBaseMemoryAllocatorCopyFunction          copy;
  GstGLBaseMemoryAllocatorDestroyFunction       destroy;
  /* <private> */

  gpointer                                      _padding[GST_PADDING];
};
</STRUCT>
<MACRO>
<NAME>GST_GL_BASE_MEMORY_ALLOCATOR_NAME</NAME>
#define GST_GL_BASE_MEMORY_ALLOCATOR_NAME   "GLBaseMemory"
</MACRO>
<FUNCTION>
<NAME>gst_gl_base_memory_init_once</NAME>
<RETURNS>void           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_is_gl_base_memory</NAME>
<RETURNS>gboolean       </RETURNS>
GstMemory * mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_base_memory_init</NAME>
<RETURNS>void           </RETURNS>
GstGLBaseMemory * mem, GstAllocator * allocator, GstMemory * parent, GstGLContext * context, GstAllocationParams * params, gsize size, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_base_memory_alloc_data</NAME>
<RETURNS>gboolean       </RETURNS>
GstGLBaseMemory * gl_mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_base_memory_memcpy</NAME>
<RETURNS>gboolean       </RETURNS>
GstGLBaseMemory * src, GstGLBaseMemory * dest, gssize offset, gssize size
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_base_memory_alloc</NAME>
<RETURNS>GstGLBaseMemory  *   </RETURNS>
GstGLBaseMemoryAllocator * allocator, GstGLAllocationParams * params
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_BUFFER_ALLOCATOR</NAME>
#define GST_TYPE_GL_BUFFER_ALLOCATOR (gst_gl_buffer_allocator_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_gl_buffer_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_IS_GL_BUFFER_ALLOCATOR</NAME>
#define GST_IS_GL_BUFFER_ALLOCATOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_GL_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_BUFFER_ALLOCATOR_CLASS</NAME>
#define GST_IS_GL_BUFFER_ALLOCATOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_GL_BUFFER_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_GL_BUFFER_ALLOCATOR_GET_CLASS</NAME>
#define GST_GL_BUFFER_ALLOCATOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_GL_BUFFER_ALLOCATOR, GstGLBufferAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_GL_BUFFER_ALLOCATOR</NAME>
#define GST_GL_BUFFER_ALLOCATOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_GL_BUFFER_ALLOCATOR, GstGLBufferAllocator))
</MACRO>
<MACRO>
<NAME>GST_GL_BUFFER_ALLOCATOR_CLASS</NAME>
#define GST_GL_BUFFER_ALLOCATOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_GL_BUFFER_ALLOCATOR, GstGLBufferAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_GL_BUFFER_ALLOCATOR_CAST</NAME>
#define GST_GL_BUFFER_ALLOCATOR_CAST(obj)            ((GstGLBufferAllocator *)(obj))
</MACRO>
<STRUCT>
<NAME>GstGLBuffer</NAME>
struct _GstGLBuffer
{
  GstGLBaseMemory       mem;

  guint                 id;
  guint                 target;         /* XXX: put this in the allocator? */
  guint                 usage_hints;     /* XXX: put this in the allocator? */
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GL_BUFFER_ALLOCATION_PARAMS</NAME>
#define GST_TYPE_GL_BUFFER_ALLOCATION_PARAMS (gst_gl_buffer_allocation_params_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_gl_buffer_allocation_params_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_BUFFER</NAME>
#define GST_GL_ALLOCATION_PARAMS_ALLOC_FLAG_BUFFER (1 << 4)
</MACRO>
<STRUCT>
<NAME>GstGLBufferAllocationParams</NAME>
struct _GstGLBufferAllocationParams
{
  GstGLAllocationParams     parent;

  guint                     gl_target;
  guint                     gl_usage;

  /* <private> */
  gpointer                  _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_buffer_allocation_params_new</NAME>
<RETURNS>GstGLBufferAllocationParams  *   </RETURNS>
GstGLContext * context, gsize alloc_size, GstAllocationParams * alloc_params, guint gl_target, guint gl_usage
</FUNCTION>
<STRUCT>
<NAME>GstGLBufferAllocator</NAME>
struct _GstGLBufferAllocator
{
  GstGLBaseMemoryAllocator parent;

  /* <private> */
  gpointer _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLBufferAllocatorClass</NAME>
struct _GstGLBufferAllocatorClass
{
  GstGLBaseMemoryAllocatorClass parent_class;

  /* <private> */
  gpointer _padding[GST_PADDING];
};
</STRUCT>
<MACRO>
<NAME>GST_CAPS_FEATURE_MEMORY_GL_BUFFER</NAME>
#define GST_CAPS_FEATURE_MEMORY_GL_BUFFER "memory:GLBuffer"
</MACRO>
<MACRO>
<NAME>GST_GL_BUFFER_ALLOCATOR_NAME</NAME>
#define GST_GL_BUFFER_ALLOCATOR_NAME   "GLBuffer"
</MACRO>
<FUNCTION>
<NAME>gst_gl_buffer_init_once</NAME>
<RETURNS>void           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_is_gl_buffer</NAME>
<RETURNS>gboolean       </RETURNS>
GstMemory * mem
</FUNCTION>
<USER_FUNCTION>
<NAME>GstGLAsyncDebugLogGetMessage</NAME>
<RETURNS>gchar *</RETURNS>
gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GstGLAsyncDebug</NAME>
struct _GstGLAsyncDebug
{
  /* <private> */
  guint             state_flags;
  GstDebugCategory *cat;
  GstDebugLevel     level;
  const gchar      *file;
  const gchar      *function;
  gint              line;
  GObject          *object;
  gchar            *debug_msg;

  /* <protected> */
  GstGLAsyncDebugLogGetMessage callback;
  gpointer          user_data;
  GDestroyNotify    notify;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_async_debug_new</NAME>
<RETURNS>GstGLAsyncDebug  *   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_async_debug_free</NAME>
<RETURNS>void                 </RETURNS>
GstGLAsyncDebug * ad
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_async_debug_init</NAME>
<RETURNS>void                 </RETURNS>
GstGLAsyncDebug * ad
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_async_debug_unset</NAME>
<RETURNS>void                 </RETURNS>
GstGLAsyncDebug * ad
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_async_debug_freeze</NAME>
<RETURNS>void                 </RETURNS>
GstGLAsyncDebug * ad
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_async_debug_thaw</NAME>
<RETURNS>void                 </RETURNS>
GstGLAsyncDebug * ad
</FUNCTION>
<MACRO>
<NAME>GST_GL_ASYNC_CAT_LEVEL_LOG_valist</NAME>
#define GST_GL_ASYNC_CAT_LEVEL_LOG_valist(ad,cat,level,object,format,varargs)   \
    gst_gl_async_debug_store_log_msg_valist (ad, cat, level, __FILE__,          \
        GST_FUNCTION, __LINE__, object, format, varargs)
</MACRO>
<MACRO>
<NAME>GST_GL_ASYNC_CAT_LEVEL_LOG</NAME>
#define GST_GL_ASYNC_CAT_LEVEL_LOG(ad,cat,level,object,format,...)              \
    gst_gl_async_debug_store_log_msg (ad, cat, level, __FILE__, GST_FUNCTION,   \
        __LINE__, object, format, __VA_ARGS__)
</MACRO>
<FUNCTION>
<NAME>gst_gl_insert_debug_marker</NAME>
<RETURNS>void         </RETURNS>
GstGLContext * context, const gchar * format, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_async_debug_output_log_msg</NAME>
<RETURNS>void         </RETURNS>
GstGLAsyncDebug * ad
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_async_debug_store_log_msg</NAME>
<RETURNS>void         </RETURNS>
GstGLAsyncDebug * ad, GstDebugCategory * cat, GstDebugLevel level, const gchar * file, const gchar * function, gint line, GObject * object, const gchar * format, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_async_debug_store_log_msg_valist</NAME>
<RETURNS>void         </RETURNS>
GstGLAsyncDebug * ad, GstDebugCategory * cat, GstDebugLevel level, const gchar * file, const gchar * function, gint line, GObject * object, const gchar * format, va_list varargs
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_SHADER</NAME>
#define GST_TYPE_GL_SHADER         (gst_gl_shader_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_TYPE_SHADER</NAME>
<DEPRECATED/>
#define GST_GL_TYPE_SHADER GST_TYPE_GL_SHADER
</MACRO>
<MACRO>
<NAME>GST_GL_SHADER</NAME>
#define GST_GL_SHADER(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_SHADER, GstGLShader))
</MACRO>
<MACRO>
<NAME>GST_GL_SHADER_CLASS</NAME>
#define GST_GL_SHADER_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GL_SHADER, GstGLShaderClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_SHADER</NAME>
#define GST_IS_GL_SHADER(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_SHADER))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_SHADER_CLASS</NAME>
#define GST_IS_GL_SHADER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_SHADER))
</MACRO>
<MACRO>
<NAME>GST_GL_SHADER_GET_CLASS</NAME>
#define GST_GL_SHADER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_SHADER, GstGLShaderClass))
</MACRO>
<STRUCT>
<NAME>GstGLShader</NAME>
struct _GstGLShader
{
  GstObject parent;

  GstGLContext *context;

  /*< private >*/
  GstGLShaderPrivate *priv;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLShaderClass</NAME>
struct _GstGLShaderClass {
  /*< private >*/
  GstObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_shader_new</NAME>
<RETURNS>GstGLShader  * </RETURNS>
GstGLContext *context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_new_with_stages</NAME>
<RETURNS>GstGLShader  * </RETURNS>
GstGLContext * context, GError ** error, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_new_link_with_stages</NAME>
<RETURNS>GstGLShader  * </RETURNS>
GstGLContext * context, GError ** error, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_new_default</NAME>
<RETURNS>GstGLShader  * </RETURNS>
GstGLContext * context, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_attach</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLShader * shader, GstGLSLStage * stage
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_attach_unlocked</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLShader * shader, GstGLSLStage * stage
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_detach</NAME>
<RETURNS>void      </RETURNS>
GstGLShader * shader, GstGLSLStage * stage
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_detach_unlocked</NAME>
<RETURNS>void      </RETURNS>
GstGLShader * shader, GstGLSLStage * stage
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_compile_attach_stage</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLShader * shader, GstGLSLStage *stage, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_link</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLShader * shader, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_is_linked</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLShader *shader
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_get_program_handle</NAME>
<RETURNS>int  </RETURNS>
GstGLShader * shader
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_release</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_release_unlocked</NAME>
<RETURNS>void  </RETURNS>
GstGLShader * shader
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_use</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_clear_shader</NAME>
<RETURNS>void  </RETURNS>
GstGLContext *context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_1i</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gint value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_1iv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, guint count, gint *value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_1f</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gfloat value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_1fv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, guint count, gfloat *value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_2i</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gint v0,     gint v1
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_2iv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, guint count, gint *value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_2f</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gfloat v0,   gfloat v1
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_2fv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, guint count, gfloat *value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_3i</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gint v0,     gint v1,       gint v2
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_3iv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, guint count, gint * value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_3f</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gfloat v0,   gfloat v1,     gfloat v2
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_3fv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, guint count, gfloat *value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_4i</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gint v0,     gint v1,       gint v2,   gint v3
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_4iv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, guint count, gint *value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_4f</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gfloat v0,   gfloat v1,     gfloat v2, gfloat v3
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_4fv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, guint count, gfloat *value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_matrix_2fv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gint count, gboolean transpose, const gfloat* value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_matrix_3fv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gint count, gboolean transpose, const gfloat* value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_matrix_4fv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gint count, gboolean transpose, const gfloat* value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_matrix_2x3fv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gint count, gboolean transpose, const gfloat* value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_matrix_2x4fv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gint count, gboolean transpose, const gfloat* value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_matrix_3x2fv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gint count, gboolean transpose, const gfloat* value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_matrix_3x4fv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gint count, gboolean transpose, const gfloat* value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_matrix_4x2fv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gint count, gboolean transpose, const gfloat* value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_set_uniform_matrix_4x3fv</NAME>
<RETURNS>void  </RETURNS>
GstGLShader *shader, const gchar *name, gint count, gboolean transpose, const gfloat* value
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_get_attribute_location</NAME>
<RETURNS>gint  </RETURNS>
GstGLShader *shader, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_bind_attribute_location</NAME>
<RETURNS>void  </RETURNS>
GstGLShader * shader, guint index, const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_shader_bind_frag_data_location</NAME>
<RETURNS>void  </RETURNS>
GstGLShader * shader, guint index, const gchar * name
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_CONTEXT_COCOA</NAME>
#define GST_TYPE_GL_CONTEXT_COCOA         (gst_gl_context_cocoa_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_gl_context_cocoa_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_GL_TYPE_CONTEXT_COCOA</NAME>
<DEPRECATED/>
#define GST_GL_TYPE_CONTEXT_COCOA GST_TYPE_GL_CONTEXT_COCOA
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_COCOA</NAME>
#define GST_GL_CONTEXT_COCOA(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_CONTEXT_COCOA, GstGLContextCocoa))
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_COCOA_CLASS</NAME>
#define GST_GL_CONTEXT_COCOA_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GL_CONTEXT_COCOA, GstGLContextCocoaClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_CONTEXT_COCOA</NAME>
#define GST_IS_GL_CONTEXT_COCOA(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_CONTEXT_COCOA))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_CONTEXT_COCOA_CLASS</NAME>
#define GST_IS_GL_CONTEXT_COCOA_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_CONTEXT_COCOA))
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_COCOA_GET_CLASS</NAME>
#define GST_GL_CONTEXT_COCOA_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_CONTEXT_COCOA, GstGLContextCocoaClass))
</MACRO>
<STRUCT>
<NAME>GstGLContextCocoa</NAME>
struct _GstGLContextCocoa {
  /*< private >*/
  GstGLContext parent;

  /*< private >*/
  GstGLContextCocoaPrivate *priv;
  
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLContextCocoaClass</NAME>
struct _GstGLContextCocoaClass {
  /*< private >*/
  GstGLContextClass parent_class;

  /*< private >*/
  gpointer _reserved[GST_PADDING_LARGE];

  GstGLContextCocoaPrivate *priv;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_context_cocoa_new</NAME>
<RETURNS>GstGLContextCocoa  * </RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_cocoa_get_current_context</NAME>
<RETURNS>guintptr  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_cocoa_get_pixel_format</NAME>
<RETURNS>CGLPixelFormatObj  </RETURNS>
GstGLContextCocoa *context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_cocoa_dump_pixel_format</NAME>
<RETURNS>void  </RETURNS>
CGLPixelFormatObj fmt
</FUNCTION>
<STRUCT>
<NAME>GstGLContextCocoaPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GL_WINDOW_COCOA</NAME>
#define GST_TYPE_GL_WINDOW_COCOA         (gst_gl_window_cocoa_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_COCOA</NAME>
#define GST_GL_WINDOW_COCOA(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_WINDOW_COCOA, GstGLWindowCocoa))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_COCOA_CLASS</NAME>
#define GST_GL_WINDOW_COCOA_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GL_WINDOW_COCOA, GstGLWindowCocoaClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_COCOA</NAME>
#define GST_IS_GL_WINDOW_COCOA(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_WINDOW_COCOA))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_COCOA_CLASS</NAME>
#define GST_IS_GL_WINDOW_COCOA_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_WINDOW_COCOA))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_COCOA_GET_CLASS</NAME>
#define GST_GL_WINDOW_COCOA_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_WINDOW_COCOA, GstGLWindowCocoaClass))
</MACRO>
<STRUCT>
<NAME>GstGLWindowCocoa</NAME>
struct _GstGLWindowCocoa {
  /*< private >*/
  GstGLWindow parent;

  /*< private >*/
  GstGLWindowCocoaPrivate *priv;
  
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLWindowCocoaClass</NAME>
struct _GstGLWindowCocoaClass {
  /*< private >*/
  GstGLWindowClass parent_class;

  /*< private >*/
  gpointer _reserved[GST_PADDING_LARGE];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_window_cocoa_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_cocoa_new</NAME>
<RETURNS>GstGLWindowCocoa  * </RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_cocoa_draw_thread</NAME>
<RETURNS>void  </RETURNS>
GstGLWindowCocoa *window_cocoa
</FUNCTION>
<STRUCT>
<NAME>GstGLWindowCocoaPrivate</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_gl_display_cocoa_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_DISPLAY_COCOA</NAME>
#define GST_TYPE_GL_DISPLAY_COCOA             (gst_gl_display_cocoa_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_COCOA</NAME>
#define GST_GL_DISPLAY_COCOA(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_DISPLAY_COCOA,GstGLDisplayCocoa))
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_COCOA_CLASS</NAME>
#define GST_GL_DISPLAY_COCOA_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_GL_DISPLAY_COCOA,GstGLDisplayCocoaClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DISPLAY_COCOA</NAME>
#define GST_IS_GL_DISPLAY_COCOA(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_DISPLAY_COCOA))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DISPLAY_COCOA_CLASS</NAME>
#define GST_IS_GL_DISPLAY_COCOA_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_GL_DISPLAY_COCOA))
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_COCOA_CAST</NAME>
#define GST_GL_DISPLAY_COCOA_CAST(obj)        ((GstGLDisplayCocoa*)(obj))
</MACRO>
<STRUCT>
<NAME>GstGLDisplayCocoa</NAME>
struct _GstGLDisplayCocoa
{
  GstGLDisplay          parent;
};
</STRUCT>
<STRUCT>
<NAME>GstGLDisplayCocoaClass</NAME>
struct _GstGLDisplayCocoaClass
{
  GstGLDisplayClass object_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_display_cocoa_new</NAME>
<RETURNS>GstGLDisplayCocoa  *</RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstGLContextCocoaPrivate</NAME>
struct _GstGLContextCocoaPrivate
{
  CGLPixelFormatObj pixel_format;
  CGLContextObj gl_context;
  CGLContextObj external_gl_context;

  GstGLAPI context_api;

  gint source_id;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_window_cocoa_create_window</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLWindowCocoa *window_cocoa
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_WINDOW_EAGL</NAME>
#define GST_TYPE_GL_WINDOW_EAGL         (gst_gl_window_eagl_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_EAGL</NAME>
#define GST_GL_WINDOW_EAGL(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_WINDOW_EAGL, GstGLWindowEagl))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_EAGL_CLASS</NAME>
#define GST_GL_WINDOW_EAGL_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GL_WINDOW_EAGL, GstGLWindowEaglClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_EAGL</NAME>
#define GST_IS_GL_WINDOW_EAGL(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_WINDOW_EAGL))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_EAGL_CLASS</NAME>
#define GST_IS_GL_WINDOW_EAGL_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_WINDOW_EAGL))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_EAGL_GET_CLASS</NAME>
#define GST_GL_WINDOW_EAGL_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_WINDOW_EAGL, GstGLWindowEaglClass))
</MACRO>
<MACRO>
<NAME>GS_GL_WINDOW_EAGL_VIEW</NAME>
#define GS_GL_WINDOW_EAGL_VIEW(obj) \
    ((__bridge UIView *)(obj->priv->view))
</MACRO>
<MACRO>
<NAME>GS_GL_WINDOW_EAGL_QUEUE</NAME>
#define GS_GL_WINDOW_EAGL_QUEUE(obj) \
    ((__bridge dispatch_queue_t)(obj->priv->gl_queue))
</MACRO>
<STRUCT>
<NAME>GstGLWindowEagl</NAME>
struct _GstGLWindowEagl {
  /*< private >*/
  GstGLWindow parent;

  /*< private >*/
  GstGLWindowEaglPrivate *priv;
  
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLWindowEaglClass</NAME>
struct _GstGLWindowEaglClass {
  /*< private >*/
  GstGLWindowClass parent_class;

  /*< private >*/
  gpointer _reserved[GST_PADDING_LARGE];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_window_eagl_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_eagl_new</NAME>
<RETURNS>GstGLWindowEagl  * </RETURNS>
GstGLDisplay * display
</FUNCTION>
<STRUCT>
<NAME>GstGLWindowEaglPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GL_CONTEXT_EAGL</NAME>
#define GST_TYPE_GL_CONTEXT_EAGL         (gst_gl_context_eagl_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_EAGL</NAME>
#define GST_GL_CONTEXT_EAGL(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_CONTEXT_EAGL, GstGLContextEagl))
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_EAGL_CLASS</NAME>
#define GST_GL_CONTEXT_EAGL_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GL_CONTEXT_EAGL, GstGLContextEaglClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_CONTEXT_EAGL</NAME>
#define GST_IS_GL_CONTEXT_EAGL(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_CONTEXT_EAGL))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_CONTEXT_EAGL_CLASS</NAME>
#define GST_IS_GL_CONTEXT_EAGL_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_CONTEXT_EAGL))
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_EAGL_GET_CLASS</NAME>
#define GST_GL_CONTEXT_EAGL_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_CONTEXT_EAGL, GstGLContextEaglClass))
</MACRO>
<MACRO>
<NAME>GS_GL_CONTEXT_EAGL_CONTEXT</NAME>
#define GS_GL_CONTEXT_EAGL_CONTEXT(obj) \
    ((__bridge EAGLContext *)(obj->priv->eagl_context))
</MACRO>
<MACRO>
<NAME>GS_GL_CONTEXT_EAGL_LAYER</NAME>
#define GS_GL_CONTEXT_EAGL_LAYER(obj) \
    ((__bridge CAEAGLLayer *)(obj->priv->eagl_layer))
</MACRO>
<STRUCT>
<NAME>GstGLContextEagl</NAME>
struct _GstGLContextEagl {
  /*< private >*/
  GstGLContext parent;

  /*< private >*/
  GstGLContextEaglPrivate *priv;
  
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLContextEaglClass</NAME>
struct _GstGLContextEaglClass {
  /*< private >*/
  GstGLContextClass parent_class;

  /*< private >*/
  gpointer _reserved[GST_PADDING_LARGE];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_context_eagl_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_eagl_new</NAME>
<RETURNS>GstGLContextEagl  * </RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_eagl_update_layer</NAME>
<RETURNS>void  </RETURNS>
GstGLContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_eagl_resize</NAME>
<RETURNS>void  </RETURNS>
GstGLContextEagl * eagl_context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_eagl_prepare_draw</NAME>
<RETURNS>void  </RETURNS>
GstGLContextEagl * context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_eagl_finish_draw</NAME>
<RETURNS>void  </RETURNS>
GstGLContextEagl * context
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_eagl_get_current_context</NAME>
<RETURNS>guintptr  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstGLContextEaglPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GL_CONTEXT_GLX</NAME>
#define GST_TYPE_GL_CONTEXT_GLX         (gst_gl_context_glx_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_gl_context_glx_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_GL_TYPE_CONTEXT_GLX</NAME>
<DEPRECATED/>
#define GST_GL_TYPE_CONTEXT_GLX GST_TYPE_GL_CONTEXT_GLX
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_GLX</NAME>
#define GST_GL_CONTEXT_GLX(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_CONTEXT_GLX, GstGLContextGLX))
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_GLX_CLASS</NAME>
#define GST_GL_CONTEXT_GLX_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GL_CONTEXT_GLX, GstGLContextGLXClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_CONTEXT_GLX</NAME>
#define GST_IS_GL_CONTEXT_GLX(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_CONTEXT_GLX))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_CONTEXT_GLX_CLASS</NAME>
#define GST_IS_GL_CONTEXT_GLX_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_CONTEXT_GLX))
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_GLX_GET_CLASS</NAME>
#define GST_GL_CONTEXT_GLX_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_CONTEXT_GLX, GstGLContextGLX_Class))
</MACRO>
<STRUCT>
<NAME>GstGLContextGLX</NAME>
struct _GstGLContextGLX {
  /*< private >*/
  GstGLContext parent;

  GLXContext glx_context;

  GstGLContextGLXPrivate *priv;

  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLContextGLXClass</NAME>
struct _GstGLContextGLXClass {
  /*< private >*/
  GstGLContextClass parent_class;

  /*< private >*/
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_context_glx_new</NAME>
<RETURNS>GstGLContextGLX  *   </RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_glx_get_current_context</NAME>
<RETURNS>guintptr             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_glx_get_proc_address</NAME>
<RETURNS>gpointer             </RETURNS>
GstGLAPI gl_api, const gchar * name
</FUNCTION>
<STRUCT>
<NAME>GstGLContextGLXPrivate</NAME>
</STRUCT>
<FUNCTION>
<NAME>xcb_event_source_new</NAME>
<RETURNS>GSource  * </RETURNS>
GstGLDisplayX11 *display_x11
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_WINDOW_X11</NAME>
#define GST_TYPE_GL_WINDOW_X11         (gst_gl_window_x11_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_gl_window_x11_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_GL_WINDOW_X11</NAME>
#define GST_GL_WINDOW_X11(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_WINDOW_X11, GstGLWindowX11))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_X11_CLASS</NAME>
#define GST_GL_WINDOW_X11_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GL_WINDOW_X11, GstGLWindowX11Class))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_X11</NAME>
#define GST_IS_GL_WINDOW_X11(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_WINDOW_X11))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_X11_CLASS</NAME>
#define GST_IS_GL_WINDOW_X11_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_WINDOW_X11))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_X11_GET_CLASS</NAME>
#define GST_GL_WINDOW_X11_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_WINDOW_X11, GstGLWindowX11Class))
</MACRO>
<STRUCT>
<NAME>GstGLWindowX11</NAME>
struct _GstGLWindowX11
{
  /*< private >*/
  GstGLWindow parent;

  gboolean      running;
  gboolean      visible;
  gboolean      allow_extra_expose_events;

  /* opengl context */
  Display      *device;
  Screen       *screen;
  gint          screen_num;
  Visual       *visual;
  Window        root;
  gulong        white;
  gulong        black;
  gint          depth;
  gint          device_width;
  gint          device_height;
  gint          connection;
  XVisualInfo  *visual_info;
  Window        parent_win;

  /* X window */
  Window        internal_win_id;

  GSource *x11_source;

  /*< private >*/
  GstGLWindowX11Private *priv;
  
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLWindowX11Class</NAME>
struct _GstGLWindowX11Class {
  /*< private >*/
  GstGLWindowClass parent_class;

  /*< private >*/
  gpointer _reserved[GST_PADDING_LARGE];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_window_x11_new</NAME>
<RETURNS>GstGLWindowX11  * </RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_x11_trap_x_errors</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_x11_untrap_x_errors</NAME>
<RETURNS>gint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_x11_create_window</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLWindowX11 * window_x11
</FUNCTION>
<STRUCT>
<NAME>GstGLWindowX11Private</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_gl_display_x11_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_DISPLAY_X11</NAME>
#define GST_TYPE_GL_DISPLAY_X11             (gst_gl_display_x11_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_X11</NAME>
#define GST_GL_DISPLAY_X11(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_DISPLAY_X11,GstGLDisplayX11))
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_X11_CLASS</NAME>
#define GST_GL_DISPLAY_X11_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_GL_DISPLAY_X11,GstGLDisplayX11Class))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DISPLAY_X11</NAME>
#define GST_IS_GL_DISPLAY_X11(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_DISPLAY_X11))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DISPLAY_X11_CLASS</NAME>
#define GST_IS_GL_DISPLAY_X11_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_GL_DISPLAY_X11))
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_X11_CAST</NAME>
#define GST_GL_DISPLAY_X11_CAST(obj)        ((GstGLDisplayX11*)(obj))
</MACRO>
<STRUCT>
<NAME>GstGLDisplayX11</NAME>
struct _GstGLDisplayX11
{
  GstGLDisplay          parent;

  /* <private> */
  gchar *name;
  Display *display;
  xcb_connection_t *xcb_connection;
  gboolean foreign_display;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLDisplayX11Class</NAME>
struct _GstGLDisplayX11Class
{
  GstGLDisplayClass object_class;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_display_x11_new</NAME>
<RETURNS>GstGLDisplayX11  *</RETURNS>
const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_x11_new_with_display</NAME>
<RETURNS>GstGLDisplayX11  *</RETURNS>
Display *display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_wayland_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_DISPLAY_WAYLAND</NAME>
#define GST_TYPE_GL_DISPLAY_WAYLAND             (gst_gl_display_wayland_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_WAYLAND</NAME>
#define GST_GL_DISPLAY_WAYLAND(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_DISPLAY_WAYLAND,GstGLDisplayWayland))
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_WAYLAND_CLASS</NAME>
#define GST_GL_DISPLAY_WAYLAND_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_GL_DISPLAY_WAYLAND,GstGLDisplayWaylandClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DISPLAY_WAYLAND</NAME>
#define GST_IS_GL_DISPLAY_WAYLAND(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_DISPLAY_WAYLAND))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DISPLAY_WAYLAND_CLASS</NAME>
#define GST_IS_GL_DISPLAY_WAYLAND_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_GL_DISPLAY_WAYLAND))
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_WAYLAND_CAST</NAME>
#define GST_GL_DISPLAY_WAYLAND_CAST(obj)        ((GstGLDisplayWayland*)(obj))
</MACRO>
<STRUCT>
<NAME>GstGLDisplayWayland</NAME>
struct _GstGLDisplayWayland
{
  GstGLDisplay            parent;

  struct wl_display       *display;
  struct wl_registry      *registry;
  struct wl_compositor    *compositor;
  struct wl_subcompositor *subcompositor;
  struct wl_shell         *shell;

  /* <private> */
  gboolean foreign_display;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLDisplayWaylandClass</NAME>
struct _GstGLDisplayWaylandClass
{
  GstGLDisplayClass object_class;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_display_wayland_new</NAME>
<RETURNS>GstGLDisplayWayland  *</RETURNS>
const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_wayland_new_with_display</NAME>
<RETURNS>GstGLDisplayWayland  *</RETURNS>
struct wl_display *display
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_WINDOW_WAYLAND_EGL</NAME>
#define GST_TYPE_GL_WINDOW_WAYLAND_EGL         (gst_gl_window_wayland_egl_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_WAYLAND_EGL</NAME>
#define GST_GL_WINDOW_WAYLAND_EGL(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_WINDOW_WAYLAND_EGL, GstGLWindowWaylandEGL))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_WAYLAND_EGL_CLASS</NAME>
#define GST_GL_WINDOW_WAYLAND_EGL_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GL_WINDOW_WAYLAND_EGL, GstGLWindowWaylandEGLClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_WAYLAND_EGL</NAME>
#define GST_IS_GL_WINDOW_WAYLAND_EGL(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_WINDOW_WAYLAND_EGL))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_WAYLAND_EGL_CLASS</NAME>
#define GST_IS_GL_WINDOW_WAYLAND_EGL_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_WINDOW_WAYLAND_EGL))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_WAYLAND_EGL_GET_CLASS</NAME>
#define GST_GL_WINDOW_WAYLAND_EGL_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_WINDOW_WAYLAND_EGL, GstGLWindowWaylandEGL_Class))
</MACRO>
<STRUCT>
<NAME>display</NAME>
struct display {
  struct wl_display      *display;
  struct wl_registry     *registry;
  struct wl_compositor   *compositor;
  struct wl_shell        *shell;
  struct wl_seat         *seat;
  struct wl_pointer      *pointer;
  struct wl_keyboard     *keyboard;
  struct wl_shm          *shm;
  struct wl_cursor_theme *cursor_theme;
  struct wl_cursor       *default_cursor;
  struct wl_surface      *cursor_surface;
  struct window          *window;
  guint32                 serial;

  gdouble pointer_x;
  gdouble pointer_y;
};
</STRUCT>
<STRUCT>
<NAME>window</NAME>
struct window {
  struct display *display;

  struct wl_event_queue     *queue;
  struct wl_surface         *surface;
  struct wl_shell_surface   *shell_surface;
  struct wl_egl_window      *native;
  struct wl_surface         *foreign_surface;
  struct wl_subsurface      *subsurface;
  struct wl_callback        *callback;
  int fullscreen, configured;
  int window_width, window_height;
  int window_x, window_y;
};
</STRUCT>
<STRUCT>
<NAME>GstGLWindowWaylandEGL</NAME>
struct _GstGLWindowWaylandEGL {
  /*< private >*/
  GstGLWindow parent;

  struct display display;
  struct window  window;

  GSource *wl_source;

  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLWindowWaylandEGLClass</NAME>
struct _GstGLWindowWaylandEGLClass {
  /*< private >*/
  GstGLWindowClass parent_class;

  /*< private >*/
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_window_wayland_egl_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_wayland_egl_new</NAME>
<RETURNS>GstGLWindowWaylandEGL  * </RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_wayland_egl_create_window</NAME>
<RETURNS>void  </RETURNS>
GstGLWindowWaylandEGL * window_egl
</FUNCTION>
<FUNCTION>
<NAME>wayland_event_source_new</NAME>
<RETURNS>GSource  * </RETURNS>
struct wl_display *display, struct wl_event_queue *queue
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_viv_fb_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_DISPLAY_VIV_FB</NAME>
#define GST_TYPE_GL_DISPLAY_VIV_FB             (gst_gl_display_viv_fb_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_VIV_FB</NAME>
#define GST_GL_DISPLAY_VIV_FB(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_DISPLAY_VIV_FB,GstGLDisplayVivFB))
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_VIV_FB_CLASS</NAME>
#define GST_GL_DISPLAY_VIV_FB_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_GL_DISPLAY_VIV_FB,GstGLDisplayVivFBClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DISPLAY_VIV_FB</NAME>
#define GST_IS_GL_DISPLAY_VIV_FB(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_DISPLAY_VIV_FB))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DISPLAY_VIV_FB_CLASS</NAME>
#define GST_IS_GL_DISPLAY_VIV_FB_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_GL_DISPLAY_VIV_FB))
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_VIV_FB_CAST</NAME>
#define GST_GL_DISPLAY_VIV_FB_CAST(obj)        ((GstGLDisplayVivFB*)(obj))
</MACRO>
<STRUCT>
<NAME>GstGLDisplayVivFB</NAME>
struct _GstGLDisplayVivFB
{
  GstGLDisplay          parent;

  /* <private> */
  gint disp_idx;
  EGLNativeDisplayType display;
};
</STRUCT>
<STRUCT>
<NAME>GstGLDisplayVivFBClass</NAME>
struct _GstGLDisplayVivFBClass
{
  GstGLDisplayClass object_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_display_viv_fb_new</NAME>
<RETURNS>GstGLDisplayVivFB  *</RETURNS>
gint disp_idx
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_WINDOW_VIV_FB_EGL</NAME>
#define GST_TYPE_GL_WINDOW_VIV_FB_EGL         (gst_gl_window_viv_fb_egl_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_VIV_FB_EGL</NAME>
#define GST_GL_WINDOW_VIV_FB_EGL(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_WINDOW_VIV_FB_EGL, GstGLWindowVivFBEGL))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_VIV_FB_EGL_CLASS</NAME>
#define GST_GL_WINDOW_VIV_FB_EGL_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GL_WINDOW_VIV_FB_EGL, GstGLWindowVivFBEGLClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_VIV_FB_EGL</NAME>
#define GST_IS_GL_WINDOW_VIV_FB_EGL(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_WINDOW_VIV_FB_EGL))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_VIV_FB_EGL_CLASS</NAME>
#define GST_IS_GL_WINDOW_VIV_FB_EGL_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_WINDOW_VIV_FB_EGL))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_VIV_FB_EGL_GET_CLASS</NAME>
#define GST_GL_WINDOW_VIV_FB_EGL_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_WINDOW_VIV_FB_EGL, GstGLWindowVivFBEGL_Class))
</MACRO>
<STRUCT>
<NAME>GstGLWindowVivFBEGL</NAME>
struct _GstGLWindowVivFBEGL {
  /*< private >*/
  GstGLWindow parent;

  /* <private> */
  EGLNativeWindowType win_id;
  gboolean external_window;
  gint window_width, window_height;

  GstVideoRectangle render_rectangle;
};
</STRUCT>
<STRUCT>
<NAME>GstGLWindowVivFBEGLClass</NAME>
struct _GstGLWindowVivFBEGLClass {
  /*< private >*/
  GstGLWindowClass parent_class;

  /*< private >*/
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_window_viv_fb_egl_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_viv_fb_egl_new</NAME>
<RETURNS>GstGLWindowVivFBEGL  * </RETURNS>
GstGLDisplay * display
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_WINDOW_ANDROID_EGL</NAME>
#define GST_TYPE_GL_WINDOW_ANDROID_EGL         (gst_gl_window_android_egl_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_ANDROID_EGL</NAME>
#define GST_GL_WINDOW_ANDROID_EGL(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_WINDOW_ANDROID_EGL, GstGLWindowAndroidEGL))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_ANDROID_EGL_CLASS</NAME>
#define GST_GL_WINDOW_ANDROID_EGL_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GL_WINDOW_ANDROID_EGL, GstGLWindowAndroidEGLClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_ANDROID_EGL</NAME>
#define GST_IS_GL_WINDOW_ANDROID_EGL(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_WINDOW_ANDROID_EGL))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_ANDROID_EGL_CLASS</NAME>
#define GST_IS_GL_WINDOW_ANDROID_EGL_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_WINDOW_ANDROID_EGL))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_ANDROID_EGL_GET_CLASS</NAME>
#define GST_GL_WINDOW_ANDROID_EGL_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_WINDOW_ANDROID_EGL, GstGLWindowAndroidEGL_Class))
</MACRO>
<STRUCT>
<NAME>GstGLWindowAndroidEGL</NAME>
struct _GstGLWindowAndroidEGL {
  /*< private >*/
  GstGLWindow parent;

  /* This is actually an ANativeWindow */
  EGLNativeWindowType native_window;
  gint window_width, window_height;

  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLWindowAndroidEGLClass</NAME>
struct _GstGLWindowAndroidEGLClass {
  /*< private >*/
  GstGLWindowClass parent_class;

  /*< private >*/
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_window_android_egl_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_android_egl_new</NAME>
<RETURNS>GstGLWindowAndroidEGL  * </RETURNS>
GstGLDisplay * display
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_CONTEXT_WGL</NAME>
#define GST_TYPE_GL_CONTEXT_WGL         (gst_gl_context_wgl_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_WGL</NAME>
#define GST_GL_CONTEXT_WGL(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_CONTEXT_WGL, GstGLContextWGL))
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_WGL_CLASS</NAME>
#define GST_GL_CONTEXT_WGL_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GL_CONTEXT_WGL, GstGLContextWGLClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_CONTEXT_WGL</NAME>
#define GST_IS_GL_CONTEXT_WGL(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_CONTEXT_WGL))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_CONTEXT_WGL_CLASS</NAME>
#define GST_IS_GL_CONTEXT_WGL_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_CONTEXT_WGL))
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_WGL_GET_CLASS</NAME>
#define GST_GL_CONTEXT_WGL_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_CONTEXT_WGL, GstGLContextWGLClass))
</MACRO>
<STRUCT>
<NAME>GstGLContextWGL</NAME>
struct _GstGLContextWGL {
  /*< private >*/
  GstGLContext parent;

  HGLRC wgl_context;
  HGLRC external_gl_context;

  GstGLContextWGLPrivate *priv;

  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLContextWGLClass</NAME>
struct _GstGLContextWGLClass {
  /*< private >*/
  GstGLContextClass parent_class;

  /*< private >*/
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_context_wgl_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_wgl_new</NAME>
<RETURNS>GstGLContextWGL  *   </RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_wgl_get_current_context</NAME>
<RETURNS>guintptr             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_wgl_get_proc_address</NAME>
<RETURNS>gpointer             </RETURNS>
GstGLAPI gl_api, const gchar * name
</FUNCTION>
<STRUCT>
<NAME>GstGLContextWGLPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>Win32MessageSourceFunc</NAME>
<RETURNS>void </RETURNS>
GstGLWindowWin32 *window_win32,
    MSG *msg, gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>win32_message_source_new</NAME>
<RETURNS>GSource  *</RETURNS>
GstGLWindowWin32 *window_win32
</FUNCTION>
<MACRO>
<NAME>UNICODE</NAME>
#define UNICODE
</MACRO>
<MACRO>
<NAME>GST_TYPE_GL_WINDOW_WIN32</NAME>
#define GST_TYPE_GL_WINDOW_WIN32         (gst_gl_window_win32_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_WIN32</NAME>
#define GST_GL_WINDOW_WIN32(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_WINDOW_WIN32, GstGLWindowWin32))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_WIN32_CLASS</NAME>
#define GST_GL_WINDOW_WIN32_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GL_WINDOW_WIN32, GstGLWindowWin32Class))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_WIN32</NAME>
#define GST_IS_GL_WINDOW_WIN32(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_WINDOW_WIN32))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_WIN32_CLASS</NAME>
#define GST_IS_GL_WINDOW_WIN32_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_WINDOW_WIN32))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_WIN32_GET_CLASS</NAME>
#define GST_GL_WINDOW_WIN32_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_WINDOW_WIN32, GstGLWindowWin32Class))
</MACRO>
<STRUCT>
<NAME>GstGLWindowWin32</NAME>
struct _GstGLWindowWin32 {
  /*< private >*/
  GstGLWindow parent;
  
  HWND internal_win_id;
  HWND parent_win_id;
  HDC device;
  gboolean is_closed;
  gboolean visible;

  GSource *msg_source;

  /*< private >*/
  GstGLWindowWin32Private *priv;

  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLWindowWin32Class</NAME>
struct _GstGLWindowWin32Class {
  /*< private >*/
  GstGLWindowClass parent_class;

  gboolean (*choose_format)     (GstGLWindowWin32 *window);
  gboolean (*create_context)    (GstGLWindowWin32 *window, GstGLAPI gl_api,
                                 guintptr external_gl_context, GError ** error);
  gboolean (*share_context)     (GstGLWindowWin32 *window, guintptr external_gl_context);
  void     (*swap_buffers)      (GstGLWindowWin32 *window);
  gboolean (*activate)          (GstGLWindowWin32 *window, gboolean activate);
  void     (*destroy_context)   (GstGLWindowWin32 *window);
  guintptr (*get_gl_context)    (GstGLWindowWin32 *window);

  /*< private >*/
  gpointer _reserved[GST_PADDING_LARGE];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_window_win32_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_win32_new</NAME>
<RETURNS>GstGLWindowWin32  * </RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_win32_create_window</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLWindowWin32 * window_win32, GError ** error
</FUNCTION>
<STRUCT>
<NAME>GstGLWindowWin32Private</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_gl_context_egl_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_CONTEXT_EGL</NAME>
#define GST_TYPE_GL_CONTEXT_EGL         (gst_gl_context_egl_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_TYPE_CONTEXT_EGL</NAME>
<DEPRECATED/>
#define GST_GL_TYPE_CONTEXT_EGL GST_TYPE_GL_CONTEXT_EGL
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_EGL</NAME>
#define GST_GL_CONTEXT_EGL(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_CONTEXT_EGL, GstGLContextEGL))
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_EGL_CLASS</NAME>
#define GST_GL_CONTEXT_EGL_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GL_CONTEXT_EGL, GstGLContextEGLClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_CONTEXT_EGL</NAME>
#define GST_IS_GL_CONTEXT_EGL(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_CONTEXT_EGL))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_CONTEXT_EGL_CLASS</NAME>
#define GST_IS_GL_CONTEXT_EGL_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_CONTEXT_EGL))
</MACRO>
<MACRO>
<NAME>GST_GL_CONTEXT_EGL_GET_CLASS</NAME>
#define GST_GL_CONTEXT_EGL_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_CONTEXT_EGL, GstGLContextEGLClass))
</MACRO>
<STRUCT>
<NAME>GstGLContextEGL</NAME>
struct _GstGLContextEGL
{
  /* <private> */
  GstGLContext context;

  GstGLDisplayEGL *display_egl;

  EGLContext egl_context;
  EGLDisplay egl_display;
  EGLSurface egl_surface;
  EGLConfig  egl_config;

  gint egl_major;
  gint egl_minor;

  GstGLAPI gl_api;

  const gchar *egl_exts;

  /* Cached handle */
  EGLNativeWindowType window_handle;
};
</STRUCT>
<STRUCT>
<NAME>GstGLContextEGLClass</NAME>
struct _GstGLContextEGLClass
{
  /* <private> */
  GstGLContextClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_context_egl_new</NAME>
<RETURNS>GstGLContextEGL  *   </RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_egl_get_current_context</NAME>
<RETURNS>guintptr             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_egl_get_proc_address</NAME>
<RETURNS>gpointer             </RETURNS>
GstGLAPI gl_api, const gchar * name
</FUNCTION>
<MACRO>
<NAME>EGL_EGLEXT_PROTOTYPES</NAME>
#define EGL_EGLEXT_PROTOTYPES 1
</MACRO>
<TYPEDEF>
<NAME>EGLAttrib</NAME>
typedef gintptr EGLAttrib;
</TYPEDEF>
<FUNCTION>
<NAME>gst_egl_get_error_string</NAME>
<RETURNS>const gchar  *   </RETURNS>
EGLint err
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_egl_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_DISPLAY_EGL</NAME>
#define GST_TYPE_GL_DISPLAY_EGL             (gst_gl_display_egl_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_EGL</NAME>
#define GST_GL_DISPLAY_EGL(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_DISPLAY_EGL,GstGLDisplayEGL))
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_EGL_CLASS</NAME>
#define GST_GL_DISPLAY_EGL_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_GL_DISPLAY_EGL,GstGLDisplayEGLClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DISPLAY_EGL</NAME>
#define GST_IS_GL_DISPLAY_EGL(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_DISPLAY_EGL))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DISPLAY_EGL_CLASS</NAME>
#define GST_IS_GL_DISPLAY_EGL_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_GL_DISPLAY_EGL))
</MACRO>
<MACRO>
<NAME>GST_GL_DISPLAY_EGL_CAST</NAME>
#define GST_GL_DISPLAY_EGL_CAST(obj)        ((GstGLDisplayEGL*)(obj))
</MACRO>
<STRUCT>
<NAME>GstGLDisplayEGL</NAME>
struct _GstGLDisplayEGL
{
  GstGLDisplay          parent;

  /* <private> */
  EGLDisplay display;

  gboolean foreign_display;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLDisplayEGLClass</NAME>
struct _GstGLDisplayEGLClass
{
  GstGLDisplayClass object_class;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_display_egl_new</NAME>
<RETURNS>GstGLDisplayEGL  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_egl_new_with_egl_display</NAME>
<RETURNS>GstGLDisplayEGL  *</RETURNS>
EGLDisplay display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_egl_from_gl_display</NAME>
<RETURNS>GstGLDisplayEGL  *</RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_display_egl_get_from_native</NAME>
<RETURNS>EGLDisplay        </RETURNS>
GstGLDisplayType type, guintptr display
</FUNCTION>
<MACRO>
<NAME>GST_GL_DISPLAY_EGL_NAME</NAME>
#define GST_GL_DISPLAY_EGL_NAME "gst.gl.display.egl"
</MACRO>
<MACRO>
<NAME>GST_TYPE_GL_MEMORY_EGL_ALLOCATOR</NAME>
#define GST_TYPE_GL_MEMORY_EGL_ALLOCATOR (gst_gl_memory_egl_allocator_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_gl_memory_egl_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_IS_GL_MEMORY_EGL_ALLOCATOR</NAME>
#define GST_IS_GL_MEMORY_EGL_ALLOCATOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_GL_MEMORY_EGL_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_MEMORY_EGL_ALLOCATOR_CLASS</NAME>
#define GST_IS_GL_MEMORY_EGL_ALLOCATOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_GL_MEMORY_EGL_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_GL_MEMORY_EGL_ALLOCATOR_GET_CLASS</NAME>
#define GST_GL_MEMORY_EGL_ALLOCATOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_GL_MEMORY_EGL_ALLOCATOR, GstGLMemoryEGLAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_GL_MEMORY_EGL_ALLOCATOR</NAME>
#define GST_GL_MEMORY_EGL_ALLOCATOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_GL_MEMORY_EGL_ALLOCATOR, GstGLMemoryEGLAllocator))
</MACRO>
<MACRO>
<NAME>GST_GL_MEMORY_EGL_ALLOCATOR_CLASS</NAME>
#define GST_GL_MEMORY_EGL_ALLOCATOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_GL_MEMORY_EGL_ALLOCATOR, GstGLAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_GL_MEMORY_EGL_ALLOCATOR_CAST</NAME>
#define GST_GL_MEMORY_EGL_ALLOCATOR_CAST(obj)            ((GstGLMemoryEGLAllocator *)(obj))
</MACRO>
<STRUCT>
<NAME>GstGLMemoryEGL</NAME>
struct _GstGLMemoryEGL
{
  /* <private> */
  GstGLMemory mem;

  GstEGLImage *image;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<MACRO>
<NAME>GST_GL_MEMORY_EGL_ALLOCATOR_NAME</NAME>
#define GST_GL_MEMORY_EGL_ALLOCATOR_NAME "GLMemoryEGL"
</MACRO>
<FUNCTION>
<NAME>gst_gl_memory_egl_init_once</NAME>
<RETURNS>void           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_is_gl_memory_egl</NAME>
<RETURNS>gboolean       </RETURNS>
GstMemory * mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_egl_get_image</NAME>
<RETURNS>EGLImageKHR    </RETURNS>
GstGLMemoryEGL * mem
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_memory_egl_get_display</NAME>
<RETURNS>EGLDisplay     </RETURNS>
GstGLMemoryEGL * mem
</FUNCTION>
<STRUCT>
<NAME>GstGLMemoryEGLAllocator</NAME>
struct _GstGLMemoryEGLAllocator
{
  /* <private> */

  GstGLMemoryAllocator parent;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLMemoryEGLAllocatorClass</NAME>
struct _GstGLMemoryEGLAllocatorClass
{
  /* <private> */
  GstGLMemoryAllocatorClass parent_class;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_egl_image_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_EGL_IMAGE</NAME>
#define GST_TYPE_EGL_IMAGE                         (gst_egl_image_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_EGL_IMAGE</NAME>
#define GST_IS_EGL_IMAGE(obj)                      (GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_EGL_IMAGE))
</MACRO>
<MACRO>
<NAME>GST_EGL_IMAGE_CAST</NAME>
#define GST_EGL_IMAGE_CAST(obj)                    ((GstEGLImage *)(obj))
</MACRO>
<MACRO>
<NAME>GST_EGL_IMAGE</NAME>
#define GST_EGL_IMAGE(obj)                         (GST_EGL_IMAGE_CAST(obj))
</MACRO>
<USER_FUNCTION>
<NAME>GstEGLImageDestroyNotify</NAME>
<RETURNS>void </RETURNS>
GstEGLImage * image,
    gpointer data
</USER_FUNCTION>
<STRUCT>
<NAME>GstEGLImage</NAME>
struct _GstEGLImage
{
  GstMiniObject parent;

  GstGLContext *context;
  EGLImageKHR image;
  GstGLFormat format;

  /* <private> */
  gpointer destroy_data;
  GstEGLImageDestroyNotify destroy_notify;

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_egl_image_new_wrapped</NAME>
<RETURNS>GstEGLImage  *             </RETURNS>
GstGLContext * context, EGLImageKHR image, GstGLFormat format, gpointer user_data, GstEGLImageDestroyNotify user_data_destroy
</FUNCTION>
<FUNCTION>
<NAME>gst_egl_image_get_image</NAME>
<RETURNS>EGLImageKHR              </RETURNS>
GstEGLImage * image
</FUNCTION>
<FUNCTION>
<NAME>gst_egl_image_from_texture</NAME>
<RETURNS>GstEGLImage  *           </RETURNS>
GstGLContext * context, GstGLMemory * gl_mem, guintptr * attribs
</FUNCTION>
<FUNCTION>
<NAME>gst_egl_image_from_dmabuf</NAME>
<RETURNS>GstEGLImage  *           </RETURNS>
GstGLContext * context, gint dmabuf, GstVideoInfo * in_info, gint plane, gsize offset
</FUNCTION>
<FUNCTION>
<NAME>gst_egl_image_ref</NAME>
<RETURNS>GstEGLImage  *</RETURNS>
GstEGLImage * image
</FUNCTION>
<FUNCTION>
<NAME>gst_egl_image_unref</NAME>
<RETURNS>void </RETURNS>
GstEGLImage * image
</FUNCTION>
<MACRO>
<NAME>GL_RGB16</NAME>
#define GL_RGB16 GL_RGB565
</MACRO>
<MACRO>
<NAME>GL_RGB8</NAME>
#define GL_RGB8 GL_RGB
</MACRO>
<MACRO>
<NAME>GL_COLOR_ATTACHMENT1</NAME>
#define GL_COLOR_ATTACHMENT1 0x8CE1
</MACRO>
<MACRO>
<NAME>GL_COLOR_ATTACHMENT2</NAME>
#define GL_COLOR_ATTACHMENT2 0x8CE2
</MACRO>
<MACRO>
<NAME>GL_TEXTURE_ENV</NAME>
#define GL_TEXTURE_ENV 0
</MACRO>
<MACRO>
<NAME>GL_TEXTURE_ENV_MODE</NAME>
#define GL_TEXTURE_ENV_MODE 0
</MACRO>
<MACRO>
<NAME>GL_DEPTH24_STENCIL8</NAME>
#define GL_DEPTH24_STENCIL8 0x88F0
</MACRO>
<TYPEDEF>
<NAME>GLeglImageOES</NAME>
typedef gpointer GLeglImageOES;
</TYPEDEF>
<TYPEDEF>
<NAME>GLchar</NAME>
typedef gchar GLchar;
</TYPEDEF>
<TYPEDEF>
<NAME>GLsizeiptr</NAME>
typedef ptrdiff_t GLsizeiptr;
</TYPEDEF>
<TYPEDEF>
<NAME>GLintptr</NAME>
typedef ptrdiff_t GLintptr;
</TYPEDEF>
<TYPEDEF>
<NAME>GLsync</NAME>
typedef gpointer GLsync;
</TYPEDEF>
<TYPEDEF>
<NAME>GLuint64</NAME>
typedef guint64 GLuint64;
</TYPEDEF>
<TYPEDEF>
<NAME>GLint64</NAME>
typedef gint64 GLint64;
</TYPEDEF>
<MACRO>
<NAME>GST_GL_DEBUG_PROC</NAME>
#define GST_GL_DEBUG_PROC GLDEBUGPROC
</MACRO>
<MACRO>
<NAME>GST_TYPE_GL_WINDOW_DISPMANX_EGL</NAME>
#define GST_TYPE_GL_WINDOW_DISPMANX_EGL         (gst_gl_window_dispmanx_egl_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_DISPMANX_EGL</NAME>
#define GST_GL_WINDOW_DISPMANX_EGL(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_GL_WINDOW_DISPMANX_EGL, GstGLWindowDispmanxEGL))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_DISPMANX_EGL_CLASS</NAME>
#define GST_GL_WINDOW_DISPMANX_EGL_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_GL_WINDOW_DISPMANX_EGL, GstGLWindowDispmanxEGLClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_DISPMANX_EGL</NAME>
#define GST_IS_GL_WINDOW_DISPMANX_EGL(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_GL_WINDOW_DISPMANX_EGL))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_WINDOW_DISPMANX_EGL_CLASS</NAME>
#define GST_IS_GL_WINDOW_DISPMANX_EGL_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_GL_WINDOW_DISPMANX_EGL))
</MACRO>
<MACRO>
<NAME>GST_GL_WINDOW_DISPMANX_EGL_GET_CLASS</NAME>
#define GST_GL_WINDOW_DISPMANX_EGL_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_GL_WINDOW_DISPMANX_EGL, GstGLWindowDispmanxEGL_Class))
</MACRO>
<STRUCT>
<NAME>GstGLWindowDispmanxEGL</NAME>
struct _GstGLWindowDispmanxEGL {
  /*< private >*/
  GstGLWindow parent;

  EGLDisplay egldisplay;

  DISPMANX_DISPLAY_HANDLE_T display;
  uint32_t dp_height;
  uint32_t dp_width;
  EGL_DISPMANX_WINDOW_T native;
  EGL_DISPMANX_WINDOW_T foreign;

  gint preferred_width;
  gint preferred_height;
  GstVideoRectangle render_rect;

  gboolean visible;

  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstGLWindowDispmanxEGLClass</NAME>
struct _GstGLWindowDispmanxEGLClass {
  /*< private >*/
  GstGLWindowClass parent_class;

  /*< private >*/
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_window_dispmanx_egl_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_dispmanx_egl_new</NAME>
<RETURNS>GstGLWindowDispmanxEGL  * </RETURNS>
GstGLDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_window_dispmanx_egl_create_window</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLWindowDispmanxEGL * window_egl
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OPENCV_VIDEO_FILTER</NAME>
#define GST_TYPE_OPENCV_VIDEO_FILTER \
  (gst_opencv_video_filter_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPENCV_VIDEO_FILTER</NAME>
#define GST_OPENCV_VIDEO_FILTER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OPENCV_VIDEO_FILTER,GstOpencvVideoFilter))
</MACRO>
<MACRO>
<NAME>GST_OPENCV_VIDEO_FILTER_CLASS</NAME>
#define GST_OPENCV_VIDEO_FILTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OPENCV_VIDEO_FILTER,GstOpencvVideoFilterClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENCV_VIDEO_FILTER</NAME>
#define GST_IS_OPENCV_VIDEO_FILTER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OPENCV_VIDEO_FILTER))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENCV_VIDEO_FILTER_CLASS</NAME>
#define GST_IS_OPENCV_VIDEO_FILTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OPENCV_VIDEO_FILTER))
</MACRO>
<MACRO>
<NAME>GST_OPENCV_VIDEO_FILTER_GET_CLASS</NAME>
#define GST_OPENCV_VIDEO_FILTER_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_OPENCV_VIDEO_FILTER,GstOpencvVideoFilterClass))
</MACRO>
<MACRO>
<NAME>GST_OPENCV_VIDEO_FILTER_CAST</NAME>
#define GST_OPENCV_VIDEO_FILTER_CAST(obj) ((GstOpencvVideoFilter *) (obj))
</MACRO>
<STRUCT>
<NAME>GstOpencvVideoFilter</NAME>
struct _GstOpencvVideoFilter
{
  GstVideoFilter trans;

  gboolean in_place;

  IplImage *cvImage;
  IplImage *out_cvImage;
};
</STRUCT>
<STRUCT>
<NAME>GstOpencvVideoFilterClass</NAME>
struct _GstOpencvVideoFilterClass
{
  GstVideoFilterClass parent_class;

  GstOpencvVideoFilterTransformFunc cv_trans_func;
  GstOpencvVideoFilterTransformIPFunc cv_trans_ip_func;

  GstOpencvVideoFilterSetCaps cv_set_caps;
};
</STRUCT>
<FUNCTION>
<NAME>gst_opencv_video_filter_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_opencv_video_filter_set_in_place</NAME>
<RETURNS>void  </RETURNS>
GstOpencvVideoFilter * transform, gboolean ip
</FUNCTION>
<STRUCT>
<NAME>IplImage</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_opencv_parse_iplimage_params_from_caps</NAME>
<RETURNS>gboolean  </RETURNS>
GstCaps * caps, gint * width, gint * height, gint * depth, gint * channels, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_opencv_iplimage_params_from_video_info</NAME>
<RETURNS>gboolean  </RETURNS>
GstVideoInfo * info, gint * width, gint * height, gint * depth, gint * channels, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_opencv_cv_image_type_from_video_format</NAME>
<RETURNS>gboolean  </RETURNS>
GstVideoFormat format, int * cv_type, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_opencv_caps_from_cv_image_type</NAME>
<RETURNS>GstCaps  * </RETURNS>
int cv_type
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AGGREGATOR_PAD</NAME>
#define GST_TYPE_AGGREGATOR_PAD            (gst_aggregator_pad_get_type())
</MACRO>
<MACRO>
<NAME>GST_AGGREGATOR_PAD</NAME>
#define GST_AGGREGATOR_PAD(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AGGREGATOR_PAD, GstAggregatorPad))
</MACRO>
<MACRO>
<NAME>GST_AGGREGATOR_PAD_CAST</NAME>
#define GST_AGGREGATOR_PAD_CAST(obj)       ((GstAggregatorPad *)(obj))
</MACRO>
<MACRO>
<NAME>GST_AGGREGATOR_PAD_CLASS</NAME>
#define GST_AGGREGATOR_PAD_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AGGREGATOR_PAD, GstAggregatorPadClass))
</MACRO>
<MACRO>
<NAME>GST_AGGREGATOR_PAD_GET_CLASS</NAME>
#define GST_AGGREGATOR_PAD_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_AGGREGATOR_PAD, GstAggregatorPadClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AGGREGATOR_PAD</NAME>
#define GST_IS_AGGREGATOR_PAD(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AGGREGATOR_PAD))
</MACRO>
<MACRO>
<NAME>GST_IS_AGGREGATOR_PAD_CLASS</NAME>
#define GST_IS_AGGREGATOR_PAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AGGREGATOR_PAD))
</MACRO>
<STRUCT>
<NAME>GstAggregatorPad</NAME>
struct _GstAggregatorPad
{
  GstPad                       parent;

  /* Protected by the OBJECT_LOCK */
  GstSegment segment;
  /* Segment to use in the clip function, before the queue */
  GstSegment clip_segment;

  /* < Private > */
  GstAggregatorPadPrivate   *  priv;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstAggregatorPadClass</NAME>
struct _GstAggregatorPadClass
{
  GstPadClass   parent_class;

  GstFlowReturn (*flush)     (GstAggregatorPad * aggpad, GstAggregator * aggregator);

  /*< private >*/
  gpointer      _gst_reserved[GST_PADDING_LARGE];
};
</STRUCT>
<FUNCTION>
<NAME>gst_aggregator_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_aggregator_pad_steal_buffer</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstAggregatorPad *  pad
</FUNCTION>
<FUNCTION>
<NAME>gst_aggregator_pad_get_buffer</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstAggregatorPad *  pad
</FUNCTION>
<FUNCTION>
<NAME>gst_aggregator_pad_drop_buffer</NAME>
<RETURNS>gboolean     </RETURNS>
GstAggregatorPad *  pad
</FUNCTION>
<FUNCTION>
<NAME>gst_aggregator_pad_is_eos</NAME>
<RETURNS>gboolean     </RETURNS>
GstAggregatorPad *  pad
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AGGREGATOR</NAME>
#define GST_TYPE_AGGREGATOR            (gst_aggregator_get_type())
</MACRO>
<MACRO>
<NAME>GST_AGGREGATOR</NAME>
#define GST_AGGREGATOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AGGREGATOR,GstAggregator))
</MACRO>
<MACRO>
<NAME>GST_AGGREGATOR_CAST</NAME>
#define GST_AGGREGATOR_CAST(obj)       ((GstAggregator *)(obj))
</MACRO>
<MACRO>
<NAME>GST_AGGREGATOR_CLASS</NAME>
#define GST_AGGREGATOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AGGREGATOR,GstAggregatorClass))
</MACRO>
<MACRO>
<NAME>GST_AGGREGATOR_GET_CLASS</NAME>
#define GST_AGGREGATOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_AGGREGATOR,GstAggregatorClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AGGREGATOR</NAME>
#define GST_IS_AGGREGATOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AGGREGATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_AGGREGATOR_CLASS</NAME>
#define GST_IS_AGGREGATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AGGREGATOR))
</MACRO>
<MACRO>
<NAME>GST_FLOW_NOT_HANDLED</NAME>
#define GST_FLOW_NOT_HANDLED           GST_FLOW_CUSTOM_SUCCESS
</MACRO>
<STRUCT>
<NAME>GstAggregator</NAME>
struct _GstAggregator
{
  GstElement               parent;

  GstPad                *  srcpad;

  /* Only access with the object lock held */
  GstSegment               segment;

  /*< private >*/
  GstAggregatorPrivate  *  priv;

  gpointer                 _gst_reserved[GST_PADDING_LARGE];
};
</STRUCT>
<STRUCT>
<NAME>GstAggregatorClass</NAME>
struct _GstAggregatorClass {
  GstElementClass   parent_class;

  GType             sinkpads_type;

  GstFlowReturn     (*flush)          (GstAggregator    *  aggregator);

  GstFlowReturn     (*clip)           (GstAggregator    *  aggregator,
                                       GstAggregatorPad *  aggregator_pad,
                                       GstBuffer        *  buf,
                                       GstBuffer        ** outbuf);

  /* sinkpads virtual methods */
  gboolean          (*sink_event)     (GstAggregator    *  aggregator,
                                       GstAggregatorPad *  aggregator_pad,
                                       GstEvent         *  event);

  gboolean          (*sink_query)     (GstAggregator    *  aggregator,
                                       GstAggregatorPad *  aggregator_pad,
                                       GstQuery         *  query);

  /* srcpad virtual methods */
  gboolean          (*src_event)      (GstAggregator    *  aggregator,
                                       GstEvent         *  event);

  gboolean          (*src_query)      (GstAggregator    *  aggregator,
                                       GstQuery         *  query);

  gboolean          (*src_activate)   (GstAggregator    *  aggregator,
                                       GstPadMode          mode,
                                       gboolean            active);

  GstFlowReturn     (*aggregate)      (GstAggregator    *  aggregator,
                                       gboolean            timeout);

  gboolean          (*stop)           (GstAggregator    *  aggregator);

  gboolean          (*start)          (GstAggregator    *  aggregator);

  GstClockTime      (*get_next_time)  (GstAggregator    *  aggregator);

  GstAggregatorPad * (*create_new_pad) (GstAggregator  * self,
                                        GstPadTemplate * templ,
                                        const gchar    * req_name,
                                        const GstCaps  * caps);

  /*< private >*/
  gpointer          _gst_reserved[GST_PADDING_LARGE];
};
</STRUCT>
<MACRO>
<NAME>GST_AGGREGATOR_SRC_PAD</NAME>
#define GST_AGGREGATOR_SRC_PAD(agg) (((GstAggregator *)(agg))->srcpad)
</MACRO>
<FUNCTION>
<NAME>gst_aggregator_finish_buffer</NAME>
<RETURNS>GstFlowReturn   </RETURNS>
GstAggregator                *  self, GstBuffer                    *  buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_aggregator_set_src_caps</NAME>
<RETURNS>void            </RETURNS>
GstAggregator                *  self, GstCaps                      *  caps
</FUNCTION>
<FUNCTION>
<NAME>gst_aggregator_set_latency</NAME>
<RETURNS>void            </RETURNS>
GstAggregator                *  self, GstClockTime                    min_latency, GstClockTime                    max_latency
</FUNCTION>
<FUNCTION>
<NAME>gst_aggregator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<USER_FUNCTION>
<NAME>GstAggregatorPadForeachFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstAggregator                 *  aggregator,
                                                    GstAggregatorPad              *  aggregator_pad,
                                                    gpointer                         user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_aggregator_iterate_sinkpads</NAME>
<RETURNS>gboolean  </RETURNS>
GstAggregator                 *  self, GstAggregatorPadForeachFunc      func, gpointer                         user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_aggregator_get_latency</NAME>
<RETURNS>GstClockTime   </RETURNS>
GstAggregator                 *  self
</FUNCTION>
<STRUCT>
<NAME>GstAggregatorPadPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAggregatorPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_ADAPTIVE_DEMUX</NAME>
#define GST_TYPE_ADAPTIVE_DEMUX \
  (gst_adaptive_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_ADAPTIVE_DEMUX</NAME>
#define GST_ADAPTIVE_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ADAPTIVE_DEMUX,GstAdaptiveDemux))
</MACRO>
<MACRO>
<NAME>GST_ADAPTIVE_DEMUX_CLASS</NAME>
#define GST_ADAPTIVE_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ADAPTIVE_DEMUX,GstAdaptiveDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_ADAPTIVE_DEMUX_GET_CLASS</NAME>
#define GST_ADAPTIVE_DEMUX_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_ADAPTIVE_DEMUX,GstAdaptiveDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ADAPTIVE_DEMUX</NAME>
#define GST_IS_ADAPTIVE_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ADAPTIVE_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_ADAPTIVE_DEMUX_CLASS</NAME>
#define GST_IS_ADAPTIVE_DEMUX_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ADAPTIVE_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_ADAPTIVE_DEMUX_CAST</NAME>
#define GST_ADAPTIVE_DEMUX_CAST(obj) ((GstAdaptiveDemux *)obj)
</MACRO>
<MACRO>
<NAME>GST_ADAPTIVE_DEMUX_STREAM_CAST</NAME>
#define GST_ADAPTIVE_DEMUX_STREAM_CAST(obj) ((GstAdaptiveDemuxStream *)obj)
</MACRO>
<MACRO>
<NAME>GST_ADAPTIVE_DEMUX_SINK_NAME</NAME>
#define GST_ADAPTIVE_DEMUX_SINK_NAME    "sink"
</MACRO>
<MACRO>
<NAME>GST_ADAPTIVE_DEMUX_SINK_PAD</NAME>
#define GST_ADAPTIVE_DEMUX_SINK_PAD(obj)        (((GstAdaptiveDemux *) (obj))->sinkpad)
</MACRO>
<MACRO>
<NAME>GST_ADAPTIVE_DEMUX_STREAM_PAD</NAME>
#define GST_ADAPTIVE_DEMUX_STREAM_PAD(obj)      (((GstAdaptiveDemuxStream *) (obj))->pad)
</MACRO>
<MACRO>
<NAME>GST_ADAPTIVE_DEMUX_STREAM_NEED_HEADER</NAME>
#define GST_ADAPTIVE_DEMUX_STREAM_NEED_HEADER(obj) (((GstAdaptiveDemuxStream *) (obj))->need_header)
</MACRO>
<MACRO>
<NAME>GST_ADAPTIVE_DEMUX_STATISTICS_MESSAGE_NAME</NAME>
#define GST_ADAPTIVE_DEMUX_STATISTICS_MESSAGE_NAME "adaptive-streaming-statistics"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_ERROR_FROM_ERROR</NAME>
#define GST_ELEMENT_ERROR_FROM_ERROR(el, msg, err) G_STMT_START { \
  gchar *__dbg = g_strdup_printf ("%s: %s", msg, err->message);         \
  GST_WARNING_OBJECT (el, "error: %s", __dbg);                          \
  gst_element_message_full (GST_ELEMENT(el), GST_MESSAGE_ERROR,         \
    err->domain, err->code,                                             \
    NULL, __dbg, __FILE__, GST_FUNCTION, __LINE__);                     \
  g_clear_error (&err); \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_ADAPTIVE_DEMUX_FLOW_END_OF_FRAGMENT</NAME>
#define GST_ADAPTIVE_DEMUX_FLOW_END_OF_FRAGMENT GST_FLOW_CUSTOM_SUCCESS_1
</MACRO>
<STRUCT>
<NAME>GstAdaptiveDemuxStreamFragment</NAME>
struct _GstAdaptiveDemuxStreamFragment
{
  GstClockTime timestamp;
  GstClockTime duration;

  gchar *uri;
  gint64 range_start;
  gint64 range_end;

  /* when chunked downloading is used, may be be updated need_another_chunk() */
  guint chunk_size;

  /* when headers are needed */
  gchar *header_uri;
  gint64 header_range_start;
  gint64 header_range_end;

  /* when index is needed */
  gchar *index_uri;
  gint64 index_range_start;
  gint64 index_range_end;

  /* Nominal bitrate as provided by
   * sub-class or calculated by base-class */
  guint bitrate;

  gboolean finished;
};
</STRUCT>
<STRUCT>
<NAME>GstAdaptiveDemuxStream</NAME>
struct _GstAdaptiveDemuxStream
{
  GstPad *pad;
  GstPad *internal_pad;

  GstAdaptiveDemux *demux;

  GstSegment segment;

  GstCaps *pending_caps;
  GstEvent *pending_segment;
  GstTagList *pending_tags;
  gboolean need_header;
  GList *pending_events;

  GstFlowReturn last_ret;
  GError *last_error;

  GstTask *download_task;
  GRecMutex download_lock;

  gboolean restart_download;
  gboolean discont;

  gboolean downloading_first_buffer;
  gboolean downloading_header;
  gboolean downloading_index;

  gboolean bitrate_changed;

  /* download tooling */
  GstElement *src;
  guint last_status_code;
  GstPad *src_srcpad;
  GstElement *uri_handler;
  GstElement *queue;
  GMutex fragment_download_lock;
  GCond fragment_download_cond;
  gboolean download_finished;   /* protected by fragment_download_lock */
  gboolean cancelled;           /* protected by fragment_download_lock */
  gboolean src_at_ready;     /* protected by fragment_download_lock */
  gboolean starting_fragment;
  gboolean first_fragment_buffer;
  gint64 download_start_time;
  gint64 download_total_bytes;
  guint64 current_download_rate;

  /* amount of data downloaded in current fragment (pre-queue2) */
  guint64 fragment_bytes_downloaded;
  /* bitrate of the previous fragment (pre-queue2) */
  guint64 last_bitrate;
  /* latency (request to first byte) and full download time (request to EOS)
   * of previous fragment (pre-queue2) */
  GstClockTime last_latency;
  GstClockTime last_download_time;

  /* Average for the last fragments */
  guint64 moving_bitrate;
  guint moving_index;
  guint64 *fragment_bitrates;

  GstAdaptiveDemuxStreamFragment fragment;

  guint download_error_count;

  /* TODO check if used */
  gboolean eos;

  gboolean do_block; /* TRUE if stream should block on preroll */
};
</STRUCT>
<STRUCT>
<NAME>GstAdaptiveDemux</NAME>
struct _GstAdaptiveDemux
{
  /*< private >*/
  GstBin     bin;

  gboolean running;

  gsize stream_struct_size;

  /*< protected >*/
  GstPad         *sinkpad;

  GstUriDownloader *downloader;

  GList *streams;
  GList *prepared_streams;
  GList *next_streams;

  GstSegment segment;

  gchar *manifest_uri;
  gchar *manifest_base_uri;

  /* Properties */
  gfloat bitrate_limit;         /* limit of the available bitrate to use */
  guint connection_speed;

  gboolean have_group_id;
  guint group_id;

  /* Realtime clock */
  GstClock *realtime_clock;
  gint64 clock_offset; /* offset between realtime_clock and UTC (in usec) */

  /* < private > */
  GstAdaptiveDemuxPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstAdaptiveDemuxClass</NAME>
struct _GstAdaptiveDemuxClass
{
  /*< private >*/
  GstBinClass bin_class;

  /*< public >*/

  /**
   * process_manifest: Parse the manifest
   * @demux: #GstAdaptiveDemux
   * @manifest: the manifest to be parsed
   *
   * Parse the manifest and add the created streams using
   * gst_adaptive_demux_stream_new()
   *
   * Returns: #TRUE if successful
   */
  gboolean      (*process_manifest) (GstAdaptiveDemux * demux, GstBuffer * manifest);

  /**
   * get_manifest_update_interval:
   * @demux: #GstAdaptiveDemux
   *
   * Used during live streaming, the subclass should return the interval
   * between successive manifest updates
   *
   * Returns: the update interval in microseconds
   */
  gint64        (*get_manifest_update_interval) (GstAdaptiveDemux * demux);

  /**
   * update_manifest:
   * @demux: #GstAdaptiveDemux
   *
   * During live streaming, this will be called for the subclass to update its
   * manifest with the new version. By default it fetches the manifest URI
   * and passes it to GstAdaptiveDemux::update_manifest_data().
   *
   * Returns: #GST_FLOW_OK is all succeeded, #GST_FLOW_EOS if the stream ended
   *          or #GST_FLOW_ERROR if an error happened
   */
  GstFlowReturn (*update_manifest) (GstAdaptiveDemux * demux);

  /**
   * update_manifest_data:
   * @demux: #GstAdaptiveDemux
   * @buf: Downloaded manifest data
   *
   * During live streaming, this will be called for the subclass to update its
   * manifest with the new version
   *
   * Returns: #GST_FLOW_OK is all succeeded, #GST_FLOW_EOS if the stream ended
   *          or #GST_FLOW_ERROR if an error happened
   */
  GstFlowReturn (*update_manifest_data) (GstAdaptiveDemux * demux, GstBuffer * buf);

  gboolean      (*is_live)          (GstAdaptiveDemux * demux);
  GstClockTime  (*get_duration)     (GstAdaptiveDemux * demux);

  /**
   * reset:
   * @demux: #GstAdaptiveDemux
   *
   * Reset the internal state of the subclass, getting ready to restart with
   * a new stream afterwards
   */
  void          (*reset)            (GstAdaptiveDemux * demux);

  /**
   * seek:
   * @demux: #GstAdaptiveDemux
   * @seek: a seek #GstEvent
   *
   * The demuxer should seek on all its streams to the specified position
   * in the seek event
   *
   * Returns: #TRUE if successful
   */
  gboolean      (*seek)             (GstAdaptiveDemux * demux, GstEvent * seek);

  /**
   * has_next_period:
   * @demux: #GstAdaptiveDemux
   *
   * Checks if there is a next period following the current one.
   * DASH can have multiple medias chained in its manifest, when one finishes
   * this function is called to verify if there is a new period to be played
   * in sequence.
   *
   * Returns: #TRUE if there is another period
   */
  gboolean      (*has_next_period)  (GstAdaptiveDemux * demux);
  /**
   * advance_period:
   * @demux: #GstAdaptiveDemux
   *
   * Advances the manifest to the next period. New streams should be created
   * using gst_adaptive_demux_stream_new().
   */
  void          (*advance_period)  (GstAdaptiveDemux * demux);

  void          (*stream_free)     (GstAdaptiveDemuxStream * stream);
  GstFlowReturn (*stream_seek)     (GstAdaptiveDemuxStream * stream, gboolean forward, GstSeekFlags flags, GstClockTime target_ts, GstClockTime * final_ts);
  gboolean      (*stream_has_next_fragment)  (GstAdaptiveDemuxStream * stream);
  GstFlowReturn (*stream_advance_fragment) (GstAdaptiveDemuxStream * stream);

  /**
   * need_another_chunk:
   * @stream: #GstAdaptiveDemuxStream
   *
   * If chunked downloading is used (chunk_size != 0) this is called once as
   * chunk is finished to decide whether more has to be downloaded or not.
   * May update chunk_size to a different value
   */
  gboolean      (*need_another_chunk) (GstAdaptiveDemuxStream * stream);

  /**
   * stream_update_fragment_info:
   * @stream: #GstAdaptiveDemuxStream
   *
   * Requests the stream to set the information about the current fragment to its
   * current fragment struct
   *
   * Returns: #GST_FLOW_OK in success, #GST_FLOW_ERROR on error and #GST_FLOW_EOS
   *          if there is no fragment.
   */
  GstFlowReturn (*stream_update_fragment_info) (GstAdaptiveDemuxStream * stream);
  /**
   * stream_select_bitrate:
   * @stream: #GstAdaptiveDemuxStream
   * @bitrate: the bitrate to select (in bytes per second)
   *
   * The stream should try to select the bitrate that is the greater, but not
   * greater than the requested bitrate. If it needs a codec change it should
   * create the new stream using gst_adaptive_demux_stream_new(). If it only
   * needs a caps change it should set the new caps using
   * gst_adaptive_demux_stream_set_caps().
   *
   * Returns: #TRUE if the stream changed bitrate, #FALSE otherwise
   */
  gboolean      (*stream_select_bitrate) (GstAdaptiveDemuxStream * stream, guint64 bitrate);
  /**
   * stream_get_fragment_waiting_time:
   * @stream: #GstAdaptiveDemuxStream
   *
   * For live streams, requests how much time should be waited before starting
   * to download the fragment. This is useful to avoid downloading a fragment that
   * isn't available yet.
   *
   * Returns: The waiting time in microsseconds
   */
  gint64        (*stream_get_fragment_waiting_time) (GstAdaptiveDemuxStream * stream);

  /**
   * start_fragment:
   * @demux: #GstAdaptiveDemux
   * @stream: #GstAdaptiveDemuxStream
   *
   * Notifies the subclass that the given stream is starting the download
   * of a new fragment. Can be used to reset/init internal state that is
   * needed before each fragment, like decryption engines.
   *
   * Returns: #TRUE if successful.
   */
  gboolean      (*start_fragment) (GstAdaptiveDemux * demux, GstAdaptiveDemuxStream * stream);
  /**
   * finish_fragment:
   * @demux: #GstAdaptiveDemux
   * @stream: #GstAdaptiveDemuxStream
   *
   * Notifies the subclass that a fragment download was finished.
   * It can be used to cleanup internal state after a fragment and
   * also push any pending data before moving to the next fragment.
   */
  GstFlowReturn (*finish_fragment) (GstAdaptiveDemux * demux, GstAdaptiveDemuxStream * stream);
  /**
   * data_received:
   * @demux: #GstAdaptiveDemux
   * @stream: #GstAdaptiveDemuxStream
   * @buffer: #GstBuffer
   *
   * Notifies the subclass that a fragment chunk was downloaded. The subclass
   * can look at the data and modify/push data as desired.
   *
   * Returns: #GST_FLOW_OK if successful, #GST_FLOW_ERROR in case of error.
   */
  GstFlowReturn (*data_received) (GstAdaptiveDemux * demux, GstAdaptiveDemuxStream * stream, GstBuffer * buffer);

  /**
   * get_live_seek_range:
   * @demux: #GstAdaptiveDemux
   * @start: pointer to put the start position allowed to seek to
   * @stop: pointer to put the stop position allowed to seek to
   *
   * Gets the allowed seek start and stop positions for the current live stream
   *
   * Return: %TRUE if successful
   */
  gboolean (*get_live_seek_range) (GstAdaptiveDemux * demux, gint64 * start, gint64 * stop);

  /**
   * get_presentation_offset:
   * @demux: #GstAdaptiveDemux
   * @stream: #GstAdaptiveDemuxStream
   *
   * Gets the delay to apply to @stream.
   *
   * Return: a #GstClockTime representing the (positive) time offset to apply to
   * @stream.
   */
  GstClockTime (*get_presentation_offset) (GstAdaptiveDemux *demux, GstAdaptiveDemuxStream *stream);

  /**
   * get_period_start_time:
   * @demux: #GstAdaptiveDemux
   *
   * Gets the start time of the current period. Timestamps are resetting to 0
   * after each period but we have to maintain a continuous stream and running
   * time so need to know the start time of the current period.
   *
   * Return: a #GstClockTime representing the start time of the currently
   * selected period.
   */
  GstClockTime (*get_period_start_time) (GstAdaptiveDemux *demux);

  /**
   * requires_periodical_playlist_update:
   * @demux: #GstAdaptiveDemux
   *
   * Some adaptive streaming protocols allow the client to download
   * the playlist once and build up the fragment list based on the
   * current fragment metadata. For those protocols the demuxer
   * doesn't need to periodically refresh the playlist. This vfunc
   * is relevant only for live playback scenarios.
   *
   * Return: %TRUE if the playlist needs to be refreshed periodically by the demuxer.
   */
  gboolean (*requires_periodical_playlist_update) (GstAdaptiveDemux * demux);
};
</STRUCT>
<FUNCTION>
<NAME>gst_adaptive_demux_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_adaptive_demux_set_stream_struct_size</NAME>
<RETURNS>void      </RETURNS>
GstAdaptiveDemux * demux, gsize struct_size
</FUNCTION>
<FUNCTION>
<NAME>gst_adaptive_demux_stream_new</NAME>
<RETURNS>GstAdaptiveDemuxStream  *</RETURNS>
GstAdaptiveDemux * demux, GstPad * pad
</FUNCTION>
<FUNCTION>
<NAME>gst_adaptive_demux_find_stream_for_pad</NAME>
<RETURNS>GstAdaptiveDemuxStream  *</RETURNS>
GstAdaptiveDemux * demux, GstPad * pad
</FUNCTION>
<FUNCTION>
<NAME>gst_adaptive_demux_stream_set_caps</NAME>
<RETURNS>void  </RETURNS>
GstAdaptiveDemuxStream * stream, GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>gst_adaptive_demux_stream_set_tags</NAME>
<RETURNS>void  </RETURNS>
GstAdaptiveDemuxStream * stream, GstTagList * tags
</FUNCTION>
<FUNCTION>
<NAME>gst_adaptive_demux_stream_fragment_clear</NAME>
<RETURNS>void  </RETURNS>
GstAdaptiveDemuxStreamFragment * f
</FUNCTION>
<FUNCTION>
<NAME>gst_adaptive_demux_stream_push_buffer</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstAdaptiveDemuxStream * stream, GstBuffer * buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_adaptive_demux_stream_advance_fragment</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstAdaptiveDemux * demux, GstAdaptiveDemuxStream * stream, GstClockTime duration
</FUNCTION>
<FUNCTION>
<NAME>gst_adaptive_demux_stream_queue_event</NAME>
<RETURNS>void  </RETURNS>
GstAdaptiveDemuxStream * stream, GstEvent * event
</FUNCTION>
<FUNCTION>
<NAME>gst_adaptive_demux_get_monotonic_time</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstAdaptiveDemux * demux
</FUNCTION>
<FUNCTION>
<NAME>gst_adaptive_demux_get_client_now_utc</NAME>
<RETURNS>GDateTime  *</RETURNS>
GstAdaptiveDemux * demux
</FUNCTION>
<STRUCT>
<NAME>GstAdaptiveDemuxPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_AUDIO_AGGREGATOR_PAD</NAME>
#define GST_TYPE_AUDIO_AGGREGATOR_PAD            (gst_audio_aggregator_pad_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_AGGREGATOR_PAD</NAME>
#define GST_AUDIO_AGGREGATOR_PAD(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_AGGREGATOR_PAD, GstAudioAggregatorPad))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_AGGREGATOR_PAD_CLASS</NAME>
#define GST_AUDIO_AGGREGATOR_PAD_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AUDIO_AGGREGATOR_PAD, GstAudioAggregatorPadClass))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_AGGREGATOR_PAD_GET_CLASS</NAME>
#define GST_AUDIO_AGGREGATOR_PAD_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_AUDIO_AGGREGATOR_PAD, GstAudioAggregatorPadClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_AGGREGATOR_PAD</NAME>
#define GST_IS_AUDIO_AGGREGATOR_PAD(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_AGGREGATOR_PAD))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_AGGREGATOR_PAD_CLASS</NAME>
#define GST_IS_AUDIO_AGGREGATOR_PAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_AGGREGATOR_PAD))
</MACRO>
<STRUCT>
<NAME>GstAudioAggregatorPad</NAME>
struct _GstAudioAggregatorPad
{
  GstAggregatorPad                  parent;

  GstAudioInfo                      info;

  /*< private >*/
  GstAudioAggregatorPadPrivate   *  priv;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstAudioAggregatorPadClass</NAME>
struct _GstAudioAggregatorPadClass
{
  GstAggregatorPadClass   parent_class;

  /*< private >*/
  gpointer      _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_aggregator_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_AGGREGATOR</NAME>
#define GST_TYPE_AUDIO_AGGREGATOR            (gst_audio_aggregator_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_AGGREGATOR</NAME>
#define GST_AUDIO_AGGREGATOR(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_AGGREGATOR,GstAudioAggregator))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_AGGREGATOR_CLASS</NAME>
#define GST_AUDIO_AGGREGATOR_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AUDIO_AGGREGATOR,GstAudioAggregatorClass))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_AGGREGATOR_GET_CLASS</NAME>
#define GST_AUDIO_AGGREGATOR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_AUDIO_AGGREGATOR,GstAudioAggregatorClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_AGGREGATOR</NAME>
#define GST_IS_AUDIO_AGGREGATOR(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_AGGREGATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_AGGREGATOR_CLASS</NAME>
#define GST_IS_AUDIO_AGGREGATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_AGGREGATOR))
</MACRO>
<MACRO>
<NAME>GST_FLOW_CUSTOM_SUCCESS</NAME>
#define GST_FLOW_CUSTOM_SUCCESS        GST_FLOW_NOT_HANDLED
</MACRO>
<STRUCT>
<NAME>GstAudioAggregator</NAME>
struct _GstAudioAggregator
{
  GstAggregator            parent;

  /* All member are read only for subclasses, must hold OBJECT lock  */
  GstAudioInfo    info;

  GstCaps *current_caps;

  /*< private >*/
  GstAudioAggregatorPrivate *priv;

  gpointer                 _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstAudioAggregatorClass</NAME>
struct _GstAudioAggregatorClass {
  GstAggregatorClass   parent_class;

  GstBuffer * (* create_output_buffer) (GstAudioAggregator * aagg,
      guint num_frames);
  gboolean (* aggregate_one_buffer) (GstAudioAggregator * aagg,
      GstAudioAggregatorPad * pad, GstBuffer * inbuf, guint in_offset,
      GstBuffer * outbuf, guint out_offset, guint num_frames);

  /*< private >*/
  gpointer          _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_aggregator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_audio_aggregator_set_sink_caps</NAME>
<RETURNS>void </RETURNS>
GstAudioAggregator * aagg, GstAudioAggregatorPad * pad, GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>gst_audio_aggregator_set_src_caps</NAME>
<RETURNS>gboolean </RETURNS>
GstAudioAggregator * aagg, GstCaps * caps
</FUNCTION>
<STRUCT>
<NAME>GstAudioAggregatorPadPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAudioAggregatorPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_INSERT_BIN</NAME>
#define GST_TYPE_INSERT_BIN            (gst_insert_bin_get_type())
</MACRO>
<MACRO>
<NAME>GST_INSERT_BIN</NAME>
#define GST_INSERT_BIN(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_INSERT_BIN,GstInsertBin))
</MACRO>
<MACRO>
<NAME>GST_IS_INSERT_BIN</NAME>
#define GST_IS_INSERT_BIN(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_INSERT_BIN))
</MACRO>
<MACRO>
<NAME>GST_INSERT_BIN_CLASS</NAME>
#define GST_INSERT_BIN_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_INSERT_BIN,GstInsertBinClass))
</MACRO>
<MACRO>
<NAME>GST_IS_INSERT_BIN_CLASS</NAME>
#define GST_IS_INSERT_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_INSERT_BIN))
</MACRO>
<MACRO>
<NAME>GST_INSERT_BIN_GET_CLASS</NAME>
#define GST_INSERT_BIN_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_INSERT_BIN,GstInsertBinClass))
</MACRO>
<USER_FUNCTION>
<NAME>GstInsertBinCallback</NAME>
<RETURNS>void </RETURNS>
GstInsertBin *insertbin,
    GstElement *element,
    gboolean success,
    gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GstInsertBin</NAME>
struct _GstInsertBin
{
  GstBin parent;

  /*< private >*/
  GstInsertBinPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstInsertBinClass</NAME>
struct _GstInsertBinClass
{
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_insert_bin_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_insert_bin_new</NAME>
<RETURNS>GstElement  *</RETURNS>
const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_insert_bin_prepend</NAME>
<RETURNS>void  </RETURNS>
GstInsertBin * self, GstElement * element, GstInsertBinCallback callback, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_insert_bin_append</NAME>
<RETURNS>void  </RETURNS>
GstInsertBin * self, GstElement * element, GstInsertBinCallback callback, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_insert_bin_insert_before</NAME>
<RETURNS>void  </RETURNS>
GstInsertBin * self, GstElement * element, GstElement * sibling, GstInsertBinCallback callback, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_insert_bin_insert_after</NAME>
<RETURNS>void  </RETURNS>
GstInsertBin * self, GstElement * element, GstElement * sibling, GstInsertBinCallback callback, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_insert_bin_remove</NAME>
<RETURNS>void  </RETURNS>
GstInsertBin * self, GstElement * element, GstInsertBinCallback callback, gpointer user_data
</FUNCTION>
<STRUCT>
<NAME>GstInsertBinPrivate</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_section_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_SECTION_TYPE</NAME>
#define GST_TYPE_MPEGTS_SECTION_TYPE (gst_mpegts_section_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_section_table_id_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_SECTION_TABLE_ID</NAME>
#define GST_TYPE_MPEGTS_SECTION_TABLE_ID (gst_mpegts_section_table_id_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_stream_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_STREAM_TYPE</NAME>
#define GST_TYPE_MPEGTS_STREAM_TYPE (gst_mpegts_stream_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_descriptor_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_DESCRIPTOR_TYPE</NAME>
#define GST_TYPE_MPEGTS_DESCRIPTOR_TYPE (gst_mpegts_descriptor_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_misc_descriptor_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_MISC_DESCRIPTOR_TYPE</NAME>
#define GST_TYPE_MPEGTS_MISC_DESCRIPTOR_TYPE (gst_mpegts_misc_descriptor_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_atsc_descriptor_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ATSC_DESCRIPTOR_TYPE</NAME>
#define GST_TYPE_MPEGTS_ATSC_DESCRIPTOR_TYPE (gst_mpegts_atsc_descriptor_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_isdb_descriptor_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ISDB_DESCRIPTOR_TYPE</NAME>
#define GST_TYPE_MPEGTS_ISDB_DESCRIPTOR_TYPE (gst_mpegts_isdb_descriptor_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_iso639_audio_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ISO639_AUDIO_TYPE</NAME>
#define GST_TYPE_MPEGTS_ISO639_AUDIO_TYPE (gst_mpegts_iso639_audio_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_section_atsc_table_id_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_SECTION_ATSC_TABLE_ID</NAME>
#define GST_TYPE_MPEGTS_SECTION_ATSC_TABLE_ID (gst_mpegts_section_atsc_table_id_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_atsc_mgt_table_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ATSC_MGT_TABLE_TYPE</NAME>
#define GST_TYPE_MPEGTS_ATSC_MGT_TABLE_TYPE (gst_mpegts_atsc_mgt_table_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_section_dvb_table_id_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_SECTION_DVB_TABLE_ID</NAME>
#define GST_TYPE_MPEGTS_SECTION_DVB_TABLE_ID (gst_mpegts_section_dvb_table_id_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_running_status_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_RUNNING_STATUS</NAME>
#define GST_TYPE_MPEGTS_RUNNING_STATUS (gst_mpegts_running_status_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_scte_stream_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_SCTE_STREAM_TYPE</NAME>
#define GST_TYPE_MPEGTS_SCTE_STREAM_TYPE (gst_mpegts_scte_stream_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_section_scte_table_id_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_SECTION_SCTE_TABLE_ID</NAME>
#define GST_TYPE_MPEGTS_SECTION_SCTE_TABLE_ID (gst_mpegts_section_scte_table_id_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_dvb_descriptor_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_DVB_DESCRIPTOR_TYPE</NAME>
#define GST_TYPE_MPEGTS_DVB_DESCRIPTOR_TYPE (gst_mpegts_dvb_descriptor_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_dvb_extended_descriptor_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_DVB_EXTENDED_DESCRIPTOR_TYPE</NAME>
#define GST_TYPE_MPEGTS_DVB_EXTENDED_DESCRIPTOR_TYPE (gst_mpegts_dvb_extended_descriptor_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_modulation_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_MODULATION_TYPE</NAME>
#define GST_TYPE_MPEGTS_MODULATION_TYPE (gst_mpegts_modulation_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_dvb_code_rate_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_DVB_CODE_RATE</NAME>
#define GST_TYPE_MPEGTS_DVB_CODE_RATE (gst_mpegts_dvb_code_rate_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_satellite_rolloff_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_SATELLITE_ROLLOFF</NAME>
#define GST_TYPE_MPEGTS_SATELLITE_ROLLOFF (gst_mpegts_satellite_rolloff_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_satellite_polarization_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_SATELLITE_POLARIZATION_TYPE</NAME>
#define GST_TYPE_MPEGTS_SATELLITE_POLARIZATION_TYPE (gst_mpegts_satellite_polarization_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_cable_outer_fec_scheme_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_CABLE_OUTER_FEC_SCHEME</NAME>
#define GST_TYPE_MPEGTS_CABLE_OUTER_FEC_SCHEME (gst_mpegts_cable_outer_fec_scheme_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_dvb_service_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_DVB_SERVICE_TYPE</NAME>
#define GST_TYPE_MPEGTS_DVB_SERVICE_TYPE (gst_mpegts_dvb_service_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_dvb_linkage_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_DVB_LINKAGE_TYPE</NAME>
#define GST_TYPE_MPEGTS_DVB_LINKAGE_TYPE (gst_mpegts_dvb_linkage_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_dvb_linkage_hand_over_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_DVB_LINKAGE_HAND_OVER_TYPE</NAME>
#define GST_TYPE_MPEGTS_DVB_LINKAGE_HAND_OVER_TYPE (gst_mpegts_dvb_linkage_hand_over_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_component_stream_content_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_COMPONENT_STREAM_CONTENT</NAME>
#define GST_TYPE_MPEGTS_COMPONENT_STREAM_CONTENT (gst_mpegts_component_stream_content_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_content_nibble_hi_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_CONTENT_NIBBLE_HI</NAME>
#define GST_TYPE_MPEGTS_CONTENT_NIBBLE_HI (gst_mpegts_content_nibble_hi_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_dvb_teletext_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_DVB_TELETEXT_TYPE</NAME>
#define GST_TYPE_MPEGTS_DVB_TELETEXT_TYPE (gst_mpegts_dvb_teletext_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_terrestrial_transmission_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_TERRESTRIAL_TRANSMISSION_MODE</NAME>
#define GST_TYPE_MPEGTS_TERRESTRIAL_TRANSMISSION_MODE (gst_mpegts_terrestrial_transmission_mode_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_terrestrial_guard_interval_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_TERRESTRIAL_GUARD_INTERVAL</NAME>
#define GST_TYPE_MPEGTS_TERRESTRIAL_GUARD_INTERVAL (gst_mpegts_terrestrial_guard_interval_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_terrestrial_hierarchy_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_TERRESTRIAL_HIERARCHY</NAME>
#define GST_TYPE_MPEGTS_TERRESTRIAL_HIERARCHY (gst_mpegts_terrestrial_hierarchy_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_dvb_scrambling_mode_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_DVB_SCRAMBLING_MODE_TYPE</NAME>
#define GST_TYPE_MPEGTS_DVB_SCRAMBLING_MODE_TYPE (gst_mpegts_dvb_scrambling_mode_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_initialize</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_SECTION</NAME>
#define GST_TYPE_MPEGTS_SECTION (gst_mpegts_section_get_type())
</MACRO>
<MACRO>
<NAME>GST_MPEGTS_SECTION</NAME>
#define GST_MPEGTS_SECTION(section) ((GstMpegtsSection*) section)
</MACRO>
<MACRO>
<NAME>GST_MPEGTS_SECTION_TYPE</NAME>
#define GST_MPEGTS_SECTION_TYPE(section) (GST_MPEGTS_SECTION (section)->section_type)
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_section_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstMpegtsSectionType</NAME>
typedef enum {
  GST_MPEGTS_SECTION_UNKNOWN           = 0,
  GST_MPEGTS_SECTION_PAT, 
  GST_MPEGTS_SECTION_PMT, 
  GST_MPEGTS_SECTION_CAT, 
  GST_MPEGTS_SECTION_TSDT,
  GST_MPEGTS_SECTION_EIT, 
  GST_MPEGTS_SECTION_NIT, 
  GST_MPEGTS_SECTION_BAT, 
  GST_MPEGTS_SECTION_SDT, 
  GST_MPEGTS_SECTION_TDT, 
  GST_MPEGTS_SECTION_TOT,
  GST_MPEGTS_SECTION_ATSC_TVCT,
  GST_MPEGTS_SECTION_ATSC_CVCT,
  GST_MPEGTS_SECTION_ATSC_MGT,
  GST_MPEGTS_SECTION_ATSC_ETT,
  GST_MPEGTS_SECTION_ATSC_EIT,
  GST_MPEGTS_SECTION_ATSC_STT
} GstMpegtsSectionType;
</ENUM>
<ENUM>
<NAME>GstMpegtsSectionTableID</NAME>
typedef enum {
  /* ITU H.222.0 / IEC 13818-1 */
  GST_MTS_TABLE_ID_PROGRAM_ASSOCIATION		= 0x00,
  GST_MTS_TABLE_ID_CONDITIONAL_ACCESS		= 0x01,
  GST_MTS_TABLE_ID_TS_PROGRAM_MAP		= 0x02,
  GST_MTS_TABLE_ID_TS_DESCRIPTION		= 0x03,
  GST_MTS_TABLE_ID_14496_SCENE_DESCRIPTION	= 0x04,
  GST_MTS_TABLE_ID_14496_OBJET_DESCRIPTOR	= 0x05,
  GST_MTS_TABLE_ID_METADATA			= 0x06,
  GST_MTS_TABLE_ID_IPMP_CONTROL_INFORMATION	= 0x07,

  /* 0x08 - 0x39 : ITU H.222.0 | ISO/IEC 13818-1 reserved */

  /* IEC 13818-6 (DSM-CC) */
  GST_MTS_TABLE_ID_DSM_CC_MULTIPROTO_ENCAPSULATED_DATA	= 0x3A,
  GST_MTS_TABLE_ID_DSM_CC_U_N_MESSAGES			= 0x3B,
  GST_MTS_TABLE_ID_DSM_CC_DOWNLOAD_DATA_MESSAGES	= 0x3C,
  GST_MTS_TABLE_ID_DSM_CC_STREAM_DESCRIPTORS		= 0x3D,
  GST_MTS_TABLE_ID_DSM_CC_PRIVATE_DATA			= 0x3E,
  GST_MTS_TABLE_ID_DSM_CC_ADDRESSABLE_SECTIONS		= 0x3F,

  /* Unset */
  GST_MTS_TABLE_ID_UNSET = 0xFF
  
} GstMpegtsSectionTableID;
</ENUM>
<USER_FUNCTION>
<NAME>GstMpegtsPacketizeFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstMpegtsSection *section
</USER_FUNCTION>
<STRUCT>
<NAME>GstMpegtsSection</NAME>
struct _GstMpegtsSection
{
  /*< private >*/
  GstMiniObject parent;

  /*< public >*/
  GstMpegtsSectionType   section_type;

  guint16       pid;
  guint8        table_id;

  guint16       subtable_extension;
  guint8        version_number;

  gboolean      current_next_indicator;

  guint8        section_number;
  guint8        last_section_number;

  guint32       crc;

  /*< private >*/
  /* data: Points to beginning of section data
   * i.e. the first byte is the table_id field */
  guint8       *data;
  /* section_length: length of data (including final CRC if present) */
  guint		section_length;
  /* cached_parsed: cached copy of parsed section */
  gpointer     *cached_parsed;
  /* destroy_parsed: function to clear cached_parsed */
  GDestroyNotify destroy_parsed;
  /* offset: offset of the section within the container stream */
  guint64       offset;
  /* short_section: TRUE if section_syntax_indicator == 0
   * FIXME : Maybe make public later on when allowing creation of
   * sections to that people can create private short sections ? */
  gboolean      short_section;
  GstMpegtsPacketizeFunc packetizer;

  /* Padding for future extension */
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_section_get_data</NAME>
<RETURNS>GBytes  *</RETURNS>
GstMpegtsSection *section
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_PAT_PROGRAM</NAME>
#define GST_TYPE_MPEGTS_PAT_PROGRAM (gst_mpegts_pat_program_get_type())
</MACRO>
<STRUCT>
<NAME>GstMpegtsPatProgram</NAME>
struct _GstMpegtsPatProgram
{
  guint16 program_number;
  guint16 network_or_program_map_PID;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_section_get_pat</NAME>
<RETURNS>GPtrArray  *</RETURNS>
GstMpegtsSection *section
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_pat_program_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_pat_new</NAME>
<RETURNS>GPtrArray  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_pat_program_new</NAME>
<RETURNS>GstMpegtsPatProgram  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_from_pat</NAME>
<RETURNS>GstMpegtsSection  *</RETURNS>
GPtrArray * programs, guint16 ts_id
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_cat</NAME>
<RETURNS>GPtrArray  *</RETURNS>
GstMpegtsSection *section
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_PMT</NAME>
#define GST_TYPE_MPEGTS_PMT (gst_mpegts_pmt_get_type())
</MACRO>
<MACRO>
<NAME>GST_TYPE_MPEGTS_PMT_STREAM</NAME>
#define GST_TYPE_MPEGTS_PMT_STREAM (gst_mpegts_pmt_stream_get_type())
</MACRO>
<ENUM>
<NAME>GstMpegtsStreamType</NAME>
typedef enum {
  GST_MPEGTS_STREAM_TYPE_RESERVED_00                  = 0x00,
  GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG1                  = 0x01,
  GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG2                  = 0x02,
  GST_MPEGTS_STREAM_TYPE_AUDIO_MPEG1                  = 0x03,
  GST_MPEGTS_STREAM_TYPE_AUDIO_MPEG2                  = 0x04,
  GST_MPEGTS_STREAM_TYPE_PRIVATE_SECTIONS             = 0x05,
  GST_MPEGTS_STREAM_TYPE_PRIVATE_PES_PACKETS          = 0x06,
  GST_MPEGTS_STREAM_TYPE_MHEG                         = 0x07,
  GST_MPEGTS_STREAM_TYPE_DSM_CC                       = 0x08,
  GST_MPEGTS_STREAM_TYPE_H_222_1                      = 0x09,
  GST_MPEGTS_STREAM_TYPE_DSMCC_A                      = 0x0a,
  GST_MPEGTS_STREAM_TYPE_DSMCC_B                      = 0x0b,
  GST_MPEGTS_STREAM_TYPE_DSMCC_C                      = 0x0c,
  GST_MPEGTS_STREAM_TYPE_DSMCC_D                      = 0x0d,
  GST_MPEGTS_STREAM_TYPE_AUXILIARY                    = 0x0e,
  GST_MPEGTS_STREAM_TYPE_AUDIO_AAC_ADTS               = 0x0f,
  GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG4                  = 0x10,
  GST_MPEGTS_STREAM_TYPE_AUDIO_AAC_LATM               = 0x11,
  GST_MPEGTS_STREAM_TYPE_SL_FLEXMUX_PES_PACKETS       = 0x12,
  GST_MPEGTS_STREAM_TYPE_SL_FLEXMUX_SECTIONS          = 0x13,
  GST_MPEGTS_STREAM_TYPE_SYNCHRONIZED_DOWNLOAD        = 0x14,
  GST_MPEGTS_STREAM_TYPE_METADATA_PES_PACKETS         = 0x15,
  GST_MPEGTS_STREAM_TYPE_METADATA_SECTIONS            = 0x16,
  GST_MPEGTS_STREAM_TYPE_METADATA_DATA_CAROUSEL       = 0x17,
  GST_MPEGTS_STREAM_TYPE_METADATA_OBJECT_CAROUSEL     = 0x18,
  GST_MPEGTS_STREAM_TYPE_METADATA_SYNCHRONIZED_DOWNLOAD  = 0x19,
  GST_MPEGTS_STREAM_TYPE_MPEG2_IPMP                   = 0x1a,
  GST_MPEGTS_STREAM_TYPE_VIDEO_H264                   = 0x1b,
  GST_MPEGTS_STREAM_TYPE_AUDIO_AAC_CLEAN              = 0x1c,
  GST_MPEGTS_STREAM_TYPE_MPEG4_TIMED_TEXT             = 0x1d,
  GST_MPEGTS_STREAM_TYPE_VIDEO_RVC                    = 0x1e,
  GST_MPEGTS_STREAM_TYPE_VIDEO_H264_SVC_SUB_BITSTREAM = 0x1f,
  GST_MPEGTS_STREAM_TYPE_VIDEO_H264_MVC_SUB_BITSTREAM = 0x20,
  GST_MPEGTS_STREAM_TYPE_VIDEO_JP2K                   = 0x21,
  GST_MPEGTS_STREAM_TYPE_VIDEO_MPEG2_STEREO_ADDITIONAL_VIEW = 0x22,
  GST_MPEGTS_STREAM_TYPE_VIDEO_H264_STEREO_ADDITIONAL_VIEW  = 0x23,
  GST_MPEGTS_STREAM_TYPE_VIDEO_HEVC                   = 0x24,
  /* 0x24 - 0x7e : Rec. ITU-T H.222.0 | ISO/IEC 13818-1 Reserved */
  GST_MPEGTS_STREAM_TYPE_IPMP_STREAM                  = 0x7f
  /* 0x80 - 0xff : User Private (or defined in other specs) */
} GstMpegtsStreamType;
</ENUM>
<STRUCT>
<NAME>GstMpegtsPMTStream</NAME>
struct _GstMpegtsPMTStream
{
  guint8      stream_type;
  guint16     pid;

  GPtrArray  *descriptors;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsPMT</NAME>
struct _GstMpegtsPMT
{
  guint16    pcr_pid;
  guint16    program_number;

  GPtrArray *descriptors;
  GPtrArray *streams;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_pmt_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_pmt_stream_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_pmt_new</NAME>
<RETURNS>GstMpegtsPMT  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_pmt_stream_new</NAME>
<RETURNS>GstMpegtsPMTStream  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_pmt</NAME>
<RETURNS>const GstMpegtsPMT  *</RETURNS>
GstMpegtsSection *section
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_from_pmt</NAME>
<RETURNS>GstMpegtsSection  *</RETURNS>
GstMpegtsPMT *pmt, guint16 pid
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_tsdt</NAME>
<RETURNS>GPtrArray  *</RETURNS>
GstMpegtsSection *section
</FUNCTION>
<MACRO>
<NAME>gst_mpegts_section_ref</NAME>
#define gst_mpegts_section_ref(section)   ((GstMpegtsSection*) gst_mini_object_ref (GST_MINI_OBJECT_CAST (section)))
</MACRO>
<MACRO>
<NAME>gst_mpegts_section_unref</NAME>
#define gst_mpegts_section_unref(section) (gst_mini_object_unref (GST_MINI_OBJECT_CAST (section)))
</MACRO>
<FUNCTION>
<NAME>gst_message_new_mpegts_section</NAME>
<RETURNS>GstMessage  *</RETURNS>
GstObject *parent, GstMpegtsSection *section
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_send_event</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpegtsSection * section, GstElement * element
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_mpegts_section</NAME>
<RETURNS>GstMpegtsSection  *</RETURNS>
GstEvent * event
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_mpegts_section</NAME>
<RETURNS>GstMpegtsSection  *</RETURNS>
GstMessage *message
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_new</NAME>
<RETURNS>GstMpegtsSection  *</RETURNS>
guint16 pid, guint8 * data, gsize data_size
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_packetize</NAME>
<RETURNS>guint8  *</RETURNS>
GstMpegtsSection * section, gsize * output_size
</FUNCTION>
<ENUM>
<NAME>GstMpegtsDescriptorType</NAME>
typedef enum {
  /* 0-18 ISO/IEC 13818-1 (H222.0 06/2012) */
  GST_MTS_DESC_RESERVED_00                      = 0x00,
  GST_MTS_DESC_RESERVED_01                      = 0x01,
  GST_MTS_DESC_VIDEO_STREAM                     = 0x02,
  GST_MTS_DESC_AUDIO_STREAM                     = 0x03,
  GST_MTS_DESC_HIERARCHY                        = 0x04,
  GST_MTS_DESC_REGISTRATION                     = 0x05,
  GST_MTS_DESC_DATA_STREAM_ALIGNMENT            = 0x06,
  GST_MTS_DESC_TARGET_BACKGROUND_GRID           = 0x07,
  GST_MTS_DESC_VIDEO_WINDOW                     = 0x08,
  GST_MTS_DESC_CA                               = 0x09,
  GST_MTS_DESC_ISO_639_LANGUAGE                 = 0x0A,
  GST_MTS_DESC_SYSTEM_CLOCK                     = 0x0B,
  GST_MTS_DESC_MULTIPLEX_BUFFER_UTILISATION     = 0x0C,
  GST_MTS_DESC_COPYRIGHT                        = 0x0D,
  GST_MTS_DESC_MAXIMUM_BITRATE                  = 0x0E,
  GST_MTS_DESC_PRIVATE_DATA_INDICATOR           = 0x0F,
  GST_MTS_DESC_SMOOTHING_BUFFER                 = 0x10,
  GST_MTS_DESC_STD                              = 0x11,
  GST_MTS_DESC_IBP                              = 0x12,

  /* 19-26 Defined in ISO/IEC 13818-6 (Extensions for DSM-CC) */
  GST_MTS_DESC_DSMCC_CAROUSEL_IDENTIFIER        = 0x13,
  GST_MTS_DESC_DSMCC_ASSOCIATION_TAG            = 0x14,
  GST_MTS_DESC_DSMCC_DEFERRED_ASSOCIATION_TAG   = 0x15,
  /* 0x16 is reserved (so far) */
  GST_MTS_DESC_DSMCC_NPT_REFERENCE              = 0x17,
  GST_MTS_DESC_DSMCC_NPT_ENDPOINT               = 0x18,
  GST_MTS_DESC_DSMCC_STREAM_MODE                = 0x19,
  GST_MTS_DESC_DSMCC_STREAM_EVENT               = 0x1A,

  /* 27-54 Later additions to ISO/IEC 13818-1 (H222.0 06/2012) */
  GST_MTS_DESC_MPEG4_VIDEO                      = 0x1B,
  GST_MTS_DESC_MPEG4_AUDIO                      = 0x1C,
  GST_MTS_DESC_IOD                              = 0x1D,
  GST_MTS_DESC_SL                               = 0x1E,
  GST_MTS_DESC_FMC                              = 0x1F,
  GST_MTS_DESC_EXTERNAL_ES_ID                   = 0x20,
  GST_MTS_DESC_MUX_CODE                         = 0x21,
  GST_MTS_DESC_FMX_BUFFER_SIZE                  = 0x22,
  GST_MTS_DESC_MULTIPLEX_BUFFER                 = 0x23,
  GST_MTS_DESC_CONTENT_LABELING                 = 0x24,
  GST_MTS_DESC_METADATA_POINTER                 = 0x25,
  GST_MTS_DESC_METADATA                         = 0x26,
  GST_MTS_DESC_METADATA_STD                     = 0x27,
  GST_MTS_DESC_AVC_VIDEO                        = 0x28,
  /* defined in ISO/IEC 13818-11, MPEG-2 IPMP */
  GST_MTS_DESC_IPMP                             = 0x29,
  GST_MTS_DESC_AVC_TIMING_AND_HRD               = 0x2A,
  GST_MTS_DESC_MPEG2_AAC_AUDIO                  = 0x2B,
  GST_MTS_DESC_FLEX_MUX_TIMING                  = 0x2C,
  GST_MTS_DESC_MPEG4_TEXT                       = 0x2D,
  GST_MTS_DESC_MPEG4_AUDIO_EXTENSION            = 0x2E,
  GST_MTS_DESC_AUXILIARY_VIDEO_STREAM           = 0x2F,
  GST_MTS_DESC_SVC_EXTENSION                    = 0x30,
  GST_MTS_DESC_MVC_EXTENSION                    = 0x31,
  GST_MTS_DESC_J2K_VIDEO                        = 0x32,
  GST_MTS_DESC_MVC_OPERATION_POINT              = 0x33,
  GST_MTS_DESC_MPEG2_STEREOSCOPIC_VIDEO_FORMAT  = 0x34,
  GST_MTS_DESC_STEREOSCOPIC_PROGRAM_INFO        = 0x35,
  GST_MTS_DESC_STEREOSCOPIC_VIDEO_INFO          = 0x36,

  /* 55-63 ITU-T Rec. H.222.0 | ISO/IEC 13818-1 Reserved */
} GstMpegtsDescriptorType;
</ENUM>
<ENUM>
<NAME>GstMpegtsMiscDescriptorType</NAME>
typedef enum {
  /* 0x80 - 0xFE are user defined */
  GST_MTS_DESC_AC3_AUDIO_STREAM                 = 0x81,
  GST_MTS_DESC_DTG_LOGICAL_CHANNEL              = 0x83,    /* from DTG D-Book */
} GstMpegtsMiscDescriptorType;
</ENUM>
<ENUM>
<NAME>GstMpegtsATSCDescriptorType</NAME>
typedef enum {
  /* ATSC A/65 2009 */
  GST_MTS_DESC_ATSC_STUFFING                    = 0x80,
  GST_MTS_DESC_ATSC_AC3                         = 0x83,
  GST_MTS_DESC_ATSC_CAPTION_SERVICE             = 0x86,
  GST_MTS_DESC_ATSC_CONTENT_ADVISORY            = 0x87,
  GST_MTS_DESC_ATSC_EXTENDED_CHANNEL_NAME       = 0xA0,
  GST_MTS_DESC_ATSC_SERVICE_LOCATION            = 0xA1,
  GST_MTS_DESC_ATSC_TIME_SHIFTED_SERVICE        = 0xA2,
  GST_MTS_DESC_ATSC_COMPONENT_NAME              = 0xA3,
  GST_MTS_DESC_ATSC_DCC_DEPARTING_REQUEST       = 0xA8,
  GST_MTS_DESC_ATSC_DCC_ARRIVING_REQUEST        = 0xA9,
  GST_MTS_DESC_ATSC_REDISTRIBUTION_CONTROL      = 0xAA,
  GST_MTS_DESC_ATSC_GENRE                       = 0xAB,
  GST_MTS_DESC_ATSC_PRIVATE_INFORMATION         = 0xAD,
  GST_MTS_DESC_ATSC_EAC3                        = 0xCC,

  /* ATSC A/53:3 2009 */
  GST_MTS_DESC_ATSC_ENHANCED_SIGNALING          = 0xB2,

  /* ATSC A/90 */
  GST_MTS_DESC_ATSC_DATA_SERVICE                = 0xA4,
  GST_MTS_DESC_ATSC_PID_COUNT                   = 0xA5,
  GST_MTS_DESC_ATSC_DOWNLOAD_DESCRIPTOR         = 0xA6,
  GST_MTS_DESC_ATSC_MULTIPROTOCOL_ENCAPSULATION = 0xA7,
  GST_MTS_DESC_ATSC_MODULE_LINK                 = 0xB4,
  GST_MTS_DESC_ATSC_CRC32                       = 0xB5,
  GST_MTS_DESC_ATSC_GROUP_LINK                  = 0xB8,
} GstMpegtsATSCDescriptorType;
</ENUM>
<ENUM>
<NAME>GstMpegtsISDBDescriptorType</NAME>
typedef enum {
  /* ISDB ARIB B10 v4.6 */
  GST_MTS_DESC_ISDB_HIERARCHICAL_TRANSMISSION   = 0xC0,
  GST_MTS_DESC_ISDB_DIGITAL_COPY_CONTROL        = 0xC1,
  GST_MTS_DESC_ISDB_NETWORK_IDENTIFICATION      = 0xC2,
  GST_MTS_DESC_ISDB_PARTIAL_TS_TIME             = 0xc3,
  GST_MTS_DESC_ISDB_AUDIO_COMPONENT             = 0xc4,
  GST_MTS_DESC_ISDB_HYPERLINK                   = 0xc5,
  GST_MTS_DESC_ISDB_TARGET_REGION               = 0xc6,
  GST_MTS_DESC_ISDB_DATA_CONTENT                = 0xc7,
  GST_MTS_DESC_ISDB_VIDEO_DECODE_CONTROL        = 0xc8,
  GST_MTS_DESC_ISDB_DOWNLOAD_CONTENT            = 0xc9,
  GST_MTS_DESC_ISDB_CA_EMM_TS                   = 0xca,
  GST_MTS_DESC_ISDB_CA_CONTRACT_INFORMATION     = 0xcb,
  GST_MTS_DESC_ISDB_CA_SERVICE                  = 0xcc,
  GST_MTS_DESC_ISDB_TS_INFORMATION              = 0xcd,
  GST_MTS_DESC_ISDB_EXTENDED_BROADCASTER        = 0xce,
  GST_MTS_DESC_ISDB_LOGO_TRANSMISSION           = 0xcf,
  GST_MTS_DESC_ISDB_BASIC_LOCAL_EVENT           = 0xd0,
  GST_MTS_DESC_ISDB_REFERENCE                   = 0xd1,
  GST_MTS_DESC_ISDB_NODE_RELATION               = 0xd2,
  GST_MTS_DESC_ISDB_SHORT_NODE_INFORMATION      = 0xd3,
  GST_MTS_DESC_ISDB_STC_REFERENCE               = 0xd4,
  GST_MTS_DESC_ISDB_SERIES                      = 0xd5,
  GST_MTS_DESC_ISDB_EVENT_GROUP                 = 0xd6,
  GST_MTS_DESC_ISDB_SI_PARAMETER                = 0xd7,
  GST_MTS_DESC_ISDB_BROADCASTER_NAME            = 0xd8,
  GST_MTS_DESC_ISDB_COMPONENT_GROUP             = 0xd9,
  GST_MTS_DESC_ISDB_SI_PRIME_TS                 = 0xda,
  GST_MTS_DESC_ISDB_BOARD_INFORMATION           = 0xdb,
  GST_MTS_DESC_ISDB_LDT_LINKAGE                 = 0xdc,
  GST_MTS_DESC_ISDB_CONNECTED_TRANSMISSION      = 0xdd,
  GST_MTS_DESC_ISDB_CONTENT_AVAILABILITY        = 0xde,
  /* ... */
  GST_MTS_DESC_ISDB_SERVICE_GROUP               = 0xe0
  
} GstMpegtsISDBDescriptorType;
</ENUM>
<MACRO>
<NAME>GST_TYPE_MPEGTS_DESCRIPTOR</NAME>
#define GST_TYPE_MPEGTS_DESCRIPTOR (gst_mpegts_descriptor_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_descriptor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstMpegtsDescriptor</NAME>
struct _GstMpegtsDescriptor
{
  guint8 tag;
  guint8 tag_extension;
  guint8 length;
  guint8 *data;

  /*< private >*/
  /* Padding for future extension */
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_descriptor_free</NAME>
<RETURNS>void        </RETURNS>
GstMpegtsDescriptor *desc
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_parse_descriptors</NAME>
<RETURNS>GPtrArray  *</RETURNS>
guint8 * buffer, gsize buf_len
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_find_descriptor</NAME>
<RETURNS>const GstMpegtsDescriptor  * </RETURNS>
GPtrArray *descriptors, guint8 tag
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_from_registration</NAME>
<RETURNS>GstMpegtsDescriptor  *</RETURNS>
 const gchar *format_identifier, guint8 *additional_info, gsize additional_info_length
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_ca</NAME>
<RETURNS>gboolean   </RETURNS>
GstMpegtsDescriptor *descriptor, guint16 *ca_system_id, guint16 *ca_pid, const guint8 **private_data, gsize *private_data_size
</FUNCTION>
<ENUM>
<NAME>GstMpegtsIso639AudioType</NAME>
typedef enum {
  GST_MPEGTS_AUDIO_TYPE_UNDEFINED = 0,
  GST_MPEGTS_AUDIO_TYPE_CLEAN_EFFECTS,
  GST_MPEGTS_AUDIO_TYPE_HEARING_IMPAIRED,
  GST_MPEGTS_AUDIO_TYPE_VISUAL_IMPAIRED_COMMENTARY
} GstMpegtsIso639AudioType;
</ENUM>
<STRUCT>
<NAME>GstMpegtsISO639LanguageDescriptor</NAME>
struct _GstMpegtsISO639LanguageDescriptor
{
  guint                    nb_language;
  gchar                    *language[64];
  GstMpegtsIso639AudioType audio_type[64];
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ISO_639_LANGUAGE</NAME>
#define GST_TYPE_MPEGTS_ISO_639_LANGUAGE (gst_mpegts_iso_639_language_get_type ())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_iso_639_language_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_iso_639_language_descriptor_free</NAME>
<RETURNS>void  </RETURNS>
GstMpegtsISO639LanguageDescriptor * desc
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_iso_639_language</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, GstMpegtsISO639LanguageDescriptor **res
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_iso_639_language_idx</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, guint idx, gchar **lang, GstMpegtsIso639AudioType *audio_type
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_iso_639_language_nb</NAME>
<RETURNS>guint  </RETURNS>
const GstMpegtsDescriptor *descriptor
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_from_iso_639_language</NAME>
<RETURNS>GstMpegtsDescriptor  * </RETURNS>
const gchar * language
</FUNCTION>
<STRUCT>
<NAME>GstMpegtsLogicalChannel</NAME>
struct _GstMpegtsLogicalChannel
{
  guint16   service_id;
  gboolean  visible_service;
  guint16   logical_channel_number;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsLogicalChannelDescriptor</NAME>
struct _GstMpegtsLogicalChannelDescriptor
{
  guint                   nb_channels;
  GstMpegtsLogicalChannel channels[64];
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_logical_channel</NAME>
<RETURNS>gboolean </RETURNS>
const GstMpegtsDescriptor *descriptor, GstMpegtsLogicalChannelDescriptor *res
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_from_custom</NAME>
<RETURNS>GstMpegtsDescriptor  *</RETURNS>
guint8 tag, const guint8 *data, gsize length
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_from_custom_with_extension</NAME>
<RETURNS>GstMpegtsDescriptor  *</RETURNS>
guint8 tag, guint8 tag_extension, const guint8 *data, gsize length
</FUNCTION>
<ENUM>
<NAME>GstMpegtsSectionDVBTableID</NAME>
typedef enum {
  /* EN 300 468 (DVB) v 1.12.1 */
  GST_MTS_TABLE_ID_NETWORK_INFORMATION_ACTUAL_NETWORK	= 0x40,
  GST_MTS_TABLE_ID_NETWORK_INFORMATION_OTHER_NETWORK	= 0x41,
  GST_MTS_TABLE_ID_SERVICE_DESCRIPTION_ACTUAL_TS	= 0x42,
  GST_MTS_TABLE_ID_SERVICE_DESCRIPTION_OTHER_TS		= 0x46,
  GST_MTS_TABLE_ID_BOUQUET_ASSOCIATION			= 0x4A,
  GST_MTS_TABLE_ID_EVENT_INFORMATION_ACTUAL_TS_PRESENT	= 0x4E,
  GST_MTS_TABLE_ID_EVENT_INFORMATION_OTHER_TS_PRESENT	= 0x4F,
  GST_MTS_TABLE_ID_EVENT_INFORMATION_ACTUAL_TS_SCHEDULE_1	= 0x50,
  GST_MTS_TABLE_ID_EVENT_INFORMATION_ACTUAL_TS_SCHEDULE_N	= 0x5F,
  GST_MTS_TABLE_ID_EVENT_INFORMATION_OTHER_TS_SCHEDULE_1	= 0x60,
  GST_MTS_TABLE_ID_EVENT_INFORMATION_OTHER_TS_SCHEDULE_N	= 0x6F,
  GST_MTS_TABLE_ID_TIME_DATE				= 0x70,
  GST_MTS_TABLE_ID_RUNNING_STATUS			= 0x71,
  GST_MTS_TABLE_ID_STUFFING				= 0x72,
  GST_MTS_TABLE_ID_TIME_OFFSET				= 0x73,

  /* TS 102 812 (MHP v1.1.3) */
  GST_MTS_TABLE_ID_APPLICATION_INFORMATION_TABLE	= 0x74,

  /* TS 102 323 (DVB TV Anytime v1.5.1) */
  GST_MTS_TABLE_ID_CONTAINER				= 0x75,
  GST_MTS_TABLE_ID_RELATED_CONTENT			= 0x76,
  GST_MTS_TABLE_ID_CONTENT_IDENTIFIER			= 0x77,
  
  /* EN 301 192 (DVB specification for data broadcasting) */
  GST_MTS_TABLE_ID_MPE_FEC				= 0x78,

  /* TS 102 323 (DVB TV Anytime v1.5.1) */
  GST_MTS_TABLE_ID_RESOLUTION_NOTIFICATION		= 0x79,

  /* TS 102 772 (DVB-SH Multi-Protocol Encapsulation) */
  GST_MTS_TABLE_ID_MPE_IFEC				= 0x7A,
  
  /* EN 300 468 (DVB) v 1.12.1 */
  GST_MTS_TABLE_ID_DISCONTINUITY_INFORMATION		= 0x7E,
  GST_MTS_TABLE_ID_SELECTION_INFORMATION		= 0x7F,

  /* ETR 289 (DVB Support for use of scrambling and CA) */
  GST_MTS_TABLE_ID_CA_MESSAGE_ECM_0			= 0x80,
  GST_MTS_TABLE_ID_CA_MESSAGE_ECM_1			= 0x81,
  GST_MTS_TABLE_ID_CA_MESSAGE_SYSTEM_PRIVATE_1		= 0x82,
  GST_MTS_TABLE_ID_CA_MESSAGE_SYSTEM_PRIVATE_N		= 0x8F,

  /* ... */

  /* EN 301 790 (DVB interaction channel for satellite distribution channels) */
  GST_MTS_TABLE_ID_SCT					= 0xA0,
  GST_MTS_TABLE_ID_FCT					= 0xA1,
  GST_MTS_TABLE_ID_TCT					= 0xA2,
  GST_MTS_TABLE_ID_SPT					= 0xA3,
  GST_MTS_TABLE_ID_CMT					= 0xA4,
  GST_MTS_TABLE_ID_TBTP					= 0xA5,
  GST_MTS_TABLE_ID_PCR_PACKET_PAYLOAD			= 0xA6,
  GST_MTS_TABLE_ID_TRANSMISSION_MODE_SUPPORT_PAYLOAD	= 0xAA,
  GST_MTS_TABLE_ID_TIM					= 0xB0,
  GST_MTS_TABLE_ID_LL_FEC_PARITY_DATA_TABLE		= 0xB1

} GstMpegtsSectionDVBTableID;
</ENUM>
<ENUM>
<NAME>GstMpegtsRunningStatus</NAME>
typedef enum
{
  GST_MPEGTS_RUNNING_STATUS_UNDEFINED = 0,
  GST_MPEGTS_RUNNING_STATUS_NOT_RUNNING,
  GST_MPEGTS_RUNNING_STATUS_STARTS_IN_FEW_SECONDS,
  GST_MPEGTS_RUNNING_STATUS_PAUSING,
  GST_MPEGTS_RUNNING_STATUS_RUNNING,
  GST_MPEGTS_RUNNING_STATUS_OFF_AIR
} GstMpegtsRunningStatus;
</ENUM>
<MACRO>
<NAME>GST_TYPE_MPEGTS_NIT</NAME>
#define GST_TYPE_MPEGTS_NIT (gst_mpegts_nit_get_type())
</MACRO>
<MACRO>
<NAME>GST_TYPE_MPEGTS_NIT_STREAM</NAME>
#define GST_TYPE_MPEGTS_NIT_STREAM (gst_mpegts_nit_stream_get_type())
</MACRO>
<STRUCT>
<NAME>GstMpegtsNITStream</NAME>
struct _GstMpegtsNITStream
{
  guint16  transport_stream_id;
  guint16  original_network_id;

  GPtrArray  *descriptors;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsNIT</NAME>
struct _GstMpegtsNIT
{
  gboolean   actual_network;
  guint16    network_id;

  GPtrArray  *descriptors;

  GPtrArray *streams;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_nit_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_nit_stream_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_nit</NAME>
<RETURNS>const GstMpegtsNIT  *</RETURNS>
GstMpegtsSection *section
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_from_nit</NAME>
<RETURNS>GstMpegtsSection  *</RETURNS>
GstMpegtsNIT *nit
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_nit_new</NAME>
<RETURNS>GstMpegtsNIT  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_nit_stream_new</NAME>
<RETURNS>GstMpegtsNITStream  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_BAT</NAME>
#define GST_TYPE_MPEGTS_BAT (gst_mpegts_bat_get_type())
</MACRO>
<MACRO>
<NAME>GST_TYPE_MPEGTS_BAT_STREAM</NAME>
#define GST_TYPE_MPEGTS_BAT_STREAM (gst_mpegts_bat_get_type())
</MACRO>
<STRUCT>
<NAME>GstMpegtsBATStream</NAME>
struct _GstMpegtsBATStream
{
  guint16   transport_stream_id;
  guint16   original_network_id;

  GPtrArray   *descriptors;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsBAT</NAME>
struct _GstMpegtsBAT
{
  GPtrArray  *descriptors;

  GPtrArray  *streams;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_bat_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_bat_stream_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_bat</NAME>
<RETURNS>const GstMpegtsBAT  *</RETURNS>
GstMpegtsSection *section
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_SDT</NAME>
#define GST_TYPE_MPEGTS_SDT (gst_mpegts_sdt_get_type())
</MACRO>
<MACRO>
<NAME>GST_TYPE_MPEGTS_SDT_SERVICE</NAME>
#define GST_TYPE_MPEGTS_SDT_SERVICE (gst_mpegts_sdt_service_get_type())
</MACRO>
<STRUCT>
<NAME>GstMpegtsSDTService</NAME>
struct _GstMpegtsSDTService
{
  guint16    service_id;

  gboolean   EIT_schedule_flag;
  gboolean   EIT_present_following_flag;
  GstMpegtsRunningStatus running_status;
  gboolean   free_CA_mode;

  GPtrArray    *descriptors;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsSDT</NAME>
struct _GstMpegtsSDT
{
  guint16    original_network_id;
  gboolean   actual_ts;
  guint16    transport_stream_id;

  GPtrArray *services;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_sdt_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_sdt_service_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_sdt</NAME>
<RETURNS>const GstMpegtsSDT  *</RETURNS>
GstMpegtsSection *section
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_from_sdt</NAME>
<RETURNS>GstMpegtsSection  *</RETURNS>
GstMpegtsSDT * sdt
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_sdt_new</NAME>
<RETURNS>GstMpegtsSDT  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_sdt_service_new</NAME>
<RETURNS>GstMpegtsSDTService  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_EIT</NAME>
#define GST_TYPE_MPEGTS_EIT (gst_mpegts_eit_get_type())
</MACRO>
<MACRO>
<NAME>GST_TYPE_MPEGTS_EIT_EVENT</NAME>
#define GST_TYPE_MPEGTS_EIT_EVENT (gst_mpegts_eit_event_get_type())
</MACRO>
<STRUCT>
<NAME>GstMpegtsEITEvent</NAME>
struct _GstMpegtsEITEvent
{
  guint16      event_id;

  GstDateTime *start_time;
  guint32      duration;

  GstMpegtsRunningStatus running_status;
  gboolean     free_CA_mode;

  GPtrArray   *descriptors;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsEIT</NAME>
struct _GstMpegtsEIT
{
  guint16        transport_stream_id;
  guint16        original_network_id;
  guint8         segment_last_section_number;
  guint8         last_table_id;

  gboolean       actual_stream;
  gboolean       present_following;

  GPtrArray     *events;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_eit_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_eit_event_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_eit</NAME>
<RETURNS>const GstMpegtsEIT  *</RETURNS>
GstMpegtsSection *section
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_tdt</NAME>
<RETURNS>GstDateTime  *</RETURNS>
GstMpegtsSection *section
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_TOT</NAME>
#define GST_TYPE_MPEGTS_TOT (gst_mpegts_tot_get_type())
</MACRO>
<STRUCT>
<NAME>GstMpegtsTOT</NAME>
struct _GstMpegtsTOT
{
  GstDateTime   *utc_time;

  GPtrArray     *descriptors;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_tot_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_tot</NAME>
<RETURNS>const GstMpegtsTOT  *</RETURNS>
GstMpegtsSection *section
</FUNCTION>
<ENUM>
<NAME>GstMpegtsSectionATSCTableID</NAME>
typedef enum {


  /* ATSC (A/65) */
  GST_MTS_TABLE_ID_ATSC_MASTER_GUIDE                    = 0xC7,
  GST_MTS_TABLE_ID_ATSC_TERRESTRIAL_VIRTUAL_CHANNEL     = 0xC8,
  GST_MTS_TABLE_ID_ATSC_CABLE_VIRTUAL_CHANNEL           = 0xC9,
  GST_MTS_TABLE_ID_ATSC_RATING_REGION                   = 0xCA,
  GST_MTS_TABLE_ID_ATSC_EVENT_INFORMATION               = 0xCB,
  GST_MTS_TABLE_ID_ATSC_CHANNEL_OR_EVENT_EXTENDED_TEXT  = 0xCC,
  GST_MTS_TABLE_ID_ATSC_SYSTEM_TIME                     = 0xCD,
  /* ATSC (A/90) */
  GST_MTS_TABLE_ID_ATSC_DATA_EVENT                      = 0xCE,
  GST_MTS_TABLE_ID_ATSC_DATA_SERVICE                    = 0xCF,
  /* 0xD0 ?? */
  GST_MTS_TABLE_ID_ATSC_NETWORK_RESOURCE                = 0xD1,
  GST_MTS_TABLE_ID_ATSC_LONG_TERM_SERVICE               = 0xD2,
  GST_MTS_TABLE_ID_ATSC_DIRECTED_CHANNEL_CHANGE         = 0xD3,
  GST_MTS_TABLE_ID_ATSC_DIRECTED_CHANNEL_CHANGE_SECTION_CODE = 0xD4,
  /* 0xD5 ?? */
  GST_MTS_TABLE_ID_ATSC_AGGREGATE_EVENT_INFORMATION     = 0xD6,
  GST_MTS_TABLE_ID_ATSC_AGGREGATE_EXTENDED_TEXT         = 0xD7,
  /* 0xD8 ?? */
  GST_MTS_TABLE_ID_ATSC_AGGREGATE_DATA_EVENT            = 0xD9,
  GST_MTS_TABLE_ID_ATSC_SATELLITE_VIRTUAL_CHANNEL       = 0xDA,
} GstMpegtsSectionATSCTableID;
</ENUM>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ATSC_VCT</NAME>
#define GST_TYPE_MPEGTS_ATSC_VCT (gst_mpegts_atsc_vct_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ATSC_VCT_SOURCE</NAME>
#define GST_TYPE_MPEGTS_ATSC_VCT_SOURCE (gst_mpegts_atsc_vct_source_get_type ())
</MACRO>
<STRUCT>
<NAME>GstMpegtsAtscVCTSource</NAME>
struct _GstMpegtsAtscVCTSource
{
  gchar    *short_name;
  guint16   major_channel_number;
  guint16   minor_channel_number;
  guint8    modulation_mode;
  guint32   carrier_frequency;
  guint16   channel_TSID;
  guint16   program_number;
  /* FIXME: */
  guint8    ETM_location;
  gboolean  access_controlled;
  gboolean  hidden;
  gboolean  path_select; /* CVCT only - reserved bit in TVCT */
  gboolean  out_of_band; /* CVCT only - reserved bit in TVCT */
  gboolean  hide_guide;
  /* FIXME: */
  guint8    service_type;
  guint16   source_id;
  GPtrArray *descriptors;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsAtscVCT</NAME>
struct _GstMpegtsAtscVCT
{
  guint16   transport_stream_id;
  guint8    protocol_version;
  GPtrArray *sources;
  GPtrArray *descriptors;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_atsc_vct_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_atsc_vct_source_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_atsc_tvct</NAME>
<RETURNS>const GstMpegtsAtscVCT  * </RETURNS>
GstMpegtsSection * section
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_atsc_cvct</NAME>
<RETURNS>const GstMpegtsAtscVCT  * </RETURNS>
GstMpegtsSection * section
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ATSC_MGT</NAME>
#define GST_TYPE_MPEGTS_ATSC_MGT (gst_mpegts_atsc_mgt_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ATSC_MGT_TABLE</NAME>
#define GST_TYPE_MPEGTS_ATSC_MGT_TABLE (gst_mpegts_atsc_mgt_table_get_type ())
</MACRO>
<ENUM>
<NAME>GstMpegtsAtscMGTTableType</NAME>
typedef enum {
  GST_MPEGTS_ATSC_MGT_TABLE_TYPE_EIT0 = 0x0100,
  GST_MPEGTS_ATSC_MGT_TABLE_TYPE_EIT127 = 0x017F,
  GST_MPEGTS_ATSC_MGT_TABLE_TYPE_ETT0 = 0x0200,
  GST_MPEGTS_ATSC_MGT_TABLE_TYPE_ETT127 = 0x027F
} GstMpegtsAtscMGTTableType;
</ENUM>
<STRUCT>
<NAME>GstMpegtsAtscMGTTable</NAME>
struct _GstMpegtsAtscMGTTable
{
  guint16 table_type;
  guint16 pid;
  guint8  version_number;
  guint32 number_bytes;
  GPtrArray *descriptors;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsAtscMGT</NAME>
struct _GstMpegtsAtscMGT
{
  guint8  protocol_version;
  guint16 tables_defined;
  GPtrArray *tables;
  GPtrArray *descriptors;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_atsc_mgt_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_atsc_mgt_table_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_atsc_mgt</NAME>
<RETURNS>const GstMpegtsAtscMGT  * </RETURNS>
GstMpegtsSection * section
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ATSC_STRING_SEGMENT</NAME>
#define GST_TYPE_MPEGTS_ATSC_STRING_SEGMENT (gst_mpegts_atsc_string_segment_get_type())
</MACRO>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ATSC_MULT_STRING</NAME>
#define GST_TYPE_MPEGTS_ATSC_MULT_STRING (gst_mpegts_atsc_mult_string_get_type())
</MACRO>
<STRUCT>
<NAME>GstMpegtsAtscStringSegment</NAME>
struct _GstMpegtsAtscStringSegment {
  guint8 compression_type;
  guint8 mode;
  guint8 compressed_data_size;
  guint8 *compressed_data;

  gchar *cached_string;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_atsc_string_segment_get_string</NAME>
<RETURNS>const gchar  * </RETURNS>
GstMpegtsAtscStringSegment * seg
</FUNCTION>
<STRUCT>
<NAME>GstMpegtsAtscMultString</NAME>
struct _GstMpegtsAtscMultString {
  gchar      iso_639_langcode[4];
  GPtrArray *segments;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_atsc_string_segment_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_atsc_mult_string_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ATSC_EIT_EVENT</NAME>
#define GST_TYPE_MPEGTS_ATSC_EIT_EVENT (gst_mpegts_atsc_eit_event_get_type())
</MACRO>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ATSC_EIT</NAME>
#define GST_TYPE_MPEGTS_ATSC_EIT (gst_mpegts_atsc_eit_get_type())
</MACRO>
<STRUCT>
<NAME>GstMpegtsAtscEITEvent</NAME>
struct _GstMpegtsAtscEITEvent {
  guint16        event_id;
  guint32        start_time;
  guint8         etm_location;
  guint32        length_in_seconds;
  GPtrArray     *titles;

  GPtrArray *descriptors;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsAtscEIT</NAME>
struct _GstMpegtsAtscEIT
{
  guint16        source_id;
  guint8         protocol_version;

  GPtrArray     *events;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_atsc_eit_event_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_atsc_eit_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_atsc_eit</NAME>
<RETURNS>const GstMpegtsAtscEIT  *</RETURNS>
GstMpegtsSection *section
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ATSC_ETT</NAME>
#define GST_TYPE_MPEGTS_ATSC_ETT (gst_mpegts_atsc_ett_get_type())
</MACRO>
<STRUCT>
<NAME>GstMpegtsAtscETT</NAME>
struct _GstMpegtsAtscETT
{
  guint16        ett_table_id_extension;
  guint16        protocol_version;
  guint32        etm_id;

  GPtrArray     *messages;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_atsc_ett_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_atsc_ett</NAME>
<RETURNS>const GstMpegtsAtscETT  *</RETURNS>
GstMpegtsSection *section
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_ATSC_STT</NAME>
#define GST_TYPE_MPEGTS_ATSC_STT (gst_mpegts_atsc_stt_get_type ())
</MACRO>
<STRUCT>
<NAME>GstMpegtsAtscSTT</NAME>
struct _GstMpegtsAtscSTT
{
  guint8     protocol_version;
  guint32    system_time;
  guint8     gps_utc_offset;
  gboolean   ds_status;
  guint8     ds_dayofmonth;
  guint8     ds_hour;
  GPtrArray *descriptors;

  GstDateTime *utc_datetime;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_atsc_stt_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_section_get_atsc_stt</NAME>
<RETURNS>const GstMpegtsAtscSTT  * </RETURNS>
GstMpegtsSection * section
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_atsc_stt_get_datetime_utc</NAME>
<RETURNS>GstDateTime  * </RETURNS>
GstMpegtsAtscSTT * stt
</FUNCTION>
<ENUM>
<NAME>GstMpegtsDVBDescriptorType</NAME>
typedef enum {
  /* 64-127 DVB tags ETSI EN 300 468
   * (Specification for Service Information (SI) in DVB systems)
   */
  GST_MTS_DESC_DVB_NETWORK_NAME                 = 0x40,
  GST_MTS_DESC_DVB_SERVICE_LIST                 = 0x41,
  GST_MTS_DESC_DVB_STUFFING                     = 0x42,
  GST_MTS_DESC_DVB_SATELLITE_DELIVERY_SYSTEM    = 0x43,
  GST_MTS_DESC_DVB_CABLE_DELIVERY_SYSTEM        = 0x44,
  GST_MTS_DESC_DVB_VBI_DATA                     = 0x45,
  GST_MTS_DESC_DVB_VBI_TELETEXT                 = 0x46,
  GST_MTS_DESC_DVB_BOUQUET_NAME                 = 0x47,
  GST_MTS_DESC_DVB_SERVICE                      = 0x48,
  GST_MTS_DESC_DVB_COUNTRY_AVAILABILITY         = 0x49,
  GST_MTS_DESC_DVB_LINKAGE                      = 0x4A,
  GST_MTS_DESC_DVB_NVOD_REFERENCE               = 0x4B,
  GST_MTS_DESC_DVB_TIME_SHIFTED_SERVICE         = 0x4C,
  GST_MTS_DESC_DVB_SHORT_EVENT                  = 0x4D,
  GST_MTS_DESC_DVB_EXTENDED_EVENT               = 0x4E,
  GST_MTS_DESC_DVB_TIME_SHIFTED_EVENT           = 0x4F,
  GST_MTS_DESC_DVB_COMPONENT                    = 0x50,
  GST_MTS_DESC_DVB_MOSAIC                       = 0x51,
  GST_MTS_DESC_DVB_STREAM_IDENTIFIER            = 0x52,
  GST_MTS_DESC_DVB_CA_IDENTIFIER                = 0x53,
  GST_MTS_DESC_DVB_CONTENT                      = 0x54,
  GST_MTS_DESC_DVB_PARENTAL_RATING              = 0x55,
  GST_MTS_DESC_DVB_TELETEXT                     = 0x56,
  GST_MTS_DESC_DVB_TELEPHONE                    = 0x57,
  GST_MTS_DESC_DVB_LOCAL_TIME_OFFSET            = 0x58,
  GST_MTS_DESC_DVB_SUBTITLING                   = 0x59,
  GST_MTS_DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM  = 0x5A,
  GST_MTS_DESC_DVB_MULTILINGUAL_NETWORK_NAME    = 0x5B,
  GST_MTS_DESC_DVB_MULTILINGUAL_BOUQUET_NAME    = 0x5C,
  GST_MTS_DESC_DVB_MULTILINGUAL_SERVICE_NAME    = 0x5D,
  GST_MTS_DESC_DVB_MULTILINGUAL_COMPONENT       = 0x5E,
  GST_MTS_DESC_DVB_PRIVATE_DATA_SPECIFIER       = 0x5F,
  GST_MTS_DESC_DVB_SERVICE_MOVE                 = 0x60,
  GST_MTS_DESC_DVB_SHORT_SMOOTHING_BUFFER       = 0x61,
  GST_MTS_DESC_DVB_FREQUENCY_LIST               = 0x62,
  GST_MTS_DESC_DVB_PARTIAL_TRANSPORT_STREAM     = 0x63,
  GST_MTS_DESC_DVB_DATA_BROADCAST               = 0x64,
  GST_MTS_DESC_DVB_SCRAMBLING                   = 0x65,
  GST_MTS_DESC_DVB_DATA_BROADCAST_ID            = 0x66,
  GST_MTS_DESC_DVB_TRANSPORT_STREAM             = 0x67,
  GST_MTS_DESC_DVB_DSNG                         = 0x68,
  GST_MTS_DESC_DVB_PDC                          = 0x69,
  GST_MTS_DESC_DVB_AC3                          = 0x6A,
  GST_MTS_DESC_DVB_ANCILLARY_DATA               = 0x6B,
  GST_MTS_DESC_DVB_CELL_LIST                    = 0x6C,
  GST_MTS_DESC_DVB_CELL_FREQUENCY_LINK          = 0x6D,
  GST_MTS_DESC_DVB_ANNOUNCEMENT_SUPPORT         = 0x6E,
  GST_MTS_DESC_DVB_APPLICATION_SIGNALLING       = 0x6F,
  GST_MTS_DESC_DVB_ADAPTATION_FIELD_DATA        = 0x70,
  GST_MTS_DESC_DVB_SERVICE_IDENTIFIER           = 0x71,
  GST_MTS_DESC_DVB_SERVICE_AVAILABILITY         = 0x72,
  GST_MTS_DESC_DVB_DEFAULT_AUTHORITY            = 0x73,
  GST_MTS_DESC_DVB_RELATED_CONTENT              = 0x74,
  GST_MTS_DESC_DVB_TVA_ID                       = 0x75,
  GST_MTS_DESC_DVB_CONTENT_IDENTIFIER           = 0x76,
  GST_MTS_DESC_DVB_TIMESLICE_FEC_IDENTIFIER     = 0x77,
  GST_MTS_DESC_DVB_ECM_REPETITION_RATE          = 0x78,
  GST_MTS_DESC_DVB_S2_SATELLITE_DELIVERY_SYSTEM = 0x79,
  GST_MTS_DESC_DVB_ENHANCED_AC3                 = 0x7A,
  GST_MTS_DESC_DVB_DTS                          = 0x7B,
  GST_MTS_DESC_DVB_AAC                          = 0x7C,
  GST_MTS_DESC_DVB_XAIT_LOCATION                = 0x7D,
  GST_MTS_DESC_DVB_FTA_CONTENT_MANAGEMENT       = 0x7E,
  GST_MTS_DESC_DVB_EXTENSION                    = 0x7F,
} GstMpegtsDVBDescriptorType;
</ENUM>
<ENUM>
<NAME>GstMpegtsDVBExtendedDescriptorType</NAME>
typedef enum {
  /* 00 - 0x7F DVB extended tags ETSI EN 300 468
   * (Specification for Service Information (SI) in DVB systems)
   */
  GST_MTS_DESC_EXT_DVB_IMAGE_ICON               = 0x00,
  /* TS/TR 102 825 */
  GST_MTS_DESC_EXT_DVB_CPCM_DELIVERY_SIGNALLING = 0x01,
  GST_MTS_DESC_EXT_DVB_CP                       = 0x02,
  GST_MTS_DESC_EXT_DVB_CP_IDENTIFIER            = 0x03,
  GST_MTS_DESC_EXT_DVB_T2_DELIVERY_SYSTEM       = 0x04,
  GST_MTS_DESC_EXT_DVB_SH_DELIVERY_SYSTEM       = 0x05,
  GST_MTS_DESC_EXT_DVB_SUPPLEMENTARY_AUDIO      = 0x06,
  GST_MTS_DESC_EXT_DVB_NETWORK_CHANGE_NOTIFY    = 0x07,
  GST_MTS_DESC_EXT_DVB_MESSAGE                  = 0x08,
  GST_MTS_DESC_EXT_DVB_TARGET_REGION            = 0x09,
  GST_MTS_DESC_EXT_DVB_TARGET_REGION_NAME       = 0x0A,
  GST_MTS_DESC_EXT_DVB_SERVICE_RELOCATED        = 0x0B,
  GST_MTS_DESC_EXT_DVB_XAIT_PID                 = 0x0C,
  GST_MTS_DESC_EXT_DVB_C2_DELIVERY_SYSTEM       = 0x0D,
  GST_MTS_DESC_EXT_DVB_DTS_HD_AUDIO_STREAM      = 0x0E,
  GST_MTS_DESC_EXT_DVB_DTS_NEUTRAL              = 0x0F,
  GST_MTS_DESC_EXT_DVB_VIDEO_DEPTH_RANGE        = 0x10,
  GST_MTS_DESC_EXT_DVB_T2MI                     = 0x11,
  GST_MTS_DESC_EXT_DVB_URI_LINKAGE              = 0x13,
} GstMpegtsDVBExtendedDescriptorType;
</ENUM>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_network_name</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, gchar **name
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_from_dvb_network_name</NAME>
<RETURNS>GstMpegtsDescriptor  *</RETURNS>
const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_stuffing</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor * descriptor, guint8 ** stuffing_bytes
</FUNCTION>
<ENUM>
<NAME>GstMpegtsModulationType</NAME>
typedef enum {
  GST_MPEGTS_MODULATION_QPSK    = 0,
  GST_MPEGTS_MODULATION_QAM_16,
  GST_MPEGTS_MODULATION_QAM_32,
  GST_MPEGTS_MODULATION_QAM_64,
  GST_MPEGTS_MODULATION_QAM_128,
  GST_MPEGTS_MODULATION_QAM_256,
  GST_MPEGTS_MODULATION_QAM_AUTO,
  GST_MPEGTS_MODULATION_VSB_8,
  GST_MPEGTS_MODULATION_VSB_16,
  GST_MPEGTS_MODULATION_PSK_8,
  GST_MPEGTS_MODULATION_APSK_16,
  GST_MPEGTS_MODULATION_APSK_32,
  GST_MPEGTS_MODULATION_DQPSK,
  GST_MPEGTS_MODULATION_QAM_4_NR_,
  GST_MPEGTS_MODULATION_NONE
} GstMpegtsModulationType;
</ENUM>
<ENUM>
<NAME>GstMpegtsDVBCodeRate</NAME>
typedef enum {
  GST_MPEGTS_FEC_NONE = 0,
  GST_MPEGTS_FEC_1_2,
  GST_MPEGTS_FEC_2_3,
  GST_MPEGTS_FEC_3_4,
  GST_MPEGTS_FEC_4_5,
  GST_MPEGTS_FEC_5_6,
  GST_MPEGTS_FEC_6_7,
  GST_MPEGTS_FEC_7_8,
  GST_MPEGTS_FEC_8_9,
  GST_MPEGTS_FEC_AUTO,
  GST_MPEGTS_FEC_3_5,
  GST_MPEGTS_FEC_9_10,
  GST_MPEGTS_FEC_2_5
} GstMpegtsDVBCodeRate;
</ENUM>
<ENUM>
<NAME>GstMpegtsSatelliteRolloff</NAME>
typedef enum {
  GST_MPEGTS_ROLLOFF_35 = 0,
  GST_MPEGTS_ROLLOFF_20,
  GST_MPEGTS_ROLLOFF_25,
  GST_MPEGTS_ROLLOFF_RESERVED,
  GST_MPEGTS_ROLLOFF_AUTO
} GstMpegtsSatelliteRolloff;
</ENUM>
<ENUM>
<NAME>GstMpegtsSatellitePolarizationType</NAME>
typedef enum {
  GST_MPEGTS_POLARIZATION_LINEAR_HORIZONTAL = 0,
  GST_MPEGTS_POLARIZATION_LINEAR_VERTICAL,
  GST_MPEGTS_POLARIZATION_CIRCULAR_LEFT,
  GST_MPEGTS_POLARIZATION_CIRCULAR_RIGHT
} GstMpegtsSatellitePolarizationType;
</ENUM>
<STRUCT>
<NAME>GstMpegtsSatelliteDeliverySystemDescriptor</NAME>
struct _GstMpegtsSatelliteDeliverySystemDescriptor
{
  guint32                            frequency;
  gfloat                             orbital_position;
  gboolean                           west_east; 
  GstMpegtsSatellitePolarizationType polarization;

  GstMpegtsSatelliteRolloff          roll_off;
  gboolean                           modulation_system;
  GstMpegtsModulationType            modulation_type;

  guint32                            symbol_rate;
  GstMpegtsDVBCodeRate               fec_inner;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_satellite_delivery_system</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, GstMpegtsSatelliteDeliverySystemDescriptor *res
</FUNCTION>
<ENUM>
<NAME>GstMpegtsCableOuterFECScheme</NAME>
typedef enum {
  GST_MPEGTS_CABLE_OUTER_FEC_UNDEFINED = 0,
  GST_MPEGTS_CABLE_OUTER_FEC_NONE,
  GST_MPEGTS_CABLE_OUTER_FEC_RS_204_188,
} GstMpegtsCableOuterFECScheme;
</ENUM>
<STRUCT>
<NAME>GstMpegtsCableDeliverySystemDescriptor</NAME>
struct _GstMpegtsCableDeliverySystemDescriptor
{
  guint32                            frequency;
  GstMpegtsCableOuterFECScheme       outer_fec;
  GstMpegtsModulationType            modulation;

  guint32                            symbol_rate;
  GstMpegtsDVBCodeRate               fec_inner;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_cable_delivery_system</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, GstMpegtsCableDeliverySystemDescriptor *res
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_bouquet_name</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor * descriptor, gchar ** bouquet_name
</FUNCTION>
<ENUM>
<NAME>GstMpegtsDVBServiceType</NAME>
typedef enum {
  GST_DVB_SERVICE_RESERVED_00               = 0x00,
  GST_DVB_SERVICE_DIGITAL_TELEVISION,
  GST_DVB_SERVICE_DIGITAL_RADIO_SOUND,
  GST_DVB_SERVICE_TELETEXT,
  GST_DVB_SERVICE_NVOD_REFERENCE,
  GST_DVB_SERVICE_NVOD_TIME_SHIFTED,
  GST_DVB_SERVICE_MOSAIC,
  GST_DVB_SERVICE_FM_RADIO,
  GST_DVB_SERVICE_DVB_SRM,
  GST_DVB_SERVICE_RESERVED_09,
  GST_DVB_SERVICE_ADVANCED_CODEC_DIGITAL_RADIO_SOUND,
  GST_DVB_SERVICE_ADVANCED_CODEC_MOSAIC,
  GST_DVB_SERVICE_DATA_BROADCAST,
  GST_DVB_SERVICE_RESERVED_0D_COMMON_INTERFACE,
  GST_DVB_SERVICE_RCS_MAP,
  GST_DVB_SERVICE_RCS_FLS,
  GST_DVB_SERVICE_DVB_MHP,
  GST_DVB_SERVICE_MPEG2_HD_DIGITAL_TELEVISION,
  /* 0x12 - 015 Reserved for future use */
  GST_DVB_SERVICE_ADVANCED_CODEC_SD_DIGITAL_TELEVISION = 0x16,
  GST_DVB_SERVICE_ADVANCED_CODEC_SD_NVOD_TIME_SHIFTED,
  GST_DVB_SERVICE_ADVANCED_CODEC_SD_NVOD_REFERENCE,
  GST_DVB_SERVICE_ADVANCED_CODEC_HD_DIGITAL_TELEVISION,
  GST_DVB_SERVICE_ADVANCED_CODEC_HD_NVOD_TIME_SHIFTED,
  GST_DVB_SERVICE_ADVANCED_CODEC_HD_NVOD_REFERENCE,
  GST_DVB_SERVICE_ADVANCED_CODEC_STEREO_HD_DIGITAL_TELEVISION,
  GST_DVB_SERVICE_ADVANCED_CODEC_STEREO_HD_NVOD_TIME_SHIFTED,
  GST_DVB_SERVICE_ADVANCED_CODEC_STEREO_HD_NVOD_REFERENCE,
  /* 0x1F - 0x7f Reserved for future use */
  /* 0x80 - 0xfe user defined */
  /* 0xff Reserved for future use */
  GST_DVB_SERVICE_RESERVED_FF
} GstMpegtsDVBServiceType;
</ENUM>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_service</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, GstMpegtsDVBServiceType *service_type, gchar **service_name, gchar **provider_name
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_from_dvb_service</NAME>
<RETURNS>GstMpegtsDescriptor  *</RETURNS>
GstMpegtsDVBServiceType service_type, const gchar * service_name, const gchar * service_provider
</FUNCTION>
<STRUCT>
<NAME>GstMpegtsDVBServiceListItem</NAME>
struct _GstMpegtsDVBServiceListItem
{
  guint16                 service_id;
  GstMpegtsDVBServiceType type;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_service_list</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor * descriptor, GPtrArray ** list
</FUNCTION>
<ENUM>
<NAME>GstMpegtsDVBLinkageType</NAME>
typedef enum {
  /* 0x00, 0x0F-0x7F reserved for future use */
  GST_MPEGTS_DVB_LINKAGE_RESERVED_00               = 0x00,
  GST_MPEGTS_DVB_LINKAGE_INFORMATION               = 0x01,
  GST_MPEGTS_DVB_LINKAGE_EPG                       = 0x02,
  GST_MPEGTS_DVB_LINKAGE_CA_REPLACEMENT            = 0x03,
  GST_MPEGTS_DVB_LINKAGE_TS_CONTAINING_COMPLETE_SI = 0x04,
  GST_MPEGTS_DVB_LINKAGE_SERVICE_REPLACEMENT       = 0x05,
  GST_MPEGTS_DVB_LINKAGE_DATA_BROADCAST            = 0x06,
  GST_MPEGTS_DVB_LINKAGE_RCS_MAP                   = 0x07,
  GST_MPEGTS_DVB_LINKAGE_MOBILE_HAND_OVER          = 0x08,
  GST_MPEGTS_DVB_LINKAGE_SYSTEM_SOFTWARE_UPDATE    = 0x09,
  GST_MPEGTS_DVB_LINKAGE_TS_CONTAINING_SSU         = 0x0A,
  GST_MPEGTS_DVB_LINKAGE_IP_MAC_NOTIFICATION       = 0x0B,
  GST_MPEGTS_DVB_LINKAGE_TS_CONTAINING_INT         = 0x0C,
  GST_MPEGTS_DVB_LINKAGE_EVENT                     = 0x0D,
  GST_MPEGTS_DVB_LINKAGE_EXTENDED_EVENT            = 0x0E,
} GstMpegtsDVBLinkageType;
</ENUM>
<ENUM>
<NAME>GstMpegtsDVBLinkageHandOverType</NAME>
typedef enum {
  GST_MPEGTS_DVB_LINKAGE_HAND_OVER_RESERVED        = 0x00,
  GST_MPEGTS_DVB_LINKAGE_HAND_OVER_IDENTICAL       = 0x01,
  GST_MPEGTS_DVB_LINKAGE_HAND_OVER_LOCAL_VARIATION = 0x02,
  GST_MPEGTS_DVB_LINKAGE_HAND_OVER_ASSOCIATED      = 0x03,
} GstMpegtsDVBLinkageHandOverType;
</ENUM>
<STRUCT>
<NAME>GstMpegtsDVBLinkageMobileHandOver</NAME>
struct _GstMpegtsDVBLinkageMobileHandOver
{
  GstMpegtsDVBLinkageHandOverType hand_over_type;
  /* 0 = NIT, 1 = SDT */
  gboolean                        origin_type;
  guint16                         network_id;
  guint16                         initial_service_id;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsDVBLinkageEvent</NAME>
struct _GstMpegtsDVBLinkageEvent
{
  guint16  target_event_id;
  gboolean target_listed;
  gboolean event_simulcast;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsDVBLinkageExtendedEvent</NAME>
struct _GstMpegtsDVBLinkageExtendedEvent
{
  guint16        target_event_id;
  gboolean       target_listed;
  gboolean       event_simulcast;
  /* FIXME: */
  guint8         link_type;
  /* FIXME: */
  guint8         target_id_type;
  gboolean       original_network_id_flag;
  gboolean       service_id_flag;
  /* if (target_id_type == 3) */
  guint16        user_defined_id;
  /* else */
  guint16        target_transport_stream_id;
  guint16        target_original_network_id;
  guint16        target_service_id;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsDVBLinkageDescriptor</NAME>
struct _GstMpegtsDVBLinkageDescriptor
{
  guint16                           transport_stream_id;
  guint16                           original_network_id;
  guint16                           service_id;
  GstMpegtsDVBLinkageType           linkage_type;
  /*< private >*/
  gpointer                          linkage_data;
  /*< public >*/
  guint8                            private_data_length;
  guint8                            *private_data_bytes;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_MPEGTS_DVB_LINKAGE_DESCRIPTOR</NAME>
#define GST_TYPE_MPEGTS_DVB_LINKAGE_DESCRIPTOR ( gst_mpegts_dvb_linkage_descriptor_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_dvb_linkage_descriptor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_dvb_linkage_descriptor_free</NAME>
<RETURNS>void  </RETURNS>
GstMpegtsDVBLinkageDescriptor * source
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_dvb_linkage_descriptor_get_mobile_hand_over</NAME>
<RETURNS>const GstMpegtsDVBLinkageMobileHandOver  *</RETURNS>
const GstMpegtsDVBLinkageDescriptor * desc
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_dvb_linkage_descriptor_get_event</NAME>
<RETURNS>const GstMpegtsDVBLinkageEvent  *</RETURNS>
const GstMpegtsDVBLinkageDescriptor * desc
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_dvb_linkage_descriptor_get_extended_event</NAME>
<RETURNS>const GPtrArray  *</RETURNS>
const GstMpegtsDVBLinkageDescriptor * desc
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_linkage</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor * descriptor, GstMpegtsDVBLinkageDescriptor ** res
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_short_event</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, gchar **language_code, gchar **event_name, gchar **text
</FUNCTION>
<STRUCT>
<NAME>GstMpegtsExtendedEventItem</NAME>
struct _GstMpegtsExtendedEventItem
{
  gchar *item_description;
  gchar *item;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsExtendedEventDescriptor</NAME>
struct _GstMpegtsExtendedEventDescriptor
{
  guint8 descriptor_number;
  guint8 last_descriptor_number;
  gchar  *language_code;
  GPtrArray *items;
  gchar *text;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_MPEGTS_EXTENDED_EVENT_DESCRIPTOR</NAME>
#define GST_TYPE_MPEGTS_EXTENDED_EVENT_DESCRIPTOR (gst_mpegts_extended_event_descriptor_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_extended_event_descriptor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_extended_event_descriptor_free</NAME>
<RETURNS>void  </RETURNS>
GstMpegtsExtendedEventDescriptor * source
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_extended_event</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, GstMpegtsExtendedEventDescriptor **res
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_COMPONENT_DESCRIPTOR</NAME>
#define GST_TYPE_MPEGTS_COMPONENT_DESCRIPTOR (gst_mpegts_component_descriptor_get_type ())
</MACRO>
<ENUM>
<NAME>GstMpegtsComponentStreamContent</NAME>
typedef enum {
  GST_MPEGTS_STREAM_CONTENT_MPEG2_VIDEO          = 0x01,
  GST_MPEGTS_STREAM_CONTENT_MPEG1_LAYER2_AUDIO   = 0x02,
  GST_MPEGTS_STREAM_CONTENT_TELETEXT_OR_SUBTITLE = 0x03,
  GST_MPEGTS_STREAM_CONTENT_AC_3                 = 0x04,
  GST_MPEGTS_STREAM_CONTENT_AVC                  = 0x05,
  GST_MPEGTS_STREAM_CONTENT_AAC                  = 0x06,
  GST_MPEGTS_STREAM_CONTENT_DTS                  = 0x07,
  GST_MPEGTS_STREAM_CONTENT_SRM_CPCM             = 0x08
} GstMpegtsComponentStreamContent;
</ENUM>
<STRUCT>
<NAME>GstMpegtsComponentDescriptor</NAME>
struct _GstMpegtsComponentDescriptor
{
  guint8 stream_content;
  guint8 component_type;
  guint8 component_tag;
  gchar  *language_code;
  gchar  *text;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_component_descriptor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_dvb_component_descriptor_free</NAME>
<RETURNS>void  </RETURNS>
GstMpegtsComponentDescriptor * source
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_component</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, GstMpegtsComponentDescriptor **res
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_stream_identifier</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, guint8 *component_tag
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_ca_identifier</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor * descriptor, GArray ** list
</FUNCTION>
<ENUM>
<NAME>GstMpegtsContentNibbleHi</NAME>
typedef enum {
  GST_MPEGTS_CONTENT_MOVIE_DRAMA                = 0x01,
  GST_MPEGTS_CONTENT_NEWS_CURRENT_AFFAIRS       = 0x02,
  GST_MPEGTS_CONTENT_SHOW_GAME_SHOW             = 0x03,
  GST_MPEGTS_CONTENT_SPORTS                     = 0x04,
  GST_MPEGTS_CONTENT_CHILDREN_YOUTH_PROGRAM     = 0x05,
  GST_MPEGTS_CONTENT_MUSIC_BALLET_DANCE         = 0x06,
  GST_MPEGTS_CONTENT_ARTS_CULTURE               = 0x07,
  GST_MPEGTS_CONTENT_SOCIAL_POLITICAL_ECONOMICS = 0x08,
  GST_MPEGTS_CONTENT_EDUCATION_SCIENCE_FACTUAL  = 0x09,
  GST_MPEGTS_CONTENT_LEISURE_HOBBIES            = 0x0A,
  GST_MPEGTS_CONTENT_SPECIAL_CHARACTERISTICS    = 0x0B
} GstMpegtsContentNibbleHi;
</ENUM>
<STRUCT>
<NAME>GstMpegtsContent</NAME>
struct _GstMpegtsContent
{
  GstMpegtsContentNibbleHi content_nibble_1;
  guint8 content_nibble_2;
  guint8 user_byte;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_content</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor * descriptor, GPtrArray ** content
</FUNCTION>
<STRUCT>
<NAME>GstMpegtsDVBParentalRatingItem</NAME>
struct _GstMpegtsDVBParentalRatingItem
{
  gchar  *country_code;
  guint8 rating;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_parental_rating</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor * descriptor, GPtrArray ** rating
</FUNCTION>
<ENUM>
<NAME>GstMpegtsDVBTeletextType</NAME>
typedef enum {
  INITIAL_PAGE = 0x01,
  SUBTITLE_PAGE,
  ADDITIONAL_INFO_PAGE,
  PROGRAMME_SCHEDULE_PAGE,
  HEARING_IMPAIRED_PAGE
} GstMpegtsDVBTeletextType;
</ENUM>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_teletext_idx</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor * descriptor, guint idx, gchar ** language_code, GstMpegtsDVBTeletextType * teletext_type, guint8 * magazine_number, guint8 * page_number
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_teletext_nb</NAME>
<RETURNS>guint  </RETURNS>
const GstMpegtsDescriptor * descriptor
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_subtitling_idx</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, guint idx, gchar ** lang, guint8 *type, guint16 *composition_page_id, guint16 *ancillary_page_id
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_subtitling_nb</NAME>
<RETURNS>guint  </RETURNS>
const GstMpegtsDescriptor *descriptor
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_from_dvb_subtitling</NAME>
<RETURNS>GstMpegtsDescriptor  * </RETURNS>
const gchar *lang, guint8 type, guint16 composition, guint16 ancillary
</FUNCTION>
<ENUM>
<NAME>GstMpegtsTerrestrialTransmissionMode</NAME>
typedef enum {
  GST_MPEGTS_TRANSMISSION_MODE_2K = 0,
  GST_MPEGTS_TRANSMISSION_MODE_8K,
  GST_MPEGTS_TRANSMISSION_MODE_AUTO,
  GST_MPEGTS_TRANSMISSION_MODE_4K,
  GST_MPEGTS_TRANSMISSION_MODE_1K,
  GST_MPEGTS_TRANSMISSION_MODE_16K,
  GST_MPEGTS_TRANSMISSION_MODE_32K,
  GST_MPEGTS_TRANSMISSION_MODE_C1,
  GST_MPEGTS_TRANSMISSION_MODE_C3780
} GstMpegtsTerrestrialTransmissionMode;
</ENUM>
<ENUM>
<NAME>GstMpegtsTerrestrialGuardInterval</NAME>
typedef enum {
  GST_MPEGTS_GUARD_INTERVAL_1_32 = 0,
  GST_MPEGTS_GUARD_INTERVAL_1_16,
  GST_MPEGTS_GUARD_INTERVAL_1_8,
  GST_MPEGTS_GUARD_INTERVAL_1_4,
  GST_MPEGTS_GUARD_INTERVAL_AUTO,
  GST_MPEGTS_GUARD_INTERVAL_1_128,
  GST_MPEGTS_GUARD_INTERVAL_19_128,
  GST_MPEGTS_GUARD_INTERVAL_19_256,
  GST_MPEGTS_GUARD_INTERVAL_PN420,
  GST_MPEGTS_GUARD_INTERVAL_PN595,
  GST_MPEGTS_GUARD_INTERVAL_PN945
} GstMpegtsTerrestrialGuardInterval;
</ENUM>
<ENUM>
<NAME>GstMpegtsTerrestrialHierarchy</NAME>
typedef enum {
  GST_MPEGTS_HIERARCHY_NONE = 0,
  GST_MPEGTS_HIERARCHY_1,
  GST_MPEGTS_HIERARCHY_2,
  GST_MPEGTS_HIERARCHY_4,
  GST_MPEGTS_HIERARCHY_AUTO
} GstMpegtsTerrestrialHierarchy;
</ENUM>
<STRUCT>
<NAME>GstMpegtsTerrestrialDeliverySystemDescriptor</NAME>
struct _GstMpegtsTerrestrialDeliverySystemDescriptor
{
  guint32				frequency;
  guint32				bandwidth;
  gboolean				priority;
  gboolean				time_slicing;
  gboolean				mpe_fec;
  GstMpegtsModulationType		constellation;
  GstMpegtsTerrestrialHierarchy		hierarchy;
  GstMpegtsDVBCodeRate			code_rate_hp;
  GstMpegtsDVBCodeRate			code_rate_lp;
  GstMpegtsTerrestrialGuardInterval	guard_interval;
  GstMpegtsTerrestrialTransmissionMode	transmission_mode;
  gboolean				other_frequency;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_terrestrial_delivery_system</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, GstMpegtsTerrestrialDeliverySystemDescriptor * res
</FUNCTION>
<STRUCT>
<NAME>GstMpegtsDvbMultilingualNetworkNameItem</NAME>
struct _GstMpegtsDvbMultilingualNetworkNameItem
{
  gchar *language_code;
  gchar *network_name;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_multilingual_network_name</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, GPtrArray ** network_name_items
</FUNCTION>
<STRUCT>
<NAME>GstMpegtsDvbMultilingualBouquetNameItem</NAME>
struct _GstMpegtsDvbMultilingualBouquetNameItem
{
  gchar *language_code;
  gchar *bouquet_name;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_multilingual_bouquet_name</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, GPtrArray ** bouquet_name_items
</FUNCTION>
<STRUCT>
<NAME>GstMpegtsDvbMultilingualServiceNameItem</NAME>
struct _GstMpegtsDvbMultilingualServiceNameItem
{
  gchar *language_code;
  gchar *provider_name;
  gchar *service_name;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_multilingual_service_name</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, GPtrArray ** service_name_items
</FUNCTION>
<STRUCT>
<NAME>GstMpegtsDvbMultilingualComponentItem</NAME>
struct _GstMpegtsDvbMultilingualComponentItem
{
  gchar *language_code;
  gchar *description;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_multilingual_component</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, guint8 * component_tag, GPtrArray ** component_description_items
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_private_data_specifier</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor * descriptor, guint32 * private_data_specifier, guint8 ** private_data, guint8 * length
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_frequency_list</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor * descriptor, gboolean * offset, GArray ** list
</FUNCTION>
<STRUCT>
<NAME>GstMpegtsDataBroadcastDescriptor</NAME>
struct _GstMpegtsDataBroadcastDescriptor
{
  guint16     data_broadcast_id;
  guint8      component_tag;
  guint8      length;
  guint8      *selector_bytes;
  gchar       *language_code;
  gchar       *text;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_MPEGTS_DVB_DATA_BROADCAST_DESCRIPTOR</NAME>
#define GST_TYPE_MPEGTS_DVB_DATA_BROADCAST_DESCRIPTOR (gst_mpegts_dvb_data_broadcast_descriptor_get_type ())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_dvb_data_broadcast_descriptor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_dvb_data_broadcast_descriptor_free</NAME>
<RETURNS>void  </RETURNS>
GstMpegtsDataBroadcastDescriptor * source
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_data_broadcast</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, GstMpegtsDataBroadcastDescriptor ** res
</FUNCTION>
<ENUM>
<NAME>GstMpegtsDVBScramblingModeType</NAME>
typedef enum
{
  GST_MPEGTS_DVB_SCRAMBLING_MODE_RESERVED              = 0x00,
  GST_MPEGTS_DVB_SCRAMBLING_MODE_CSA1                  = 0x01,
  GST_MPEGTS_DVB_SCRAMBLING_MODE_CSA2                  = 0x02,
  GST_MPEGTS_DVB_SCRAMBLING_MODE_CSA3_STANDARD         = 0x03,
  GST_MPEGTS_DVB_SCRAMBLING_MODE_CSA3_MINIMAL_ENHANCED = 0x04,
  GST_MPEGTS_DVB_SCRAMBLING_MODE_CSA3_FULL_ENHANCED    = 0x05,
  /* 0x06 - 0x0f reserved for future use */
  GST_MPEGTS_DVB_SCRAMBLING_MODE_CISSA                 = 0x10,
  /* 0x11 - 0x1f reserved for future DVB-CISSA versions */
  GST_MPEGTS_DVB_SCRAMBLING_MODE_ATIS_0                = 0x70,
  GST_MPEGTS_DVB_SCRAMBLING_MODE_ATIS_F                = 0x7f,
} GstMpegtsDVBScramblingModeType;
</ENUM>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_scrambling</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor * descriptor, GstMpegtsDVBScramblingModeType * scrambling_mode
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_data_broadcast_id</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor * descriptor, guint16 * data_broadcast_id, guint8 ** id_selector_bytes, guint8 * len
</FUNCTION>
<STRUCT>
<NAME>GstMpegtsT2DeliverySystemCellExtension</NAME>
struct _GstMpegtsT2DeliverySystemCellExtension
{
  guint8  cell_id_extension;
  guint32 transposer_frequency;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsT2DeliverySystemCell</NAME>
struct _GstMpegtsT2DeliverySystemCell
{
  guint16      cell_id;
  GArray       *centre_frequencies;
  GPtrArray    *sub_cells;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegtsT2DeliverySystemDescriptor</NAME>
struct _GstMpegtsT2DeliverySystemDescriptor
{
  guint8                                plp_id;
  guint16                               t2_system_id;
  /* FIXME: */
  guint8                                siso_miso;
  guint32                               bandwidth;
  GstMpegtsTerrestrialGuardInterval     guard_interval;
  GstMpegtsTerrestrialTransmissionMode  transmission_mode;
  gboolean                              other_frequency;
  gboolean                              tfs;
  GPtrArray                             *cells;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_MPEGTS_T2_DELIVERY_SYSTEM_DESCRIPTOR</NAME>
#define GST_TYPE_MPEGTS_T2_DELIVERY_SYSTEM_DESCRIPTOR (gst_mpegts_t2_delivery_system_descriptor_get_type ())
</MACRO>
<FUNCTION>
<NAME>gst_mpegts_t2_delivery_system_descriptor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_t2_delivery_system_descriptor_free</NAME>
<RETURNS>void  </RETURNS>
GstMpegtsT2DeliverySystemDescriptor * source
</FUNCTION>
<FUNCTION>
<NAME>gst_mpegts_descriptor_parse_dvb_t2_delivery_system</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegtsDescriptor *descriptor, GstMpegtsT2DeliverySystemDescriptor ** res
</FUNCTION>
<ENUM>
<NAME>GstMpegtsScteStreamType</NAME>
typedef enum {

  /* 0x01 - 0x82 : defined in other specs */
  GST_MPEGTS_STREAM_TYPE_SCTE_SUBTITLING = 0x82,   /* Subtitling data */
  GST_MPEGTS_STREAM_TYPE_SCTE_ISOCH_DATA = 0x83,   /* Isochronous data */
  /* 0x84 - 0x94 : defined in other specs */
  GST_MPEGTS_STREAM_TYPE_SCTE_DST_NRT    = 0x95,   /* DST / NRT data */
  /* 0x96 - 0xaf : defined in other specs */
  GST_MPEGTS_STREAM_TYPE_SCTE_DSMCC_DCB  = 0xb0,   /* Data Carousel Type B */
  /* 0xb1 - 0xbf : User Private (or defined in other specs) */
  GST_MPEGTS_STREAM_TYPE_SCTE_SIGNALING  = 0xc0,   /* EBIF Signaling */
  GST_MPEGTS_STREAM_TYPE_SCTE_SYNC_DATA  = 0xc2,   /* Synchronous data */
  GST_MPEGTS_STREAM_TYPE_SCTE_ASYNC_DATA = 0xc3,   /* Asynchronous data */
  /* 0xc4 - 0xff : User Private (or defined in other specs) */

} GstMpegtsScteStreamType;
</ENUM>
<ENUM>
<NAME>GstMpegtsSectionSCTETableID</NAME>
typedef enum {

  /* 0x01 - 0xd7 : defined in other specs */
  GST_MTS_TABLE_ID_SCTE_EAS      = 0xd8,     /* emergency alert information */
  /* 0xd8 - 0xdf : defined in other specs */
  GST_MTS_TABLE_ID_SCTE_EBIF     = 0xE0,     /* EBIF message */
  GST_MTS_TABLE_ID_SCTE_RESERVED = 0xE1,
  GST_MTS_TABLE_ID_SCTE_EISS     = 0xE2,     /* EBIF Int. Signaling Sect. */
  GST_MTS_TABLE_ID_SCTE_DII      = 0xE3,     /* DSMCC DII message */
  GST_MTS_TABLE_ID_SCTE_DDB      = 0xE4,     /* DSMCC Data Download Block */
  /* 0xe5 - 0xfb : defined in other specs */
  GST_MTS_TABLE_ID_SCTE_SPLICE   = 0xfc,     /* splice information table */

} GstMpegtsSectionSCTETableID;
</ENUM>
<MACRO>
<NAME>GST_WAYLAND_DISPLAY_HANDLE_CONTEXT_TYPE</NAME>
#define GST_WAYLAND_DISPLAY_HANDLE_CONTEXT_TYPE "GstWaylandDisplayHandleContextType"
</MACRO>
<FUNCTION>
<NAME>gst_is_wayland_display_handle_need_context_message</NAME>
<RETURNS>gboolean  </RETURNS>
GstMessage * msg
</FUNCTION>
<FUNCTION>
<NAME>gst_wayland_display_handle_context_new</NAME>
<RETURNS>GstContext  *</RETURNS>
struct wl_display * display
</FUNCTION>
<FUNCTION>
<NAME>gst_wayland_display_handle_context_get_handle</NAME>
<RETURNS>struct wl_display  *</RETURNS>
GstContext * context
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WAYLAND_VIDEO</NAME>
#define GST_TYPE_WAYLAND_VIDEO \
    (gst_wayland_video_get_type ())
</MACRO>
<MACRO>
<NAME>GST_WAYLAND_VIDEO</NAME>
#define GST_WAYLAND_VIDEO(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WAYLAND_VIDEO, GstWaylandVideo))
</MACRO>
<MACRO>
<NAME>GST_IS_WAYLAND_VIDEO</NAME>
#define GST_IS_WAYLAND_VIDEO(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WAYLAND_VIDEO))
</MACRO>
<MACRO>
<NAME>GST_WAYLAND_VIDEO_GET_INTERFACE</NAME>
#define GST_WAYLAND_VIDEO_GET_INTERFACE(inst) \
    (G_TYPE_INSTANCE_GET_INTERFACE ((inst), GST_TYPE_WAYLAND_VIDEO, GstWaylandVideoInterface))
</MACRO>
<STRUCT>
<NAME>GstWaylandVideoInterface</NAME>
struct _GstWaylandVideoInterface {
  GTypeInterface iface;

  /* virtual functions */
  void (*begin_geometry_change)    (GstWaylandVideo *video);
  void (*end_geometry_change)     (GstWaylandVideo *video);
};
</STRUCT>
<FUNCTION>
<NAME>gst_wayland_video_get_type</NAME>
<RETURNS>GType    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_wayland_video_begin_geometry_change</NAME>
<RETURNS>void  </RETURNS>
GstWaylandVideo * video
</FUNCTION>
<FUNCTION>
<NAME>gst_wayland_video_end_geometry_change</NAME>
<RETURNS>void  </RETURNS>
GstWaylandVideo * video
</FUNCTION>
<STRUCT>
<NAME>GstWaylandVideo</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_PHYS_MEMORY_ALLOCATOR</NAME>
#define GST_TYPE_PHYS_MEMORY_ALLOCATOR                  (gst_phys_memory_allocator_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_PHYS_MEMORY_ALLOCATOR</NAME>
#define GST_IS_PHYS_MEMORY_ALLOCATOR(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PHYS_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_PHYS_MEMORY_ALLOCATOR_INTERFACE</NAME>
#define GST_IS_PHYS_MEMORY_ALLOCATOR_INTERFACE(iface)   (G_TYPE_CHECK_INTERFACE_TYPE ((iface), GST_TYPE_PHYS_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_PHYS_MEMORY_ALLOCATOR_GET_INTERFACE</NAME>
#define GST_PHYS_MEMORY_ALLOCATOR_GET_INTERFACE(obj)    (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GST_TYPE_PHYS_MEMORY_ALLOCATOR, GstPhysMemoryAllocatorInterface))
</MACRO>
<MACRO>
<NAME>GST_PHYS_MEMORY_ALLOCATOR</NAME>
#define GST_PHYS_MEMORY_ALLOCATOR(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PHYS_MEMORY_ALLOCATOR, GstPhysMemoryAllocator))
</MACRO>
<MACRO>
<NAME>GST_PHYS_MEMORY_ALLOCATOR_INTERFACE</NAME>
#define GST_PHYS_MEMORY_ALLOCATOR_INTERFACE(iface)      (G_TYPE_CHECK_INTERFACE_CAST ((iface), GST_TYPE_PHYS_MEMORY_ALLOCATOR, GstPhysMemoryAllocatorInterface))
</MACRO>
<MACRO>
<NAME>GST_PHYS_MEMORY_ALLOCATOR_CAST</NAME>
#define GST_PHYS_MEMORY_ALLOCATOR_CAST(obj)             ((GstPhysMemoryAllocator *)(obj))
</MACRO>
<STRUCT>
<NAME>GstPhysMemoryAllocatorInterface</NAME>
struct _GstPhysMemoryAllocatorInterface
{
  GTypeInterface parent_iface;

  guintptr (*get_phys_addr) (GstPhysMemoryAllocator * allocator, GstMemory * mem);
};
</STRUCT>
<FUNCTION>
<NAME>gst_phys_memory_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_is_phys_memory</NAME>
<RETURNS>gboolean  </RETURNS>
GstMemory *mem
</FUNCTION>
<FUNCTION>
<NAME>gst_phys_memory_get_phys_addr</NAME>
<RETURNS>guintptr  </RETURNS>
GstMemory * mem
</FUNCTION>
<STRUCT>
<NAME>GstPhysMemoryAllocator</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_VIDEO_AGGREGATOR</NAME>
#define GST_TYPE_VIDEO_AGGREGATOR (gst_video_aggregator_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_AGGREGATOR</NAME>
#define GST_VIDEO_AGGREGATOR(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_AGGREGATOR, GstVideoAggregator))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_AGGREGATOR_CLASS</NAME>
#define GST_VIDEO_AGGREGATOR_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_AGGREGATOR, GstVideoAggregatorClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_AGGREGATOR</NAME>
#define GST_IS_VIDEO_AGGREGATOR(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_AGGREGATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_AGGREGATOR_CLASS</NAME>
#define GST_IS_VIDEO_AGGREGATOR_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_AGGREGATOR))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_AGGREGATOR_GET_CLASS</NAME>
#define GST_VIDEO_AGGREGATOR_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_VIDEO_AGGREGATOR,GstVideoAggregatorClass))
</MACRO>
<STRUCT>
<NAME>GstVideoAggregator</NAME>
struct _GstVideoAggregator
{
  GstAggregator aggregator;

  /*< public >*/
  /* Output caps */
  GstVideoInfo info;

  /* < private > */
  GstVideoAggregatorPrivate *priv;
  gpointer          _gst_reserved[GST_PADDING_LARGE];
};
</STRUCT>
<STRUCT>
<NAME>GstVideoAggregatorClass</NAME>
struct _GstVideoAggregatorClass
{
  /*< private >*/
  GstAggregatorClass parent_class;

  /*< public >*/
  GstCaps *          (*update_caps)               (GstVideoAggregator *  videoaggregator,
                                                   GstCaps            *  caps,
                                                   GstCaps            *  filter_caps);
  GstCaps *          (*fixate_caps)               (GstVideoAggregator *  videoaggregator,
                                                   GstCaps            *  caps);
  GstFlowReturn      (*aggregate_frames)          (GstVideoAggregator *  videoaggregator,
                                                   GstBuffer          *  outbuffer);
  GstFlowReturn      (*get_output_buffer)         (GstVideoAggregator *  videoaggregator,
                                                   GstBuffer          ** outbuffer);
  gboolean           (*negotiated_caps)           (GstVideoAggregator *  videoaggregator,
                                                   GstCaps            *  caps);
  void               (*find_best_format)          (GstVideoAggregator *  vagg,
                                                   GstCaps            *  downstream_caps,
                                                   GstVideoInfo       *  best_info,
                                                   gboolean           *  at_least_one_alpha);

  GstCaps           *sink_non_alpha_caps;

  /* < private > */
  gpointer            _gst_reserved[GST_PADDING_LARGE];
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_aggregator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstVideoAggregatorPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_VIDEO_AGGREGATOR_PAD</NAME>
#define GST_TYPE_VIDEO_AGGREGATOR_PAD (gst_video_aggregator_pad_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_AGGREGATOR_PAD</NAME>
#define GST_VIDEO_AGGREGATOR_PAD(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_AGGREGATOR_PAD, GstVideoAggregatorPad))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_AGGREGATOR_PAD_CLASS</NAME>
#define GST_VIDEO_AGGREGATOR_PAD_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_COMPOSITOR_PAD, GstVideoAggregatorPadClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_AGGREGATOR_PAD</NAME>
#define GST_IS_VIDEO_AGGREGATOR_PAD(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_AGGREGATOR_PAD))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_AGGREGATOR_PAD_CLASS</NAME>
#define GST_IS_VIDEO_AGGREGATOR_PAD_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_AGGREGATOR_PAD))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_AGGREGATOR_PAD_GET_CLASS</NAME>
#define GST_VIDEO_AGGREGATOR_PAD_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_VIDEO_AGGREGATOR_PAD,GstVideoAggregatorPadClass))
</MACRO>
<STRUCT>
<NAME>GstVideoAggregatorPad</NAME>
struct _GstVideoAggregatorPad
{
  GstAggregatorPad parent;

  GstVideoInfo info;

  GstBuffer *buffer;
  /* The caps on the pad may not match the buffer above because of two reasons:
   * 1) When caps change, the info above will get updated, but the buffer might
   *    not since it might be pending on the GstAggregatorPad
   * 2) We might reject the new buffer in fill_queues() and reuse a previous
   *    buffer which has older GstVideoInfo
   * Hence, we need to maintain a GstVideoInfo for mapping buffers separately */
  GstVideoInfo buffer_vinfo;

  GstVideoFrame *aggregated_frame;

  /* properties */
  guint zorder;
  gboolean ignore_eos;

  /* < private > */
  GstVideoAggregatorPadPrivate *priv;
  gpointer          _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstVideoAggregatorPadClass</NAME>
struct _GstVideoAggregatorPadClass
{
  GstAggregatorPadClass parent_class;
  gboolean           (*set_info)              (GstVideoAggregatorPad * pad,
                                               GstVideoAggregator    * videoaggregator,
                                               GstVideoInfo          * current_info,
                                               GstVideoInfo          * wanted_info);

  gboolean           (*prepare_frame)         (GstVideoAggregatorPad * pad,
                                               GstVideoAggregator    * videoaggregator);

  void               (*clean_frame)           (GstVideoAggregatorPad * pad,
                                               GstVideoAggregator    * videoaggregator);

  gpointer          _gst_reserved[GST_PADDING_LARGE];
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_aggregator_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstVideoAggregatorPadPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_PHOTOGRAPHY</NAME>
#define GST_TYPE_PHOTOGRAPHY \
  (gst_photography_get_type ())
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY</NAME>
#define GST_PHOTOGRAPHY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PHOTOGRAPHY, GstPhotography))
</MACRO>
<MACRO>
<NAME>GST_IS_PHOTOGRAPHY</NAME>
#define GST_IS_PHOTOGRAPHY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PHOTOGRAPHY))
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_GET_INTERFACE</NAME>
#define GST_PHOTOGRAPHY_GET_INTERFACE(inst) \
  (G_TYPE_INSTANCE_GET_INTERFACE ((inst), GST_TYPE_PHOTOGRAPHY, GstPhotographyInterface))
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_AUTOFOCUS_DONE</NAME>
#define GST_PHOTOGRAPHY_AUTOFOCUS_DONE "autofocus-done"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_SHAKE_RISK</NAME>
#define GST_PHOTOGRAPHY_SHAKE_RISK "shake-risk"
</MACRO>
<MACRO>
<NAME>MAX_WHITE_POINT_VALUES</NAME>
#define MAX_WHITE_POINT_VALUES 4
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_WB_MODE</NAME>
#define GST_PHOTOGRAPHY_PROP_WB_MODE            "white-balance-mode"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_COLOR_TONE</NAME>
#define GST_PHOTOGRAPHY_PROP_COLOR_TONE         "color-tone-mode"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_SCENE_MODE</NAME>
#define GST_PHOTOGRAPHY_PROP_SCENE_MODE         "scene-mode"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_FLASH_MODE</NAME>
#define GST_PHOTOGRAPHY_PROP_FLASH_MODE         "flash-mode"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_NOISE_REDUCTION</NAME>
#define GST_PHOTOGRAPHY_PROP_NOISE_REDUCTION    "noise-reduction"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_FOCUS_STATUS</NAME>
#define GST_PHOTOGRAPHY_PROP_FOCUS_STATUS       "focus-status"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_CAPABILITIES</NAME>
#define GST_PHOTOGRAPHY_PROP_CAPABILITIES       "capabilities"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_SHAKE_RISK</NAME>
#define GST_PHOTOGRAPHY_PROP_SHAKE_RISK         "shake-risk"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_EV_COMP</NAME>
#define GST_PHOTOGRAPHY_PROP_EV_COMP            "ev-compensation"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_ISO_SPEED</NAME>
#define GST_PHOTOGRAPHY_PROP_ISO_SPEED          "iso-speed"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_APERTURE</NAME>
#define GST_PHOTOGRAPHY_PROP_APERTURE           "aperture"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_EXPOSURE_TIME</NAME>
#define GST_PHOTOGRAPHY_PROP_EXPOSURE_TIME      "exposure-time"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_IMAGE_CAPTURE_SUPPORTED_CAPS</NAME>
#define GST_PHOTOGRAPHY_PROP_IMAGE_CAPTURE_SUPPORTED_CAPS \
                                                "image-capture-supported-caps"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_IMAGE_PREVIEW_SUPPORTED_CAPS</NAME>
#define GST_PHOTOGRAPHY_PROP_IMAGE_PREVIEW_SUPPORTED_CAPS \
                                                "image-preview-supported-caps"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_FLICKER_MODE</NAME>
#define GST_PHOTOGRAPHY_PROP_FLICKER_MODE       "flicker-mode"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_FOCUS_MODE</NAME>
#define GST_PHOTOGRAPHY_PROP_FOCUS_MODE         "focus-mode"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_ZOOM</NAME>
#define GST_PHOTOGRAPHY_PROP_ZOOM               "zoom"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_COLOR_TEMPERATURE</NAME>
#define GST_PHOTOGRAPHY_PROP_COLOR_TEMPERATURE  "color-temperature"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_WHITE_POINT</NAME>
#define GST_PHOTOGRAPHY_PROP_WHITE_POINT        "white-point"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_ANALOG_GAIN</NAME>
#define GST_PHOTOGRAPHY_PROP_ANALOG_GAIN        "analog-gain"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_EXPOSURE_MODE</NAME>
#define GST_PHOTOGRAPHY_PROP_EXPOSURE_MODE      "exposure-mode"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_LENS_FOCUS</NAME>
#define GST_PHOTOGRAPHY_PROP_LENS_FOCUS         "lens-focus"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_MIN_EXPOSURE_TIME</NAME>
#define GST_PHOTOGRAPHY_PROP_MIN_EXPOSURE_TIME  "min-exposure-time"
</MACRO>
<MACRO>
<NAME>GST_PHOTOGRAPHY_PROP_MAX_EXPOSURE_TIME</NAME>
#define GST_PHOTOGRAPHY_PROP_MAX_EXPOSURE_TIME  "max-exposure-time"
</MACRO>
<ENUM>
<NAME>GstPhotographyNoiseReduction</NAME>
typedef enum
{
  GST_PHOTOGRAPHY_NOISE_REDUCTION_BAYER    = (1 << 0),
  GST_PHOTOGRAPHY_NOISE_REDUCTION_YCC      = (1 << 1),
  GST_PHOTOGRAPHY_NOISE_REDUCTION_TEMPORAL = (1 << 2),
  GST_PHOTOGRAPHY_NOISE_REDUCTION_FIXED    = (1 << 3),
  GST_PHOTOGRAPHY_NOISE_REDUCTION_EXTRA    = (1 << 4)
} GstPhotographyNoiseReduction;
</ENUM>
<ENUM>
<NAME>GstPhotographyWhiteBalanceMode</NAME>
typedef enum
{
  GST_PHOTOGRAPHY_WB_MODE_AUTO = 0,
  GST_PHOTOGRAPHY_WB_MODE_DAYLIGHT,
  GST_PHOTOGRAPHY_WB_MODE_CLOUDY,
  GST_PHOTOGRAPHY_WB_MODE_SUNSET,
  GST_PHOTOGRAPHY_WB_MODE_TUNGSTEN,
  GST_PHOTOGRAPHY_WB_MODE_FLUORESCENT,
  GST_PHOTOGRAPHY_WB_MODE_MANUAL,
  GST_PHOTOGRAPHY_WB_MODE_WARM_FLUORESCENT,
  GST_PHOTOGRAPHY_WB_MODE_SHADE
} GstPhotographyWhiteBalanceMode;
</ENUM>
<ENUM>
<NAME>GstPhotographyColorToneMode</NAME>
typedef enum
{
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_NORMAL = 0,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_SEPIA,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_NEGATIVE,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_GRAYSCALE,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_NATURAL,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_VIVID,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_COLORSWAP,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_SOLARIZE,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_OUT_OF_FOCUS,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_SKY_BLUE,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_GRASS_GREEN,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_SKIN_WHITEN,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_POSTERIZE,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_WHITEBOARD,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_BLACKBOARD,
  GST_PHOTOGRAPHY_COLOR_TONE_MODE_AQUA
} GstPhotographyColorToneMode;
</ENUM>
<ENUM>
<NAME>GstPhotographySceneMode</NAME>
typedef enum
{
  GST_PHOTOGRAPHY_SCENE_MODE_MANUAL = 0,
  GST_PHOTOGRAPHY_SCENE_MODE_CLOSEUP,
  GST_PHOTOGRAPHY_SCENE_MODE_PORTRAIT,
  GST_PHOTOGRAPHY_SCENE_MODE_LANDSCAPE,
  GST_PHOTOGRAPHY_SCENE_MODE_SPORT,
  GST_PHOTOGRAPHY_SCENE_MODE_NIGHT,
  GST_PHOTOGRAPHY_SCENE_MODE_AUTO,
  GST_PHOTOGRAPHY_SCENE_MODE_ACTION,
  GST_PHOTOGRAPHY_SCENE_MODE_NIGHT_PORTRAIT,
  GST_PHOTOGRAPHY_SCENE_MODE_THEATRE,
  GST_PHOTOGRAPHY_SCENE_MODE_BEACH,
  GST_PHOTOGRAPHY_SCENE_MODE_SNOW,
  GST_PHOTOGRAPHY_SCENE_MODE_SUNSET,
  GST_PHOTOGRAPHY_SCENE_MODE_STEADY_PHOTO,
  GST_PHOTOGRAPHY_SCENE_MODE_FIREWORKS,
  GST_PHOTOGRAPHY_SCENE_MODE_PARTY,
  GST_PHOTOGRAPHY_SCENE_MODE_CANDLELIGHT,
  GST_PHOTOGRAPHY_SCENE_MODE_BARCODE
} GstPhotographySceneMode;
</ENUM>
<ENUM>
<NAME>GstPhotographyFlashMode</NAME>
typedef enum
{
  GST_PHOTOGRAPHY_FLASH_MODE_AUTO = 0,
  GST_PHOTOGRAPHY_FLASH_MODE_OFF,
  GST_PHOTOGRAPHY_FLASH_MODE_ON,
  GST_PHOTOGRAPHY_FLASH_MODE_FILL_IN,
  GST_PHOTOGRAPHY_FLASH_MODE_RED_EYE
} GstPhotographyFlashMode;
</ENUM>
<ENUM>
<NAME>GstPhotographyFocusStatus</NAME>
typedef enum
{
  GST_PHOTOGRAPHY_FOCUS_STATUS_NONE = 0,
  GST_PHOTOGRAPHY_FOCUS_STATUS_RUNNING,
  GST_PHOTOGRAPHY_FOCUS_STATUS_FAIL,
  GST_PHOTOGRAPHY_FOCUS_STATUS_SUCCESS
} GstPhotographyFocusStatus;
</ENUM>
<ENUM>
<NAME>GstPhotographyCaps</NAME>
typedef enum
{
  GST_PHOTOGRAPHY_CAPS_NONE              = (0 << 0),
  GST_PHOTOGRAPHY_CAPS_EV_COMP           = (1 << 0),
  GST_PHOTOGRAPHY_CAPS_ISO_SPEED         = (1 << 1),
  GST_PHOTOGRAPHY_CAPS_WB_MODE           = (1 << 2),
  GST_PHOTOGRAPHY_CAPS_TONE              = (1 << 3),
  GST_PHOTOGRAPHY_CAPS_SCENE             = (1 << 4),
  GST_PHOTOGRAPHY_CAPS_FLASH             = (1 << 5),
  GST_PHOTOGRAPHY_CAPS_ZOOM              = (1 << 6),
  GST_PHOTOGRAPHY_CAPS_FOCUS             = (1 << 7),
  GST_PHOTOGRAPHY_CAPS_APERTURE          = (1 << 8),
  GST_PHOTOGRAPHY_CAPS_EXPOSURE          = (1 << 9),
  GST_PHOTOGRAPHY_CAPS_SHAKE             = (1 << 10),
  GST_PHOTOGRAPHY_CAPS_WHITE_BALANCE     = (1 << 11),
  GST_PHOTOGRAPHY_CAPS_NOISE_REDUCTION   = (1 << 12),
  GST_PHOTOGRAPHY_CAPS_FLICKER_REDUCTION = (1 << 13),
  GST_PHOTOGRAPHY_CAPS_ALL               = (~0)
} GstPhotographyCaps;
</ENUM>
<ENUM>
<NAME>GstPhotographyShakeRisk</NAME>
typedef enum
{
  GST_PHOTOGRAPHY_SHAKE_RISK_LOW = 0,
  GST_PHOTOGRAPHY_SHAKE_RISK_MEDIUM,
  GST_PHOTOGRAPHY_SHAKE_RISK_HIGH,
} GstPhotographyShakeRisk;
</ENUM>
<ENUM>
<NAME>GstPhotographyFlickerReductionMode</NAME>
typedef enum
{
  GST_PHOTOGRAPHY_FLICKER_REDUCTION_OFF = 0,
  GST_PHOTOGRAPHY_FLICKER_REDUCTION_50HZ,
  GST_PHOTOGRAPHY_FLICKER_REDUCTION_60HZ,
  GST_PHOTOGRAPHY_FLICKER_REDUCTION_AUTO,
} GstPhotographyFlickerReductionMode;
</ENUM>
<ENUM>
<NAME>GstPhotographyFocusMode</NAME>
typedef enum {
    GST_PHOTOGRAPHY_FOCUS_MODE_AUTO = 0,
    GST_PHOTOGRAPHY_FOCUS_MODE_MACRO,
    GST_PHOTOGRAPHY_FOCUS_MODE_PORTRAIT,
    GST_PHOTOGRAPHY_FOCUS_MODE_INFINITY,
    GST_PHOTOGRAPHY_FOCUS_MODE_HYPERFOCAL,
    GST_PHOTOGRAPHY_FOCUS_MODE_EXTENDED,
    GST_PHOTOGRAPHY_FOCUS_MODE_CONTINUOUS_NORMAL,
    GST_PHOTOGRAPHY_FOCUS_MODE_CONTINUOUS_EXTENDED,
    GST_PHOTOGRAPHY_FOCUS_MODE_MANUAL
} GstPhotographyFocusMode;
</ENUM>
<ENUM>
<NAME>GstPhotographyExposureMode</NAME>
typedef enum {
    GST_PHOTOGRAPHY_EXPOSURE_MODE_AUTO = 0,
    GST_PHOTOGRAPHY_EXPOSURE_MODE_MANUAL
} GstPhotographyExposureMode;
</ENUM>
<USER_FUNCTION>
<NAME>GstPhotographyCapturePrepared</NAME>
<RETURNS>void </RETURNS>
gpointer data, const GstCaps *configured_caps
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>get_ev_compensation</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, gfloat * ev_comp
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>get_iso_speed</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, guint * iso_speed
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>get_aperture</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, guint * aperture
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>get_exposure</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, guint32 * exposure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>get_white_balance_mode</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographyWhiteBalanceMode * wb_mode
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>get_color_tone_mode</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographyColorToneMode * tone_mode
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>get_scene_mode</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographySceneMode * scene_mode
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>get_flash_mode</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographyFlashMode * flash_mode
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>get_zoom</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, gfloat * zoom
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>get_flicker_mode</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographyFlickerReductionMode * flicker_mode
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>get_focus_mode</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographyFocusMode * focus_mode
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>set_ev_compensation</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, gfloat ev_comp
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>set_iso_speed</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, guint iso_speed
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>set_aperture</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, guint aperture
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>set_exposure</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, guint32 exposure
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>set_white_balance_mode</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographyWhiteBalanceMode wb_mode
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>set_color_tone_mode</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographyColorToneMode tone_mode
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>set_scene_mode</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographySceneMode scene_mode
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>set_flash_mode</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographyFlashMode flash_mode
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>set_zoom</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, gfloat zoom
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>set_flicker_mode</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographyFlickerReductionMode flicker_mode
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>set_focus_mode</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographyFocusMode focus_mode
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>get_capabilities</NAME>
<RETURNS>GstPhotographyCaps </RETURNS>
GstPhotography * photo
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>prepare_for_capture</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographyCapturePrepared func, GstCaps *capture_caps, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>set_autofocus</NAME>
<RETURNS>void </RETURNS>
GstPhotography * photo, gboolean on
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>set_config</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographySettings * config
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>get_config</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographySettings * config
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>get_noise_reduction</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographyNoiseReduction * noise_reduction
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>set_noise_reduction</NAME>
<RETURNS>gboolean </RETURNS>
GstPhotography * photo, GstPhotographyNoiseReduction noise_reduction
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_ev_compensation</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, gfloat * ev_comp
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_iso_speed</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, guint * iso_speed
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_aperture</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, guint * aperture
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_exposure</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, guint32 * exposure
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_white_balance_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographyWhiteBalanceMode * wb_mode
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_color_tone_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographyColorToneMode * tone_mode
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_scene_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographySceneMode * scene_mode
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_flash_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographyFlashMode * flash_mode
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_noise_reduction</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographyNoiseReduction * noise_reduction
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_zoom</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, gfloat * zoom
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_flicker_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographyFlickerReductionMode * mode
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_focus_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographyFocusMode * mode
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_set_ev_compensation</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, gfloat ev_comp
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_set_iso_speed</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, guint iso_speed
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_set_aperture</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, guint aperture
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_set_exposure</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, guint exposure
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_set_white_balance_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographyWhiteBalanceMode wb_mode
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_set_color_tone_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographyColorToneMode tone_mode
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_set_scene_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographySceneMode scene_mode
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_set_flash_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographyFlashMode flash_mode
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_set_noise_reduction</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographyNoiseReduction noise_reduction
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_set_zoom</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, gfloat zoom
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_set_flicker_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographyFlickerReductionMode mode
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_set_focus_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographyFocusMode mode
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_capabilities</NAME>
<RETURNS>GstPhotographyCaps  </RETURNS>
GstPhotography * photo
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_prepare_for_capture</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography * photo, GstPhotographyCapturePrepared func, GstCaps *capture_caps, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_set_config</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography         * photo, GstPhotographySettings * config
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_get_config</NAME>
<RETURNS>gboolean  </RETURNS>
GstPhotography         * photo, GstPhotographySettings * config
</FUNCTION>
<FUNCTION>
<NAME>gst_photography_set_autofocus</NAME>
<RETURNS>void      </RETURNS>
GstPhotography * photo, gboolean on
</FUNCTION>
<STRUCT>
<NAME>GstPhotography</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_photography_noise_reduction_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PHOTOGRAPHY_NOISE_REDUCTION</NAME>
#define GST_TYPE_PHOTOGRAPHY_NOISE_REDUCTION (gst_photography_noise_reduction_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_photography_white_balance_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PHOTOGRAPHY_WHITE_BALANCE_MODE</NAME>
#define GST_TYPE_PHOTOGRAPHY_WHITE_BALANCE_MODE (gst_photography_white_balance_mode_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_photography_color_tone_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PHOTOGRAPHY_COLOR_TONE_MODE</NAME>
#define GST_TYPE_PHOTOGRAPHY_COLOR_TONE_MODE (gst_photography_color_tone_mode_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_photography_scene_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PHOTOGRAPHY_SCENE_MODE</NAME>
#define GST_TYPE_PHOTOGRAPHY_SCENE_MODE (gst_photography_scene_mode_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_photography_flash_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PHOTOGRAPHY_FLASH_MODE</NAME>
#define GST_TYPE_PHOTOGRAPHY_FLASH_MODE (gst_photography_flash_mode_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_photography_focus_status_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PHOTOGRAPHY_FOCUS_STATUS</NAME>
#define GST_TYPE_PHOTOGRAPHY_FOCUS_STATUS (gst_photography_focus_status_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_photography_caps_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PHOTOGRAPHY_CAPS</NAME>
#define GST_TYPE_PHOTOGRAPHY_CAPS (gst_photography_caps_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_photography_shake_risk_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PHOTOGRAPHY_SHAKE_RISK</NAME>
#define GST_TYPE_PHOTOGRAPHY_SHAKE_RISK (gst_photography_shake_risk_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_photography_flicker_reduction_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PHOTOGRAPHY_FLICKER_REDUCTION_MODE</NAME>
#define GST_TYPE_PHOTOGRAPHY_FLICKER_REDUCTION_MODE (gst_photography_flicker_reduction_mode_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_photography_focus_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PHOTOGRAPHY_FOCUS_MODE</NAME>
#define GST_TYPE_PHOTOGRAPHY_FOCUS_MODE (gst_photography_focus_mode_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_photography_exposure_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PHOTOGRAPHY_EXPOSURE_MODE</NAME>
#define GST_TYPE_PHOTOGRAPHY_EXPOSURE_MODE (gst_photography_exposure_mode_get_type())
</MACRO>
<ENUM>
<NAME>GstVp8ParserResult</NAME>
typedef enum {
  GST_VP8_PARSER_OK,
  GST_VP8_PARSER_BROKEN_DATA,
  GST_VP8_PARSER_ERROR,
} GstVp8ParserResult;
</ENUM>
<STRUCT>
<NAME>GstVp8QuantIndices</NAME>
struct _GstVp8QuantIndices
{
  guint8 y_ac_qi;
  gint8 y_dc_delta;
  gint8 y2_dc_delta;
  gint8 y2_ac_delta;
  gint8 uv_dc_delta;
  gint8 uv_ac_delta;
};
</STRUCT>
<STRUCT>
<NAME>GstVp8Segmentation</NAME>
struct _GstVp8Segmentation
{
  guint8 segmentation_enabled;
  guint8 update_mb_segmentation_map;
  guint8 update_segment_feature_data;

  /* if update_segment_feature_data == 1 */
  guint8 segment_feature_mode;
  gint8 quantizer_update_value[4];
  gint8 lf_update_value[4];

  /* if update_mb_segmentation_map == 1 */
  guint8 segment_prob[3];
};
</STRUCT>
<STRUCT>
<NAME>GstVp8MbLfAdjustments</NAME>
struct _GstVp8MbLfAdjustments
{
  guint8 loop_filter_adj_enable;
  guint8 mode_ref_lf_delta_update;

  /* if mode_ref_lf_delta_update == 1 */
  gint8 ref_frame_delta[4];
  gint8 mb_mode_delta[4];
};
</STRUCT>
<STRUCT>
<NAME>GstVp8TokenProbs</NAME>
struct _GstVp8TokenProbs
{
  guint8 prob[4][8][3][11];
};
</STRUCT>
<STRUCT>
<NAME>GstVp8MvProbs</NAME>
struct _GstVp8MvProbs
{
  guint8 prob[2][19];
};
</STRUCT>
<STRUCT>
<NAME>GstVp8ModeProbs</NAME>
struct _GstVp8ModeProbs
{
  guint8 y_prob[4];
  guint8 uv_prob[3];
};
</STRUCT>
<STRUCT>
<NAME>GstVp8FrameHdr</NAME>
struct _GstVp8FrameHdr
{
  guint8 key_frame;
  guint8 version;
  guint8 show_frame;
  guint8 data_chunk_size;
  guint32 first_part_size;

  /* if key_frame == 1 */
  guint16 width;
  guint16 height;
  guint8 horiz_scale_code;
  guint8 vert_scale_code;
  guint8 color_space;
  guint8 clamping_type;

  guint8 filter_type;
  guint8 loop_filter_level;
  guint8 sharpness_level;
  guint8 log2_nbr_of_dct_partitions;
  guint partition_size[8];

  GstVp8QuantIndices quant_indices;
  GstVp8TokenProbs token_probs;
  GstVp8MvProbs mv_probs;
  GstVp8ModeProbs mode_probs;

  guint8 refresh_entropy_probs;
  guint8 refresh_last;
  /* if key_frame != 1 */
  guint8 refresh_golden_frame;
  guint8 refresh_alternate_frame;
  guint8 copy_buffer_to_golden;
  guint8 copy_buffer_to_alternate;
  guint8 sign_bias_golden;
  guint8 sign_bias_alternate;

  guint8 mb_no_skip_coeff;
  guint8 prob_skip_false;

  /* if key_frame != 1 */
  guint8 prob_intra;
  guint8 prob_last;
  guint8 prob_gf;

  /* Range decoder state */
  guint8 rd_range;
  guint8 rd_value;
  guint8 rd_count;

  /* Size of the Frame Header in bits */
  guint header_size;
};
</STRUCT>
<STRUCT>
<NAME>GstVp8Parser</NAME>
struct _GstVp8Parser
{
  GstVp8Segmentation segmentation;
  GstVp8MbLfAdjustments mb_lf_adjust;
  GstVp8TokenProbs token_probs;
  GstVp8MvProbs mv_probs;
  GstVp8ModeProbs mode_probs;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vp8_parser_init</NAME>
<RETURNS>void </RETURNS>
GstVp8Parser * parser
</FUNCTION>
<FUNCTION>
<NAME>gst_vp8_parser_parse_frame_header</NAME>
<RETURNS>GstVp8ParserResult </RETURNS>
GstVp8Parser * parser, GstVp8FrameHdr * frame_hdr, const guint8 * data, gsize size
</FUNCTION>
<MACRO>
<NAME>GST_H264_MAX_SPS_COUNT</NAME>
#define GST_H264_MAX_SPS_COUNT   32
</MACRO>
<MACRO>
<NAME>GST_H264_MAX_PPS_COUNT</NAME>
#define GST_H264_MAX_PPS_COUNT   256
</MACRO>
<MACRO>
<NAME>GST_H264_MAX_VIEW_COUNT</NAME>
#define GST_H264_MAX_VIEW_COUNT  1024
</MACRO>
<MACRO>
<NAME>GST_H264_MAX_VIEW_ID</NAME>
#define GST_H264_MAX_VIEW_ID     (GST_H264_MAX_VIEW_COUNT - 1)
</MACRO>
<MACRO>
<NAME>GST_H264_IS_P_SLICE</NAME>
#define GST_H264_IS_P_SLICE(slice)  (((slice)->type % 5) == GST_H264_P_SLICE)
</MACRO>
<MACRO>
<NAME>GST_H264_IS_B_SLICE</NAME>
#define GST_H264_IS_B_SLICE(slice)  (((slice)->type % 5) == GST_H264_B_SLICE)
</MACRO>
<MACRO>
<NAME>GST_H264_IS_I_SLICE</NAME>
#define GST_H264_IS_I_SLICE(slice)  (((slice)->type % 5) == GST_H264_I_SLICE)
</MACRO>
<MACRO>
<NAME>GST_H264_IS_SP_SLICE</NAME>
#define GST_H264_IS_SP_SLICE(slice) (((slice)->type % 5) == GST_H264_SP_SLICE)
</MACRO>
<MACRO>
<NAME>GST_H264_IS_SI_SLICE</NAME>
#define GST_H264_IS_SI_SLICE(slice) (((slice)->type % 5) == GST_H264_SI_SLICE)
</MACRO>
<MACRO>
<NAME>GST_H264_IS_SVC_NALU</NAME>
#define GST_H264_IS_SVC_NALU(nalu) \
  ((nalu)->extension_type == GST_H264_NAL_EXTENSION_SVC)
</MACRO>
<MACRO>
<NAME>GST_H264_IS_MVC_NALU</NAME>
#define GST_H264_IS_MVC_NALU(nalu) \
  ((nalu)->extension_type == GST_H264_NAL_EXTENSION_MVC)
</MACRO>
<ENUM>
<NAME>GstH264Profile</NAME>
typedef enum {
  GST_H264_PROFILE_BASELINE             = 66,
  GST_H264_PROFILE_MAIN                 = 77,
  GST_H264_PROFILE_EXTENDED             = 88,
  GST_H264_PROFILE_HIGH                 = 100,
  GST_H264_PROFILE_HIGH10               = 110,
  GST_H264_PROFILE_HIGH_422             = 122,
  GST_H264_PROFILE_HIGH_444             = 244,
  GST_H264_PROFILE_MULTIVIEW_HIGH       = 118,
  GST_H264_PROFILE_STEREO_HIGH          = 128,
  GST_H264_PROFILE_SCALABLE_BASELINE    = 83,
  GST_H264_PROFILE_SCALABLE_HIGH        = 86
} GstH264Profile;
</ENUM>
<ENUM>
<NAME>GstH264NalUnitType</NAME>
typedef enum
{
  GST_H264_NAL_UNKNOWN      = 0,
  GST_H264_NAL_SLICE        = 1,
  GST_H264_NAL_SLICE_DPA    = 2,
  GST_H264_NAL_SLICE_DPB    = 3,
  GST_H264_NAL_SLICE_DPC    = 4,
  GST_H264_NAL_SLICE_IDR    = 5,
  GST_H264_NAL_SEI          = 6,
  GST_H264_NAL_SPS          = 7,
  GST_H264_NAL_PPS          = 8,
  GST_H264_NAL_AU_DELIMITER = 9,
  GST_H264_NAL_SEQ_END      = 10,
  GST_H264_NAL_STREAM_END   = 11,
  GST_H264_NAL_FILLER_DATA  = 12,
  GST_H264_NAL_SPS_EXT      = 13,
  GST_H264_NAL_PREFIX_UNIT  = 14,
  GST_H264_NAL_SUBSET_SPS   = 15,
  GST_H264_NAL_DEPTH_SPS    = 16,
  GST_H264_NAL_SLICE_AUX    = 19,
  GST_H264_NAL_SLICE_EXT    = 20,
  GST_H264_NAL_SLICE_DEPTH  = 21
} GstH264NalUnitType;
</ENUM>
<ENUM>
<NAME>GstH264NalUnitExtensionType</NAME>
typedef enum
{
  GST_H264_NAL_EXTENSION_NONE = 0,
  GST_H264_NAL_EXTENSION_SVC,
  GST_H264_NAL_EXTENSION_MVC,
} GstH264NalUnitExtensionType;
</ENUM>
<ENUM>
<NAME>GstH264ParserResult</NAME>
typedef enum
{
  GST_H264_PARSER_OK,
  GST_H264_PARSER_BROKEN_DATA,
  GST_H264_PARSER_BROKEN_LINK,
  GST_H264_PARSER_ERROR,
  GST_H264_PARSER_NO_NAL,
  GST_H264_PARSER_NO_NAL_END
} GstH264ParserResult;
</ENUM>
<ENUM>
<NAME>GstH264FramePackingType</NAME>
typedef enum
{
  GST_H264_FRAME_PACKING_NONE                           = 6,
  GST_H264_FRAME_PACKING_CHECKERBOARD_INTERLEAVING      = 0,
  GST_H264_FRAME_PACKING_COLUMN_INTERLEAVING            = 1,
  GST_H264_FRAME_PACKING_ROW_INTERLEAVING               = 2,
  GST_H264_FRAME_PACKING_SIDE_BY_SIDE                   = 3,
  GST_H264_FRMAE_PACKING_TOP_BOTTOM                     = 4,
  GST_H264_FRAME_PACKING_TEMPORAL_INTERLEAVING          = 5
} GstH264FramePackingType;
</ENUM>
<ENUM>
<NAME>GstH264SEIPayloadType</NAME>
typedef enum
{
  GST_H264_SEI_BUF_PERIOD = 0,
  GST_H264_SEI_PIC_TIMING = 1,
  GST_H264_SEI_RECOVERY_POINT = 6,
  GST_H264_SEI_STEREO_VIDEO_INFO = 21,
  GST_H264_SEI_FRAME_PACKING = 45
      /* and more...  */
} GstH264SEIPayloadType;
</ENUM>
<ENUM>
<NAME>GstH264SEIPicStructType</NAME>
typedef enum
{
  GST_H264_SEI_PIC_STRUCT_FRAME             = 0,
  GST_H264_SEI_PIC_STRUCT_TOP_FIELD         = 1,
  GST_H264_SEI_PIC_STRUCT_BOTTOM_FIELD      = 2,
  GST_H264_SEI_PIC_STRUCT_TOP_BOTTOM        = 3,
  GST_H264_SEI_PIC_STRUCT_BOTTOM_TOP        = 4,
  GST_H264_SEI_PIC_STRUCT_TOP_BOTTOM_TOP    = 5,
  GST_H264_SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM = 6,
  GST_H264_SEI_PIC_STRUCT_FRAME_DOUBLING    = 7,
  GST_H264_SEI_PIC_STRUCT_FRAME_TRIPLING    = 8
} GstH264SEIPicStructType;
</ENUM>
<ENUM>
<NAME>GstH264SliceType</NAME>
typedef enum
{
  GST_H264_P_SLICE    = 0,
  GST_H264_B_SLICE    = 1,
  GST_H264_I_SLICE    = 2,
  GST_H264_SP_SLICE   = 3,
  GST_H264_SI_SLICE   = 4,
  GST_H264_S_P_SLICE  = 5,
  GST_H264_S_B_SLICE  = 6,
  GST_H264_S_I_SLICE  = 7,
  GST_H264_S_SP_SLICE = 8,
  GST_H264_S_SI_SLICE = 9
} GstH264SliceType;
</ENUM>
<STRUCT>
<NAME>GstH264NalUnitExtensionMVC</NAME>
struct _GstH264NalUnitExtensionMVC
{
  guint8 non_idr_flag;
  guint8 priority_id;
  guint16 view_id;
  guint8 temporal_id;
  guint8 anchor_pic_flag;
  guint8 inter_view_flag;
};
</STRUCT>
<STRUCT>
<NAME>GstH264NalUnit</NAME>
struct _GstH264NalUnit
{
  guint16 ref_idc;
  guint16 type;

  /* calculated values */
  guint8 idr_pic_flag;
  guint size;
  guint offset;
  guint sc_offset;
  gboolean valid;

  guint8 *data;

  guint8 header_bytes;
  guint8 extension_type;
  union {
    GstH264NalUnitExtensionMVC mvc;
  } extension;
};
</STRUCT>
<STRUCT>
<NAME>GstH264HRDParams</NAME>
struct _GstH264HRDParams
{
  guint8 cpb_cnt_minus1;
  guint8 bit_rate_scale;
  guint8 cpb_size_scale;

  guint32 bit_rate_value_minus1[32];
  guint32 cpb_size_value_minus1[32];
  guint8 cbr_flag[32];

  guint8 initial_cpb_removal_delay_length_minus1;
  guint8 cpb_removal_delay_length_minus1;
  guint8 dpb_output_delay_length_minus1;
  guint8 time_offset_length;
};
</STRUCT>
<STRUCT>
<NAME>GstH264VUIParams</NAME>
struct _GstH264VUIParams
{
  guint8 aspect_ratio_info_present_flag;
  guint8 aspect_ratio_idc;
  /* if aspect_ratio_idc == 255 */
  guint16 sar_width;
  guint16 sar_height;

  guint8 overscan_info_present_flag;
  /* if overscan_info_present_flag */
  guint8 overscan_appropriate_flag;

  guint8 video_signal_type_present_flag;
  guint8 video_format;
  guint8 video_full_range_flag;
  guint8 colour_description_present_flag;
  guint8 colour_primaries;
  guint8 transfer_characteristics;
  guint8 matrix_coefficients;

  guint8 chroma_loc_info_present_flag;
  guint8 chroma_sample_loc_type_top_field;
  guint8 chroma_sample_loc_type_bottom_field;

  guint8 timing_info_present_flag;
  /* if timing_info_present_flag */
  guint32 num_units_in_tick;
  guint32 time_scale;
  guint8 fixed_frame_rate_flag;

  guint8 nal_hrd_parameters_present_flag;
  /* if nal_hrd_parameters_present_flag */
  GstH264HRDParams nal_hrd_parameters;

  guint8 vcl_hrd_parameters_present_flag;
  /* if vcl_hrd_parameters_present_flag */
  GstH264HRDParams vcl_hrd_parameters;

  guint8 low_delay_hrd_flag;
  guint8 pic_struct_present_flag;

  guint8 bitstream_restriction_flag;
  /*  if bitstream_restriction_flag */
  guint8 motion_vectors_over_pic_boundaries_flag;
  guint32 max_bytes_per_pic_denom;
  guint32 max_bits_per_mb_denom;
  guint32 log2_max_mv_length_horizontal;
  guint32 log2_max_mv_length_vertical;
  guint32 num_reorder_frames;
  guint32 max_dec_frame_buffering;

  /* calculated values */
  guint par_n;
  guint par_d;
};
</STRUCT>
<STRUCT>
<NAME>GstH264SPSExtMVCView</NAME>
struct _GstH264SPSExtMVCView
{
  guint16 view_id;
  guint8 num_anchor_refs_l0;
  guint16 anchor_ref_l0[15];
  guint8 num_anchor_refs_l1;
  guint16 anchor_ref_l1[15];
  guint8 num_non_anchor_refs_l0;
  guint16 non_anchor_ref_l0[15];
  guint8 num_non_anchor_refs_l1;
  guint16 non_anchor_ref_l1[15];
};
</STRUCT>
<STRUCT>
<NAME>GstH264SPSExtMVCLevelValueOp</NAME>
struct _GstH264SPSExtMVCLevelValueOp
{
  guint8 temporal_id;
  guint16 num_target_views_minus1;
  guint16 *target_view_id;
  guint16 num_views_minus1;
};
</STRUCT>
<STRUCT>
<NAME>GstH264SPSExtMVCLevelValue</NAME>
struct _GstH264SPSExtMVCLevelValue
{
  guint8 level_idc;
  guint16 num_applicable_ops_minus1;
  GstH264SPSExtMVCLevelValueOp *applicable_op;
};
</STRUCT>
<STRUCT>
<NAME>GstH264SPSExtMVC</NAME>
struct _GstH264SPSExtMVC
{
  guint16 num_views_minus1;
  GstH264SPSExtMVCView *view;
  guint8 num_level_values_signalled_minus1;
  GstH264SPSExtMVCLevelValue *level_value;
};
</STRUCT>
<STRUCT>
<NAME>GstH264SPS</NAME>
struct _GstH264SPS
{
  gint id;

  guint8 profile_idc;
  guint8 constraint_set0_flag;
  guint8 constraint_set1_flag;
  guint8 constraint_set2_flag;
  guint8 constraint_set3_flag;
  guint8 constraint_set4_flag;
  guint8 constraint_set5_flag;
  guint8 level_idc;

  guint8 chroma_format_idc;
  guint8 separate_colour_plane_flag;
  guint8 bit_depth_luma_minus8;
  guint8 bit_depth_chroma_minus8;
  guint8 qpprime_y_zero_transform_bypass_flag;

  guint8 scaling_matrix_present_flag;
  guint8 scaling_lists_4x4[6][16];
  guint8 scaling_lists_8x8[6][64];

  guint8 log2_max_frame_num_minus4;
  guint8 pic_order_cnt_type;

  /* if pic_order_cnt_type == 0 */
  guint8 log2_max_pic_order_cnt_lsb_minus4;

  /* else if pic_order_cnt_type == 1 */
  guint8 delta_pic_order_always_zero_flag;
  gint32 offset_for_non_ref_pic;
  gint32 offset_for_top_to_bottom_field;
  guint8 num_ref_frames_in_pic_order_cnt_cycle;
  gint32 offset_for_ref_frame[255];

  guint32 num_ref_frames;
  guint8 gaps_in_frame_num_value_allowed_flag;
  guint32 pic_width_in_mbs_minus1;
  guint32 pic_height_in_map_units_minus1;
  guint8 frame_mbs_only_flag;

  guint8 mb_adaptive_frame_field_flag;

  guint8 direct_8x8_inference_flag;

  guint8 frame_cropping_flag;

  /* if frame_cropping_flag */
  guint32 frame_crop_left_offset;
  guint32 frame_crop_right_offset;
  guint32 frame_crop_top_offset;
  guint32 frame_crop_bottom_offset;

  guint8 vui_parameters_present_flag;
  /* if vui_parameters_present_flag */
  GstH264VUIParams vui_parameters;

  /* calculated values */
  guint8 chroma_array_type;
  guint32 max_frame_num;
  gint width, height;
  gint crop_rect_width, crop_rect_height;
  gint crop_rect_x, crop_rect_y;
  gint fps_num_removed, fps_den_removed; /* FIXME: remove */
  gboolean valid;

  /* Subset SPS extensions */
  guint8 extension_type;
  union {
    GstH264SPSExtMVC mvc;
  } extension;
};
</STRUCT>
<STRUCT>
<NAME>GstH264PPS</NAME>
struct _GstH264PPS
{
  gint id;

  GstH264SPS *sequence;

  guint8 entropy_coding_mode_flag;
  guint8 pic_order_present_flag;

  guint32 num_slice_groups_minus1;

  /* if num_slice_groups_minus1 > 0 */
  guint8 slice_group_map_type;
  /* and if slice_group_map_type == 0 */
  guint32 run_length_minus1[8];
  /* or if slice_group_map_type == 2 */
  guint32 top_left[8];
  guint32 bottom_right[8];
  /* or if slice_group_map_type == (3, 4, 5) */
  guint8 slice_group_change_direction_flag;
  guint32 slice_group_change_rate_minus1;
  /* or if slice_group_map_type == 6 */
  guint32 pic_size_in_map_units_minus1;
  guint8 *slice_group_id;

  guint8 num_ref_idx_l0_active_minus1;
  guint8 num_ref_idx_l1_active_minus1;
  guint8 weighted_pred_flag;
  guint8 weighted_bipred_idc;
  gint8 pic_init_qp_minus26;
  gint8 pic_init_qs_minus26;
  gint8 chroma_qp_index_offset;
  guint8 deblocking_filter_control_present_flag;
  guint8 constrained_intra_pred_flag;
  guint8 redundant_pic_cnt_present_flag;

  guint8 transform_8x8_mode_flag;

  guint8 scaling_lists_4x4[6][16];
  guint8 scaling_lists_8x8[6][64];

  guint8 second_chroma_qp_index_offset;

  gboolean valid;
};
</STRUCT>
<STRUCT>
<NAME>GstH264RefPicListModification</NAME>
struct _GstH264RefPicListModification
{
  guint8 modification_of_pic_nums_idc;
  union
  {
    /* if modification_of_pic_nums_idc == 0 || 1 */
    guint32 abs_diff_pic_num_minus1;
    /* if modification_of_pic_nums_idc == 2 */
    guint32 long_term_pic_num;
    /* if modification_of_pic_nums_idc == 4 || 5 */
    guint32 abs_diff_view_idx_minus1;
  } value;
};
</STRUCT>
<STRUCT>
<NAME>GstH264PredWeightTable</NAME>
struct _GstH264PredWeightTable
{
  guint8 luma_log2_weight_denom;
  guint8 chroma_log2_weight_denom;

  gint16 luma_weight_l0[32];
  gint8 luma_offset_l0[32];

  /* if seq->ChromaArrayType != 0 */
  gint16 chroma_weight_l0[32][2];
  gint8 chroma_offset_l0[32][2];

  /* if slice->slice_type % 5 == 1 */
  gint16 luma_weight_l1[32];
  gint8 luma_offset_l1[32];

  /* and if seq->ChromaArrayType != 0 */
  gint16 chroma_weight_l1[32][2];
  gint8 chroma_offset_l1[32][2];
};
</STRUCT>
<STRUCT>
<NAME>GstH264RefPicMarking</NAME>
struct _GstH264RefPicMarking
{
  guint8 memory_management_control_operation;

  guint32 difference_of_pic_nums_minus1;
  guint32 long_term_pic_num;
  guint32 long_term_frame_idx;
  guint32 max_long_term_frame_idx_plus1;
};
</STRUCT>
<STRUCT>
<NAME>GstH264DecRefPicMarking</NAME>
struct _GstH264DecRefPicMarking
{
  /* if slice->nal_unit.IdrPicFlag */
  guint8 no_output_of_prior_pics_flag;
  guint8 long_term_reference_flag;

  guint8 adaptive_ref_pic_marking_mode_flag;
  GstH264RefPicMarking ref_pic_marking[10];
  guint8 n_ref_pic_marking;
};
</STRUCT>
<STRUCT>
<NAME>GstH264SliceHdr</NAME>
struct _GstH264SliceHdr
{
  guint32 first_mb_in_slice;
  guint32 type;
  GstH264PPS *pps;

  /* if seq->separate_colour_plane_flag */
  guint8 colour_plane_id;

  guint16 frame_num;

  guint8 field_pic_flag;
  guint8 bottom_field_flag;

  /* if nal_unit.type == 5 */
  guint16 idr_pic_id;

  /* if seq->pic_order_cnt_type == 0 */
  guint16 pic_order_cnt_lsb;
  /* if seq->pic_order_present_flag && !field_pic_flag */
  gint32 delta_pic_order_cnt_bottom;

  gint32 delta_pic_order_cnt[2];
  guint8 redundant_pic_cnt;

  /* if slice_type == B_SLICE */
  guint8 direct_spatial_mv_pred_flag;

  guint8 num_ref_idx_l0_active_minus1;
  guint8 num_ref_idx_l1_active_minus1;

  guint8 ref_pic_list_modification_flag_l0;
  guint8 n_ref_pic_list_modification_l0;
  GstH264RefPicListModification ref_pic_list_modification_l0[32];
  guint8 ref_pic_list_modification_flag_l1;
  guint8 n_ref_pic_list_modification_l1;
  GstH264RefPicListModification ref_pic_list_modification_l1[32];

  GstH264PredWeightTable pred_weight_table;
  /* if nal_unit.ref_idc != 0 */
  GstH264DecRefPicMarking dec_ref_pic_marking;

  guint8 cabac_init_idc;
  gint8 slice_qp_delta;
  gint8 slice_qs_delta;

  guint8 disable_deblocking_filter_idc;
  gint8 slice_alpha_c0_offset_div2;
  gint8 slice_beta_offset_div2;

  guint16 slice_group_change_cycle;

  /* calculated values */
  guint32 max_pic_num;
  gboolean valid;

  /* Size of the slice_header() in bits */
  guint header_size;

  /* Number of emulation prevention bytes (EPB) in this slice_header() */
  guint n_emulation_prevention_bytes;
};
</STRUCT>
<STRUCT>
<NAME>GstH264ClockTimestamp</NAME>
struct _GstH264ClockTimestamp
{
  guint8 ct_type;
  guint8 nuit_field_based_flag;
  guint8 counting_type;
  guint8 discontinuity_flag;
  guint8 cnt_dropped_flag;
  guint8 n_frames;

  guint8 seconds_flag;
  guint8 seconds_value;

  guint8 minutes_flag;
  guint8 minutes_value;

  guint8 hours_flag;
  guint8 hours_value;

  guint32 time_offset;
};
</STRUCT>
<STRUCT>
<NAME>GstH264FramePacking</NAME>
struct _GstH264FramePacking
{
  guint32 frame_packing_id;
  guint8 frame_packing_cancel_flag;
  guint8 frame_packing_type; /* GstH264FramePackingType */
  guint8 quincunx_sampling_flag;
  guint8 content_interpretation_type;
  guint8 spatial_flipping_flag;
  guint8 frame0_flipped_flag;
  guint8 field_views_flag;
  guint8 current_frame_is_frame0_flag;
  guint8 frame0_self_contained_flag;
  guint8 frame1_self_contained_flag;
  guint8 frame0_grid_position_x;
  guint8 frame0_grid_position_y;
  guint8 frame1_grid_position_x;
  guint8 frame1_grid_position_y;
  guint16 frame_packing_repetition_period;
};
</STRUCT>
<STRUCT>
<NAME>GstH264StereoVideoInfo</NAME>
struct _GstH264StereoVideoInfo
{
  guint8 field_views_flag;
  guint8 top_field_is_left_view_flag;
  guint8 current_frame_is_left_view_flag;
  guint8 next_frame_is_second_view_flag;
  guint8 left_view_self_contained_flag;
  guint8 right_view_self_contained_flag;
};
</STRUCT>
<STRUCT>
<NAME>GstH264PicTiming</NAME>
struct _GstH264PicTiming
{
  guint32 cpb_removal_delay;
  guint32 dpb_output_delay;

  guint8 pic_struct_present_flag;
  /* if pic_struct_present_flag */
  guint8 pic_struct;

  guint8 clock_timestamp_flag[3];
  GstH264ClockTimestamp clock_timestamp[3];
};
</STRUCT>
<STRUCT>
<NAME>GstH264BufferingPeriod</NAME>
struct _GstH264BufferingPeriod
{
  GstH264SPS *sps;

  /* seq->vui_parameters->nal_hrd_parameters_present_flag */
  guint32 nal_initial_cpb_removal_delay[32];
  guint32 nal_initial_cpb_removal_delay_offset[32];

  /* seq->vui_parameters->vcl_hrd_parameters_present_flag */
  guint32 vcl_initial_cpb_removal_delay[32];
  guint32 vcl_initial_cpb_removal_delay_offset[32];
};
</STRUCT>
<STRUCT>
<NAME>GstH264RecoveryPoint</NAME>
struct _GstH264RecoveryPoint
{
  guint32 recovery_frame_cnt;
  guint8 exact_match_flag;
  guint8 broken_link_flag;
  guint8 changing_slice_group_idc;
};
</STRUCT>
<STRUCT>
<NAME>GstH264SEIMessage</NAME>
struct _GstH264SEIMessage
{
  GstH264SEIPayloadType payloadType;

  union {
    GstH264BufferingPeriod buffering_period;
    GstH264PicTiming pic_timing;
    GstH264RecoveryPoint recovery_point;
    GstH264StereoVideoInfo stereo_video_info;
    GstH264FramePacking frame_packing;
    /* ... could implement more */
  } payload;
};
</STRUCT>
<STRUCT>
<NAME>GstH264NalParser</NAME>
struct _GstH264NalParser
{
  /*< private >*/
  GstH264SPS sps[GST_H264_MAX_SPS_COUNT];
  GstH264PPS pps[GST_H264_MAX_PPS_COUNT];
  GstH264SPS *last_sps;
  GstH264PPS *last_pps;
};
</STRUCT>
<FUNCTION>
<NAME>gst_h264_nal_parser_new</NAME>
<RETURNS>GstH264NalParser  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_parser_identify_nalu</NAME>
<RETURNS>GstH264ParserResult  </RETURNS>
GstH264NalParser *nalparser, const guint8 *data, guint offset, gsize size, GstH264NalUnit *nalu
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_parser_identify_nalu_unchecked</NAME>
<RETURNS>GstH264ParserResult  </RETURNS>
GstH264NalParser *nalparser, const guint8 *data, guint offset, gsize size, GstH264NalUnit *nalu
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_parser_identify_nalu_avc</NAME>
<RETURNS>GstH264ParserResult  </RETURNS>
GstH264NalParser *nalparser, const guint8 *data, guint offset, gsize size, guint8 nal_length_size, GstH264NalUnit *nalu
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_parser_parse_nal</NAME>
<RETURNS>GstH264ParserResult  </RETURNS>
GstH264NalParser *nalparser, GstH264NalUnit *nalu
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_parser_parse_slice_hdr</NAME>
<RETURNS>GstH264ParserResult  </RETURNS>
GstH264NalParser *nalparser, GstH264NalUnit *nalu, GstH264SliceHdr *slice, gboolean parse_pred_weight_table, gboolean parse_dec_ref_pic_marking
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_parser_parse_subset_sps</NAME>
<RETURNS>GstH264ParserResult  </RETURNS>
GstH264NalParser *nalparser, GstH264NalUnit *nalu, GstH264SPS *sps, gboolean parse_vui_params
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_parser_parse_sps</NAME>
<RETURNS>GstH264ParserResult  </RETURNS>
GstH264NalParser *nalparser, GstH264NalUnit *nalu, GstH264SPS *sps, gboolean parse_vui_params
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_parser_parse_pps</NAME>
<RETURNS>GstH264ParserResult  </RETURNS>
GstH264NalParser *nalparser, GstH264NalUnit *nalu, GstH264PPS *pps
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_parser_parse_sei</NAME>
<RETURNS>GstH264ParserResult  </RETURNS>
GstH264NalParser *nalparser, GstH264NalUnit *nalu, GArray ** messages
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_nal_parser_free</NAME>
<RETURNS>void  </RETURNS>
GstH264NalParser *nalparser
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_parse_subset_sps</NAME>
<RETURNS>GstH264ParserResult  </RETURNS>
GstH264NalUnit *nalu, GstH264SPS *sps, gboolean parse_vui_params
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_parse_sps</NAME>
<RETURNS>GstH264ParserResult  </RETURNS>
GstH264NalUnit *nalu, GstH264SPS *sps, gboolean parse_vui_params
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_parse_pps</NAME>
<RETURNS>GstH264ParserResult  </RETURNS>
GstH264NalParser *nalparser, GstH264NalUnit *nalu, GstH264PPS *pps
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_sps_clear</NAME>
<RETURNS>void                 </RETURNS>
GstH264SPS *sps
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_pps_clear</NAME>
<RETURNS>void                 </RETURNS>
GstH264PPS *pps
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_quant_matrix_8x8_get_zigzag_from_raster</NAME>
<RETURNS>void     </RETURNS>
guint8 out_quant[64], const guint8 quant[64]
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_quant_matrix_8x8_get_raster_from_zigzag</NAME>
<RETURNS>void     </RETURNS>
guint8 out_quant[64], const guint8 quant[64]
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_quant_matrix_4x4_get_zigzag_from_raster</NAME>
<RETURNS>void     </RETURNS>
guint8 out_quant[16], const guint8 quant[16]
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_quant_matrix_4x4_get_raster_from_zigzag</NAME>
<RETURNS>void     </RETURNS>
guint8 out_quant[16], const guint8 quant[16]
</FUNCTION>
<FUNCTION>
<NAME>gst_h264_video_calculate_framerate</NAME>
<RETURNS>void  </RETURNS>
const GstH264SPS * sps, guint field_pic_flag, guint pic_struct, gint * fps_num, gint * fps_den
</FUNCTION>
<MACRO>
<NAME>MAXQ</NAME>
#define MAXQ 255
</MACRO>
<MACRO>
<NAME>QINDEX_RANGE</NAME>
#define QINDEX_RANGE 256
</MACRO>
<MACRO>
<NAME>QINDEX_BITS</NAME>
#define QINDEX_BITS 8
</MACRO>
<FUNCTION>
<NAME>gst_vp9_dc_quant</NAME>
<RETURNS>int16_t  </RETURNS>
int qindex, int delta, int bit_depth
</FUNCTION>
<FUNCTION>
<NAME>gst_vp9_ac_quant</NAME>
<RETURNS>int16_t  </RETURNS>
int qindex, int delta, int bit_depth
</FUNCTION>
<MACRO>
<NAME>GET_BITS</NAME>
#define GET_BITS(b, num, bits) G_STMT_START {        \
  if (!gst_bit_reader_get_bits_uint32(b, bits, num)) \
    goto failed;                                     \
  GST_TRACE ("parsed %d bits: %d", num, *(bits));    \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>CHECK_ALLOWED</NAME>
#define CHECK_ALLOWED(val, min, max) G_STMT_START { \
  if (val < min || val > max) { \
    GST_WARNING ("value not in allowed range. value: %d, range %d-%d", \
                     val, min, max); \
    goto failed; \
  } \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>READ_UINT8</NAME>
#define READ_UINT8(reader, val, nbits) G_STMT_START { \
  if (!gst_bit_reader_get_bits_uint8 (reader, &val, nbits)) { \
    GST_WARNING ("failed to read uint8, nbits: %d", nbits); \
    goto failed; \
  } \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>READ_UINT16</NAME>
#define READ_UINT16(reader, val, nbits) G_STMT_START { \
  if (!gst_bit_reader_get_bits_uint16 (reader, &val, nbits)) { \
    GST_WARNING ("failed to read uint16, nbits: %d", nbits); \
    goto failed; \
  } \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>READ_UINT32</NAME>
#define READ_UINT32(reader, val, nbits) G_STMT_START { \
  if (!gst_bit_reader_get_bits_uint32 (reader, &val, nbits)) { \
    GST_WARNING ("failed to read uint32, nbits: %d", nbits); \
    goto failed; \
  } \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>READ_UINT64</NAME>
#define READ_UINT64(reader, val, nbits) G_STMT_START { \
  if (!gst_bit_reader_get_bits_uint64 (reader, &val, nbits)) { \
    GST_WARNING ("failed to read uint64, nbits: %d", nbits); \
    goto failed; \
  } \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>U_READ_UINT8</NAME>
#define U_READ_UINT8(reader, val, nbits) G_STMT_START { \
  val = gst_bit_reader_get_bits_uint8_unchecked (reader, nbits); \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>U_READ_UINT16</NAME>
#define U_READ_UINT16(reader, val, nbits) G_STMT_START { \
  val = gst_bit_reader_get_bits_uint16_unchecked (reader, nbits); \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>U_READ_UINT32</NAME>
#define U_READ_UINT32(reader, val, nbits) G_STMT_START { \
  val = gst_bit_reader_get_bits_uint32_unchecked (reader, nbits); \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>U_READ_UINT64</NAME>
#define U_READ_UINT64(reader, val, nbits) G_STMT_START { \
  val = gst_bit_reader_get_bits_uint64_unchecked (reader, nbits); \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>SKIP</NAME>
#define SKIP(reader, nbits) G_STMT_START { \
  if (!gst_bit_reader_skip (reader, nbits)) { \
    GST_WARNING ("failed to skip nbits: %d", nbits); \
    goto failed; \
  } \
} G_STMT_END
</MACRO>
<STRUCT>
<NAME>VLCTable</NAME>
struct _VLCTable
{
  guint value;
  guint cword;
  guint cbits;
};
</STRUCT>
<TYPEDEF>
<NAME>VP8_BD_VALUE</NAME>
typedef size_t VP8_BD_VALUE;
</TYPEDEF>
<MACRO>
<NAME>VP8_BD_VALUE_SIZE</NAME>
#define VP8_BD_VALUE_SIZE ((int)sizeof(VP8_BD_VALUE)*CHAR_BIT)
</MACRO>
<MACRO>
<NAME>VP8_LOTS_OF_BITS</NAME>
#define VP8_LOTS_OF_BITS (0x40000000)
</MACRO>
<FUNCTION>
<NAME>vp8dx_start_decode</NAME>
<RETURNS>int  </RETURNS>
BOOL_DECODER *br, const unsigned char *source, unsigned int source_sz, vp8_decrypt_cb *decrypt_cb, void *decrypt_state
</FUNCTION>
<FUNCTION>
<NAME>vp8dx_bool_decoder_fill</NAME>
<RETURNS>void  </RETURNS>
BOOL_DECODER *br
</FUNCTION>
<VARIABLE>
<NAME>bit</NAME>
    unsigned int bit = 0;
</VARIABLE>
<VARIABLE>
<NAME>z</NAME>
    int z = 0;
</VARIABLE>
<MACRO>
<NAME>MAX_HRD_NUM_LEAKY_BUCKETS</NAME>
#define MAX_HRD_NUM_LEAKY_BUCKETS 31
</MACRO>
<MACRO>
<NAME>GST_VC1_BFRACTION_BASIS</NAME>
#define GST_VC1_BFRACTION_BASIS 840
</MACRO>
<MACRO>
<NAME>GST_VC1_BFRACTION_RESERVED</NAME>
#define GST_VC1_BFRACTION_RESERVED (GST_VC1_BFRACTION_BASIS + 1)
</MACRO>
<MACRO>
<NAME>GST_VC1_BFRACTION_PTYPE_BI</NAME>
#define GST_VC1_BFRACTION_PTYPE_BI (GST_VC1_BFRACTION_BASIS + 2)
</MACRO>
<ENUM>
<NAME>GstVC1StartCode</NAME>
typedef enum {
  GST_VC1_END_OF_SEQ       = 0x0A,
  GST_VC1_SLICE            = 0x0B,
  GST_VC1_FIELD            = 0x0C,
  GST_VC1_FRAME            = 0x0D,
  GST_VC1_ENTRYPOINT       = 0x0E,
  GST_VC1_SEQUENCE         = 0x0F,
  GST_VC1_SLICE_USER       = 0x1B,
  GST_VC1_FIELD_USER       = 0x1C,
  GST_VC1_FRAME_USER       = 0x1D,
  GST_VC1_ENTRY_POINT_USER = 0x1E,
  GST_VC1_SEQUENCE_USER    = 0x1F
} GstVC1StartCode;
</ENUM>
<ENUM>
<NAME>GstVC1Profile</NAME>
typedef enum {
  GST_VC1_PROFILE_SIMPLE,
  GST_VC1_PROFILE_MAIN,
  GST_VC1_PROFILE_RESERVED,
  GST_VC1_PROFILE_ADVANCED
} GstVC1Profile;
</ENUM>
<ENUM>
<NAME>GstVC1ParserResult</NAME>
typedef enum {
  GST_VC1_PARSER_OK,
  GST_VC1_PARSER_BROKEN_DATA,
  GST_VC1_PARSER_NO_BDU,
  GST_VC1_PARSER_NO_BDU_END,
  GST_VC1_PARSER_ERROR,
} GstVC1ParserResult;
</ENUM>
<ENUM>
<NAME>GstVC1PictureType</NAME>
typedef enum
{
  GST_VC1_PICTURE_TYPE_P,
  GST_VC1_PICTURE_TYPE_B,
  GST_VC1_PICTURE_TYPE_I,
  GST_VC1_PICTURE_TYPE_BI,
  GST_VC1_PICTURE_TYPE_SKIPPED
} GstVC1PictureType;
</ENUM>
<ENUM>
<NAME>GstVC1Level</NAME>
typedef enum
{
    GST_VC1_LEVEL_LOW    = 0,    /* Simple/Main profile low level */
    GST_VC1_LEVEL_MEDIUM = 2,    /* Simple/Main profile medium level */
    GST_VC1_LEVEL_HIGH   = 4,   /* Main profile high level */

    GST_VC1_LEVEL_L0    = 0,    /* Advanced profile level 0 */
    GST_VC1_LEVEL_L1    = 1,    /* Advanced profile level 1 */
    GST_VC1_LEVEL_L2    = 2,    /* Advanced profile level 2 */
    GST_VC1_LEVEL_L3    = 3,    /* Advanced profile level 3 */
    GST_VC1_LEVEL_L4    = 4,    /* Advanced profile level 4 */

    /* 5 to 7 reserved */
    GST_VC1_LEVEL_UNKNOWN = 255  /* Unknown profile */
} GstVC1Level;
</ENUM>
<ENUM>
<NAME>GstVC1QuantizerSpec</NAME>
typedef enum
{
  GST_VC1_QUANTIZER_IMPLICITLY,
  GST_VC1_QUANTIZER_EXPLICITLY,
  GST_VC1_QUANTIZER_NON_UNIFORM,
  GST_VC1_QUANTIZER_UNIFORM
} GstVC1QuantizerSpec;
</ENUM>
<ENUM>
<NAME>GstVC1DQProfile</NAME>
typedef enum {
  GST_VC1_DQPROFILE_FOUR_EDGES,
  GST_VC1_DQPROFILE_DOUBLE_EDGES,
  GST_VC1_DQPROFILE_SINGLE_EDGE,
  GST_VC1_DQPROFILE_ALL_MBS
} GstVC1DQProfile;
</ENUM>
<ENUM>
<NAME>GstVC1Condover</NAME>
typedef enum {
  GST_VC1_CONDOVER_NONE,
  GST_VC1_CONDOVER_ALL,
  GST_VC1_CONDOVER_SELECT
} GstVC1Condover;
</ENUM>
<ENUM>
<NAME>GstVC1MvMode</NAME>
typedef enum
{
  GST_VC1_MVMODE_1MV_HPEL_BILINEAR,
  GST_VC1_MVMODE_1MV,
  GST_VC1_MVMODE_1MV_HPEL,
  GST_VC1_MVMODE_MIXED_MV,
  GST_VC1_MVMODE_INTENSITY_COMP
} GstVC1MvMode;
</ENUM>
<ENUM>
<NAME>GstVC1FrameCodingMode</NAME>
typedef enum
{
  GST_VC1_FRAME_PROGRESSIVE = 0x0,
  GST_VC1_FRAME_INTERLACE   = 0x10,
  GST_VC1_FIELD_INTERLACE   = 0x11
} GstVC1FrameCodingMode;
</ENUM>
<STRUCT>
<NAME>GstVC1HrdParam</NAME>
struct _GstVC1HrdParam
{
  guint8 hrd_num_leaky_buckets;
  guint8 bit_rate_exponent;
  guint8 buffer_size_exponent;
  guint16 hrd_rate[MAX_HRD_NUM_LEAKY_BUCKETS];
  guint16 hrd_buffer[MAX_HRD_NUM_LEAKY_BUCKETS];
};
</STRUCT>
<STRUCT>
<NAME>GstVC1EntryPointHdr</NAME>
struct _GstVC1EntryPointHdr
{
  guint8 broken_link;
  guint8 closed_entry;
  guint8 panscan_flag;
  guint8 refdist_flag;
  guint8 loopfilter;
  guint8 fastuvmc;
  guint8 extended_mv;
  guint8 dquant;
  guint8 vstransform;
  guint8 overlap;
  guint8 quantizer;
  guint8 coded_size_flag;
  guint16 coded_width;
  guint16 coded_height;
  guint8 extended_dmv;
  guint8 range_mapy_flag;
  guint8 range_mapy;
  guint8 range_mapuv_flag;
  guint8 range_mapuv;

  guint8 hrd_full[MAX_HRD_NUM_LEAKY_BUCKETS];
};
</STRUCT>
<STRUCT>
<NAME>GstVC1AdvancedSeqHdr</NAME>
struct _GstVC1AdvancedSeqHdr
{
  GstVC1Level  level;

  guint8  frmrtq_postproc;
  guint8  bitrtq_postproc;
  guint8  postprocflag;
  guint16 max_coded_width;
  guint16 max_coded_height;
  guint8  pulldown;
  guint8  interlace;
  guint8  tfcntrflag;
  guint8  finterpflag;
  guint8  psf;
  guint8  display_ext;
  guint16 disp_horiz_size;
  guint16 disp_vert_size;
  guint8  aspect_ratio_flag;
  guint8  aspect_ratio;
  guint8  aspect_horiz_size;
  guint8  aspect_vert_size;
  guint8  framerate_flag;
  guint8  framerateind;
  guint8  frameratenr;
  guint8  frameratedr;
  guint16 framerateexp;
  guint8  color_format_flag;
  guint8  color_prim;
  guint8  transfer_char;
  guint8  matrix_coef;
  guint8  hrd_param_flag;
  guint8  colordiff_format;

  GstVC1HrdParam hrd_param;

  /* computed */
  guint framerate; /* Around in fps, 0 if unknown*/
  guint bitrate;   /* Around in kpbs, 0 if unknown*/
  guint par_n;
  guint par_d;
  guint fps_n;
  guint fps_d;

  /* The last parsed entry point */
  GstVC1EntryPointHdr entrypoint;
};
</STRUCT>
<STRUCT>
<NAME>GstVC1SeqStructA</NAME>
struct _GstVC1SeqStructA
{
  guint32 vert_size;
  guint32 horiz_size;
};
</STRUCT>
<STRUCT>
<NAME>GstVC1SeqStructB</NAME>
struct _GstVC1SeqStructB
{
  GstVC1Level  level;

  guint8 cbr;
  guint32 framerate;

  /* In simple and main profiles only */
  guint32 hrd_buffer;
  guint32 hrd_rate;
};
</STRUCT>
<STRUCT>
<NAME>GstVC1SeqStructC</NAME>
struct _GstVC1SeqStructC
{
  GstVC1Profile profile;

  /* Only in simple and main profiles */
  guint8 frmrtq_postproc;
  guint8 bitrtq_postproc;
  guint8 res_sprite;
  guint8 loop_filter;
  guint8 multires;
  guint8 fastuvmc;
  guint8 extended_mv;
  guint8 dquant;
  guint8 vstransform;
  guint8 overlap;
  guint8 syncmarker;
  guint8 rangered;
  guint8 maxbframes;
  guint8 quantizer;
  guint8 finterpflag;

  /* Computed */
  guint framerate; /* Around in fps, 0 if unknown*/
  guint bitrate;   /* Around in kpbs, 0 if unknown*/

  /* This should be filled by user if previously known */
  guint16 coded_width;
  /* This should be filled by user if previously known */
  guint16 coded_height;

  /* Wmvp specific */
  guint8 wmvp;          /* Specify if the stream is wmp or not */
  /* In the wmvp case, the framerate is not computed but in the bistream */
  guint8 slice_code;
};
</STRUCT>
<STRUCT>
<NAME>GstVC1SeqLayer</NAME>
struct _GstVC1SeqLayer
{
  guint32 numframes;

  GstVC1SeqStructA struct_a;
  GstVC1SeqStructB struct_b;
  GstVC1SeqStructC struct_c;
};
</STRUCT>
<STRUCT>
<NAME>GstVC1SeqHdr</NAME>
struct _GstVC1SeqHdr
{
  GstVC1Profile profile;

  GstVC1SeqStructC struct_c;

  /*  calculated */
  guint mb_height;
  guint mb_width;
  guint mb_stride;

  GstVC1AdvancedSeqHdr   advanced;

};
</STRUCT>
<STRUCT>
<NAME>GstVC1PicSimpleMain</NAME>
struct _GstVC1PicSimpleMain
{
  guint8 frmcnt;
  guint8 mvrange;
  guint8 rangeredfrm;

  /* I and P pic simple and main profiles only */
  guint8 respic;

  /* I and BI pic simple and main profiles only */
  guint8 transacfrm2;
  guint8 bf;

  /* B and P pic simple and main profiles only */
  guint8 mvmode;
  guint8 mvtab;
  guint8 ttmbf;

  /* P pic simple and main profiles only */
  guint8 mvmode2;
  guint8 lumscale;
  guint8 lumshift;

  guint8 cbptab;
  guint8 ttfrm;

  /* B and BI picture only
   * Should be divided by #GST_VC1_BFRACTION_BASIS
   * to get the real value. */
  guint16 bfraction;

  /* Biplane value, those fields only mention the fact
   * that the bitplane is in raw mode or not */
  guint8 mvtypemb;
  guint8 skipmb;
  guint8 directmb; /* B pic main profile only */
};
</STRUCT>
<STRUCT>
<NAME>GstVC1PicAdvanced</NAME>
struct _GstVC1PicAdvanced
{
  GstVC1FrameCodingMode fcm;
  guint8  tfcntr;

  guint8  rptfrm;
  guint8  tff;
  guint8  rff;
  guint8  ps_present;
  guint32 ps_hoffset;
  guint32 ps_voffset;
  guint16 ps_width;
  guint16 ps_height;
  guint8  rndctrl;
  guint8  uvsamp;
  guint8  postproc;

  /*  B and P picture specific */
  guint8  mvrange;
  guint8  mvmode;
  guint8  mvtab;
  guint8  cbptab;
  guint8  ttmbf;
  guint8  ttfrm;

  /* B and BI picture only
   * Should be divided by #GST_VC1_BFRACTION_BASIS
   * to get the real value. */
  guint16 bfraction;

  /* ppic */
  guint8  mvmode2;
  guint8  lumscale;
  guint8  lumshift;

  /* bipic */
  guint8  bf;
  guint8  condover;
  guint8  transacfrm2;

  /* Biplane value, those fields only mention the fact
   * that the bitplane is in raw mode or not */
  guint8  acpred;
  guint8  overflags;
  guint8  mvtypemb;
  guint8  skipmb;
  guint8  directmb;
  guint8  forwardmb; /* B pic interlace field only */

  /* For interlaced pictures only */
  guint8  fieldtx;

  /* P and B pictures */
  guint8  intcomp;
  guint8  dmvrange;
  guint8  mbmodetab;
  guint8  imvtab;
  guint8  icbptab;
  guint8  mvbptab2;
  guint8  mvbptab4; /* If 4mvswitch in ppic */

  /*  P picture */
  guint8  mvswitch4;

  /* For interlaced fields only */
  guint16 refdist;
  guint8 fptype; /* Raw value */

  /* P pic */
  guint8  numref;
  guint8  reffield;
  guint8  lumscale2;
  guint8  lumshift2;
  guint8  intcompfield;

};
</STRUCT>
<STRUCT>
<NAME>GstVC1BitPlanes</NAME>
struct _GstVC1BitPlanes
{
  guint8  *acpred;
  guint8  *fieldtx;
  guint8  *overflags;
  guint8  *mvtypemb;
  guint8  *skipmb;
  guint8  *directmb;
  guint8  *forwardmb;

  guint size; /* Size of the arrays */
};
</STRUCT>
<STRUCT>
<NAME>GstVC1VopDquant</NAME>
struct _GstVC1VopDquant
{
  guint8 pqdiff;
  guint8 abspq;

  /* Computed */
  guint8 altpquant;

  /*  if dqant != 2*/
  guint8 dquantfrm;
  guint8 dqprofile;

  /* Boundary edge selection. This represents DQSBEDGE
   * if dqprofile == GST_VC1_DQPROFILE_SINGLE_EDGE or
   * DQDBEDGE if dqprofile == GST_VC1_DQPROFILE_DOUBLE_EDGE */
  guint8 dqbedge;

  /* FIXME: remove */
  guint8 unused;

  /* if dqprofile == GST_VC1_DQPROFILE_ALL_MBS */
  guint8 dqbilevel;

};
</STRUCT>
<STRUCT>
<NAME>GstVC1FrameLayer</NAME>
struct _GstVC1FrameLayer
{
  guint8 key;
  guint32 framesize;

  guint32 timestamp;

  /* calculated */
  guint32 next_framelayer_offset;
  guint8 skiped_p_frame;
};
</STRUCT>
<STRUCT>
<NAME>GstVC1FrameHdr</NAME>
struct _GstVC1FrameHdr
{
  /* common fields */
  GstVC1PictureType ptype;
  guint8 interpfrm;
  guint8 halfqp;
  guint8 transacfrm;
  guint8 transdctab;
  guint8 pqindex;
  guint8 pquantizer;

  /* Computed */
  guint8 pquant;

  /* Convenience fields */
  guint8 profile;
  guint8 dquant;

  /*  If dquant */
  GstVC1VopDquant vopdquant;

  union {
    GstVC1PicSimpleMain simple;
    GstVC1PicAdvanced advanced;
  } pic;

  /* Size of the picture layer in bits */
  guint header_size;
};
</STRUCT>
<STRUCT>
<NAME>GstVC1SliceHdr</NAME>
struct _GstVC1SliceHdr
{
  guint16 slice_addr;

  /* Size of the slice layer in bits */
  guint header_size;
};
</STRUCT>
<STRUCT>
<NAME>GstVC1BDU</NAME>
struct _GstVC1BDU
{
  GstVC1StartCode type;
  guint size;
  guint sc_offset;
  guint offset;
  guint8 * data;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vc1_identify_next_bdu</NAME>
<RETURNS>GstVC1ParserResult  </RETURNS>
const guint8 *data, gsize size, GstVC1BDU *bdu
</FUNCTION>
<FUNCTION>
<NAME>gst_vc1_parse_sequence_header</NAME>
<RETURNS>GstVC1ParserResult  </RETURNS>
const guint8 *data, gsize size, GstVC1SeqHdr * seqhdr
</FUNCTION>
<FUNCTION>
<NAME>gst_vc1_parse_entry_point_header</NAME>
<RETURNS>GstVC1ParserResult  </RETURNS>
const  guint8 *data, gsize size, GstVC1EntryPointHdr * entrypoint, GstVC1SeqHdr *seqhdr
</FUNCTION>
<FUNCTION>
<NAME>gst_vc1_parse_sequence_layer</NAME>
<RETURNS>GstVC1ParserResult  </RETURNS>
const guint8 *data, gsize size, GstVC1SeqLayer * seqlayer
</FUNCTION>
<FUNCTION>
<NAME>gst_vc1_parse_sequence_header_struct_a</NAME>
<RETURNS>GstVC1ParserResult </RETURNS>
const guint8 *data, gsize size, GstVC1SeqStructA *structa
</FUNCTION>
<FUNCTION>
<NAME>gst_vc1_parse_sequence_header_struct_b</NAME>
<RETURNS>GstVC1ParserResult </RETURNS>
const guint8 *data, gsize size, GstVC1SeqStructB *structb
</FUNCTION>
<FUNCTION>
<NAME>gst_vc1_parse_sequence_header_struct_c</NAME>
<RETURNS>GstVC1ParserResult </RETURNS>
const guint8 *data, gsize size, GstVC1SeqStructC *structc
</FUNCTION>
<FUNCTION>
<NAME>gst_vc1_parse_frame_layer</NAME>
<RETURNS>GstVC1ParserResult  </RETURNS>
const guint8 *data, gsize size, GstVC1FrameLayer * framelayer
</FUNCTION>
<FUNCTION>
<NAME>gst_vc1_parse_frame_header</NAME>
<RETURNS>GstVC1ParserResult  </RETURNS>
const guint8 *data, gsize size, GstVC1FrameHdr * framehdr, GstVC1SeqHdr *seqhdr, GstVC1BitPlanes *bitplanes
</FUNCTION>
<FUNCTION>
<NAME>gst_vc1_parse_field_header</NAME>
<RETURNS>GstVC1ParserResult  </RETURNS>
const guint8 *data, gsize size, GstVC1FrameHdr * fieldhdr, GstVC1SeqHdr *seqhdr, GstVC1BitPlanes *bitplanes
</FUNCTION>
<FUNCTION>
<NAME>gst_vc1_parse_slice_header</NAME>
<RETURNS>GstVC1ParserResult  </RETURNS>
const guint8 *data, gsize size, GstVC1SliceHdr *slicehdr, GstVC1SeqHdr *seqhdr
</FUNCTION>
<FUNCTION>
<NAME>gst_vc1_bitplanes_new</NAME>
<RETURNS>GstVC1BitPlanes  *  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vc1_bitplanes_free</NAME>
<RETURNS>void                </RETURNS>
GstVC1BitPlanes *bitplanes
</FUNCTION>
<FUNCTION>
<NAME>gst_vc1_bitplanes_free_1</NAME>
<RETURNS>void                </RETURNS>
GstVC1BitPlanes *bitplanes
</FUNCTION>
<FUNCTION>
<NAME>gst_vc1_bitplanes_ensure_size</NAME>
<RETURNS>gboolean            </RETURNS>
GstVC1BitPlanes *bitplanes, GstVC1SeqHdr *seqhdr
</FUNCTION>
<STRUCT>
<NAME>GstVC1Picture</NAME>
</STRUCT>
<ENUM>
<NAME>GstMpegVideoPacketTypeCode</NAME>
typedef enum {
  GST_MPEG_VIDEO_PACKET_PICTURE      = 0x00,
  GST_MPEG_VIDEO_PACKET_SLICE_MIN    = 0x01,
  GST_MPEG_VIDEO_PACKET_SLICE_MAX    = 0xaf,
  GST_MPEG_VIDEO_PACKET_USER_DATA    = 0xb2,
  GST_MPEG_VIDEO_PACKET_SEQUENCE     = 0xb3,
  GST_MPEG_VIDEO_PACKET_EXTENSION    = 0xb5,
  GST_MPEG_VIDEO_PACKET_SEQUENCE_END = 0xb7,
  GST_MPEG_VIDEO_PACKET_GOP          = 0xb8,
  GST_MPEG_VIDEO_PACKET_NONE         = 0xff
} GstMpegVideoPacketTypeCode;
</ENUM>
<MACRO>
<NAME>GST_MPEG_VIDEO_PACKET_IS_SLICE</NAME>
#define GST_MPEG_VIDEO_PACKET_IS_SLICE(typecode) ((typecode) >= GST_MPEG_VIDEO_PACKET_SLICE_MIN && \
                                                  (typecode) <= GST_MPEG_VIDEO_PACKET_SLICE_MAX)
</MACRO>
<ENUM>
<NAME>GstMpegVideoPacketExtensionCode</NAME>
typedef enum {
  GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE          = 0x01,
  GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE_DISPLAY  = 0x02,
  GST_MPEG_VIDEO_PACKET_EXT_QUANT_MATRIX      = 0x03,
  GST_MPEG_VIDEO_PACKET_EXT_SEQUENCE_SCALABLE = 0x05,
  GST_MPEG_VIDEO_PACKET_EXT_PICTURE           = 0x08
} GstMpegVideoPacketExtensionCode;
</ENUM>
<ENUM>
<NAME>GstMpegVideoSequenceScalableMode</NAME>
typedef enum {
  GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_DATA_PARTITIONING  = 0x00,
  GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_SPATIAL            = 0x01,
  GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_SNR                = 0x02,
  GST_MPEG_VIDEO_SEQ_SCALABLE_MODE_TEMPORAL           = 0x03
} GstMpegVideoSequenceScalableMode;
</ENUM>
<ENUM>
<NAME>GstMpegVideoLevel</NAME>
typedef enum {
 GST_MPEG_VIDEO_LEVEL_HIGH      = 0x04,
 GST_MPEG_VIDEO_LEVEL_HIGH_1440 = 0x06,
 GST_MPEG_VIDEO_LEVEL_MAIN      = 0x08,
 GST_MPEG_VIDEO_LEVEL_LOW       = 0x0a
} GstMpegVideoLevel;
</ENUM>
<ENUM>
<NAME>GstMpegVideoProfile</NAME>
typedef enum {
  GST_MPEG_VIDEO_PROFILE_422                 = 0x00,
  GST_MPEG_VIDEO_PROFILE_HIGH                = 0x01,
  GST_MPEG_VIDEO_PROFILE_SPATIALLY_SCALABLE  = 0x02,
  GST_MPEG_VIDEO_PROFILE_SNR_SCALABLE        = 0x03,
  GST_MPEG_VIDEO_PROFILE_MAIN                = 0x04,
  GST_MPEG_VIDEO_PROFILE_SIMPLE              = 0x05
} GstMpegVideoProfile;
</ENUM>
<ENUM>
<NAME>GstMpegVideoChromaFormat</NAME>
typedef enum {
  GST_MPEG_VIDEO_CHROMA_RES = 0x00,
  GST_MPEG_VIDEO_CHROMA_420 = 0x01,
  GST_MPEG_VIDEO_CHROMA_422 = 0x02,
  GST_MPEG_VIDEO_CHROMA_444 = 0x03,
} GstMpegVideoChromaFormat;
</ENUM>
<ENUM>
<NAME>GstMpegVideoPictureType</NAME>
typedef enum {
  GST_MPEG_VIDEO_PICTURE_TYPE_I = 0x01,
  GST_MPEG_VIDEO_PICTURE_TYPE_P = 0x02,
  GST_MPEG_VIDEO_PICTURE_TYPE_B = 0x03,
  GST_MPEG_VIDEO_PICTURE_TYPE_D = 0x04
} GstMpegVideoPictureType;
</ENUM>
<ENUM>
<NAME>GstMpegVideoPictureStructure</NAME>
typedef enum {
    GST_MPEG_VIDEO_PICTURE_STRUCTURE_TOP_FIELD    = 0x01,
    GST_MPEG_VIDEO_PICTURE_STRUCTURE_BOTTOM_FIELD = 0x02,
    GST_MPEG_VIDEO_PICTURE_STRUCTURE_FRAME        = 0x03
} GstMpegVideoPictureStructure;
</ENUM>
<STRUCT>
<NAME>GstMpegVideoSequenceHdr</NAME>
struct _GstMpegVideoSequenceHdr
{
  guint16 width, height;
  guint8  aspect_ratio_info;
  guint8  frame_rate_code;
  guint32 bitrate_value;
  guint16 vbv_buffer_size_value;

  guint8  constrained_parameters_flag;

  guint8  load_intra_quantiser_matrix;
  guint8  intra_quantizer_matrix[64];
  guint8  load_non_intra_quantiser_matrix;
  guint8  non_intra_quantizer_matrix[64];

  /* Calculated values */
  guint   par_w, par_h;
  guint   fps_n, fps_d;
  guint   bitrate;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegVideoSequenceExt</NAME>
struct _GstMpegVideoSequenceExt
{
  /* mpeg2 decoder profile */
  guint8 profile;
  /* mpeg2 decoder level */
  guint8 level;

  guint8 progressive;
  guint8 chroma_format;

  guint8 horiz_size_ext, vert_size_ext;

  guint16 bitrate_ext;
  guint8 vbv_buffer_size_extension;
  guint8 low_delay;
  guint8 fps_n_ext, fps_d_ext;

  /* Additional information */
  guint8 profile_level_escape_bit;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegVideoSequenceDisplayExt</NAME>
struct _GstMpegVideoSequenceDisplayExt
{
  guint8 video_format;
  guint8 colour_description_flag;

  /* if colour_description_flag: */
    guint8 colour_primaries;
    guint8 transfer_characteristics;
    guint8 matrix_coefficients;

  guint16 display_horizontal_size;
  guint16 display_vertical_size;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegVideoSequenceScalableExt</NAME>
struct _GstMpegVideoSequenceScalableExt
{
  guint8 scalable_mode;
  guint8 layer_id;

  /* if spatial scalability */
  guint16 lower_layer_prediction_horizontal_size;
  guint16 lower_layer_prediction_vertical_size;
  guint8 horizontal_subsampling_factor_m;
  guint8 horizontal_subsampling_factor_n;
  guint8 vertical_subsampling_factor_m;
  guint8 vertical_subsampling_factor_n;

  /* if temporal scalability */
  guint8 picture_mux_enable;
  guint8 mux_to_progressive_sequence;
  guint8 picture_mux_order;
  guint8 picture_mux_factor;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegVideoQuantMatrixExt</NAME>
struct _GstMpegVideoQuantMatrixExt
{
 guint8 load_intra_quantiser_matrix;
 guint8 intra_quantiser_matrix[64];
 guint8 load_non_intra_quantiser_matrix;
 guint8 non_intra_quantiser_matrix[64];
 guint8 load_chroma_intra_quantiser_matrix;
 guint8 chroma_intra_quantiser_matrix[64];
 guint8 load_chroma_non_intra_quantiser_matrix;
 guint8 chroma_non_intra_quantiser_matrix[64];
};
</STRUCT>
<STRUCT>
<NAME>GstMpegVideoPictureHdr</NAME>
struct _GstMpegVideoPictureHdr
{
  guint16 tsn;
  guint8 pic_type;
  guint16 vbv_delay;

  guint8 full_pel_forward_vector, full_pel_backward_vector;

  guint8 f_code[2][2];
};
</STRUCT>
<STRUCT>
<NAME>GstMpegVideoPictureExt</NAME>
struct _GstMpegVideoPictureExt
{
  guint8 f_code[2][2];

  guint8 intra_dc_precision;
  guint8 picture_structure;
  guint8 top_field_first;
  guint8 frame_pred_frame_dct;
  guint8 concealment_motion_vectors;
  guint8 q_scale_type;
  guint8 intra_vlc_format;
  guint8 alternate_scan;
  guint8 repeat_first_field;
  guint8 chroma_420_type;
  guint8 progressive_frame;
  guint8 composite_display;
  guint8 v_axis;
  guint8 field_sequence;
  guint8 sub_carrier;
  guint8 burst_amplitude;
  guint8 sub_carrier_phase;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegVideoGop</NAME>
struct _GstMpegVideoGop
{
  guint8 drop_frame_flag;

  guint8 hour, minute, second, frame;

  guint8 closed_gop;
  guint8 broken_link;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegVideoSliceHdr</NAME>
struct _GstMpegVideoSliceHdr
{
  guint8 vertical_position;
  guint8 vertical_position_ext;

  guint8 priority_breakpoint;
  guint8 quantiser_scale_code;
  guint8 slice_ext_flag;
  guint8 intra_slice;
  guint8 slice_picture_id_enable;
  guint8 slice_picture_id;

  /* Calculated values */
  guint header_size;            /* slice_header size in bits */
  gint mb_row;                  /* macroblock row */
  gint mb_column;               /* macroblock column */
};
</STRUCT>
<STRUCT>
<NAME>GstMpegVideoPacket</NAME>
struct _GstMpegVideoPacket
{
  const guint8 *data;
  guint8 type;
  guint  offset;
  gint   size;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpeg_video_parse</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpegVideoPacket * packet, const guint8 * data, gsize size, guint offset
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_packet_parse_sequence_header</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegVideoPacket * packet, GstMpegVideoSequenceHdr * seqhdr
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_packet_parse_sequence_extension</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegVideoPacket * packet, GstMpegVideoSequenceExt * seqext
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_packet_parse_sequence_display_extension</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegVideoPacket * packet, GstMpegVideoSequenceDisplayExt * seqdisplayext
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_packet_parse_sequence_scalable_extension</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegVideoPacket * packet, GstMpegVideoSequenceScalableExt * seqscaleext
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_packet_parse_picture_header</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegVideoPacket * packet, GstMpegVideoPictureHdr* pichdr
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_packet_parse_picture_extension</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegVideoPacket * packet, GstMpegVideoPictureExt *picext
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_packet_parse_gop</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegVideoPacket * packet, GstMpegVideoGop * gop
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_packet_parse_slice_header</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegVideoPacket * packet, GstMpegVideoSliceHdr * slice_hdr, GstMpegVideoSequenceHdr * seq_hdr, GstMpegVideoSequenceScalableExt * seqscaleext
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_packet_parse_quant_matrix_extension</NAME>
<RETURNS>gboolean  </RETURNS>
const GstMpegVideoPacket * packet, GstMpegVideoQuantMatrixExt * quant
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_finalise_mpeg2_sequence_header</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpegVideoSequenceHdr *hdr, GstMpegVideoSequenceExt *seqext, GstMpegVideoSequenceDisplayExt *displayext
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_parse_picture_header</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
GstMpegVideoPictureHdr* hdr, const guint8 * data, gsize size, guint offset
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_parse_picture_extension</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
GstMpegVideoPictureExt *ext, const guint8 * data, gsize size, guint offset
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_parse_gop</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
GstMpegVideoGop * gop, const guint8 * data, gsize size, guint offset
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_parse_sequence_header</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
GstMpegVideoSequenceHdr * seqhdr, const guint8 * data, gsize size, guint offset
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_parse_sequence_extension</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
GstMpegVideoSequenceExt * seqext, const guint8 * data, gsize size, guint offset
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_parse_sequence_display_extension</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
GstMpegVideoSequenceDisplayExt * seqdisplayext, const guint8 * data, gsize size, guint offset
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_parse_quant_matrix_extension</NAME>
<DEPRECATED/>
<RETURNS>gboolean  </RETURNS>
GstMpegVideoQuantMatrixExt * quant, const guint8 * data, gsize size, guint offset
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_quant_matrix_get_raster_from_zigzag</NAME>
<RETURNS>void      </RETURNS>
guint8 out_quant[64], const guint8 quant[64]
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_video_quant_matrix_get_zigzag_from_raster</NAME>
<RETURNS>void      </RETURNS>
guint8 out_quant[64], const guint8 quant[64]
</FUNCTION>
<ENUM>
<NAME>GstJPEG2000Sampling</NAME>
typedef enum
{
  GST_JPEG2000_SAMPLING_NONE,
  GST_JPEG2000_SAMPLING_RGB,
  GST_JPEG2000_SAMPLING_BGR,
  GST_JPEG2000_SAMPLING_RGBA,
  GST_JPEG2000_SAMPLING_BGRA,
  GST_JPEG2000_SAMPLING_YBR444,
  GST_JPEG2000_SAMPLING_YBR422,
  GST_JPEG2000_SAMPLING_YBR420,
  GST_JPEG2000_SAMPLING_YBR410,
  GST_JPEG2000_SAMPLING_GRAYSCALE,
  GST_JPEG2000_SAMPLING_YBRA4444_EXT
} GstJPEG2000Sampling;
</ENUM>
<MACRO>
<NAME>GST_JPEG2000_SAMPLING_LIST</NAME>
#define GST_JPEG2000_SAMPLING_LIST "sampling = (string) {\"RGB\", \"BGR\", \"RGBA\", \"BGRA\", \"YCbCr-4:4:4\", \"YCbCr-4:2:2\", \"YCbCr-4:2:0\", \"YCbCr-4:1:1\", \"GRAYSCALE\" , \"YCbCrA-4:4:4:4\"}"
</MACRO>
<FUNCTION>
<NAME>gst_jpeg2000_sampling_to_string</NAME>
<RETURNS>const gchar  *</RETURNS>
GstJPEG2000Sampling sampling
</FUNCTION>
<FUNCTION>
<NAME>gst_jpeg2000_sampling_from_string</NAME>
<RETURNS>GstJPEG2000Sampling  </RETURNS>
const gchar * sampling_string
</FUNCTION>
<FUNCTION>
<NAME>gst_jpeg2000_sampling_is_rgb</NAME>
<RETURNS>gboolean  </RETURNS>
GstJPEG2000Sampling sampling
</FUNCTION>
<FUNCTION>
<NAME>gst_jpeg2000_sampling_is_yuv</NAME>
<RETURNS>gboolean  </RETURNS>
GstJPEG2000Sampling sampling
</FUNCTION>
<FUNCTION>
<NAME>gst_jpeg2000_sampling_is_mono</NAME>
<RETURNS>gboolean  </RETURNS>
GstJPEG2000Sampling sampling
</FUNCTION>
<ENUM>
<NAME>GstJPEG2000Colorspace</NAME>
typedef enum
{
  GST_JPEG2000_COLORSPACE_NONE,
  GST_JPEG2000_COLORSPACE_RGB,
  GST_JPEG2000_COLORSPACE_YUV,
  GST_JPEG2000_COLORSPACE_GRAY
} GstJPEG2000Colorspace;
</ENUM>
<FUNCTION>
<NAME>gst_jpeg2000_colorspace_to_string</NAME>
<RETURNS>const gchar  *</RETURNS>
GstJPEG2000Colorspace colorspace
</FUNCTION>
<FUNCTION>
<NAME>gst_jpeg2000_colorspace_from_string</NAME>
<RETURNS>GstJPEG2000Colorspace  </RETURNS>
const gchar * colorspace_string
</FUNCTION>
<MACRO>
<NAME>GST_JPEG2000_COLORSPACE_LIST</NAME>
#define GST_JPEG2000_COLORSPACE_LIST "colorspace = (string) { \"sRGB\", \"sYUV\", \"GRAY\" }"
</MACRO>
<ENUM>
<NAME>GstMpeg4StartCode</NAME>
typedef enum
{
  GST_MPEG4_VIDEO_OBJ_FIRST      = 0x00,
  GST_MPEG4_VIDEO_OBJ_LAST       = 0x1f,
  GST_MPEG4_VIDEO_LAYER_FIRST    = 0x20,
  GST_MPEG4_VIDEO_LAYER_LAST     = 0x2f,
  GST_MPEG4_VISUAL_OBJ_SEQ_START = 0xb0,
  GST_MPEG4_VISUAL_OBJ_SEQ_END   = 0xb1,
  GST_MPEG4_USER_DATA            = 0xb2,
  GST_MPEG4_GROUP_OF_VOP         = 0xb3,
  GST_MPEG4_VIDEO_SESSION_ERR    = 0xb4,
  GST_MPEG4_VISUAL_OBJ           = 0xb5,
  GST_MPEG4_VIDEO_OBJ_PLANE      = 0xb6,
  GST_MPEG4_FBA                  = 0xba,
  GST_MPEG4_FBA_PLAN             = 0xbb,
  GST_MPEG4_MESH                 = 0xbc,
  GST_MPEG4_MESH_PLAN            = 0xbd,
  GST_MPEG4_STILL_TEXTURE_OBJ    = 0xbe,
  GST_MPEG4_TEXTURE_SPATIAL      = 0xbf,
  GST_MPEG4_TEXTURE_SNR_LAYER    = 0xc0,
  GST_MPEG4_TEXTURE_TILE         = 0xc1,
  GST_MPEG4_SHAPE_LAYER          = 0xc2,
  GST_MPEG4_STUFFING             = 0xc3,
  GST_MPEG4_SYSTEM_FIRST         = 0xc6,
  GST_MPEG4_SYSTEM_LAST          = 0xff,
  GST_MPEG4_RESYNC               = 0xfff
} GstMpeg4StartCode;
</ENUM>
<ENUM>
<NAME>GstMpeg4VisualObjectType</NAME>
typedef enum {
  GST_MPEG4_VIDEO_ID         = 0x01,
  GST_MPEG4_STILL_TEXTURE_ID = 0x02,
  GST_MPEG4_STILL_MESH_ID    = 0x03,
  GST_MPEG4_STILL_FBA_ID     = 0x04,
  GST_MPEG4_STILL_3D_MESH_ID = 0x05,
  /*... reserved */

} GstMpeg4VisualObjectType;
</ENUM>
<ENUM>
<NAME>GstMpeg4AspectRatioInfo</NAME>
typedef enum {
  GST_MPEG4_SQUARE        = 0x01,
  GST_MPEG4_625_TYPE_4_3  = 0x02,
  GST_MPEG4_525_TYPE_4_3  = 0x03,
  GST_MPEG4_625_TYPE_16_9 = 0x04,
  GST_MPEG4_525_TYPE_16_9 = 0x05,
  GST_MPEG4_EXTENDED_PAR  = 0x0f,
} GstMpeg4AspectRatioInfo;
</ENUM>
<ENUM>
<NAME>GstMpeg4ParseResult</NAME>
typedef enum {
  GST_MPEG4_PARSER_OK,
  GST_MPEG4_PARSER_BROKEN_DATA,
  GST_MPEG4_PARSER_NO_PACKET,
  GST_MPEG4_PARSER_NO_PACKET_END,
  GST_MPEG4_PARSER_ERROR,
} GstMpeg4ParseResult;
</ENUM>
<ENUM>
<NAME>GstMpeg4VideoObjectCodingType</NAME>
typedef enum {
  GST_MPEG4_I_VOP = 0x0,
  GST_MPEG4_P_VOP = 0x1,
  GST_MPEG4_B_VOP = 0x2,
  GST_MPEG4_S_VOP = 0x3
} GstMpeg4VideoObjectCodingType;
</ENUM>
<ENUM>
<NAME>GstMpeg4ChromaFormat</NAME>
typedef enum {
  /* Other value are reserved */
  GST_MPEG4_CHROMA_4_2_0 = 0x01
} GstMpeg4ChromaFormat;
</ENUM>
<ENUM>
<NAME>GstMpeg4VideoObjectLayerShape</NAME>
typedef enum {
  GST_MPEG4_RECTANGULAR,
  GST_MPEG4_BINARY,
  GST_MPEG4_BINARY_ONLY,
  GST_MPEG4_GRAYSCALE
} GstMpeg4VideoObjectLayerShape;
</ENUM>
<ENUM>
<NAME>GstMpeg4SpriteEnable</NAME>
typedef enum {
  GST_MPEG4_SPRITE_UNUSED,
  GST_MPEG4_SPRITE_STATIC,
  GST_MPEG4_SPRITE_GMG
} GstMpeg4SpriteEnable;
</ENUM>
<ENUM>
<NAME>GstMpeg4Profile</NAME>
typedef enum {
  GST_MPEG4_PROFILE_CORE,
  GST_MPEG4_PROFILE_MAIN,
  GST_MPEG4_PROFILE_N_BIT,
  GST_MPEG4_PROFILE_SIMPLE,
  GST_MPEG4_PROFILE_HYBRID,
  GST_MPEG4_PROFILE_RESERVED,
  GST_MPEG4_PROFILE_SIMPLE_FBA,
  GST_MPEG4_PROFILE_CORE_STUDIO,
  GST_MPEG4_PROFILE_SIMPLE_STUDIO,
  GST_MPEG4_PROFILE_CORE_SCALABLE,
  GST_MPEG4_PROFILE_ADVANCED_CORE,
  GST_MPEG4_PROFILE_ADVANCED_SIMPLE,
  GST_MPEG4_PROFILE_SIMPLE_SCALABLE,
  GST_MPEG4_PROFILE_SCALABLE_TEXTURE,
  GST_MPEG4_PROFILE_SIMPLE_FACE_ANIMATION,
  GST_MPEG4_PROFILE_BASIC_ANIMATED_TEXTURE,
  GST_MPEG4_PROFILE_ADVANCED_REALTIME_SIMPLE,
  GST_MPEG4_PROFILE_ADVANCED_SCALABLE_TEXTURE,
  GST_MPEG4_PROFILE_FINE_GRANULARITY_SCALABLE,
  GST_MPEG4_PROFILE_ADVANCED_CODING_EFFICIENCY
} GstMpeg4Profile;
</ENUM>
<ENUM>
<NAME>GstMpeg4Level</NAME>
typedef enum {
  GST_MPEG4_LEVEL0,
  GST_MPEG4_LEVEL1,
  GST_MPEG4_LEVEL2,
  GST_MPEG4_LEVEL3,
  GST_MPEG4_LEVEL3b,
  GST_MPEG4_LEVEL4,
  GST_MPEG4_LEVEL5,
  GST_MPEG4_LEVEL_RESERVED
} GstMpeg4Level;
</ENUM>
<STRUCT>
<NAME>GstMpeg4VisualObjectSequence</NAME>
struct _GstMpeg4VisualObjectSequence {
  guint8 profile_and_level_indication;

  /* Computed according to:
   * Table G.1  FLC table for profile_and_level_indication */
  GstMpeg4Level level;
  GstMpeg4Profile profile;
};
</STRUCT>
<STRUCT>
<NAME>GstMpeg4VisualObject</NAME>
struct _GstMpeg4VisualObject {
  guint8 is_identifier;
  /* If is_identifier */
  guint8 verid;
  guint8 priority;

  GstMpeg4VisualObjectType type;
};
</STRUCT>
<STRUCT>
<NAME>GstMpeg4VideoSignalType</NAME>
struct _GstMpeg4VideoSignalType {
  guint8 type;

  guint8 format;
  guint8 range;
  guint8 color_description;
  guint8 color_primaries;
  guint8 transfer_characteristics;
  guint8 matrix_coefficients;
};
</STRUCT>
<STRUCT>
<NAME>GstMpeg4VideoPlaneShortHdr</NAME>
struct _GstMpeg4VideoPlaneShortHdr {
  guint8 temporal_reference;
  guint8 split_screen_indicator;
  guint8 document_camera_indicator;
  guint8 full_picture_freeze_release;
  guint8 source_format;
  guint8 picture_coding_type;
  guint8 vop_quant;
  guint8 pei;
  guint8 psupp;

  /*  Gob layer specific fields */
  guint8 gob_header_empty;
  guint8 gob_number;
  guint8 gob_frame_id;
  guint8 quant_scale;

  /* Computed
   * If all the values are set to 0, then it is reserved
   * Table 6-25 -- Parameters Defined by source_format Field
   */
  guint16 vop_width;
  guint16 vop_height;
  guint16 num_macroblocks_in_gob;
  guint8 num_gobs_in_vop;

  /* The size in bits */
  guint size;
};
</STRUCT>
<STRUCT>
<NAME>GstMpeg4VideoObjectLayer</NAME>
struct _GstMpeg4VideoObjectLayer {
  guint8 random_accessible_vol;
  guint8 video_object_type_indication;

  guint8 is_object_layer_identifier;
  /* if is_object_layer_identifier */
  guint8 verid;
  guint8 priority;

  GstMpeg4AspectRatioInfo aspect_ratio_info;
  guint8 par_width;
  guint8 par_height;

  guint8 control_parameters;
  /* if control_parameters */
  GstMpeg4ChromaFormat chroma_format;
  guint8 low_delay;
  guint8 vbv_parameters;
  /* if vbv_parameters */
  guint16 first_half_bitrate;
  guint16 latter_half_bitrate;
  guint16 first_half_vbv_buffer_size;
  guint16 latter_half_vbv_buffer_size;
  guint16 first_half_vbv_occupancy;
  guint16 latter_half_vbv_occupancy;

  /* Computed values */
  guint32 bit_rate;
  guint32 vbv_buffer_size;

  GstMpeg4VideoObjectLayerShape shape;
  /* if shape == GST_MPEG4_GRAYSCALE && verid =! 1 */
  guint8 shape_extension;

  guint16 vop_time_increment_resolution;
  guint8 vop_time_increment_bits;
  guint8 fixed_vop_rate;
  /* if fixed_vop_rate */
  guint16 fixed_vop_time_increment;

  guint16 width;
  guint16 height;
  guint8 interlaced;
  guint8 obmc_disable;

  GstMpeg4SpriteEnable sprite_enable;
  /* if vol->sprite_enable == SPRITE_GMG or SPRITE_STATIC*/
  /* if vol->sprite_enable != GST_MPEG4_SPRITE_GMG */
  guint16 sprite_width;
  guint16 sprite_height;
  guint16 sprite_left_coordinate;
  guint16 sprite_top_coordinate;

  guint8 no_of_sprite_warping_points;
  guint8 sprite_warping_accuracy;
  guint8 sprite_brightness_change;
  /* if vol->sprite_enable != GST_MPEG4_SPRITE_GMG */
  guint8 low_latency_sprite_enable;

  /* if shape != GST_MPEG4_RECTANGULAR */
  guint8 sadct_disable;

  guint8 not_8_bit;

  /* if no_8_bit */
  guint8 quant_precision;
  guint8 bits_per_pixel;

  /* if shape == GRAYSCALE */
  guint8 no_gray_quant_update;
  guint8 composition_method;
  guint8 linear_composition;

  guint8 quant_type;
  /* if quant_type */
  guint8 load_intra_quant_mat;
  guint8 intra_quant_mat[64];
  guint8 load_non_intra_quant_mat;
  guint8 non_intra_quant_mat[64];

  guint8 quarter_sample;
  guint8 complexity_estimation_disable;
  guint8 resync_marker_disable;
  guint8 data_partitioned;
  guint8 reversible_vlc;
  guint8 newpred_enable;
  guint8 reduced_resolution_vop_enable;
  guint8 scalability;
  guint8 enhancement_type;

  GstMpeg4VideoPlaneShortHdr short_hdr;
};
</STRUCT>
<STRUCT>
<NAME>GstMpeg4SpriteTrajectory</NAME>
struct _GstMpeg4SpriteTrajectory {
  guint16 vop_ref_points[63]; /* Defined as "du" in 6.2.5.4 */
  guint16 sprite_ref_points[63]; /* Defined as "dv" in 6.2.5.4 */
};
</STRUCT>
<STRUCT>
<NAME>GstMpeg4GroupOfVOP</NAME>
struct _GstMpeg4GroupOfVOP {
  guint8 hours;
  guint8 minutes;
  guint8 seconds;

  guint8 closed;
  guint8 broken_link;
};
</STRUCT>
<STRUCT>
<NAME>GstMpeg4VideoObjectPlane</NAME>
struct _GstMpeg4VideoObjectPlane {
  GstMpeg4VideoObjectCodingType coding_type;

  guint8  modulo_time_base;
  guint16 time_increment;

  guint8  coded;
  /* if newpred_enable */
  guint16 id;
  guint8  id_for_prediction_indication;
  guint16 id_for_prediction;

  guint16 width;
  guint16 height;
  guint16 horizontal_mc_spatial_ref;
  guint16 vertical_mc_spatial_ref;

  guint8  rounding_type;
  /*if vol->shape != GST_MPEG4_RECTANGULAR */
  guint8  background_composition;
  guint8  change_conv_ratio_disable;
  guint8  constant_alpha;
  guint8  constant_alpha_value;
  guint8  reduced_resolution;

  guint8  intra_dc_vlc_thr;


  guint8  top_field_first;
  guint8  alternate_vertical_scan_flag;

  guint16 quant;

  guint8  fcode_forward;
  guint8  fcode_backward;

  guint8  shape_coding_type;
  guint8  load_backward_shape;
  guint8  ref_select_code;

  /* Computed macroblock informations */
  guint16 mb_height;
  guint16 mb_width;
  guint mb_num;

  /* The size of the header */
  guint    size;
};
</STRUCT>
<STRUCT>
<NAME>GstMpeg4VideoPacketHdr</NAME>
struct _GstMpeg4VideoPacketHdr {
  guint8  header_extension_code;
  guint16 macroblock_number;
  guint16 quant_scale;
  guint   size;
};
</STRUCT>
<STRUCT>
<NAME>GstMpeg4Packet</NAME>
struct _GstMpeg4Packet
{
  const guint8     *data;
  guint             offset;
  gsize             size;
  guint             marker_size;

  GstMpeg4StartCode type;
};
</STRUCT>
<FUNCTION>
<NAME>gst_h263_parse</NAME>
<RETURNS>GstMpeg4ParseResult  </RETURNS>
GstMpeg4Packet * packet, const guint8 * data, guint offset, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg4_parse</NAME>
<RETURNS>GstMpeg4ParseResult  </RETURNS>
GstMpeg4Packet * packet, gboolean skip_user_data, GstMpeg4VideoObjectPlane *vop, const guint8 * data, guint offset, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg4_parse_video_object_plane</NAME>
<RETURNS>GstMpeg4ParseResult </RETURNS>
GstMpeg4VideoObjectPlane *vop, GstMpeg4SpriteTrajectory *sprite_trajectory, GstMpeg4VideoObjectLayer *vol, const guint8 * data, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg4_parse_group_of_vop</NAME>
<RETURNS>GstMpeg4ParseResult </RETURNS>
GstMpeg4GroupOfVOP *gov, const guint8 * data, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg4_parse_video_object_layer</NAME>
<RETURNS>GstMpeg4ParseResult </RETURNS>
GstMpeg4VideoObjectLayer *vol, GstMpeg4VisualObject *vo, const guint8 * data, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg4_parse_visual_object</NAME>
<RETURNS>GstMpeg4ParseResult </RETURNS>
GstMpeg4VisualObject *vo, GstMpeg4VideoSignalType *signal_type, const guint8 * data, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg4_parse_visual_object_sequence</NAME>
<RETURNS>GstMpeg4ParseResult </RETURNS>
GstMpeg4VisualObjectSequence *vos, const guint8 * data, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg4_parse_video_plane_short_header</NAME>
<RETURNS>GstMpeg4ParseResult </RETURNS>
GstMpeg4VideoPlaneShortHdr * shorthdr, const guint8 * data, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg4_parse_video_packet_header</NAME>
<RETURNS>GstMpeg4ParseResult </RETURNS>
GstMpeg4VideoPacketHdr * videopackethdr, GstMpeg4VideoObjectLayer * vol, GstMpeg4VideoObjectPlane * vop, GstMpeg4SpriteTrajectory * sprite_trajectory, const guint8 * data, gsize size
</FUNCTION>
<MACRO>
<NAME>GST_VP9_FRAME_MARKER</NAME>
#define GST_VP9_FRAME_MARKER 0x02
</MACRO>
<MACRO>
<NAME>GST_VP9_SYNC_CODE</NAME>
#define GST_VP9_SYNC_CODE 0x498342
</MACRO>
<MACRO>
<NAME>GST_VP9_MAX_LOOP_FILTER</NAME>
#define GST_VP9_MAX_LOOP_FILTER    63
</MACRO>
<MACRO>
<NAME>GST_VP9_MAX_PROB</NAME>
#define GST_VP9_MAX_PROB           255
</MACRO>
<MACRO>
<NAME>GST_VP9_REFS_PER_FRAME</NAME>
#define GST_VP9_REFS_PER_FRAME     3
</MACRO>
<MACRO>
<NAME>GST_VP9_REF_FRAMES_LOG2</NAME>
#define GST_VP9_REF_FRAMES_LOG2    3
</MACRO>
<MACRO>
<NAME>GST_VP9_REF_FRAMES</NAME>
#define GST_VP9_REF_FRAMES         (1 << GST_VP9_REF_FRAMES_LOG2)
</MACRO>
<MACRO>
<NAME>GST_VP9_FRAME_CONTEXTS_LOG2</NAME>
#define GST_VP9_FRAME_CONTEXTS_LOG2 2
</MACRO>
<MACRO>
<NAME>GST_VP9_MAX_SHARPNESS</NAME>
#define GST_VP9_MAX_SHARPNESS      7
</MACRO>
<MACRO>
<NAME>GST_VP9_MAX_REF_LF_DELTAS</NAME>
#define GST_VP9_MAX_REF_LF_DELTAS  4
</MACRO>
<MACRO>
<NAME>GST_VP9_MAX_MODE_LF_DELTAS</NAME>
#define GST_VP9_MAX_MODE_LF_DELTAS 2
</MACRO>
<MACRO>
<NAME>GST_VP9_SEGMENT_DELTADATA</NAME>
#define GST_VP9_SEGMENT_DELTADATA  0
</MACRO>
<MACRO>
<NAME>GST_VP9_SEGMENT_ABSDATA</NAME>
#define GST_VP9_SEGMENT_ABSDATA    1
</MACRO>
<MACRO>
<NAME>GST_VP9_MAX_SEGMENTS</NAME>
#define GST_VP9_MAX_SEGMENTS       8
</MACRO>
<MACRO>
<NAME>GST_VP9_SEG_TREE_PROBS</NAME>
#define GST_VP9_SEG_TREE_PROBS     (GST_VP9_MAX_SEGMENTS-1)
</MACRO>
<MACRO>
<NAME>GST_VP9_PREDICTION_PROBS</NAME>
#define GST_VP9_PREDICTION_PROBS   3
</MACRO>
<ENUM>
<NAME>GstVp9ParserResult</NAME>
typedef enum
{
  GST_VP9_PARSER_OK,
  GST_VP9_PARSER_BROKEN_DATA,
  GST_VP9_PARSER_ERROR,
} GstVp9ParserResult;
</ENUM>
<ENUM>
<NAME>GstVP9Profile</NAME>
typedef enum {
  GST_VP9_PROFILE_0,
  GST_VP9_PROFILE_1,
  GST_VP9_PROFILE_2,
  GST_VP9_PROFILE_3,
  GST_VP9_PROFILE_UNDEFINED
} GstVP9Profile;
</ENUM>
<ENUM>
<NAME>GstVp9FrameType</NAME>
typedef enum {
  GST_VP9_KEY_FRAME   = 0,
  GST_VP9_INTER_FRAME = 1
} GstVp9FrameType;
</ENUM>
<ENUM>
<NAME>GstVp9BitDepth</NAME>
typedef enum {
  GST_VP9_BIT_DEPTH_8  = 8,
  GST_VP9_BIT_DEPTH_10 = 10,
  GST_VP9_BIT_DEPTH_12 = 12
} GstVp9BitDepth;
</ENUM>
<ENUM>
<NAME>GstVp9ColorSpace</NAME>
typedef enum {
  GST_VP9_CS_UNKNOWN               = 0,
  GST_VP9_CS_BT_601                = 1,
  GST_VP9_CS_BT_709                = 2,
  GST_VP9_CS_SMPTE_170             = 3,
  GST_VP9_CS_SMPTE_240             = 4,
  GST_VP9_CS_BT_2020               = 5,
  GST_VP9_CS_RESERVED_2            = 6,
  GST_VP9_CS_SRGB                  = 7
} GstVp9ColorSpace;
</ENUM>
<ENUM>
<NAME>GstVp9ColorRange</NAME>
typedef enum {
  GST_VP9_CR_LIMITED,
  GST_VP9_CR_FULL
} GstVp9ColorRange;
</ENUM>
<ENUM>
<NAME>GstVp9InterpolationFilter</NAME>
typedef enum {
  GST_VP9_INTERPOLATION_FILTER_EIGHTTAP        = 0,
  GST_VP9_INTERPOLATION_FILTER_EIGHTTAP_SMOOTH = 1,
  GST_VP9_INTERPOLATION_FILTER_EIGHTTAP_SHARP  = 2,
  GST_VP9_INTERPOLATION_FILTER_BILINEAR        = 3,
  GST_VP9_INTERPOLATION_FILTER_SWITCHABLE      = 4
} GstVp9InterpolationFilter;
</ENUM>
<ENUM>
<NAME>GstVp9RefFrameType</NAME>
typedef enum {
  GST_VP9_REF_FRAME_INTRA  = 0,
  GST_VP9_REF_FRAME_LAST   = 1,
  GST_VP9_REF_FRAME_GOLDEN = 2,
  GST_VP9_REF_FRAME_ALTREF = 3,
  GST_VP9_REF_FRAME_MAX    = 4
} GstVp9RefFrameType;
</ENUM>
<STRUCT>
<NAME>GstVp9QuantIndices</NAME>
struct _GstVp9QuantIndices
{
  guint8 y_ac_qi;
  gint8 y_dc_delta;
  gint8 uv_dc_delta;
  gint8 uv_ac_delta;
};
</STRUCT>
<STRUCT>
<NAME>GstVp9LoopFilter</NAME>
struct _GstVp9LoopFilter {
  gint filter_level;
  gint sharpness_level;

  guint8 mode_ref_delta_enabled;
  guint8 mode_ref_delta_update;
  guint8 update_ref_deltas[GST_VP9_MAX_REF_LF_DELTAS];
  gint8 ref_deltas[GST_VP9_MAX_REF_LF_DELTAS];
  guint8 update_mode_deltas[GST_VP9_MAX_MODE_LF_DELTAS];
  gint8 mode_deltas[GST_VP9_MAX_MODE_LF_DELTAS];
};
</STRUCT>
<STRUCT>
<NAME>GstVp9SegmentationInfoData</NAME>
struct _GstVp9SegmentationInfoData {
  /* SEG_LVL_ALT_Q */
  guint8 alternate_quantizer_enabled;
  gint16 alternate_quantizer;

  /* SEG_LVL_ALT_LF */
  guint8 alternate_loop_filter_enabled;
  gint8 alternate_loop_filter;

  /* SEG_LVL_REF_FRAME */
  guint8 reference_frame_enabled;
  gint reference_frame;

  guint8 reference_skip;
};
</STRUCT>
<STRUCT>
<NAME>GstVp9SegmentationInfo</NAME>
struct _GstVp9SegmentationInfo {
  /* enable in setup_segmentation*/
  guint8  enabled;
  /* update_map in setup_segmentation*/
  guint8 update_map;
  /* tree_probs exist or not*/
  guint8 update_tree_probs[GST_VP9_SEG_TREE_PROBS];
  guint8 tree_probs[GST_VP9_SEG_TREE_PROBS];
  /* pred_probs exist or not*/
  guint8 update_pred_probs[GST_VP9_PREDICTION_PROBS];
  guint8 pred_probs[GST_VP9_PREDICTION_PROBS];

  /* abs_delta in setup_segmentation */
  guint8 abs_delta;
  /* temporal_update in setup_segmentation */
  guint8 temporal_update;

  /* update_data in setup_segmentation*/
  guint8 update_data;
  GstVp9SegmentationInfoData data[GST_VP9_MAX_SEGMENTS];
};
</STRUCT>
<STRUCT>
<NAME>GstVp9FrameHdr</NAME>
struct _GstVp9FrameHdr
{
  guint profile;
  guint8 show_existing_frame;
  gint  frame_to_show;
  guint frame_type;
  guint8 show_frame;
  guint8 error_resilient_mode;
  guint32 width;
  guint32 height;
  guint8 display_size_enabled;
  guint32 display_width;
  guint32 display_height;
  guint frame_context_idx;

  guint8 intra_only;
  gint reset_frame_context;
  gint refresh_frame_flags;

  gint ref_frame_indices[GST_VP9_REFS_PER_FRAME];
  gint ref_frame_sign_bias[GST_VP9_REFS_PER_FRAME];
  gint allow_high_precision_mv;
  guint8 mcomp_filter_type;

  gint refresh_frame_context;
  /* frame_parallel_decoding_mode in vp9 code*/
  gint frame_parallel_decoding_mode;

  GstVp9LoopFilter loopfilter;
  GstVp9QuantIndices quant_indices;
  GstVp9SegmentationInfo segmentation;

  gint log2_tile_rows;
  gint log2_tile_columns;

  guint32 first_partition_size;

  /* calculated values */
  guint lossless_flag;
  guint32 frame_header_length_in_bytes;
};
</STRUCT>
<STRUCT>
<NAME>GstVp9Segmentation</NAME>
struct _GstVp9Segmentation
{
  guint8 filter_level[4][2];
  gint16 luma_ac_quant_scale;
  gint16 luma_dc_quant_scale;
  gint16 chroma_ac_quant_scale;
  gint16 chroma_dc_quant_scale;

  guint8 reference_frame_enabled;
  gint reference_frame;

  guint8 reference_skip;
};
</STRUCT>
<STRUCT>
<NAME>GstVp9Parser</NAME>
struct _GstVp9Parser
{
  /* private stuct for tracking state variables across frames */
  void *priv;

  gint subsampling_x;
  gint subsampling_y;
  guint bit_depth;
  guint color_space;
  guint color_range;

  guint8 mb_segment_tree_probs[GST_VP9_SEG_TREE_PROBS];
  guint8 segment_pred_probs[GST_VP9_PREDICTION_PROBS];
  GstVp9Segmentation segmentation[GST_VP9_MAX_SEGMENTS];
};
</STRUCT>
<FUNCTION>
<NAME>gst_vp9_parser_new</NAME>
<RETURNS>GstVp9Parser  *     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vp9_parser_parse_frame_header</NAME>
<RETURNS>GstVp9ParserResult  </RETURNS>
GstVp9Parser* parser, GstVp9FrameHdr * frame_hdr, const guint8 * data, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_vp9_parser_free</NAME>
<RETURNS>void                </RETURNS>
GstVp9Parser * parser
</FUNCTION>
<MACRO>
<NAME>GST_JPEG_MAX_FRAME_COMPONENTS</NAME>
#define GST_JPEG_MAX_FRAME_COMPONENTS   256
</MACRO>
<MACRO>
<NAME>GST_JPEG_MAX_SCAN_COMPONENTS</NAME>
#define GST_JPEG_MAX_SCAN_COMPONENTS    4
</MACRO>
<MACRO>
<NAME>GST_JPEG_MAX_QUANT_ELEMENTS</NAME>
#define GST_JPEG_MAX_QUANT_ELEMENTS     64
</MACRO>
<ENUM>
<NAME>GstJpegMarker</NAME>
typedef enum {
  GST_JPEG_MARKER_SOF0          = 0xC0,
  GST_JPEG_MARKER_SOF1          = 0xC1,
  GST_JPEG_MARKER_SOF2          = 0xC2,
  GST_JPEG_MARKER_SOF3          = 0xC3,
  /* 0xC4 = DHT see below */
  GST_JPEG_MARKER_SOF5          = 0xC5,
  GST_JPEG_MARKER_SOF6          = 0xC6,
  GST_JPEG_MARKER_SOF7          = 0xC7,
  /* 0xC8 = reserved */
  GST_JPEG_MARKER_SOF9          = 0xC9,
  GST_JPEG_MARKER_SOF10         = 0xCA,
  GST_JPEG_MARKER_SOF11         = 0xCB,
  /* 0xCC = DAC see below */
  GST_JPEG_MARKER_SOF13         = 0xCD,
  GST_JPEG_MARKER_SOF14         = 0xCE,
  GST_JPEG_MARKER_SOF15         = 0xCF,
  GST_JPEG_MARKER_DHT           = 0xC4,
  GST_JPEG_MARKER_DAC           = 0xCC,
  GST_JPEG_MARKER_RST0          = 0xD0,
  GST_JPEG_MARKER_RST1          = 0xD1,
  GST_JPEG_MARKER_RST2          = 0xD2,
  GST_JPEG_MARKER_RST3          = 0xD3,
  GST_JPEG_MARKER_RST4          = 0xD4,
  GST_JPEG_MARKER_RST5          = 0xD5,
  GST_JPEG_MARKER_RST6          = 0xD6,
  GST_JPEG_MARKER_RST7          = 0xD7,
  GST_JPEG_MARKER_SOI           = 0xD8,
  GST_JPEG_MARKER_EOI           = 0xD9,
  GST_JPEG_MARKER_SOS           = 0xDA,
  GST_JPEG_MARKER_DQT           = 0xDB,
  GST_JPEG_MARKER_DNL           = 0xDC,
  GST_JPEG_MARKER_DRI           = 0xDD,
  GST_JPEG_MARKER_APP0          = 0xE0,
  GST_JPEG_MARKER_APP1          = 0xE1,
  GST_JPEG_MARKER_APP2          = 0xE2,
  GST_JPEG_MARKER_APP3          = 0xE3,
  GST_JPEG_MARKER_APP4          = 0xE4,
  GST_JPEG_MARKER_APP5          = 0xE5,
  GST_JPEG_MARKER_APP6          = 0xE6,
  GST_JPEG_MARKER_APP7          = 0xE7,
  GST_JPEG_MARKER_APP8          = 0xE8,
  GST_JPEG_MARKER_APP9          = 0xE9,
  GST_JPEG_MARKER_APP10         = 0xEA,
  GST_JPEG_MARKER_APP11         = 0xEB,
  GST_JPEG_MARKER_APP12         = 0xEC,
  GST_JPEG_MARKER_APP13         = 0xED,
  GST_JPEG_MARKER_APP14         = 0xEE,
  GST_JPEG_MARKER_APP15         = 0xEF,
  GST_JPEG_MARKER_COM           = 0xFE,
} GstJpegMarker;
</ENUM>
<MACRO>
<NAME>GST_JPEG_MARKER_SOF_MIN</NAME>
#define GST_JPEG_MARKER_SOF_MIN GST_JPEG_MARKER_SOF0
</MACRO>
<MACRO>
<NAME>GST_JPEG_MARKER_SOF_MAX</NAME>
#define GST_JPEG_MARKER_SOF_MAX GST_JPEG_MARKER_SOF15
</MACRO>
<MACRO>
<NAME>GST_JPEG_MARKER_APP_MIN</NAME>
#define GST_JPEG_MARKER_APP_MIN GST_JPEG_MARKER_APP0
</MACRO>
<MACRO>
<NAME>GST_JPEG_MARKER_APP_MAX</NAME>
#define GST_JPEG_MARKER_APP_MAX GST_JPEG_MARKER_APP15
</MACRO>
<MACRO>
<NAME>GST_JPEG_MARKER_RST_MIN</NAME>
#define GST_JPEG_MARKER_RST_MIN GST_JPEG_MARKER_RST0
</MACRO>
<MACRO>
<NAME>GST_JPEG_MARKER_RST_MAX</NAME>
#define GST_JPEG_MARKER_RST_MAX GST_JPEG_MARKER_RST7
</MACRO>
<ENUM>
<NAME>GstJpegProfile</NAME>
typedef enum {
  GST_JPEG_PROFILE_BASELINE     = 0x00,
  GST_JPEG_PROFILE_EXTENDED     = 0x01,
  GST_JPEG_PROFILE_PROGRESSIVE  = 0x02,
  GST_JPEG_PROFILE_LOSSLESS     = 0x03,
} GstJpegProfile;
</ENUM>
<ENUM>
<NAME>GstJpegEntropyCodingMode</NAME>
typedef enum {
  GST_JPEG_ENTROPY_CODING_HUFFMAN       = 0x00,
  GST_JPEG_ENTROPY_CODING_ARITHMETIC    = 0x08
} GstJpegEntropyCodingMode;
</ENUM>
<STRUCT>
<NAME>GstJpegQuantTable</NAME>
struct _GstJpegQuantTable
{
  guint8 quant_precision;
  guint16 quant_table[GST_JPEG_MAX_QUANT_ELEMENTS];
  gboolean valid;
};
</STRUCT>
<STRUCT>
<NAME>GstJpegQuantTables</NAME>
struct _GstJpegQuantTables
{
  GstJpegQuantTable quant_tables[GST_JPEG_MAX_SCAN_COMPONENTS];
};
</STRUCT>
<STRUCT>
<NAME>GstJpegHuffmanTable</NAME>
struct _GstJpegHuffmanTable
{
  guint8 huf_bits[16];
  guint8 huf_values[256];
  gboolean valid;
};
</STRUCT>
<STRUCT>
<NAME>GstJpegHuffmanTables</NAME>
struct _GstJpegHuffmanTables
{
  GstJpegHuffmanTable dc_tables[GST_JPEG_MAX_SCAN_COMPONENTS];
  GstJpegHuffmanTable ac_tables[GST_JPEG_MAX_SCAN_COMPONENTS];
};
</STRUCT>
<STRUCT>
<NAME>GstJpegScanComponent</NAME>
struct _GstJpegScanComponent
{
    guint8 component_selector;          /* 0 .. 255     */
    guint8 dc_selector;                 /* 0 .. 3       */
    guint8 ac_selector;                 /* 0 .. 3       */
};
</STRUCT>
<STRUCT>
<NAME>GstJpegScanHdr</NAME>
struct _GstJpegScanHdr
{
  guint8 num_components;                /* 1 .. 4       */
  GstJpegScanComponent components[GST_JPEG_MAX_SCAN_COMPONENTS];

  /*< private >*/
  guint8 _reserved1; /* Ss */
  guint8 _reserved2; /* Se */
  guint8 _reserved3; /* Al */
  guint8 _reserved4; /* Ah */
};
</STRUCT>
<STRUCT>
<NAME>GstJpegFrameComponent</NAME>
struct _GstJpegFrameComponent
{
  guint8 identifier;                    /* 0 .. 255     */
  guint8 horizontal_factor;             /* 1 .. 4       */
  guint8 vertical_factor;               /* 1 .. 4       */
  guint8 quant_table_selector;          /* 0 .. 3       */
};
</STRUCT>
<STRUCT>
<NAME>GstJpegFrameHdr</NAME>
struct _GstJpegFrameHdr
{
  guint8 sample_precision;              /* 2 .. 16      */
  guint16 width;                        /* 1 .. 65535   */
  guint16 height;                       /* 0 .. 65535   */
  guint8 num_components;                /* 1 .. 255     */
  GstJpegFrameComponent components[GST_JPEG_MAX_FRAME_COMPONENTS];
};
</STRUCT>
<STRUCT>
<NAME>GstJpegSegment</NAME>
struct _GstJpegSegment
{
  GstJpegMarker marker;
  const guint8 *data;
  guint offset;
  gssize size;
};
</STRUCT>
<FUNCTION>
<NAME>gst_jpeg_parse</NAME>
<RETURNS>gboolean   </RETURNS>
GstJpegSegment * seg, const guint8   * data, gsize            size, guint            offset
</FUNCTION>
<FUNCTION>
<NAME>gst_jpeg_segment_parse_frame_header</NAME>
<RETURNS>gboolean   </RETURNS>
const GstJpegSegment  * segment, GstJpegFrameHdr       * frame_hdr
</FUNCTION>
<FUNCTION>
<NAME>gst_jpeg_segment_parse_scan_header</NAME>
<RETURNS>gboolean   </RETURNS>
const GstJpegSegment * segment, GstJpegScanHdr       * scan_hdr
</FUNCTION>
<FUNCTION>
<NAME>gst_jpeg_segment_parse_huffman_table</NAME>
<RETURNS>gboolean   </RETURNS>
const GstJpegSegment * segment, GstJpegHuffmanTables * huff_tables
</FUNCTION>
<FUNCTION>
<NAME>gst_jpeg_segment_parse_restart_interval</NAME>
<RETURNS>gboolean   </RETURNS>
const GstJpegSegment * segment, guint                * interval
</FUNCTION>
<FUNCTION>
<NAME>gst_jpeg_segment_parse_quantization_table</NAME>
<RETURNS>gboolean   </RETURNS>
const GstJpegSegment * segment, GstJpegQuantTables   * quant_tables
</FUNCTION>
<FUNCTION>
<NAME>gst_jpeg_get_default_quantization_tables</NAME>
<RETURNS>void       </RETURNS>
GstJpegQuantTables * quant_tables
</FUNCTION>
<FUNCTION>
<NAME>gst_jpeg_get_default_huffman_tables</NAME>
<RETURNS>void       </RETURNS>
GstJpegHuffmanTables * huff_tables
</FUNCTION>
<MACRO>
<NAME>GST_H265_MAX_SUB_LAYERS</NAME>
#define GST_H265_MAX_SUB_LAYERS   8
</MACRO>
<MACRO>
<NAME>GST_H265_MAX_VPS_COUNT</NAME>
#define GST_H265_MAX_VPS_COUNT   16
</MACRO>
<MACRO>
<NAME>GST_H265_MAX_SPS_COUNT</NAME>
#define GST_H265_MAX_SPS_COUNT   16
</MACRO>
<MACRO>
<NAME>GST_H265_MAX_PPS_COUNT</NAME>
#define GST_H265_MAX_PPS_COUNT   64
</MACRO>
<MACRO>
<NAME>GST_H265_IS_B_SLICE</NAME>
#define GST_H265_IS_B_SLICE(slice)  ((slice)->type == GST_H265_B_SLICE)
</MACRO>
<MACRO>
<NAME>GST_H265_IS_P_SLICE</NAME>
#define GST_H265_IS_P_SLICE(slice)  ((slice)->type == GST_H265_P_SLICE)
</MACRO>
<MACRO>
<NAME>GST_H265_IS_I_SLICE</NAME>
#define GST_H265_IS_I_SLICE(slice)  ((slice)->type == GST_H265_I_SLICE)
</MACRO>
<ENUM>
<NAME>GstH265Profile</NAME>
typedef enum {
  GST_H265_PROFILE_MAIN                 = 1,
  GST_H265_PROFILE_MAIN_10              = 2,
  GST_H265_PROFILE_MAIN_STILL_PICTURE   = 3
} GstH265Profile;
</ENUM>
<ENUM>
<NAME>GstH265NalUnitType</NAME>
typedef enum
{
  GST_H265_NAL_SLICE_TRAIL_N    = 0,
  GST_H265_NAL_SLICE_TRAIL_R    = 1,
  GST_H265_NAL_SLICE_TSA_N      = 2,
  GST_H265_NAL_SLICE_TSA_R      = 3,
  GST_H265_NAL_SLICE_STSA_N     = 4,
  GST_H265_NAL_SLICE_STSA_R     = 5,
  GST_H265_NAL_SLICE_RADL_N     = 6,
  GST_H265_NAL_SLICE_RADL_R     = 7,
  GST_H265_NAL_SLICE_RASL_N     = 8,
  GST_H265_NAL_SLICE_RASL_R     = 9,
  GST_H265_NAL_SLICE_BLA_W_LP   = 16,
  GST_H265_NAL_SLICE_BLA_W_RADL = 17,
  GST_H265_NAL_SLICE_BLA_N_LP   = 18,
  GST_H265_NAL_SLICE_IDR_W_RADL = 19,
  GST_H265_NAL_SLICE_IDR_N_LP   = 20,
  GST_H265_NAL_SLICE_CRA_NUT    = 21,
  GST_H265_NAL_VPS              = 32,
  GST_H265_NAL_SPS              = 33,
  GST_H265_NAL_PPS              = 34,
  GST_H265_NAL_AUD              = 35,
  GST_H265_NAL_EOS              = 36,
  GST_H265_NAL_EOB              = 37,
  GST_H265_NAL_FD               = 38,
  GST_H265_NAL_PREFIX_SEI       = 39,
  GST_H265_NAL_SUFFIX_SEI       = 40
} GstH265NalUnitType;
</ENUM>
<MACRO>
<NAME>RESERVED_NON_IRAP_SUBLAYER_NAL_TYPE_MIN</NAME>
#define RESERVED_NON_IRAP_SUBLAYER_NAL_TYPE_MIN 10
</MACRO>
<MACRO>
<NAME>RESERVED_NON_IRAP_SUBLAYER_NAL_TYPE_MAX</NAME>
#define RESERVED_NON_IRAP_SUBLAYER_NAL_TYPE_MAX 15
</MACRO>
<MACRO>
<NAME>RESERVED_IRAP_NAL_TYPE_MIN</NAME>
#define RESERVED_IRAP_NAL_TYPE_MIN 22
</MACRO>
<MACRO>
<NAME>RESERVED_IRAP_NAL_TYPE_MAX</NAME>
#define RESERVED_IRAP_NAL_TYPE_MAX 23
</MACRO>
<MACRO>
<NAME>RESERVED_NON_IRAP_NAL_TYPE_MIN</NAME>
#define RESERVED_NON_IRAP_NAL_TYPE_MIN 24
</MACRO>
<MACRO>
<NAME>RESERVED_NON_IRAP_NAL_TYPE_MAX</NAME>
#define RESERVED_NON_IRAP_NAL_TYPE_MAX 31
</MACRO>
<MACRO>
<NAME>RESERVED_NON_VCL_NAL_TYPE_MIN</NAME>
#define RESERVED_NON_VCL_NAL_TYPE_MIN 41
</MACRO>
<MACRO>
<NAME>RESERVED_NON_VCL_NAL_TYPE_MAX</NAME>
#define RESERVED_NON_VCL_NAL_TYPE_MAX 47
</MACRO>
<MACRO>
<NAME>UNSPECIFIED_NON_VCL_NAL_TYPE_MIN</NAME>
#define UNSPECIFIED_NON_VCL_NAL_TYPE_MIN 48
</MACRO>
<MACRO>
<NAME>UNSPECIFIED_NON_VCL_NAL_TYPE_MAX</NAME>
#define UNSPECIFIED_NON_VCL_NAL_TYPE_MAX 63
</MACRO>
<ENUM>
<NAME>GstH265ParserResult</NAME>
typedef enum
{
  GST_H265_PARSER_OK,
  GST_H265_PARSER_BROKEN_DATA,
  GST_H265_PARSER_BROKEN_LINK,
  GST_H265_PARSER_ERROR,
  GST_H265_PARSER_NO_NAL,
  GST_H265_PARSER_NO_NAL_END
} GstH265ParserResult;
</ENUM>
<ENUM>
<NAME>GstH265SEIPayloadType</NAME>
typedef enum
{
  GST_H265_SEI_BUF_PERIOD = 0,
  GST_H265_SEI_PIC_TIMING = 1
      /* and more...  */
} GstH265SEIPayloadType;
</ENUM>
<ENUM>
<NAME>GstH265SEIPicStructType</NAME>
typedef enum
{
  GST_H265_SEI_PIC_STRUCT_FRAME                         = 0,
  GST_H265_SEI_PIC_STRUCT_TOP_FIELD                     = 1,
  GST_H265_SEI_PIC_STRUCT_BOTTOM_FIELD                  = 2,
  GST_H265_SEI_PIC_STRUCT_TOP_BOTTOM                    = 3,
  GST_H265_SEI_PIC_STRUCT_BOTTOM_TOP                    = 4,
  GST_H265_SEI_PIC_STRUCT_TOP_BOTTOM_TOP                = 5,
  GST_H265_SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM             = 6,
  GST_H265_SEI_PIC_STRUCT_FRAME_DOUBLING                = 7,
  GST_H265_SEI_PIC_STRUCT_FRAME_TRIPLING                = 8,
  GST_H265_SEI_PIC_STRUCT_TOP_PAIRED_PREVIOUS_BOTTOM    = 9,
  GST_H265_SEI_PIC_STRUCT_BOTTOM_PAIRED_PREVIOUS_TOP    = 10,
  GST_H265_SEI_PIC_STRUCT_TOP_PAIRED_NEXT_BOTTOM        = 11,
  GST_H265_SEI_PIC_STRUCT_BOTTOM_PAIRED_NEXT_TOP        = 12
} GstH265SEIPicStructType;
</ENUM>
<ENUM>
<NAME>GstH265SliceType</NAME>
typedef enum
{
  GST_H265_B_SLICE    = 0,
  GST_H265_P_SLICE    = 1,
  GST_H265_I_SLICE    = 2
} GstH265SliceType;
</ENUM>
<ENUM>
<NAME>GstH265QuantMatrixSize</NAME>
typedef enum
{
  GST_H265_QUANT_MATIX_4X4   = 0,
  GST_H265_QUANT_MATIX_8X8   = 1,
  GST_H265_QUANT_MATIX_16X16 = 2,
  GST_H265_QUANT_MATIX_32X32 = 3
} GstH265QuantMatrixSize;
</ENUM>
<STRUCT>
<NAME>GstH265NalUnit</NAME>
struct _GstH265NalUnit
{
  guint8 type;
  guint8 layer_id;
  guint8 temporal_id_plus1;

  /* calculated values */
  guint size;
  guint offset;
  guint sc_offset;
  gboolean valid;

  guint8 *data;
  guint8 header_bytes;
};
</STRUCT>
<STRUCT>
<NAME>GstH265ProfileTierLevel</NAME>
struct _GstH265ProfileTierLevel {
  guint8 profile_space;
  guint8 tier_flag;
  guint8 profile_idc;

  guint8 profile_compatibility_flag[32];

  guint8 progressive_source_flag;
  guint8 interlaced_source_flag;
  guint8 non_packed_constraint_flag;
  guint8 frame_only_constraint_flag;
  guint8 level_idc;

  guint8 sub_layer_profile_present_flag[6];
  guint8 sub_layer_level_present_flag[6];

  guint8 sub_layer_profile_space[6];
  guint8 sub_layer_tier_flag[6];
  guint8 sub_layer_profile_idc[6];
  guint8 sub_layer_profile_compatibility_flag[6][32];
  guint8 sub_layer_progressive_source_flag[6];
  guint8 sub_layer_interlaced_source_flag[6];
  guint8 sub_layer_non_packed_constraint_flag[6];
  guint8 sub_layer_frame_only_constraint_flag[6];
  guint8 sub_layer_level_idc[6];
};
</STRUCT>
<STRUCT>
<NAME>GstH265SubLayerHRDParams</NAME>
struct _GstH265SubLayerHRDParams
{
  guint32 bit_rate_value_minus1[32];
  guint32 cpb_size_value_minus1[32];

  guint32 cpb_size_du_value_minus1[32];
  guint32 bit_rate_du_value_minus1[32];

  guint8 cbr_flag[32];
};
</STRUCT>
<STRUCT>
<NAME>GstH265HRDParams</NAME>
struct _GstH265HRDParams
{
  guint8 nal_hrd_parameters_present_flag;
  guint8 vcl_hrd_parameters_present_flag;
  guint8 sub_pic_hrd_params_present_flag;

  guint8 tick_divisor_minus2;
  guint8 du_cpb_removal_delay_increment_length_minus1;
  guint8 sub_pic_cpb_params_in_pic_timing_sei_flag;
  guint8 dpb_output_delay_du_length_minus1;

  guint8 bit_rate_scale;
  guint8 cpb_size_scale;
  guint8 cpb_size_du_scale;

  guint8 initial_cpb_removal_delay_length_minus1;
  guint8 au_cpb_removal_delay_length_minus1;
  guint8 dpb_output_delay_length_minus1;

  guint8 fixed_pic_rate_general_flag [7];
  guint8 fixed_pic_rate_within_cvs_flag [7];
  guint16 elemental_duration_in_tc_minus1 [7];
  guint8 low_delay_hrd_flag [7];
  guint8 cpb_cnt_minus1[7];

  GstH265SubLayerHRDParams sublayer_hrd_params[7];
};
</STRUCT>
<STRUCT>
<NAME>GstH265VPS</NAME>
struct _GstH265VPS {
  guint8 id;

  guint8 max_layers_minus1;
  guint8 max_sub_layers_minus1;
  guint8 temporal_id_nesting_flag;

  GstH265ProfileTierLevel profile_tier_level;

  guint8 sub_layer_ordering_info_present_flag;
  guint8 max_dec_pic_buffering_minus1[GST_H265_MAX_SUB_LAYERS];
  guint8 max_num_reorder_pics[GST_H265_MAX_SUB_LAYERS];
  guint32 max_latency_increase_plus1[GST_H265_MAX_SUB_LAYERS];

  guint8 max_layer_id;
  guint16 num_layer_sets_minus1;

  guint8 timing_info_present_flag;
  guint32 num_units_in_tick;
  guint32 time_scale;
  guint8 poc_proportional_to_timing_flag;
  guint32 num_ticks_poc_diff_one_minus1;

  guint16 num_hrd_parameters;
  guint16 hrd_layer_set_idx;
  guint8 cprms_present_flag;

  GstH265HRDParams hrd_params;

  guint8 vps_extension;

  gboolean valid;
};
</STRUCT>
<STRUCT>
<NAME>GstH265ShortTermRefPicSet</NAME>
struct _GstH265ShortTermRefPicSet
{
  guint8 inter_ref_pic_set_prediction_flag;
  guint8 delta_idx_minus1;
  guint8 delta_rps_sign;
  guint16 abs_delta_rps_minus1;

  /* calculated values */
  guint8 NumDeltaPocs;
  guint8 NumNegativePics;
  guint8 NumPositivePics;
  guint8 UsedByCurrPicS0[16];
  guint8 UsedByCurrPicS1[16];
  gint32 DeltaPocS0[16];
  gint32 DeltaPocS1[16];
};
</STRUCT>
<STRUCT>
<NAME>GstH265VUIParams</NAME>
struct _GstH265VUIParams
{
  guint8 aspect_ratio_info_present_flag;
  guint8 aspect_ratio_idc;
  /* if aspect_ratio_idc == 255 */
  guint16 sar_width;
  guint16 sar_height;

  guint8 overscan_info_present_flag;
  /* if overscan_info_present_flag */
  guint8 overscan_appropriate_flag;

  guint8 video_signal_type_present_flag;
  guint8 video_format;
  guint8 video_full_range_flag;
  guint8 colour_description_present_flag;
  guint8 colour_primaries;
  guint8 transfer_characteristics;
  guint8 matrix_coefficients;

  guint8 chroma_loc_info_present_flag;
  guint8 chroma_sample_loc_type_top_field;
  guint8 chroma_sample_loc_type_bottom_field;

  guint8 neutral_chroma_indication_flag;
  guint8 field_seq_flag;
  guint8 frame_field_info_present_flag;
  guint8 default_display_window_flag;
  guint32 def_disp_win_left_offset;
  guint32 def_disp_win_right_offset;
  guint32 def_disp_win_top_offset;
  guint32 def_disp_win_bottom_offset;

  guint8 timing_info_present_flag;
  /* if timing_info_present_flag */
  guint32 num_units_in_tick;
  guint32 time_scale;
  guint8 poc_proportional_to_timing_flag;
  /* if poc_proportional_to_timing_flag */
  guint32 num_ticks_poc_diff_one_minus1;
  guint8 hrd_parameters_present_flag;
  /*if hrd_parameters_present_flat */
  GstH265HRDParams hrd_params;

  guint8 bitstream_restriction_flag;
  /*  if bitstream_restriction_flag */
  guint8 tiles_fixed_structure_flag;
  guint8 motion_vectors_over_pic_boundaries_flag;
  guint8 restricted_ref_pic_lists_flag;
  guint16 min_spatial_segmentation_idc;
  guint8 max_bytes_per_pic_denom;
  guint8 max_bits_per_min_cu_denom;
  guint8 log2_max_mv_length_horizontal;
  guint8 log2_max_mv_length_vertical;

  /* calculated values */
  guint par_n;
  guint par_d;
};
</STRUCT>
<STRUCT>
<NAME>GstH265ScalingList</NAME>
struct _GstH265ScalingList {

  gint16 scaling_list_dc_coef_minus8_16x16[6];
  gint16 scaling_list_dc_coef_minus8_32x32[2];

  guint8 scaling_lists_4x4 [6][16];
  guint8 scaling_lists_8x8 [6][64];
  guint8 scaling_lists_16x16 [6][64];
  guint8 scaling_lists_32x32 [2][64];
};
</STRUCT>
<STRUCT>
<NAME>GstH265SPS</NAME>
struct _GstH265SPS
{
  guint8 id;

  GstH265VPS *vps;

  guint8 max_sub_layers_minus1;
  guint8 temporal_id_nesting_flag;

  GstH265ProfileTierLevel profile_tier_level;

  guint8 chroma_format_idc;
  guint8 separate_colour_plane_flag;
  guint16 pic_width_in_luma_samples;
  guint16 pic_height_in_luma_samples;

  guint8 conformance_window_flag;
  /* if conformance_window_flag */
  guint32 conf_win_left_offset;
  guint32 conf_win_right_offset;
  guint32 conf_win_top_offset;
  guint32 conf_win_bottom_offset;

  guint8 bit_depth_luma_minus8;
  guint8 bit_depth_chroma_minus8;
  guint8 log2_max_pic_order_cnt_lsb_minus4;

  guint8 sub_layer_ordering_info_present_flag;
  guint8 max_dec_pic_buffering_minus1[GST_H265_MAX_SUB_LAYERS];
  guint8 max_num_reorder_pics[GST_H265_MAX_SUB_LAYERS];
  guint8 max_latency_increase_plus1[GST_H265_MAX_SUB_LAYERS];

  guint8 log2_min_luma_coding_block_size_minus3;
  guint8 log2_diff_max_min_luma_coding_block_size;
  guint8 log2_min_transform_block_size_minus2;
  guint8 log2_diff_max_min_transform_block_size;
  guint8 max_transform_hierarchy_depth_inter;
  guint8 max_transform_hierarchy_depth_intra;

  guint8 scaling_list_enabled_flag;
  /* if scaling_list_enabled_flag */
  guint8 scaling_list_data_present_flag;

  GstH265ScalingList scaling_list;

  guint8 amp_enabled_flag;
  guint8 sample_adaptive_offset_enabled_flag;
  guint8 pcm_enabled_flag;
  /* if pcm_enabled_flag */
  guint8 pcm_sample_bit_depth_luma_minus1;
  guint8 pcm_sample_bit_depth_chroma_minus1;
  guint8 log2_min_pcm_luma_coding_block_size_minus3;
  guint8 log2_diff_max_min_pcm_luma_coding_block_size;
  guint8 pcm_loop_filter_disabled_flag;

  guint8 num_short_term_ref_pic_sets;
  GstH265ShortTermRefPicSet short_term_ref_pic_set[65];

  guint8 long_term_ref_pics_present_flag;
  /* if long_term_ref_pics_present_flag */
  guint8 num_long_term_ref_pics_sps;
  guint16 lt_ref_pic_poc_lsb_sps[32];
  guint8 used_by_curr_pic_lt_sps_flag[32];

  guint8 temporal_mvp_enabled_flag;
  guint8 strong_intra_smoothing_enabled_flag;
  guint8 vui_parameters_present_flag;

  /* if vui_parameters_present_flat */
  GstH265VUIParams vui_params;

  guint8 sps_extension_flag;

  /* calculated values */
  guint8 chroma_array_type;
  gint width, height;
  gint crop_rect_width, crop_rect_height;
  gint crop_rect_x, crop_rect_y;
  gint fps_num, fps_den;
  gboolean valid;
};
</STRUCT>
<STRUCT>
<NAME>GstH265PPS</NAME>
struct _GstH265PPS
{
  guint id;

  GstH265SPS *sps;

  guint8 dependent_slice_segments_enabled_flag;
  guint8 output_flag_present_flag;
  guint8 num_extra_slice_header_bits;
  guint8 sign_data_hiding_enabled_flag;
  guint8 cabac_init_present_flag;
  guint8 num_ref_idx_l0_default_active_minus1;
  guint8 num_ref_idx_l1_default_active_minus1;
  gint8 init_qp_minus26;
  guint8 constrained_intra_pred_flag;
  guint8 transform_skip_enabled_flag;
  guint8 cu_qp_delta_enabled_flag;
  /*if cu_qp_delta_enabled_flag */
  guint8 diff_cu_qp_delta_depth;

  gint8 cb_qp_offset;
  gint8 cr_qp_offset;
  guint8 slice_chroma_qp_offsets_present_flag;
  guint8 weighted_pred_flag;
  guint8 weighted_bipred_flag;
  guint8 transquant_bypass_enabled_flag;
  guint8 tiles_enabled_flag;
  guint8 entropy_coding_sync_enabled_flag;

  guint8 num_tile_columns_minus1;
  guint8 num_tile_rows_minus1;
  guint8 uniform_spacing_flag;
  guint32 column_width_minus1[19];
  guint32 row_height_minus1[21];
  guint8 loop_filter_across_tiles_enabled_flag;

  guint8 loop_filter_across_slices_enabled_flag;
  guint8 deblocking_filter_control_present_flag;
  guint8 deblocking_filter_override_enabled_flag;
  guint8 deblocking_filter_disabled_flag;
  gint8 beta_offset_div2;
  gint8 tc_offset_div2;

  guint8 scaling_list_data_present_flag;

  GstH265ScalingList scaling_list;

  guint8 lists_modification_present_flag;
  guint8 log2_parallel_merge_level_minus2;
  guint8 slice_segment_header_extension_present_flag;

  guint8 pps_extension_flag;

  /* calculated values */
  guint32 PicWidthInCtbsY;
  guint32 PicHeightInCtbsY;
  gboolean valid;
};
</STRUCT>
<STRUCT>
<NAME>GstH265RefPicListModification</NAME>
struct _GstH265RefPicListModification
{
  guint8 ref_pic_list_modification_flag_l0;
  guint32 list_entry_l0[15];
  guint8 ref_pic_list_modification_flag_l1;
  guint32 list_entry_l1[15];
};
</STRUCT>
<STRUCT>
<NAME>GstH265PredWeightTable</NAME>
struct _GstH265PredWeightTable
{
  guint8 luma_log2_weight_denom;
  gint8 delta_chroma_log2_weight_denom;

  guint8 luma_weight_l0_flag[15];
  guint8  chroma_weight_l0_flag[15];
  gint8 delta_luma_weight_l0[15];
  gint8 luma_offset_l0[15];
  gint8 delta_chroma_weight_l0 [15][2];
  gint16 delta_chroma_offset_l0 [15][2];

  guint8 luma_weight_l1_flag[15];
  guint8 chroma_weight_l1_flag[15];
  gint8 delta_luma_weight_l1[15];
  gint8 luma_offset_l1[15];
  gint8 delta_chroma_weight_l1[15][2];
  gint16 delta_chroma_offset_l1[15][2];
};
</STRUCT>
<STRUCT>
<NAME>GstH265SliceHdr</NAME>
struct _GstH265SliceHdr
{
  guint8 first_slice_segment_in_pic_flag;
  guint8 no_output_of_prior_pics_flag;

  GstH265PPS *pps;

  guint8 dependent_slice_segment_flag;
  guint32 segment_address;

  guint8 type;

  guint8 pic_output_flag;
  guint8 colour_plane_id;
  guint16 pic_order_cnt_lsb;

  guint8  short_term_ref_pic_set_sps_flag;
  GstH265ShortTermRefPicSet short_term_ref_pic_sets;
  guint8 short_term_ref_pic_set_idx;

  guint8 num_long_term_sps;
  guint8 num_long_term_pics;
  guint8 lt_idx_sps[16];
  guint32 poc_lsb_lt[16];
  guint8 used_by_curr_pic_lt_flag[16];
  guint8 delta_poc_msb_present_flag[16];
  guint32 delta_poc_msb_cycle_lt[16];

  guint8 temporal_mvp_enabled_flag;
  guint8 sao_luma_flag;
  guint8 sao_chroma_flag;
  guint8 num_ref_idx_active_override_flag;
  guint8 num_ref_idx_l0_active_minus1;
  guint8 num_ref_idx_l1_active_minus1;

  GstH265RefPicListModification ref_pic_list_modification;

  guint8 mvd_l1_zero_flag;
  guint8 cabac_init_flag;
  guint8 collocated_from_l0_flag;
  guint8 collocated_ref_idx;

  GstH265PredWeightTable pred_weight_table;

  guint8 five_minus_max_num_merge_cand;

  gint8 qp_delta;
  gint8 cb_qp_offset;
  gint8 cr_qp_offset;

  guint8 deblocking_filter_override_flag;
  guint8 deblocking_filter_disabled_flag;
  gint8 beta_offset_div2;
  gint8 tc_offset_div2;

  guint8 loop_filter_across_slices_enabled_flag;

  guint32 num_entry_point_offsets;
  guint8 offset_len_minus1;
  guint32 *entry_point_offset_minus1;

  /* calculated values */

  gint NumPocTotalCurr;
  /* Size of the slice_header() in bits */
  guint header_size;
  /* Number of emulation prevention bytes (EPB) in this slice_header() */
  guint n_emulation_prevention_bytes;
};
</STRUCT>
<STRUCT>
<NAME>GstH265PicTiming</NAME>
struct _GstH265PicTiming
{
  guint8 pic_struct;
  guint8 source_scan_type;
  guint8 duplicate_flag;

  guint8 au_cpb_removal_delay_minus1;
  guint8 pic_dpb_output_delay;
  guint8 pic_dpb_output_du_delay;
  guint32 num_decoding_units_minus1;
  guint8 du_common_cpb_removal_delay_flag;
  guint8 du_common_cpb_removal_delay_increment_minus1;
  guint32 *num_nalus_in_du_minus1;
  guint8 *du_cpb_removal_delay_increment_minus1;
};
</STRUCT>
<STRUCT>
<NAME>GstH265BufferingPeriod</NAME>
struct _GstH265BufferingPeriod
{
  GstH265SPS *sps;

  guint8 irap_cpb_params_present_flag;
  guint8 cpb_delay_offset;
  guint8 dpb_delay_offset;
  guint8 concatenation_flag;
  guint8 au_cpb_removal_delay_delta_minus1;

  /* seq->vui_parameters->nal_hrd_parameters_present_flag */
  guint8 nal_initial_cpb_removal_delay[32];
  guint8 nal_initial_cpb_removal_offset[32];
  guint8 nal_initial_alt_cpb_removal_delay[32];
  guint8 nal_initial_alt_cpb_removal_offset [32];

  /* seq->vui_parameters->vcl_hrd_parameters_present_flag */
  guint8 vcl_initial_cpb_removal_delay[32];
  guint8 vcl_initial_cpb_removal_offset[32];
  guint8 vcl_initial_alt_cpb_removal_delay[32];
  guint8 vcl_initial_alt_cpb_removal_offset[32];
};
</STRUCT>
<STRUCT>
<NAME>GstH265SEIMessage</NAME>
struct _GstH265SEIMessage
{
  GstH265SEIPayloadType payloadType;

  union {
    GstH265BufferingPeriod buffering_period;
    GstH265PicTiming pic_timing;
    /* ... could implement more */
  } payload;
};
</STRUCT>
<STRUCT>
<NAME>GstH265Parser</NAME>
struct _GstH265Parser
{
  /*< private >*/
  GstH265VPS vps[GST_H265_MAX_VPS_COUNT];
  GstH265SPS sps[GST_H265_MAX_SPS_COUNT];
  GstH265PPS pps[GST_H265_MAX_PPS_COUNT];
  GstH265VPS *last_vps;
  GstH265SPS *last_sps;
  GstH265PPS *last_pps;
};
</STRUCT>
<FUNCTION>
<NAME>gst_h265_parser_new</NAME>
<RETURNS>GstH265Parser  *     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_parser_identify_nalu</NAME>
<RETURNS>GstH265ParserResult  </RETURNS>
GstH265Parser  * parser, const guint8   * data, guint            offset, gsize            size, GstH265NalUnit * nalu
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_parser_identify_nalu_unchecked</NAME>
<RETURNS>GstH265ParserResult  </RETURNS>
GstH265Parser * parser, const guint8   * data, guint            offset, gsize            size, GstH265NalUnit * nalu
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_parser_identify_nalu_hevc</NAME>
<RETURNS>GstH265ParserResult  </RETURNS>
GstH265Parser  * parser, const guint8   * data, guint            offset, gsize            size, guint8           nal_length_size, GstH265NalUnit * nalu
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_parser_parse_nal</NAME>
<RETURNS>GstH265ParserResult  </RETURNS>
GstH265Parser   * parser, GstH265NalUnit  * nalu
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_parser_parse_slice_hdr</NAME>
<RETURNS>GstH265ParserResult  </RETURNS>
GstH265Parser   * parser, GstH265NalUnit  * nalu, GstH265SliceHdr * slice
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_parser_parse_vps</NAME>
<RETURNS>GstH265ParserResult  </RETURNS>
GstH265Parser   * parser, GstH265NalUnit  * nalu, GstH265VPS      * vps
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_parser_parse_sps</NAME>
<RETURNS>GstH265ParserResult  </RETURNS>
GstH265Parser   * parser, GstH265NalUnit  * nalu, GstH265SPS      * sps, gboolean          parse_vui_params
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_parser_parse_pps</NAME>
<RETURNS>GstH265ParserResult  </RETURNS>
GstH265Parser   * parser, GstH265NalUnit  * nalu, GstH265PPS      * pps
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_parser_parse_sei</NAME>
<RETURNS>GstH265ParserResult  </RETURNS>
GstH265Parser   * parser, GstH265NalUnit  * nalu, GArray **messages
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_parser_free</NAME>
<RETURNS>void                 </RETURNS>
GstH265Parser  * parser
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_parse_vps</NAME>
<RETURNS>GstH265ParserResult  </RETURNS>
GstH265NalUnit * nalu, GstH265VPS     * vps
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_parse_sps</NAME>
<RETURNS>GstH265ParserResult  </RETURNS>
GstH265Parser  * parser, GstH265NalUnit * nalu, GstH265SPS     * sps, gboolean         parse_vui_params
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_parse_pps</NAME>
<RETURNS>GstH265ParserResult  </RETURNS>
GstH265Parser  * parser, GstH265NalUnit * nalu, GstH265PPS     * pps
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_slice_hdr_copy</NAME>
<RETURNS>gboolean             </RETURNS>
GstH265SliceHdr       * dst_slice, const GstH265SliceHdr * src_slice
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_slice_hdr_free</NAME>
<RETURNS>void                 </RETURNS>
GstH265SliceHdr * slice_hdr
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_sei_copy</NAME>
<RETURNS>gboolean             </RETURNS>
GstH265SEIMessage       * dest_sei, const GstH265SEIMessage * src_sei
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_sei_free</NAME>
<RETURNS>void                 </RETURNS>
GstH265SEIMessage * sei
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_quant_matrix_4x4_get_zigzag_from_raster</NAME>
<RETURNS>void     </RETURNS>
guint8 out_quant[16], const guint8 quant[16]
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_quant_matrix_4x4_get_raster_from_zigzag</NAME>
<RETURNS>void     </RETURNS>
guint8 out_quant[16], const guint8 quant[16]
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_quant_matrix_8x8_get_zigzag_from_raster</NAME>
<RETURNS>void     </RETURNS>
guint8 out_quant[64], const guint8 quant[64]
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_quant_matrix_8x8_get_raster_from_zigzag</NAME>
<RETURNS>void     </RETURNS>
guint8 out_quant[64], const guint8 quant[64]
</FUNCTION>
<MACRO>
<NAME>gst_h265_quant_matrix_16x16_get_zigzag_from_raster</NAME>
#define gst_h265_quant_matrix_16x16_get_zigzag_from_raster \
        gst_h265_quant_matrix_8x8_get_zigzag_from_raster
</MACRO>
<MACRO>
<NAME>gst_h265_quant_matrix_16x16_get_raster_from_zigzag</NAME>
#define gst_h265_quant_matrix_16x16_get_raster_from_zigzag \
        gst_h265_quant_matrix_8x8_get_raster_from_zigzag
</MACRO>
<MACRO>
<NAME>gst_h265_quant_matrix_32x32_get_zigzag_from_raster</NAME>
#define gst_h265_quant_matrix_32x32_get_zigzag_from_raster \
        gst_h265_quant_matrix_8x8_get_zigzag_from_raster
</MACRO>
<MACRO>
<NAME>gst_h265_quant_matrix_32x32_get_raster_from_zigzag</NAME>
#define gst_h265_quant_matrix_32x32_get_raster_from_zigzag \
        gst_h265_quant_matrix_8x8_get_raster_from_zigzag
</MACRO>
<FUNCTION>
<NAME>gst_h265_quant_matrix_4x4_get_uprightdiagonal_from_raster</NAME>
<RETURNS>void     </RETURNS>
guint8 out_quant[16], const guint8 quant[16]
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_quant_matrix_4x4_get_raster_from_uprightdiagonal</NAME>
<RETURNS>void     </RETURNS>
guint8 out_quant[16], const guint8 quant[16]
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_quant_matrix_8x8_get_uprightdiagonal_from_raster</NAME>
<RETURNS>void     </RETURNS>
guint8 out_quant[64], const guint8 quant[64]
</FUNCTION>
<FUNCTION>
<NAME>gst_h265_quant_matrix_8x8_get_raster_from_uprightdiagonal</NAME>
<RETURNS>void     </RETURNS>
guint8 out_quant[64], const guint8 quant[64]
</FUNCTION>
<MACRO>
<NAME>gst_h265_quant_matrix_16x16_get_uprightdiagonal_from_raster</NAME>
#define gst_h265_quant_matrix_16x16_get_uprightdiagonal_from_raster \
        gst_h265_quant_matrix_8x8_get_uprightdiagonal_from_raster
</MACRO>
<MACRO>
<NAME>gst_h265_quant_matrix_16x16_get_raster_from_uprightdiagonal</NAME>
#define gst_h265_quant_matrix_16x16_get_raster_from_uprightdiagonal\
        gst_h265_quant_matrix_8x8_get_raster_from_uprightdiagonal
</MACRO>
<MACRO>
<NAME>gst_h265_quant_matrix_32x32_get_uprightdiagonal_from_raster</NAME>
#define gst_h265_quant_matrix_32x32_get_uprightdiagonal_from_raster \
        gst_h265_quant_matrix_8x8_get_uprightdiagonal_from_raster
</MACRO>
<MACRO>
<NAME>gst_h265_quant_matrix_32x32_get_raster_from_uprightdiagonal</NAME>
#define gst_h265_quant_matrix_32x32_get_raster_from_uprightdiagonal\
        gst_h265_quant_matrix_8x8_get_raster_from_uprightdiagonal
</MACRO>
<FUNCTION>
<NAME>gst_mpeg_video_meta_api_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_MPEG_VIDEO_META_API_TYPE</NAME>
#define GST_MPEG_VIDEO_META_API_TYPE  (gst_mpeg_video_meta_api_get_type())
</MACRO>
<MACRO>
<NAME>GST_MPEG_VIDEO_META_INFO</NAME>
#define GST_MPEG_VIDEO_META_INFO  (gst_mpeg_video_meta_get_info())
</MACRO>
<FUNCTION>
<NAME>gst_mpeg_video_meta_get_info</NAME>
<RETURNS>const GstMetaInfo  * </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstMpegVideoMeta</NAME>
struct _GstMpegVideoMeta {
  GstMeta            meta;

  GstMpegVideoSequenceHdr        *sequencehdr;
  GstMpegVideoSequenceExt        *sequenceext;
  GstMpegVideoSequenceDisplayExt *sequencedispext;
  GstMpegVideoPictureHdr         *pichdr;
  GstMpegVideoPictureExt         *picext;
  GstMpegVideoQuantMatrixExt     *quantext;

  guint num_slices;
  gsize slice_offset;
};
</STRUCT>
<MACRO>
<NAME>gst_buffer_get_mpeg_video_meta</NAME>
#define gst_buffer_get_mpeg_video_meta(b) ((GstMpegVideoMeta*)gst_buffer_get_meta((b),GST_MPEG_VIDEO_META_API_TYPE))
</MACRO>
<FUNCTION>
<NAME>gst_buffer_add_mpeg_video_meta</NAME>
<RETURNS>GstMpegVideoMeta  *</RETURNS>
GstBuffer * buffer, const GstMpegVideoSequenceHdr *seq_hdr, const GstMpegVideoSequenceExt *seq_ext, const GstMpegVideoSequenceDisplayExt *disp_ext, const GstMpegVideoPictureHdr *pic_hdr, const GstMpegVideoPictureExt *pic_ext, const GstMpegVideoQuantMatrixExt *quant_ext
</FUNCTION>
<STRUCT>
<NAME>GstVp8RangeDecoder</NAME>
struct _GstVp8RangeDecoder {
  const guchar *buf;
  guint buf_size;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING_LARGE];
};
</STRUCT>
<STRUCT>
<NAME>GstVp8RangeDecoderState</NAME>
struct _GstVp8RangeDecoderState {
  guint8 range;
  guint8 value;
  guint8 count;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vp8_range_decoder_init</NAME>
<RETURNS>gboolean </RETURNS>
GstVp8RangeDecoder * rd, const guchar * buf, guint buf_size
</FUNCTION>
<FUNCTION>
<NAME>gst_vp8_range_decoder_read</NAME>
<RETURNS>gint </RETURNS>
GstVp8RangeDecoder * rd, guint8 prob
</FUNCTION>
<FUNCTION>
<NAME>gst_vp8_range_decoder_read_literal</NAME>
<RETURNS>gint </RETURNS>
GstVp8RangeDecoder * rd, gint bits
</FUNCTION>
<FUNCTION>
<NAME>gst_vp8_range_decoder_get_pos</NAME>
<RETURNS>guint </RETURNS>
GstVp8RangeDecoder * rd
</FUNCTION>
<FUNCTION>
<NAME>gst_vp8_range_decoder_get_state</NAME>
<RETURNS>void </RETURNS>
GstVp8RangeDecoder * rd, GstVp8RangeDecoderState * state
</FUNCTION>
<FUNCTION>
<NAME>ceil_log2</NAME>
<RETURNS>guint  </RETURNS>
guint32 v
</FUNCTION>
<FUNCTION>
<NAME>nal_reader_init</NAME>
<RETURNS>void  </RETURNS>
NalReader * nr, const guint8 * data, guint size
</FUNCTION>
<FUNCTION>
<NAME>nal_reader_read</NAME>
<RETURNS>gboolean  </RETURNS>
NalReader * nr, guint nbits
</FUNCTION>
<FUNCTION>
<NAME>nal_reader_skip</NAME>
<RETURNS>gboolean  </RETURNS>
NalReader * nr, guint nbits
</FUNCTION>
<FUNCTION>
<NAME>nal_reader_skip_long</NAME>
<RETURNS>gboolean  </RETURNS>
NalReader * nr, guint nbits
</FUNCTION>
<FUNCTION>
<NAME>nal_reader_get_pos</NAME>
<RETURNS>guint  </RETURNS>
const NalReader * nr
</FUNCTION>
<FUNCTION>
<NAME>nal_reader_get_remaining</NAME>
<RETURNS>guint  </RETURNS>
const NalReader * nr
</FUNCTION>
<FUNCTION>
<NAME>nal_reader_get_epb_count</NAME>
<RETURNS>guint  </RETURNS>
const NalReader * nr
</FUNCTION>
<FUNCTION>
<NAME>nal_reader_is_byte_aligned</NAME>
<RETURNS>gboolean  </RETURNS>
NalReader * nr
</FUNCTION>
<FUNCTION>
<NAME>nal_reader_has_more_data</NAME>
<RETURNS>gboolean  </RETURNS>
NalReader * nr
</FUNCTION>
<MACRO>
<NAME>NAL_READER_READ_BITS_H</NAME>
#define NAL_READER_READ_BITS_H(bits) \
G_GNUC_INTERNAL \
gboolean nal_reader_get_bits_uint##bits (NalReader *nr, guint##bits *val, guint nbits)
</MACRO>
<MACRO>
<NAME>NAL_READER_PEEK_BITS_H</NAME>
#define NAL_READER_PEEK_BITS_H(bits) \
G_GNUC_INTERNAL \
gboolean nal_reader_peek_bits_uint##bits (const NalReader *nr, guint##bits *val, guint nbits)
</MACRO>
<FUNCTION>
<NAME>nal_reader_get_ue</NAME>
<RETURNS>gboolean  </RETURNS>
NalReader * nr, guint32 * val
</FUNCTION>
<FUNCTION>
<NAME>nal_reader_get_se</NAME>
<RETURNS>gboolean  </RETURNS>
NalReader * nr, gint32 * val
</FUNCTION>
<MACRO>
<NAME>CHECK_ALLOWED_MAX</NAME>
#define CHECK_ALLOWED_MAX(val, max) { \
  if (val > max) { \
    GST_WARNING ("value greater than max. value: %d, max %d", \
                     val, max); \
    goto error; \
  } \
}
</MACRO>
<MACRO>
<NAME>CHECK_ALLOWED</NAME>
#define CHECK_ALLOWED(val, min, max) { \
  if (val < min || val > max) { \
    GST_WARNING ("value not in allowed range. value: %d, range %d-%d", \
                     val, min, max); \
    goto error; \
  } \
}
</MACRO>
<MACRO>
<NAME>READ_UINT8</NAME>
#define READ_UINT8(nr, val, nbits) { \
  if (!nal_reader_get_bits_uint8 (nr, &val, nbits)) { \
    GST_WARNING ("failed to read uint8, nbits: %d", nbits); \
    goto error; \
  } \
}
</MACRO>
<MACRO>
<NAME>READ_UINT16</NAME>
#define READ_UINT16(nr, val, nbits) { \
  if (!nal_reader_get_bits_uint16 (nr, &val, nbits)) { \
  GST_WARNING ("failed to read uint16, nbits: %d", nbits); \
    goto error; \
  } \
}
</MACRO>
<MACRO>
<NAME>READ_UINT32</NAME>
#define READ_UINT32(nr, val, nbits) { \
  if (!nal_reader_get_bits_uint32 (nr, &val, nbits)) { \
  GST_WARNING ("failed to read uint32, nbits: %d", nbits); \
    goto error; \
  } \
}
</MACRO>
<MACRO>
<NAME>READ_UINT64</NAME>
#define READ_UINT64(nr, val, nbits) { \
  if (!nal_reader_get_bits_uint64 (nr, &val, nbits)) { \
    GST_WARNING ("failed to read uint32, nbits: %d", nbits); \
    goto error; \
  } \
}
</MACRO>
<MACRO>
<NAME>READ_UE</NAME>
#define READ_UE(nr, val) { \
  if (!nal_reader_get_ue (nr, &val)) { \
    GST_WARNING ("failed to read UE"); \
    goto error; \
  } \
}
</MACRO>
<MACRO>
<NAME>READ_UE_ALLOWED</NAME>
#define READ_UE_ALLOWED(nr, val, min, max) { \
  guint32 tmp; \
  READ_UE (nr, tmp); \
  CHECK_ALLOWED (tmp, min, max); \
  val = tmp; \
}
</MACRO>
<MACRO>
<NAME>READ_UE_MAX</NAME>
#define READ_UE_MAX(nr, val, max) { \
  guint32 tmp; \
  READ_UE (nr, tmp); \
  CHECK_ALLOWED_MAX (tmp, max); \
  val = tmp; \
}
</MACRO>
<MACRO>
<NAME>READ_SE</NAME>
#define READ_SE(nr, val) { \
  if (!nal_reader_get_se (nr, &val)) { \
    GST_WARNING ("failed to read SE"); \
    goto error; \
  } \
}
</MACRO>
<MACRO>
<NAME>READ_SE_ALLOWED</NAME>
#define READ_SE_ALLOWED(nr, val, min, max) { \
  gint32 tmp; \
  READ_SE (nr, tmp); \
  CHECK_ALLOWED (tmp, min, max); \
  val = tmp; \
}
</MACRO>
<FUNCTION>
<NAME>scan_for_start_codes</NAME>
<RETURNS>gint  </RETURNS>
const guint8 * data, guint size
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_BASE_CAMERA_SRC</NAME>
#define GST_TYPE_BASE_CAMERA_SRC \
  (gst_base_camera_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_BASE_CAMERA_SRC</NAME>
#define GST_BASE_CAMERA_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BASE_CAMERA_SRC,GstBaseCameraSrc))
</MACRO>
<MACRO>
<NAME>GST_BASE_CAMERA_SRC_GET_CLASS</NAME>
#define GST_BASE_CAMERA_SRC_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_BASE_CAMERA_SRC, GstBaseCameraSrcClass))
</MACRO>
<MACRO>
<NAME>GST_BASE_CAMERA_SRC_CLASS</NAME>
#define GST_BASE_CAMERA_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BASE_CAMERA_SRC,GstBaseCameraSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_BASE_CAMERA_SRC</NAME>
#define GST_IS_BASE_CAMERA_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BASE_CAMERA_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_BASE_CAMERA_SRC_CLASS</NAME>
#define GST_IS_BASE_CAMERA_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BASE_CAMERA_SRC))
</MACRO>
<MACRO>
<NAME>GST_BASE_CAMERA_SRC_CAST</NAME>
#define GST_BASE_CAMERA_SRC_CAST(obj) \
  ((GstBaseCameraSrc *) (obj))
</MACRO>
<FUNCTION>
<NAME>gst_base_camera_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_BASE_CAMERA_SRC_VIEWFINDER_PAD_NAME</NAME>
#define GST_BASE_CAMERA_SRC_VIEWFINDER_PAD_NAME "vfsrc"
</MACRO>
<MACRO>
<NAME>GST_BASE_CAMERA_SRC_IMAGE_PAD_NAME</NAME>
#define GST_BASE_CAMERA_SRC_IMAGE_PAD_NAME "imgsrc"
</MACRO>
<MACRO>
<NAME>GST_BASE_CAMERA_SRC_VIDEO_PAD_NAME</NAME>
#define GST_BASE_CAMERA_SRC_VIDEO_PAD_NAME "vidsrc"
</MACRO>
<MACRO>
<NAME>GST_BASE_CAMERA_SRC_PREVIEW_MESSAGE_NAME</NAME>
#define GST_BASE_CAMERA_SRC_PREVIEW_MESSAGE_NAME "preview-image"
</MACRO>
<STRUCT>
<NAME>GstBaseCameraSrc</NAME>
struct _GstBaseCameraSrc
{
  GstBin parent;

  GstCameraBinMode mode;

  gboolean auto_start;
  gboolean capturing;
  GMutex capturing_mutex;

  /* Preview convert pipeline */
  GstCaps *preview_caps;
  gboolean post_preview;
  GstElement *preview_filter;
  GstCameraBinPreviewPipelineData *preview_pipeline;

  /* Resolution of the buffers configured to camerabin */
  gint width;
  gint height;

  gfloat zoom;
  gfloat max_zoom;

  gpointer _gst_reserved[GST_PADDING_LARGE];
};
</STRUCT>
<STRUCT>
<NAME>GstBaseCameraSrcClass</NAME>
struct _GstBaseCameraSrcClass
{
  GstBinClass parent;

  /* Construct pipeline. (called in GST_STATE_CHANGE_NULL_TO_READY) Optional. */
  gboolean    (*construct_pipeline)  (GstBaseCameraSrc *self);

  /* (called in GST_STATE_CHANGE_READY_TO_PAUSED). Optional. */
  gboolean    (*setup_pipeline)      (GstBaseCameraSrc *self);

  /* Set the zoom. If set, called when changing 'zoom' property. Optional. */
  void        (*set_zoom)            (GstBaseCameraSrc *self, gfloat zoom);

  /* Set the mode. If set, called when changing 'mode' property. Optional. */
  gboolean    (*set_mode)            (GstBaseCameraSrc *self,
                                      GstCameraBinMode mode);

  /* Set preview caps. If set, called called when setting new 'preview-caps'. Optional. */
  gboolean    (*set_preview)         (GstBaseCameraSrc *self,
                                      GstCaps *preview_caps);

  /* Called by the handler for 'start-capture'. Mandatory. */
  gboolean (*start_capture) (GstBaseCameraSrc * src);

  /* Called by the handler for 'stop-capture'. Mandatory. */
  void (*stop_capture) (GstBaseCameraSrc * src);

  gpointer _gst_reserved[GST_PADDING_LARGE];
};
</STRUCT>
<MACRO>
<NAME>MIN_ZOOM</NAME>
#define MIN_ZOOM 1.0f
</MACRO>
<MACRO>
<NAME>MAX_ZOOM</NAME>
#define MAX_ZOOM 10.0f
</MACRO>
<MACRO>
<NAME>ZOOM_1X</NAME>
#define ZOOM_1X MIN_ZOOM
</MACRO>
<FUNCTION>
<NAME>gst_base_camera_src_set_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstBaseCameraSrc *self, GstCameraBinMode mode
</FUNCTION>
<FUNCTION>
<NAME>gst_base_camera_src_setup_zoom</NAME>
<RETURNS>void  </RETURNS>
GstBaseCameraSrc * self
</FUNCTION>
<FUNCTION>
<NAME>gst_base_camera_src_setup_preview</NAME>
<RETURNS>void  </RETURNS>
GstBaseCameraSrc * self, GstCaps * preview_caps
</FUNCTION>
<FUNCTION>
<NAME>gst_base_camera_src_finish_capture</NAME>
<RETURNS>void  </RETURNS>
GstBaseCameraSrc *self
</FUNCTION>
<FUNCTION>
<NAME>gst_base_camera_src_post_preview</NAME>
<RETURNS>void  </RETURNS>
GstBaseCameraSrc *self, GstSample * sample
</FUNCTION>
<FUNCTION>
<NAME>gst_camerabin_create_preview_pipeline</NAME>
<RETURNS>GstCameraBinPreviewPipelineData  *</RETURNS>
GstElement * element, GstElement * filter
</FUNCTION>
<FUNCTION>
<NAME>gst_camerabin_destroy_preview_pipeline</NAME>
<RETURNS>void  </RETURNS>
GstCameraBinPreviewPipelineData * preview
</FUNCTION>
<FUNCTION>
<NAME>gst_camerabin_preview_pipeline_post</NAME>
<RETURNS>gboolean  </RETURNS>
GstCameraBinPreviewPipelineData * preview, GstSample * sample
</FUNCTION>
<FUNCTION>
<NAME>gst_camerabin_preview_set_caps</NAME>
<RETURNS>void  </RETURNS>
GstCameraBinPreviewPipelineData * preview, GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>gst_camerabin_preview_set_filter</NAME>
<RETURNS>gboolean  </RETURNS>
GstCameraBinPreviewPipelineData * preview, GstElement * filter
</FUNCTION>
<MACRO>
<NAME>DEFAULT_WIDTH</NAME>
#define DEFAULT_WIDTH 640
</MACRO>
<MACRO>
<NAME>DEFAULT_HEIGHT</NAME>
#define DEFAULT_HEIGHT 480
</MACRO>
<MACRO>
<NAME>DEFAULT_CAPTURE_WIDTH</NAME>
#define DEFAULT_CAPTURE_WIDTH 800
</MACRO>
<MACRO>
<NAME>DEFAULT_CAPTURE_HEIGHT</NAME>
#define DEFAULT_CAPTURE_HEIGHT 600
</MACRO>
<MACRO>
<NAME>DEFAULT_FPS_N</NAME>
#define DEFAULT_FPS_N 0         /* makes it use the default */
</MACRO>
<MACRO>
<NAME>DEFAULT_FPS_D</NAME>
#define DEFAULT_FPS_D 1
</MACRO>
<MACRO>
<NAME>DEFAULT_ZOOM</NAME>
#define DEFAULT_ZOOM MIN_ZOOM
</MACRO>
<ENUM>
<NAME>GstCameraBinMode</NAME>
typedef enum
{
  /* MODE_PREVIEW = 0, No use for this */
  MODE_IMAGE = 1,
  MODE_VIDEO = 2,
} GstCameraBinMode;
</ENUM>
<MACRO>
<NAME>GST_TYPE_CAMERABIN_MODE</NAME>
#define GST_TYPE_CAMERABIN_MODE (gst_camerabin_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gst_camerabin_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FRAGMENT</NAME>
#define GST_TYPE_FRAGMENT (gst_fragment_get_type())
</MACRO>
<MACRO>
<NAME>GST_FRAGMENT</NAME>
#define GST_FRAGMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FRAGMENT,GstFragment))
</MACRO>
<MACRO>
<NAME>GST_FRAGMENT_CLASS</NAME>
#define GST_FRAGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FRAGMENT,GstFragmentClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FRAGMENT</NAME>
#define GST_IS_FRAGMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FRAGMENT))
</MACRO>
<MACRO>
<NAME>GST_IS_FRAGMENT_CLASS</NAME>
#define GST_IS_FRAGMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FRAGMENT))
</MACRO>
<STRUCT>
<NAME>GstFragment</NAME>
struct _GstFragment
{
  GObject parent;

  gchar * uri;                  /* URI of the fragment */
  gchar * redirect_uri;         /* Redirect target if any */
  gboolean redirect_permanent;  /* If the redirect is permanent */
  gint64 range_start;
  gint64 range_end;

  gchar * name;                 /* Name of the fragment */
  gboolean completed;           /* Whether the fragment is complete or not */
  guint64 download_start_time;  /* Epoch time when the download started */
  guint64 download_stop_time;   /* Epoch time when the download finished */
  guint64 start_time;           /* Start time of the fragment */
  guint64 stop_time;            /* Stop time of the fragment */
  gboolean index;               /* Index of the fragment */
  gboolean discontinuous;       /* Whether this fragment is discontinuous or not */
  GstStructure *headers;        /* HTTP request/response headers */

  GstFragmentPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstFragmentClass</NAME>
struct _GstFragmentClass
{
  GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_fragment_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_fragment_get_buffer</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstFragment *fragment
</FUNCTION>
<FUNCTION>
<NAME>gst_fragment_set_caps</NAME>
<RETURNS>void  </RETURNS>
GstFragment * fragment, GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>gst_fragment_get_caps</NAME>
<RETURNS>GstCaps  * </RETURNS>
GstFragment * fragment
</FUNCTION>
<FUNCTION>
<NAME>gst_fragment_add_buffer</NAME>
<RETURNS>gboolean  </RETURNS>
GstFragment *fragment, GstBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_fragment_new</NAME>
<RETURNS>GstFragment  * </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstFragmentPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_URI_DOWNLOADER</NAME>
#define GST_TYPE_URI_DOWNLOADER (gst_uri_downloader_get_type())
</MACRO>
<MACRO>
<NAME>GST_URI_DOWNLOADER</NAME>
#define GST_URI_DOWNLOADER(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_URI_DOWNLOADER,GstUriDownloader))
</MACRO>
<MACRO>
<NAME>GST_URI_DOWNLOADER_CLASS</NAME>
#define GST_URI_DOWNLOADER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_URI_DOWNLOADER,GstUriDownloaderClass))
</MACRO>
<MACRO>
<NAME>GST_IS_URI_DOWNLOADER</NAME>
#define GST_IS_URI_DOWNLOADER(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_URI_DOWNLOADER))
</MACRO>
<MACRO>
<NAME>GST_IS_URI_DOWNLOADER_CLASS</NAME>
#define GST_IS_URI_DOWNLOADER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_URI_DOWNLOADER))
</MACRO>
<STRUCT>
<NAME>GstUriDownloader</NAME>
struct _GstUriDownloader
{
  GstObject parent;

  GstUriDownloaderPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstUriDownloaderClass</NAME>
struct _GstUriDownloaderClass
{
  GstObjectClass parent_class;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_uri_downloader_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_downloader_new</NAME>
<RETURNS>GstUriDownloader  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_downloader_set_parent</NAME>
<RETURNS>void  </RETURNS>
GstUriDownloader * downloader, GstElement * parent
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_downloader_fetch_uri</NAME>
<RETURNS>GstFragment  * </RETURNS>
GstUriDownloader * downloader, const gchar * uri, const gchar * referer, gboolean compress, gboolean refresh, gboolean allow_cache, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_downloader_fetch_uri_with_range</NAME>
<RETURNS>GstFragment  * </RETURNS>
GstUriDownloader * downloader, const gchar * uri, const gchar * referer, gboolean compress, gboolean refresh, gboolean allow_cache, gint64 range_start, gint64 range_end, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_downloader_reset</NAME>
<RETURNS>void  </RETURNS>
GstUriDownloader *downloader
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_downloader_cancel</NAME>
<RETURNS>void  </RETURNS>
GstUriDownloader *downloader
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_downloader_free</NAME>
<RETURNS>void  </RETURNS>
GstUriDownloader *downloader
</FUNCTION>
<STRUCT>
<NAME>GstUriDownloaderPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstPlayerVisualization</NAME>
struct _GstPlayerVisualization {
  gchar *name;
  gchar *description;
};
</STRUCT>
<FUNCTION>
<NAME>gst_player_visualization_get_type</NAME>
<RETURNS>GType                      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_player_visualization_copy</NAME>
<RETURNS>GstPlayerVisualization  *  </RETURNS>
const GstPlayerVisualization *vis
</FUNCTION>
<FUNCTION>
<NAME>gst_player_visualization_free</NAME>
<RETURNS>void                       </RETURNS>
GstPlayerVisualization *vis
</FUNCTION>
<FUNCTION>
<NAME>gst_player_visualizations_get</NAME>
<RETURNS>GstPlayerVisualization  ** </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_player_visualizations_free</NAME>
<RETURNS>void                       </RETURNS>
GstPlayerVisualization **viss
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER</NAME>
#define GST_TYPE_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER             (gst_player_video_overlay_video_renderer_get_type ())
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER</NAME>
#define GST_IS_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER_CLASS</NAME>
#define GST_IS_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER_GET_CLASS</NAME>
#define GST_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER, GstPlayerVideoOverlayVideoRendererClass))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER</NAME>
#define GST_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER, GstPlayerVideoOverlayVideoRenderer))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER_CLASS</NAME>
#define GST_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER, GstPlayerVideoOverlayVideoRendererClass))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER_CAST</NAME>
#define GST_PLAYER_VIDEO_OVERLAY_VIDEO_RENDERER_CAST(obj)        ((GstPlayerVideoOverlayVideoRenderer*)(obj))
</MACRO>
<FUNCTION>
<NAME>gst_player_video_overlay_video_renderer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_player_video_overlay_video_renderer_new</NAME>
<RETURNS>GstPlayerVideoRenderer  * </RETURNS>
gpointer window_handle
</FUNCTION>
<FUNCTION>
<NAME>gst_player_video_overlay_video_renderer_new_with_sink</NAME>
<RETURNS>GstPlayerVideoRenderer  * </RETURNS>
gpointer window_handle, GstElement * video_sink
</FUNCTION>
<FUNCTION>
<NAME>gst_player_video_overlay_video_renderer_set_window_handle</NAME>
<RETURNS>void  </RETURNS>
GstPlayerVideoOverlayVideoRenderer * self, gpointer window_handle
</FUNCTION>
<FUNCTION>
<NAME>gst_player_video_overlay_video_renderer_get_window_handle</NAME>
<RETURNS>gpointer  </RETURNS>
GstPlayerVideoOverlayVideoRenderer * self
</FUNCTION>
<FUNCTION>
<NAME>gst_player_video_overlay_video_renderer_expose</NAME>
<RETURNS>void  </RETURNS>
GstPlayerVideoOverlayVideoRenderer * self
</FUNCTION>
<FUNCTION>
<NAME>gst_player_video_overlay_video_renderer_set_render_rectangle</NAME>
<RETURNS>void  </RETURNS>
GstPlayerVideoOverlayVideoRenderer * self, gint x, gint y, gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>gst_player_video_overlay_video_renderer_get_render_rectangle</NAME>
<RETURNS>void  </RETURNS>
GstPlayerVideoOverlayVideoRenderer * self, gint *x, gint *y, gint *width, gint *height
</FUNCTION>
<STRUCT>
<NAME>GstPlayer</NAME>
</STRUCT>
<STRUCT>
<NAME>GstPlayerClass</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_PLAYER_SIGNAL_DISPATCHER</NAME>
#define GST_TYPE_PLAYER_SIGNAL_DISPATCHER                (gst_player_signal_dispatcher_get_type ())
</MACRO>
<MACRO>
<NAME>GST_PLAYER_SIGNAL_DISPATCHER</NAME>
#define GST_PLAYER_SIGNAL_DISPATCHER(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PLAYER_SIGNAL_DISPATCHER, GstPlayerSignalDispatcher))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_SIGNAL_DISPATCHER</NAME>
#define GST_IS_PLAYER_SIGNAL_DISPATCHER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PLAYER_SIGNAL_DISPATCHER))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_SIGNAL_DISPATCHER_GET_INTERFACE</NAME>
#define GST_PLAYER_SIGNAL_DISPATCHER_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), GST_TYPE_PLAYER_SIGNAL_DISPATCHER, GstPlayerSignalDispatcherInterface))
</MACRO>
<USER_FUNCTION>
<NAME>GstPlayerSignalDispatcherFunc</NAME>
<RETURNS>void </RETURNS>
gpointer data
</USER_FUNCTION>
<STRUCT>
<NAME>GstPlayerSignalDispatcherInterface</NAME>
struct _GstPlayerSignalDispatcherInterface {
  GTypeInterface parent_iface;

  void (*dispatch) (GstPlayerSignalDispatcher * self,
                    GstPlayer * player,
                    GstPlayerSignalDispatcherFunc emitter,
                    gpointer data,
                    GDestroyNotify destroy);
};
</STRUCT>
<FUNCTION>
<NAME>gst_player_signal_dispatcher_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstPlayerSignalDispatcher</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_PLAYER_STREAM_INFO</NAME>
#define GST_TYPE_PLAYER_STREAM_INFO \
  (gst_player_stream_info_get_type ())
</MACRO>
<MACRO>
<NAME>GST_PLAYER_STREAM_INFO</NAME>
#define GST_PLAYER_STREAM_INFO(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PLAYER_STREAM_INFO,GstPlayerStreamInfo))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_STREAM_INFO_CLASS</NAME>
#define GST_PLAYER_STREAM_INFO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PLAYER_STREAM_INFO,GstPlayerStreamInfo))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_STREAM_INFO</NAME>
#define GST_IS_PLAYER_STREAM_INFO(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PLAYER_STREAM_INFO))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_STREAM_INFO_CLASS</NAME>
#define GST_IS_PLAYER_STREAM_INFO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PLAYER_STREAM_INFO))
</MACRO>
<FUNCTION>
<NAME>gst_player_stream_info_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_player_stream_info_get_index</NAME>
<RETURNS>gint  </RETURNS>
const GstPlayerStreamInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_stream_info_get_stream_type</NAME>
<RETURNS>const gchar *</RETURNS>
const GstPlayerStreamInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_stream_info_get_tags</NAME>
<RETURNS>GstTagList *</RETURNS>
const GstPlayerStreamInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_stream_info_get_caps</NAME>
<RETURNS>GstCaps *</RETURNS>
const GstPlayerStreamInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_stream_info_get_codec</NAME>
<RETURNS>const gchar *</RETURNS>
const GstPlayerStreamInfo *info
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PLAYER_VIDEO_INFO</NAME>
#define GST_TYPE_PLAYER_VIDEO_INFO \
  (gst_player_video_info_get_type ())
</MACRO>
<MACRO>
<NAME>GST_PLAYER_VIDEO_INFO</NAME>
#define GST_PLAYER_VIDEO_INFO(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PLAYER_VIDEO_INFO, GstPlayerVideoInfo))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_VIDEO_INFO_CLASS</NAME>
#define GST_PLAYER_VIDEO_INFO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((obj),GST_TYPE_PLAYER_VIDEO_INFO, GstPlayerVideoInfoClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_VIDEO_INFO</NAME>
#define GST_IS_PLAYER_VIDEO_INFO(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PLAYER_VIDEO_INFO))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_VIDEO_INFO_CLASS</NAME>
#define GST_IS_PLAYER_VIDEO_INFO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((obj),GST_TYPE_PLAYER_VIDEO_INFO))
</MACRO>
<FUNCTION>
<NAME>gst_player_video_info_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_player_video_info_get_bitrate</NAME>
<RETURNS>gint  </RETURNS>
const GstPlayerVideoInfo* info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_video_info_get_max_bitrate</NAME>
<RETURNS>gint  </RETURNS>
const GstPlayerVideoInfo* info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_video_info_get_width</NAME>
<RETURNS>gint  </RETURNS>
const GstPlayerVideoInfo* info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_video_info_get_height</NAME>
<RETURNS>gint  </RETURNS>
const GstPlayerVideoInfo* info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_video_info_get_framerate</NAME>
<RETURNS>void  </RETURNS>
const GstPlayerVideoInfo* info, gint *fps_n, gint *fps_d
</FUNCTION>
<FUNCTION>
<NAME>gst_player_video_info_get_pixel_aspect_ratio</NAME>
<RETURNS>void  </RETURNS>
const GstPlayerVideoInfo* info, guint *par_n, guint *par_d
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PLAYER_AUDIO_INFO</NAME>
#define GST_TYPE_PLAYER_AUDIO_INFO \
  (gst_player_audio_info_get_type ())
</MACRO>
<MACRO>
<NAME>GST_PLAYER_AUDIO_INFO</NAME>
#define GST_PLAYER_AUDIO_INFO(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PLAYER_AUDIO_INFO, GstPlayerAudioInfo))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_AUDIO_INFO_CLASS</NAME>
#define GST_PLAYER_AUDIO_INFO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PLAYER_AUDIO_INFO, GstPlayerAudioInfoClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_AUDIO_INFO</NAME>
#define GST_IS_PLAYER_AUDIO_INFO(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PLAYER_AUDIO_INFO))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_AUDIO_INFO_CLASS</NAME>
#define GST_IS_PLAYER_AUDIO_INFO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PLAYER_AUDIO_INFO))
</MACRO>
<FUNCTION>
<NAME>gst_player_audio_info_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_player_audio_info_get_channels</NAME>
<RETURNS>gint  </RETURNS>
const GstPlayerAudioInfo* info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_audio_info_get_sample_rate</NAME>
<RETURNS>gint  </RETURNS>
const GstPlayerAudioInfo* info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_audio_info_get_bitrate</NAME>
<RETURNS>gint  </RETURNS>
const GstPlayerAudioInfo* info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_audio_info_get_max_bitrate</NAME>
<RETURNS>gint  </RETURNS>
const GstPlayerAudioInfo* info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_audio_info_get_language</NAME>
<RETURNS>const gchar *</RETURNS>
const GstPlayerAudioInfo* info
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PLAYER_SUBTITLE_INFO</NAME>
#define GST_TYPE_PLAYER_SUBTITLE_INFO \
  (gst_player_subtitle_info_get_type ())
</MACRO>
<MACRO>
<NAME>GST_PLAYER_SUBTITLE_INFO</NAME>
#define GST_PLAYER_SUBTITLE_INFO(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PLAYER_SUBTITLE_INFO, GstPlayerSubtitleInfo))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_SUBTITLE_INFO_CLASS</NAME>
#define GST_PLAYER_SUBTITLE_INFO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PLAYER_SUBTITLE_INFO,GstPlayerSubtitleInfoClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_SUBTITLE_INFO</NAME>
#define GST_IS_PLAYER_SUBTITLE_INFO(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PLAYER_SUBTITLE_INFO))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_SUBTITLE_INFO_CLASS</NAME>
#define GST_IS_PLAYER_SUBTITLE_INFO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PLAYER_SUBTITLE_INFO))
</MACRO>
<FUNCTION>
<NAME>gst_player_subtitle_info_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_player_subtitle_info_get_language</NAME>
<RETURNS>const gchar *</RETURNS>
const GstPlayerSubtitleInfo* info
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PLAYER_MEDIA_INFO</NAME>
#define GST_TYPE_PLAYER_MEDIA_INFO \
  (gst_player_media_info_get_type())
</MACRO>
<MACRO>
<NAME>GST_PLAYER_MEDIA_INFO</NAME>
#define GST_PLAYER_MEDIA_INFO(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PLAYER_MEDIA_INFO,GstPlayerMediaInfo))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_MEDIA_INFO_CLASS</NAME>
#define GST_PLAYER_MEDIA_INFO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PLAYER_MEDIA_INFO,GstPlayerMediaInfoClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_MEDIA_INFO</NAME>
#define GST_IS_PLAYER_MEDIA_INFO(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PLAYER_MEDIA_INFO))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_MEDIA_INFO_CLASS</NAME>
#define GST_IS_PLAYER_MEDIA_INFO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PLAYER_MEDIA_INFO))
</MACRO>
<FUNCTION>
<NAME>gst_player_media_info_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_get_uri</NAME>
<RETURNS>const gchar *</RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_is_seekable</NAME>
<RETURNS>gboolean  </RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_is_live</NAME>
<RETURNS>gboolean  </RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_get_duration</NAME>
<RETURNS>GstClockTime  </RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_get_stream_list</NAME>
<RETURNS>GList *</RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_get_number_of_streams</NAME>
<RETURNS>guint  </RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_get_video_streams</NAME>
<RETURNS>GList *</RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_get_number_of_video_streams</NAME>
<RETURNS>guint  </RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_get_audio_streams</NAME>
<RETURNS>GList *</RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_get_number_of_audio_streams</NAME>
<RETURNS>guint  </RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_get_subtitle_streams</NAME>
<RETURNS>GList *</RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_get_number_of_subtitle_streams</NAME>
<RETURNS>guint  </RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_get_tags</NAME>
<RETURNS>GstTagList *</RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_get_title</NAME>
<RETURNS>const gchar *</RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_get_container_format</NAME>
<RETURNS>const gchar *</RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_media_info_get_image_sample</NAME>
<RETURNS>GstSample *</RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_video_streams</NAME>
<DEPRECATED/>
<RETURNS>GList *</RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_audio_streams</NAME>
<DEPRECATED/>
<RETURNS>GList *</RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_subtitle_streams</NAME>
<DEPRECATED/>
<RETURNS>GList *</RETURNS>
const GstPlayerMediaInfo *info
</FUNCTION>
<STRUCT>
<NAME>GstPlayerAudioInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GstPlayerAudioInfoClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstPlayerMediaInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GstPlayerMediaInfoClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstPlayerStreamInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GstPlayerStreamInfoClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstPlayerSubtitleInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GstPlayerSubtitleInfoClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstPlayerVideoInfo</NAME>
</STRUCT>
<STRUCT>
<NAME>GstPlayerVideoInfoClass</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_player_state_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PLAYER_STATE</NAME>
#define      GST_TYPE_PLAYER_STATE                    (gst_player_state_get_type ())
</MACRO>
<ENUM>
<NAME>GstPlayerState</NAME>
typedef enum
{
  GST_PLAYER_STATE_STOPPED,
  GST_PLAYER_STATE_BUFFERING,
  GST_PLAYER_STATE_PAUSED,
  GST_PLAYER_STATE_PLAYING
} GstPlayerState;
</ENUM>
<FUNCTION>
<NAME>gst_player_state_get_name</NAME>
<RETURNS>const gchar  *</RETURNS>
GstPlayerState state
</FUNCTION>
<FUNCTION>
<NAME>gst_player_error_quark</NAME>
<RETURNS>GQuark        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_player_error_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_PLAYER_ERROR</NAME>
#define      GST_PLAYER_ERROR                         (gst_player_error_quark ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_PLAYER_ERROR</NAME>
#define      GST_TYPE_PLAYER_ERROR                    (gst_player_error_get_type ())
</MACRO>
<ENUM>
<NAME>GstPlayerError</NAME>
typedef enum {
  GST_PLAYER_ERROR_FAILED = 0
} GstPlayerError;
</ENUM>
<FUNCTION>
<NAME>gst_player_error_get_name</NAME>
<RETURNS>const gchar  *</RETURNS>
GstPlayerError error
</FUNCTION>
<FUNCTION>
<NAME>gst_player_color_balance_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PLAYER_COLOR_BALANCE_TYPE</NAME>
#define GST_TYPE_PLAYER_COLOR_BALANCE_TYPE            (gst_player_color_balance_type_get_type ())
</MACRO>
<ENUM>
<NAME>GstPlayerColorBalanceType</NAME>
typedef enum
{
  GST_PLAYER_COLOR_BALANCE_BRIGHTNESS,
  GST_PLAYER_COLOR_BALANCE_CONTRAST,
  GST_PLAYER_COLOR_BALANCE_SATURATION,
  GST_PLAYER_COLOR_BALANCE_HUE,
} GstPlayerColorBalanceType;
</ENUM>
<FUNCTION>
<NAME>gst_player_color_balance_type_get_name</NAME>
<RETURNS>const gchar  *</RETURNS>
GstPlayerColorBalanceType type
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PLAYER</NAME>
#define GST_TYPE_PLAYER             (gst_player_get_type ())
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER</NAME>
#define GST_IS_PLAYER(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PLAYER))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_CLASS</NAME>
#define GST_IS_PLAYER_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_PLAYER))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_GET_CLASS</NAME>
#define GST_PLAYER_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_PLAYER, GstPlayerClass))
</MACRO>
<MACRO>
<NAME>GST_PLAYER</NAME>
#define GST_PLAYER(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PLAYER, GstPlayer))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_CLASS</NAME>
#define GST_PLAYER_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_PLAYER, GstPlayerClass))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_CAST</NAME>
#define GST_PLAYER_CAST(obj)        ((GstPlayer*)(obj))
</MACRO>
<FUNCTION>
<NAME>gst_player_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_player_new</NAME>
<RETURNS>GstPlayer  *  </RETURNS>
GstPlayerVideoRenderer * video_renderer, GstPlayerSignalDispatcher * signal_dispatcher
</FUNCTION>
<FUNCTION>
<NAME>gst_player_play</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_pause</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_stop</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_seek</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player, GstClockTime   position
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_rate</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player, gdouble        rate
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_rate</NAME>
<RETURNS>gdouble       </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_uri</NAME>
<RETURNS>gchar  *      </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_uri</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player, const gchar  * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_subtitle_uri</NAME>
<RETURNS>gchar  *      </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_subtitle_uri</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player, const gchar *uri
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_position</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_duration</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_volume</NAME>
<RETURNS>gdouble       </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_volume</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player, gdouble        val
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_mute</NAME>
<RETURNS>gboolean      </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_mute</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player, gboolean       val
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_pipeline</NAME>
<RETURNS>GstElement  * </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_video_track_enabled</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player, gboolean enabled
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_audio_track_enabled</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player, gboolean enabled
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_subtitle_track_enabled</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player, gboolean enabled
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_audio_track</NAME>
<RETURNS>gboolean      </RETURNS>
GstPlayer    *player, gint stream_index
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_video_track</NAME>
<RETURNS>gboolean      </RETURNS>
GstPlayer    *player, gint stream_index
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_subtitle_track</NAME>
<RETURNS>gboolean      </RETURNS>
GstPlayer    *player, gint stream_index
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_media_info</NAME>
<RETURNS>GstPlayerMediaInfo  * </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_current_audio_track</NAME>
<RETURNS>GstPlayerAudioInfo  *</RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_current_video_track</NAME>
<RETURNS>GstPlayerVideoInfo  *</RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_current_subtitle_track</NAME>
<RETURNS>GstPlayerSubtitleInfo  *</RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_visualization</NAME>
<RETURNS>gboolean      </RETURNS>
GstPlayer    * player, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_visualization_enabled</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player, gboolean enabled
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_current_visualization</NAME>
<RETURNS>gchar  *      </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_has_color_balance</NAME>
<RETURNS>gboolean      </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_color_balance</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player, GstPlayerColorBalanceType type, gdouble value
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_color_balance</NAME>
<RETURNS>gdouble       </RETURNS>
GstPlayer    * player, GstPlayerColorBalanceType type
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_multiview_mode</NAME>
<RETURNS>GstVideoMultiviewMode 	 </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_multiview_mode</NAME>
<RETURNS>void                      </RETURNS>
GstPlayer    * player, GstVideoMultiviewMode mode
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_multiview_flags</NAME>
<RETURNS>GstVideoMultiviewFlags   </RETURNS>
GstPlayer  * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_multiview_flags</NAME>
<RETURNS>void                     </RETURNS>
GstPlayer  * player, GstVideoMultiviewFlags flags
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_audio_video_offset</NAME>
<RETURNS>gint64        </RETURNS>
GstPlayer    * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_audio_video_offset</NAME>
<RETURNS>void          </RETURNS>
GstPlayer    * player, gint64 offset
</FUNCTION>
<FUNCTION>
<NAME>gst_player_set_config</NAME>
<RETURNS>gboolean        </RETURNS>
GstPlayer * player, GstStructure * config
</FUNCTION>
<FUNCTION>
<NAME>gst_player_get_config</NAME>
<RETURNS>GstStructure  * </RETURNS>
GstPlayer * player
</FUNCTION>
<FUNCTION>
<NAME>gst_player_config_set_user_agent</NAME>
<RETURNS>void            </RETURNS>
GstStructure * config, const gchar * agent
</FUNCTION>
<FUNCTION>
<NAME>gst_player_config_get_user_agent</NAME>
<RETURNS>gchar  *        </RETURNS>
const GstStructure * config
</FUNCTION>
<FUNCTION>
<NAME>gst_player_config_set_position_update_interval</NAME>
<RETURNS>void            </RETURNS>
GstStructure * config, guint          interval
</FUNCTION>
<FUNCTION>
<NAME>gst_player_config_get_position_update_interval</NAME>
<RETURNS>guint           </RETURNS>
const GstStructure * config
</FUNCTION>
<FUNCTION>
<NAME>gst_player_config_set_seek_accurate</NAME>
<RETURNS>void            </RETURNS>
GstPlayer * player, gboolean accurate
</FUNCTION>
<FUNCTION>
<NAME>gst_player_config_get_seek_accurate</NAME>
<RETURNS>gboolean        </RETURNS>
const GstStructure * config
</FUNCTION>
<ENUM>
<NAME>GstPlayerSnapshotFormat</NAME>
typedef enum
{
  GST_PLAYER_THUMBNAIL_RAW_NATIVE = 0,
  GST_PLAYER_THUMBNAIL_RAW_xRGB,
  GST_PLAYER_THUMBNAIL_RAW_BGRx,
  GST_PLAYER_THUMBNAIL_JPG,
  GST_PLAYER_THUMBNAIL_PNG
} GstPlayerSnapshotFormat;
</ENUM>
<FUNCTION>
<NAME>gst_player_get_video_snapshot</NAME>
<RETURNS>GstSample  * </RETURNS>
GstPlayer * player, GstPlayerSnapshotFormat format, GstStructure * config
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PLAYER_VIDEO_RENDERER</NAME>
#define GST_TYPE_PLAYER_VIDEO_RENDERER                (gst_player_video_renderer_get_type ())
</MACRO>
<MACRO>
<NAME>GST_PLAYER_VIDEO_RENDERER</NAME>
#define GST_PLAYER_VIDEO_RENDERER(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PLAYER_VIDEO_RENDERER, GstPlayerVideoRenderer))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_VIDEO_RENDERER</NAME>
#define GST_IS_PLAYER_VIDEO_RENDERER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PLAYER_VIDEO_RENDERER))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_VIDEO_RENDERER_GET_INTERFACE</NAME>
#define GST_PLAYER_VIDEO_RENDERER_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), GST_TYPE_PLAYER_VIDEO_RENDERER, GstPlayerVideoRendererInterface))
</MACRO>
<STRUCT>
<NAME>GstPlayerVideoRendererInterface</NAME>
struct _GstPlayerVideoRendererInterface {
  GTypeInterface parent_iface;

  GstElement * (*create_video_sink) (GstPlayerVideoRenderer * self, GstPlayer * player);
};
</STRUCT>
<FUNCTION>
<NAME>gst_player_video_renderer_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstPlayerVideoRenderer</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER</NAME>
#define GST_TYPE_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER             (gst_player_g_main_context_signal_dispatcher_get_type ())
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER</NAME>
#define GST_IS_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER))
</MACRO>
<MACRO>
<NAME>GST_IS_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER_CLASS</NAME>
#define GST_IS_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER_GET_CLASS</NAME>
#define GST_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER, GstPlayerGMainContextSignalDispatcherClass))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER</NAME>
#define GST_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER, GstPlayerGMainContextSignalDispatcher))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER_CLASS</NAME>
#define GST_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER, GstPlayerGMainContextSignalDispatcherClass))
</MACRO>
<MACRO>
<NAME>GST_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER_CAST</NAME>
#define GST_PLAYER_G_MAIN_CONTEXT_SIGNAL_DISPATCHER_CAST(obj)        ((GstPlayerGMainContextSignalDispatcher*)(obj))
</MACRO>
<FUNCTION>
<NAME>gst_player_g_main_context_signal_dispatcher_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_player_g_main_context_signal_dispatcher_new</NAME>
<RETURNS>GstPlayerSignalDispatcher  * </RETURNS>
GMainContext * application_context
</FUNCTION>
