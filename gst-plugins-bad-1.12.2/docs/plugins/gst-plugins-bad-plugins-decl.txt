<MACRO>
<NAME>ASS_Library</NAME>
#define ASS_Library ass_library_t
</MACRO>
<MACRO>
<NAME>ASS_Renderer</NAME>
#define ASS_Renderer ass_renderer_t
</MACRO>
<MACRO>
<NAME>ASS_Track</NAME>
#define ASS_Track ass_track_t
</MACRO>
<MACRO>
<NAME>ASS_Image</NAME>
#define ASS_Image ass_image_t
</MACRO>
<MACRO>
<NAME>GST_TYPE_ASS_RENDER</NAME>
#define GST_TYPE_ASS_RENDER (gst_ass_render_get_type())
</MACRO>
<MACRO>
<NAME>GST_ASS_RENDER</NAME>
#define GST_ASS_RENDER(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ASS_RENDER,GstAssRender))
</MACRO>
<MACRO>
<NAME>GST_ASS_RENDER_CLASS</NAME>
#define GST_ASS_RENDER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ASS_RENDER,GstAssRenderClass))
</MACRO>
<MACRO>
<NAME>GST_ASS_RENDER_GET_CLASS</NAME>
#define GST_ASS_RENDER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), \
    GST_TYPE_ASS_RENDER, GstAssRenderClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ASS_RENDER</NAME>
#define GST_IS_ASS_RENDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ASS_RENDER))
</MACRO>
<MACRO>
<NAME>GST_IS_ASS_RENDER_CLASS</NAME>
#define GST_IS_ASS_RENDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ASS_RENDER))
</MACRO>
<STRUCT>
<NAME>GstAssRender</NAME>
struct _GstAssRender
{
  GstElement element;

  GstPad *video_sinkpad, *text_sinkpad, *srcpad;

  /* properties */
  gboolean enable, embeddedfonts;
  gboolean wait_text;

  /* <private> */
  GMutex lock;
  GCond cond;

  GstSegment video_segment;
  gboolean video_flushing;
  gboolean video_eos;

  GstVideoInfo info;

  GstBuffer *subtitle_pending;
  gboolean subtitle_flushing;
  gboolean subtitle_eos;
  GstSegment subtitle_segment;

  GMutex ass_mutex;
  ASS_Library *ass_library;
  ASS_Renderer *ass_renderer;
  ASS_Track *ass_track;
  gint ass_frame_width, ass_frame_height;

  gboolean renderer_init_ok, track_init_ok;
  gboolean need_process;

  /* overlay stuff */
  GstVideoOverlayComposition *composition;
  guint window_width, window_height;
  gboolean attach_compo_to_buffer;
};
</STRUCT>
<STRUCT>
<NAME>GstAssRenderClass</NAME>
struct _GstAssRenderClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ass_render_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CURL_BASE_SINK</NAME>
#define GST_TYPE_CURL_BASE_SINK \
  (gst_curl_base_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_CURL_BASE_SINK</NAME>
#define GST_CURL_BASE_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_CURL_BASE_SINK, GstCurlBaseSink))
</MACRO>
<MACRO>
<NAME>GST_CURL_BASE_SINK_CLASS</NAME>
#define GST_CURL_BASE_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_CURL_BASE_SINK, GstCurlBaseSinkClass))
</MACRO>
<MACRO>
<NAME>GST_CURL_BASE_SINK_GET_CLASS</NAME>
#define GST_CURL_BASE_SINK_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_CURL_BASE_SINK, GstCurlBaseSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_BASE_SINK</NAME>
#define GST_IS_CURL_BASE_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_CURL_BASE_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_BASE_SINK_CLASS</NAME>
#define GST_IS_CURL_BASE_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_CURL_BASE_SINK))
</MACRO>
<STRUCT>
<NAME>TransferBuffer</NAME>
struct _TransferBuffer
{
  guint8 *ptr;
  size_t len;
  size_t offset;
};
</STRUCT>
<STRUCT>
<NAME>TransferCondition</NAME>
struct _TransferCondition
{
  GCond cond;
  gboolean data_sent;
  gboolean data_available;
  gboolean wait_for_response;
};
</STRUCT>
<STRUCT>
<NAME>GstCurlBaseSink</NAME>
struct _GstCurlBaseSink
{
  GstBaseSink parent;

  /*< private > */
  CURLM *multi_handle;
  CURL *curl;
  GstPollFD fd;
  GstPoll *fdset;
  curlsocktype socket_type;
  GThread *transfer_thread;
  gchar *error;
  GstFlowReturn flow_ret;
  TransferBuffer *transfer_buf;
  TransferCondition *transfer_cond;
  gint num_buffers_per_packet;
  gint timeout;
  gchar *url;
  gchar *user;
  gchar *passwd;
  gchar *file_name;
  guint qos_dscp;
  gboolean transfer_thread_close;
  gboolean new_file;
  gboolean is_live;
};
</STRUCT>
<STRUCT>
<NAME>GstCurlBaseSinkClass</NAME>
struct _GstCurlBaseSinkClass
{
  GstBaseSinkClass parent_class;

  /* vmethods */
    gboolean (*set_protocol_dynamic_options_unlocked) (GstCurlBaseSink * sink);
    gboolean (*set_options_unlocked) (GstCurlBaseSink * sink);
  void (*set_mime_type) (GstCurlBaseSink * sink, GstCaps * caps);
  void (*transfer_prepare_poll_wait) (GstCurlBaseSink * sink);
    glong (*transfer_get_response_code) (GstCurlBaseSink * sink, glong resp);
    gboolean (*transfer_verify_response_code) (GstCurlBaseSink * sink);
    GstFlowReturn (*prepare_transfer) (GstCurlBaseSink * sink);
  void (*handle_transfer) (GstCurlBaseSink * sink);
    size_t (*transfer_read_cb) (void *curl_ptr, size_t size, size_t nmemb,
      void *stream);
    size_t (*transfer_data_buffer) (GstCurlBaseSink * sink, void *curl_ptr,
      size_t block_size, guint * last_chunk);
    size_t (*flush_data_unlocked) (GstCurlBaseSink * sink, void *curl_ptr,
      size_t block_size, gboolean new_file, gboolean close_transfer);
    gboolean (*has_buffered_data_unlocked) (GstCurlBaseSink * sink);
};
</STRUCT>
<FUNCTION>
<NAME>gst_curl_base_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_curl_base_sink_transfer_thread_notify_unlocked</NAME>
<RETURNS>void  </RETURNS>
GstCurlBaseSink * sink
</FUNCTION>
<FUNCTION>
<NAME>gst_curl_base_sink_transfer_thread_close</NAME>
<RETURNS>void  </RETURNS>
GstCurlBaseSink * sink
</FUNCTION>
<FUNCTION>
<NAME>gst_curl_base_sink_set_live</NAME>
<RETURNS>void  </RETURNS>
GstCurlBaseSink * sink, gboolean live
</FUNCTION>
<FUNCTION>
<NAME>gst_curl_base_sink_is_live</NAME>
<RETURNS>gboolean  </RETURNS>
GstCurlBaseSink * sink
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CURL_FILE_SINK</NAME>
#define GST_TYPE_CURL_FILE_SINK \
  (gst_curl_file_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_CURL_FILE_SINK</NAME>
#define GST_CURL_FILE_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_CURL_FILE_SINK, GstCurlFileSink))
</MACRO>
<MACRO>
<NAME>GST_CURL_FILE_SINK_CLASS</NAME>
#define GST_CURL_FILE_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_CURL_FILE_SINK, GstCurlFileSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_FILE_SINK</NAME>
#define GST_IS_CURL_FILE_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_CURL_FILE_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_FILE_SINK_CLASS</NAME>
#define GST_IS_CURL_FILE_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_CURL_FILE_SINK))
</MACRO>
<STRUCT>
<NAME>GstCurlFileSink</NAME>
struct _GstCurlFileSink
{
  GstCurlBaseSink parent;

  /*< private > */
  gboolean create_dirs;
};
</STRUCT>
<STRUCT>
<NAME>GstCurlFileSinkClass</NAME>
struct _GstCurlFileSinkClass
{
  GstCurlBaseSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_curl_file_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CURL_FTP_SINK</NAME>
#define GST_TYPE_CURL_FTP_SINK \
  (gst_curl_ftp_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_CURL_FTP_SINK</NAME>
#define GST_CURL_FTP_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_CURL_FTP_SINK, GstCurlFtpSink))
</MACRO>
<MACRO>
<NAME>GST_CURL_FTP_SINK_CLASS</NAME>
#define GST_CURL_FTP_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_CURL_FTP_SINK, GstCurlFtpSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_FTP_SINK</NAME>
#define GST_IS_CURL_FTP_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_CURL_FTP_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_FTP_SINK_CLASS</NAME>
#define GST_IS_CURL_FTP_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_CURL_FTP_SINK))
</MACRO>
<STRUCT>
<NAME>GstCurlFtpSink</NAME>
struct _GstCurlFtpSink
{
  GstCurlTlsSink parent;

  /*< private > */
  struct curl_slist *headerlist;
  gchar *ftp_port_arg;
  gboolean epsv_mode;
  gboolean tmpfile_create;
  gchar *tmpfile_name;
  gboolean create_dirs;
};
</STRUCT>
<STRUCT>
<NAME>GstCurlFtpSinkClass</NAME>
struct _GstCurlFtpSinkClass
{
  GstCurlTlsSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_curl_ftp_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CURL_HTTP_SINK</NAME>
#define GST_TYPE_CURL_HTTP_SINK \
  (gst_curl_http_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_CURL_HTTP_SINK</NAME>
#define GST_CURL_HTTP_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_CURL_HTTP_SINK, GstCurlHttpSink))
</MACRO>
<MACRO>
<NAME>GST_CURL_HTTP_SINK_CLASS</NAME>
#define GST_CURL_HTTP_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_CURL_HTTP_SINK, GstCurlHttpSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_HTTP_SINK</NAME>
#define GST_IS_CURL_HTTP_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_CURL_HTTP_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_HTTP_SINK_CLASS</NAME>
#define GST_IS_CURL_HTTP_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_CURL_HTTP_SINK))
</MACRO>
<STRUCT>
<NAME>GstCurlHttpSink</NAME>
struct _GstCurlHttpSink
{
  GstCurlTlsSink parent;

  /*< private > */
  struct curl_slist *header_list;
  gchar *proxy;
  guint proxy_port;
  gchar *proxy_user;
  gchar *proxy_passwd;
  gboolean use_content_length;
  gchar *content_type;
  gboolean use_proxy;
  gboolean proxy_headers_set;
  gboolean proxy_auth;
  gboolean proxy_conn_established;
  glong proxy_resp;
};
</STRUCT>
<STRUCT>
<NAME>GstCurlHttpSinkClass</NAME>
struct _GstCurlHttpSinkClass
{
  GstCurlTlsSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_curl_http_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CURL_SMTP_SINK</NAME>
#define GST_TYPE_CURL_SMTP_SINK \
  (gst_curl_smtp_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_CURL_SMTP_SINK</NAME>
#define GST_CURL_SMTP_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_CURL_SMTP_SINK, GstCurlSmtpSink))
</MACRO>
<MACRO>
<NAME>GST_CURL_SMTP_SINK_CLASS</NAME>
#define GST_CURL_SMTP_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_CURL_SMTP_SINK, GstCurlSmtpSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_SMTP_SINK</NAME>
#define GST_IS_CURL_SMTP_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_CURL_SMTP_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_SMTP_SINK_CLASS</NAME>
#define GST_IS_CURL_SMTP_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_CURL_SMTP_SINK))
</MACRO>
<STRUCT>
<NAME>Base64Chunk</NAME>
struct _Base64Chunk
{
  GByteArray *chunk_array;
  gint save;
  gint state;
};
</STRUCT>
<STRUCT>
<NAME>GstCurlSmtpSink</NAME>
struct _GstCurlSmtpSink
{
  GstCurlTlsSink parent;

  /*< private > */
  Base64Chunk *base64_chunk;
  GByteArray *payload_headers;
  struct curl_slist *curl_recipients;
  gchar *mail_rcpt;
  gchar *mail_from;
  gchar *subject;
  gchar *message_body;
  gchar *content_type;
  gboolean use_ssl;
  gint nbr_attachments;
  gchar *pop_user;
  gchar *pop_passwd;
  gchar *pop_location;
  CURL *pop_curl;

  gboolean transfer_end;
  GCond cond_transfer_end;

  gint curr_attachment;
  gboolean reset_transfer_options;
  gboolean final_boundary_added;
  gboolean eos;
};
</STRUCT>
<STRUCT>
<NAME>GstCurlSmtpSinkClass</NAME>
struct _GstCurlSmtpSinkClass
{
  GstCurlTlsSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_curl_smtp_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CURL_TLS_SINK</NAME>
#define GST_TYPE_CURL_TLS_SINK \
  (gst_curl_tls_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_CURL_TLS_SINK</NAME>
#define GST_CURL_TLS_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_CURL_TLS_SINK, GstCurlTlsSink))
</MACRO>
<MACRO>
<NAME>GST_CURL_TLS_SINK_CLASS</NAME>
#define GST_CURL_TLS_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_CURL_TLS_SINK, GstCurlTlsSinkClass))
</MACRO>
<MACRO>
<NAME>GST_CURL_TLS_SINK_GET_CLASS</NAME>
#define GST_CURL_TLS_SINK_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_CURL_TLS_SINK, GstCurlTlsSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_TLS_SINK</NAME>
#define GST_IS_CURL_TLS_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_CURL_TLS_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_TLS_SINK_CLASS</NAME>
#define GST_IS_CURL_TLS_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_CURL_TLS_SINK))
</MACRO>
<STRUCT>
<NAME>GstCurlTlsSink</NAME>
struct _GstCurlTlsSink
{
  GstCurlBaseSink parent;

  /*< private > */
  gchar *ca_cert;
  gchar *ca_path;
  gchar *crypto_engine;
  gboolean insecure;
};
</STRUCT>
<STRUCT>
<NAME>GstCurlTlsSinkClass</NAME>
struct _GstCurlTlsSinkClass
{
  GstCurlBaseSinkClass parent_class;

  /* vmethods */
    gboolean (*set_options_unlocked) (GstCurlBaseSink * sink);
};
</STRUCT>
<FUNCTION>
<NAME>gst_curl_tls_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DC1394_SRC</NAME>
#define GST_TYPE_DC1394_SRC            (gst_dc1394_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_DC1394_SRC</NAME>
#define GST_DC1394_SRC(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DC1394_SRC,GstDC1394Src))
</MACRO>
<MACRO>
<NAME>GST_DC1394_SRC_CLASS</NAME>
#define GST_DC1394_SRC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DC1394_SRC,GstDC1394SrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DC1394_SRC</NAME>
#define GST_IS_DC1394_SRC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DC1394_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_DC1394_SRC_CLASS</NAME>
#define GST_IS_DC1394_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DC1394_SRC))
</MACRO>
<STRUCT>
<NAME>GstDC1394Src</NAME>
struct _GstDC1394Src {
  GstPushSrc pushsrc;

  GstCaps * caps;

  uint64_t guid;
  int unit;
  dc1394speed_t iso_speed;
  uint32_t dma_buffer_size;
  dc1394camera_t * camera;
  dc1394_t * dc1394;
};
</STRUCT>
<STRUCT>
<NAME>GstDC1394SrcClass</NAME>
struct _GstDC1394SrcClass {
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dc1394_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_DFBVIDEOSINK_VER</NAME>
#define GST_DFBVIDEOSINK_VER(a,b,c) (((a) << 16) | ((b) << 8) | (c))
</MACRO>
<MACRO>
<NAME>DIRECTFB_VER</NAME>
#define DIRECTFB_VER GST_DFBVIDEOSINK_VER(DIRECTFB_MAJOR_VERSION,DIRECTFB_MINOR_VERSION,DIRECTFB_MICRO_VERSION)
</MACRO>
<MACRO>
<NAME>LAYER_MODE_INVALID</NAME>
#define LAYER_MODE_INVALID          -1
</MACRO>
<MACRO>
<NAME>LAYER_MODE_EXCLUSIVE</NAME>
#define LAYER_MODE_EXCLUSIVE        DLSCL_EXCLUSIVE
</MACRO>
<MACRO>
<NAME>LAYER_MODE_ADMINISTRATIVE</NAME>
#define LAYER_MODE_ADMINISTRATIVE   DLSCL_ADMINISTRATIVE
</MACRO>
<MACRO>
<NAME>GST_TYPE_DFBVIDEOSINK</NAME>
#define GST_TYPE_DFBVIDEOSINK              (gst_dfbvideosink_get_type())
</MACRO>
<MACRO>
<NAME>GST_DFBVIDEOSINK</NAME>
#define GST_DFBVIDEOSINK(obj)              (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_DFBVIDEOSINK, GstDfbVideoSink))
</MACRO>
<MACRO>
<NAME>GST_DFBVIDEOSINK_CLASS</NAME>
#define GST_DFBVIDEOSINK_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DFBVIDEOSINK, GstDfbVideoSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DFBVIDEOSINK</NAME>
#define GST_IS_DFBVIDEOSINK(obj)           (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_DFBVIDEOSINK))
</MACRO>
<MACRO>
<NAME>GST_IS_DFBVIDEOSINK_CLASS</NAME>
#define GST_IS_DFBVIDEOSINK_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_DFBVIDEOSINK))
</MACRO>
<FUNCTION>
<NAME>gst_meta_dfbsurface_api_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_meta_dfbsurface_get_info</NAME>
<RETURNS>const GstMetaInfo  * </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DFB_BUFFER_POOL</NAME>
#define GST_TYPE_DFB_BUFFER_POOL     (gst_dfb_buffer_pool_get_type())
</MACRO>
<MACRO>
<NAME>GST_META_DFBSURFACE_GET</NAME>
#define GST_META_DFBSURFACE_GET(buf) ((GstMetaDfbSurface *)gst_buffer_get_meta(buf,gst_meta_dfbsurface_api_get_type()))
</MACRO>
<MACRO>
<NAME>GST_META_DFBSURFACE_ADD</NAME>
#define GST_META_DFBSURFACE_ADD(buf) ((GstMetaDfbSurface *)gst_buffer_add_meta(buf,gst_meta_dfbsurface_get_info(),NULL))
</MACRO>
<MACRO>
<NAME>GST_DFB_BUFFER_POOL_CAST</NAME>
#define GST_DFB_BUFFER_POOL_CAST(obj) ((GstDfbBufferPool*)(obj))
</MACRO>
<STRUCT>
<NAME>GstMetaDfbSurface</NAME>
struct _GstMetaDfbSurface {
  GstMeta meta;

  IDirectFBSurface *surface;

  gint width;
  gint height;

  gboolean locked;

  DFBSurfacePixelFormat pixel_format;

  GstDfbVideoSink *dfbvideosink;
};
</STRUCT>
<STRUCT>
<NAME>GstDfbBufferPool</NAME>
struct _GstDfbBufferPool
{
  GstBufferPool bufferpool;

  GstDfbVideoSink *dfbvideosink;

  GstCaps *caps;
};
</STRUCT>
<STRUCT>
<NAME>GstDfbBufferPoolClass</NAME>
struct _GstDfbBufferPoolClass
{
  GstBufferPoolClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GstDfbVMode</NAME>
struct _GstDfbVMode {
  gint width;
  gint height;
  gint bpp;
};
</STRUCT>
<STRUCT>
<NAME>GstDfbVideoSink</NAME>
struct _GstDfbVideoSink {
  GstVideoSink videosink;

  /* for buffer pool */
  GstBufferPool *pool;

  /* Framerate numerator and denominator */
  gint fps_n;
  gint fps_d;
  
  gint video_width, video_height; /* size of incoming video */
  gint out_width, out_height;
  
  /* Standalone */
  IDirectFB *dfb;
  
  GSList *vmodes; /* Video modes */
  
  gint layer_id;
  IDirectFBDisplayLayer *layer;
  IDirectFBSurface *primary;
  IDirectFBEventBuffer *event_buffer;
  GThread *event_thread;
  
  /* Embedded */
  IDirectFBSurface *ext_surface;
  
  DFBSurfacePixelFormat pixel_format;
  
  gboolean hw_scaling;
  gboolean backbuffer;
  gboolean vsync;
  gboolean setup;
  gboolean running;
  
  /* Color balance */
  GList *cb_channels;
  gint brightness;
  gint contrast;
  gint hue;
  gint saturation;
  gboolean cb_changed;
  
  /* object-set pixel aspect ratio */
  GValue *par;

  gint layer_mode;
};
</STRUCT>
<STRUCT>
<NAME>GstDfbVideoSinkClass</NAME>
struct _GstDfbVideoSinkClass {
  GstVideoSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dfbvideosink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dfb_buffer_pool_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DTSDEC</NAME>
#define GST_TYPE_DTSDEC \
  (gst_dtsdec_get_type())
</MACRO>
<MACRO>
<NAME>GST_DTSDEC</NAME>
#define GST_DTSDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DTSDEC,GstDtsDec))
</MACRO>
<MACRO>
<NAME>GST_DTSDEC_CLASS</NAME>
#define GST_DTSDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DTSDEC,GstDtsDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DTSDEC</NAME>
#define GST_IS_DTSDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DTSDEC))
</MACRO>
<MACRO>
<NAME>GST_IS_DTSDEC_CLASS</NAME>
#define GST_IS_DTSDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DTSDEC))
</MACRO>
<STRUCT>
<NAME>GstDtsDec</NAME>
struct _GstDtsDec {
  GstAudioDecoder	 element;

  GstPadChainFunction base_chain;

  gboolean       dvdmode;
  gboolean       flag_update;
  gboolean       prev_flags;

  /* stream properties */
  gint 	         bit_rate;
  gint 	         sample_rate;
  gint 	         stream_channels;
  gint 	         request_channels;
  gint 	         using_channels;

  gint           channel_reorder_map[6];

  /* decoding properties */
  sample_t 	 level;
  sample_t 	 bias;
  gboolean 	 dynamic_range_compression;
  sample_t 	*samples;
#ifndef DTS_OLD
  dca_state_t   *state;
#else
  dts_state_t 	*state;
#endif
};
</STRUCT>
<STRUCT>
<NAME>GstDtsDecClass</NAME>
struct _GstDtsDecClass {
  GstAudioDecoderClass parent_class;

  guint32 dts_cpuflags;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dtsdec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FAAC</NAME>
#define GST_TYPE_FAAC \
  (gst_faac_get_type ())
</MACRO>
<MACRO>
<NAME>GST_FAAC</NAME>
#define GST_FAAC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_FAAC, GstFaac))
</MACRO>
<MACRO>
<NAME>GST_FAAC_CLASS</NAME>
#define GST_FAAC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_FAAC, GstFaacClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FAAC</NAME>
#define GST_IS_FAAC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_FAAC))
</MACRO>
<MACRO>
<NAME>GST_IS_FAAC_CLASS</NAME>
#define GST_IS_FAAC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_FAAC))
</MACRO>
<STRUCT>
<NAME>GstFaac</NAME>
struct _GstFaac {
  GstAudioEncoder element;

  /* input format */
  gint format;
  /* input frame size */
  gint samples;
  /* required output buffer size */
  gint bytes;

  /* negotiated */
  gint mpegversion, outputformat;

  /* properties */
  gint bitrate,
       profile,
       quality,
       brtype,
       shortctl;
  gboolean tns,
           midside;

  /* FAAC object */
  faacEncHandle handle;
};
</STRUCT>
<STRUCT>
<NAME>GstFaacClass</NAME>
struct _GstFaacClass {
  GstAudioEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_faac_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FAAD</NAME>
#define GST_TYPE_FAAD \
  (gst_faad_get_type ())
</MACRO>
<MACRO>
<NAME>GST_FAAD</NAME>
#define GST_FAAD(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_FAAD, GstFaad))
</MACRO>
<MACRO>
<NAME>GST_FAAD_CLASS</NAME>
#define GST_FAAD_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_FAAD, GstFaadClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FAAD</NAME>
#define GST_IS_FAAD(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_FAAD))
</MACRO>
<MACRO>
<NAME>GST_IS_FAAD_CLASS</NAME>
#define GST_IS_FAAD_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_FAAD))
</MACRO>
<STRUCT>
<NAME>GstFaad</NAME>
typedef struct _GstFaad {
  GstAudioDecoder element;

  guint      samplerate; /* sample rate of the last MPEG frame    */
  guint      channels;   /* number of channels of the last frame  */
  guint      bps;        /* bytes per sample                      */
  guchar    *channel_positions;
  GstAudioChannelPosition aac_positions[6], gst_positions[6];
  gboolean   need_reorder;
  gint       reorder_map[64];

  guint8     fake_codec_data[2];
  guint32    last_header;

  /* FAAD object */
  faacDecHandle handle;
  gboolean init;

  gboolean packetised; /* We must differentiate between raw and packetised streams */

} GstFaad;
</STRUCT>
<STRUCT>
<NAME>GstFaadClass</NAME>
typedef struct _GstFaadClass {
  GstAudioDecoderClass parent_class;
} GstFaadClass;
</STRUCT>
<FUNCTION>
<NAME>gst_faad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_IQA</NAME>
#define GST_TYPE_IQA (gst_iqa_get_type())
</MACRO>
<MACRO>
<NAME>GST_IQA</NAME>
#define GST_IQA(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_IQA, GstIqa))
</MACRO>
<MACRO>
<NAME>GST_IQA_CLASS</NAME>
#define GST_IQA_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_IQA, GstIqaClass))
</MACRO>
<MACRO>
<NAME>GST_IS_IQA</NAME>
#define GST_IS_IQA(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_IQA))
</MACRO>
<MACRO>
<NAME>GST_IS_IQA_CLASS</NAME>
#define GST_IS_IQA_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_IQA))
</MACRO>
<STRUCT>
<NAME>GstIqa</NAME>
struct _GstIqa
{
  GstVideoAggregator videoaggregator;

  gboolean do_dssim;
  double max_dssim;
};
</STRUCT>
<STRUCT>
<NAME>GstIqaClass</NAME>
struct _GstIqaClass
{
  GstVideoAggregatorClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_iqa_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_KATE_ENC</NAME>
#define GST_TYPE_KATE_ENC \
  (gst_kate_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_KATE_ENC</NAME>
#define GST_KATE_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_KATE_ENC,GstKateEnc))
</MACRO>
<MACRO>
<NAME>GST_KATE_ENC_CLASS</NAME>
#define GST_KATE_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_KATE,GstKateEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_KATE_ENC</NAME>
#define GST_IS_KATE_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_KATE_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_KATE_ENC_CLASS</NAME>
#define GST_IS_KATE_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_KATE_ENC))
</MACRO>
<STRUCT>
<NAME>GstKateEnc</NAME>
struct _GstKateEnc
{
  GstElement element;

  GstPad *sinkpad, *srcpad;

  kate_info ki;
  kate_comment kc;
  kate_state k;

  GstTagList *tags;

  GstClockTime last_timestamp;
  GstClockTime latest_end_time;

  GstEvent *pending_segment;

  gboolean headers_sent;
  gboolean initialized;
  gboolean delayed_spu;
  GstClockTime delayed_start;
  kate_bitmap *delayed_bitmap;
  kate_palette *delayed_palette;
  kate_region *delayed_region;
  gchar *language;
  gchar *category;

  GstKateFormat format;

  int granule_rate_numerator;
  int granule_rate_denominator;
  int granule_shift;

  float keepalive_min_time;
  float default_spu_duration;

  size_t original_canvas_width;
  size_t original_canvas_height;

  /* SPU decoding */
  guint8 spu_colormap[4];
  guint32 spu_clut[16];
  guint8 spu_alpha[4];
  guint16 spu_top;
  guint16 spu_left;
  guint16 spu_right;
  guint16 spu_bottom;
  guint16 spu_pix_data[2];
  guint16 show_time;
  guint16 hide_time;
};
</STRUCT>
<STRUCT>
<NAME>GstKateEncClass</NAME>
struct _GstKateEncClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_kate_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_KATE_DEC</NAME>
#define GST_TYPE_KATE_DEC \
  (gst_kate_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_KATE_DEC</NAME>
#define GST_KATE_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_KATE_DEC,GstKateDec))
</MACRO>
<MACRO>
<NAME>GST_KATE_DEC_CLASS</NAME>
#define GST_KATE_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_KATE,GstKateDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_KATE_DEC</NAME>
#define GST_IS_KATE_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_KATE_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_KATE_DEC_CLASS</NAME>
#define GST_IS_KATE_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_KATE_DEC))
</MACRO>
<STRUCT>
<NAME>GstKateDec</NAME>
struct _GstKateDec
{
  GstKateDecoderBase decoder;

  GstPad *sinkpad;
  GstPad *srcpad;

  GstCaps *src_caps;

  GstKateFormat output_format;

  gboolean remove_markup;
};
</STRUCT>
<STRUCT>
<NAME>GstKateDecClass</NAME>
struct _GstKateDecClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_kate_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_KATE_PARSE</NAME>
#define GST_TYPE_KATE_PARSE \
  (gst_kate_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_KATE_PARSE</NAME>
#define GST_KATE_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_KATE_PARSE,GstKateParse))
</MACRO>
<MACRO>
<NAME>GST_KATE_PARSE_CLASS</NAME>
#define GST_KATE_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_KATE_PARSE,GstKateParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_KATE_PARSE</NAME>
#define GST_IS_KATE_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_KATE_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_KATE_PARSE_CLASS</NAME>
#define GST_IS_KATE_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_KATE_PARSE))
</MACRO>
<STRUCT>
<NAME>GstKateParse</NAME>
struct _GstKateParse
{
  GstElement element;

  GstPad *sinkpad;
  GstPad *srcpad;

  guint packetno;
  gboolean streamheader_sent;
  GList *streamheader;

  GQueue *event_queue;
  GQueue *buffer_queue;

  kate_info ki;
  kate_comment kc;
};
</STRUCT>
<STRUCT>
<NAME>GstKateParseClass</NAME>
struct _GstKateParseClass
{
  GstElementClass parent_class;

  /* virtual functions */
    GstFlowReturn (*parse_packet) (GstKateParse * parse, GstBuffer * buf);
};
</STRUCT>
<FUNCTION>
<NAME>gst_kate_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_KATE_TAG</NAME>
#define GST_TYPE_KATE_TAG \
  (gst_kate_tag_get_type())
</MACRO>
<MACRO>
<NAME>GST_KATE_TAG</NAME>
#define GST_KATE_TAG(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_KATE_TAG,GstKateTag))
</MACRO>
<MACRO>
<NAME>GST_KATE_TAG_CLASS</NAME>
#define GST_KATE_TAG_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_KATE_TAG,GstKateTagClass))
</MACRO>
<MACRO>
<NAME>GST_IS_KATE_TAG</NAME>
#define GST_IS_KATE_TAG(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_KATE_TAG))
</MACRO>
<MACRO>
<NAME>GST_IS_KATE_TAG_CLASS</NAME>
#define GST_IS_KATE_TAG_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_KATE_TAG))
</MACRO>
<STRUCT>
<NAME>GstKateTag</NAME>
struct _GstKateTag
{
  GstKateParse parse;

  gchar *language;
  gchar *category;
  gint original_canvas_width;
  gint original_canvas_height;
};
</STRUCT>
<STRUCT>
<NAME>GstKateTagClass</NAME>
struct _GstKateTagClass
{
  GstKateParseClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_kate_tag_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_KATE_TIGER</NAME>
#define GST_TYPE_KATE_TIGER \
  (gst_kate_tiger_get_type())
</MACRO>
<MACRO>
<NAME>GST_KATE_TIGER</NAME>
#define GST_KATE_TIGER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_KATE_TIGER,GstKateTiger))
</MACRO>
<MACRO>
<NAME>GST_KATE_TIGER_CLASS</NAME>
#define GST_KATE_TIGER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_KATE,GstKateTigerClass))
</MACRO>
<MACRO>
<NAME>GST_IS_KATE_TIGER</NAME>
#define GST_IS_KATE_TIGER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_KATE_TIGER))
</MACRO>
<MACRO>
<NAME>GST_IS_KATE_TIGER_CLASS</NAME>
#define GST_IS_KATE_TIGER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_KATE_TIGER))
</MACRO>
<STRUCT>
<NAME>GstKateTiger</NAME>
struct _GstKateTiger
{
  GstKateDecoderBase decoder;

  GstPad *katesinkpad;
  GstPad *videosinkpad;
  GstPad *srcpad;

  tiger_renderer *tr;

  gdouble quality;
  gchar *default_font_desc;
  gboolean default_font_effect;
  gdouble default_font_effect_strength;
  guchar default_font_r;
  guchar default_font_g;
  guchar default_font_b;
  guchar default_font_a;
  guchar default_background_r;
  guchar default_background_g;
  guchar default_background_b;
  guchar default_background_a;
  gboolean silent;

  GstVideoFormat video_format;
  gint video_width;
  gint video_height;
  gboolean swap_rgb;
  GstBuffer *render_buffer;
  GstVideoOverlayComposition *composition;

  GMutex *mutex;
  GCond *cond;

  GstSegment video_segment;
  gboolean video_flushing;
  gboolean seen_header;
};
</STRUCT>
<STRUCT>
<NAME>GstKateTigerClass</NAME>
struct _GstKateTigerClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_kate_tiger_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>ladspa_meta_all</NAME>
extern GstStructure *ladspa_meta_all;
</VARIABLE>
<MACRO>
<NAME>GST_TYPE_MODPLUG</NAME>
#define GST_TYPE_MODPLUG \
  (gst_modplug_get_type())
</MACRO>
<MACRO>
<NAME>GST_MODPLUG</NAME>
#define GST_MODPLUG(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MODPLUG,GstModPlug))
</MACRO>
<MACRO>
<NAME>GST_MODPLUG_CLASS</NAME>
#define GST_MODPLUG_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MODPLUG,GstModPlugClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MODPLUG</NAME>
#define GST_IS_MODPLUG(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MODPLUG))
</MACRO>
<MACRO>
<NAME>GST_IS_MODPLUG_CLASS</NAME>
#define GST_IS_MODPLUG_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MODPLUG))
</MACRO>
<STRUCT>
<NAME>GstModPlug</NAME>
struct _GstModPlug {
  GstElement  element;

  GstPad     *sinkpad;
  GstPad     *srcpad;

  /* properties */
  const gchar *songname;
  gboolean     reverb;
  gint         reverb_depth;
  gint         reverb_delay;
  gboolean     megabass;
  gint         megabass_amount;
  gint         megabass_range;
  gboolean     surround;
  gint         surround_depth;
  gint         surround_delay;
  gboolean     noise_reduction;
  gint         bits;
  gboolean     oversamp;
  gint         channel;
  gint         frequency;

  /* state */
  GstBuffer   *buffer;

  gint32       read_bytes;
  gint32       read_samples;

  gint64       seek_at;      /* pending seek, or -1                 */
  gint64       song_size;    /* size of the raw song data in bytes  */
  gint64       song_length;  /* duration of the song in nanoseconds */
  gint64       offset;       /* current position in samples         */
  gint64       timestamp;

  CSoundFile  *mSoundFile;
};
</STRUCT>
<STRUCT>
<NAME>GstModPlugClass</NAME>
struct _GstModPlugClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_modplug_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstModPlug</NAME>
</STRUCT>
<STRUCT>
<NAME>GstModPlugClass</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_MPEG2ENC</NAME>
#define GST_TYPE_MPEG2ENC \
  (gst_mpeg2enc_get_type ())
</MACRO>
<MACRO>
<NAME>GST_MPEG2ENC</NAME>
#define GST_MPEG2ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_MPEG2ENC, GstMpeg2enc))
</MACRO>
<MACRO>
<NAME>GST_MPEG2ENC_CLASS</NAME>
#define GST_MPEG2ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_MPEG2ENC, GstMpeg2enc))
</MACRO>
<MACRO>
<NAME>GST_IS_MPEG2ENC</NAME>
#define GST_IS_MPEG2ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_MPEG2ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_MPEG2ENC_CLASS</NAME>
#define GST_IS_MPEG2ENC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_MPEG2ENC))
</MACRO>
<MACRO>
<NAME>GST_CAT_DEFAULT</NAME>
#define GST_CAT_DEFAULT mpeg2enc_debug
</MACRO>
<MACRO>
<NAME>GST_MPEG2ENC_MUTEX_LOCK</NAME>
#define GST_MPEG2ENC_MUTEX_LOCK(m) G_STMT_START {                       \
  GST_LOG_OBJECT (m, "locking tlock from thread %p", g_thread_self ()); \
  g_mutex_lock (&m->tlock);                                              \
  GST_LOG_OBJECT (m, "locked tlock from thread %p", g_thread_self ());  \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_MPEG2ENC_MUTEX_UNLOCK</NAME>
#define GST_MPEG2ENC_MUTEX_UNLOCK(m) G_STMT_START {                       \
  GST_LOG_OBJECT (m, "unlocking tlock from thread %p", g_thread_self ()); \
  g_mutex_unlock (&m->tlock);                                              \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_MPEG2ENC_WAIT</NAME>
#define GST_MPEG2ENC_WAIT(m) G_STMT_START {                             \
  GST_LOG_OBJECT (m, "thread %p waiting", g_thread_self ());            \
  g_cond_wait (&m->cond, &m->tlock);                                      \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_MPEG2ENC_SIGNAL</NAME>
#define GST_MPEG2ENC_SIGNAL(m) G_STMT_START {                           \
  GST_LOG_OBJECT (m, "signalling from thread %p", g_thread_self ());    \
  g_cond_signal (&m->cond);                                              \
} G_STMT_END
</MACRO>
<STRUCT>
<NAME>GstMpeg2enc</NAME>
typedef struct _GstMpeg2enc {
  GstElement parent;

  /* pads */
  GstPad *sinkpad, *srcpad;

  /* video info for in caps */
  GstVideoInfo vinfo;

  /* options wrapper */
  GstMpeg2EncOptions *options;

  /* general encoding object (contains rest) */
  GstMpeg2Encoder *encoder;

  /* lock for syncing with encoding task */
  GMutex tlock;
  /* with TLOCK */
  /* signals counterpart thread that something changed;
   * buffer ready for task or buffer has been processed */
  GCond cond;
  /* seen eos */
  gboolean eos;
  /* flowreturn obtained by encoding task */
  GstFlowReturn srcresult;
  /* buffer for encoding task */
  GstBuffer *buffer;
  /* timestamps for output */
  GQueue *time;

} GstMpeg2enc;
</STRUCT>
<STRUCT>
<NAME>GstMpeg2encClass</NAME>
typedef struct _GstMpeg2encClass {
  GstElementClass parent;
} GstMpeg2encClass;
</STRUCT>
<FUNCTION>
<NAME>gst_mpeg2enc_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPLEX</NAME>
#define GST_TYPE_MPLEX \
  (gst_mplex_get_type ())
</MACRO>
<MACRO>
<NAME>GST_MPLEX</NAME>
#define GST_MPLEX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_MPLEX, GstMplex))
</MACRO>
<MACRO>
<NAME>GST_MPLEX_CLASS</NAME>
#define GST_MPLEX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_MPLEX, GstMplex))
</MACRO>
<MACRO>
<NAME>GST_IS_MPLEX</NAME>
#define GST_IS_MPLEX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_MPLEX))
</MACRO>
<MACRO>
<NAME>GST_IS_MPLEX_CLASS</NAME>
#define GST_IS_MPLEX_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_MPLEX))
</MACRO>
<MACRO>
<NAME>GST_CAT_DEFAULT</NAME>
#define GST_CAT_DEFAULT mplex_debug
</MACRO>
<MACRO>
<NAME>GST_MPLEX_MUTEX_LOCK</NAME>
#define GST_MPLEX_MUTEX_LOCK(m) G_STMT_START {                          \
  GST_LOG_OBJECT (m, "locking tlock from thread %p", g_thread_self ()); \
  g_mutex_lock (&(m)->tlock);                                            \
  GST_LOG_OBJECT (m, "locked tlock from thread %p", g_thread_self ());  \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_MPLEX_MUTEX_UNLOCK</NAME>
#define GST_MPLEX_MUTEX_UNLOCK(m) G_STMT_START {                          \
  GST_LOG_OBJECT (m, "unlocking tlock from thread %p", g_thread_self ()); \
  g_mutex_unlock (&(m)->tlock);                                            \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_MPLEX_WAIT</NAME>
#define GST_MPLEX_WAIT(m, p) G_STMT_START {                          \
  GST_LOG_OBJECT (m, "thread %p waiting", g_thread_self ());         \
  g_cond_wait (&(p)->cond, &(m)->tlock);                               \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_MPLEX_SIGNAL</NAME>
#define GST_MPLEX_SIGNAL(m, p) G_STMT_START {                           \
  GST_LOG_OBJECT (m, "signalling from thread %p", g_thread_self ());    \
  g_cond_signal (&(p)->cond);                                            \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_MPLEX_SIGNAL_ALL</NAME>
#define GST_MPLEX_SIGNAL_ALL(m) G_STMT_START {                        \
  GST_LOG_OBJECT (m, "signalling all from thread %p", g_thread_self ());    \
  GSList *walk = m->pads;                                                   \
  while (walk) {                                                            \
  	GST_MPLEX_SIGNAL (m, (GstMplexPad *) walk->data);                          \
  	walk = walk->next;                                                      \
  }                                                                         \
} G_STMT_END
</MACRO>
<STRUCT>
<NAME>GstMplex</NAME>
typedef struct _GstMplex {
  GstElement parent;

  /* pads */
  GSList *pads;
  GstPad *srcpad;
  guint num_apads, num_vpads;

  /* options wrapper */
  GstMplexJob *job;

  /* lock for syncing */
  GMutex tlock;
  /* with TLOCK */
  /* muxer writer generated eos */
  gboolean eos;
  /* flowreturn obtained by muxer task */
  GstFlowReturn srcresult;
} GstMplex;
</STRUCT>
<STRUCT>
<NAME>GstMplexClass</NAME>
typedef struct _GstMplexClass {
  GstElementClass parent;
} GstMplexClass;
</STRUCT>
<FUNCTION>
<NAME>gst_mplex_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CV_DILATE</NAME>
#define GST_TYPE_CV_DILATE \
  (gst_cv_dilate_get_type())
</MACRO>
<MACRO>
<NAME>GST_CV_DILATE</NAME>
#define GST_CV_DILATE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CV_DILATE,GstCvDilate))
</MACRO>
<MACRO>
<NAME>GST_CV_DILATE_CLASS</NAME>
#define GST_CV_DILATE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CV_DILATE,GstCvDilateClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CV_DILATE</NAME>
#define GST_IS_CV_DILATE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CV_DILATE))
</MACRO>
<MACRO>
<NAME>GST_IS_CV_DILATE_CLASS</NAME>
#define GST_IS_CV_DILATE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CV_DILATE))
</MACRO>
<STRUCT>
<NAME>GstCvDilate</NAME>
struct _GstCvDilate
{
  GstCvDilateErode element;
};
</STRUCT>
<STRUCT>
<NAME>GstCvDilateClass</NAME>
struct _GstCvDilateClass 
{
  GstCvDilateErodeClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_cv_dilate_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_cv_dilate_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CV_ERODE</NAME>
#define GST_TYPE_CV_ERODE \
  (gst_cv_erode_get_type())
</MACRO>
<MACRO>
<NAME>GST_CV_ERODE</NAME>
#define GST_CV_ERODE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CV_ERODE,GstCvErode))
</MACRO>
<MACRO>
<NAME>GST_CV_ERODE_CLASS</NAME>
#define GST_CV_ERODE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CV_ERODE,GstCvErodeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CV_ERODE</NAME>
#define GST_IS_CV_ERODE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CV_ERODE))
</MACRO>
<MACRO>
<NAME>GST_IS_CV_ERODE_CLASS</NAME>
#define GST_IS_CV_ERODE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CV_ERODE))
</MACRO>
<STRUCT>
<NAME>GstCvErode</NAME>
struct _GstCvErode
{
  GstCvDilateErode element;
};
</STRUCT>
<STRUCT>
<NAME>GstCvErodeClass</NAME>
struct _GstCvErodeClass 
{
  GstCvDilateErodeClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_cv_erode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_cv_erode_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CV_EQUALIZE_HIST</NAME>
#define GST_TYPE_CV_EQUALIZE_HIST \
  (gst_cv_equalize_hist_get_type())
</MACRO>
<MACRO>
<NAME>GST_CV_EQUALIZE_HIST</NAME>
#define GST_CV_EQUALIZE_HIST(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CV_EQUALIZE_HIST,GstCvEqualizeHist))
</MACRO>
<MACRO>
<NAME>GST_CV_EQUALIZE_HIST_CLASS</NAME>
#define GST_CV_EQUALIZE_HIST_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CV_EQUALIZE_HIST,GstCvEqualizeHistClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CV_EQUALIZE_HIST</NAME>
#define GST_IS_CV_EQUALIZE_HIST(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CV_EQUALIZE_HIST))
</MACRO>
<MACRO>
<NAME>GST_IS_CV_EQUALIZE_HIST_CLASS</NAME>
#define GST_IS_CV_EQUALIZE_HIST_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CV_EQUALIZE_HIST))
</MACRO>
<STRUCT>
<NAME>GstCvEqualizeHist</NAME>
struct _GstCvEqualizeHist
{
  GstOpencvVideoFilter element;
};
</STRUCT>
<STRUCT>
<NAME>GstCvEqualizeHistClass</NAME>
struct _GstCvEqualizeHistClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_cv_equalize_hist_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_cv_equalize_hist_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CV_LAPLACE</NAME>
#define GST_TYPE_CV_LAPLACE \
  (gst_cv_laplace_get_type())
</MACRO>
<MACRO>
<NAME>GST_CV_LAPLACE</NAME>
#define GST_CV_LAPLACE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CV_LAPLACE,GstCvLaplace))
</MACRO>
<MACRO>
<NAME>GST_CV_LAPLACE_CLASS</NAME>
#define GST_CV_LAPLACE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CV_LAPLACE,GstCvLaplaceClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CV_LAPLACE</NAME>
#define GST_IS_CV_LAPLACE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CV_LAPLACE))
</MACRO>
<MACRO>
<NAME>GST_IS_CV_LAPLACE_CLASS</NAME>
#define GST_IS_CV_LAPLACE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CV_LAPLACE))
</MACRO>
<STRUCT>
<NAME>GstCvLaplace</NAME>
struct _GstCvLaplace
{
  GstOpencvVideoFilter element;

  gint aperture_size;
  gdouble scale;
  gdouble shift;
  gboolean mask;

  IplImage *intermediary_img;
  IplImage *cvGray;
  IplImage *Laplace;
};
</STRUCT>
<STRUCT>
<NAME>GstCvLaplaceClass</NAME>
struct _GstCvLaplaceClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_cv_laplace_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_cv_laplace_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CV_SMOOTH</NAME>
#define GST_TYPE_CV_SMOOTH \
  (gst_cv_smooth_get_type())
</MACRO>
<MACRO>
<NAME>GST_CV_SMOOTH</NAME>
#define GST_CV_SMOOTH(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CV_SMOOTH,GstCvSmooth))
</MACRO>
<MACRO>
<NAME>GST_CV_SMOOTH_CLASS</NAME>
#define GST_CV_SMOOTH_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CV_SMOOTH,GstCvSmoothClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CV_SMOOTH</NAME>
#define GST_IS_CV_SMOOTH(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CV_SMOOTH))
</MACRO>
<MACRO>
<NAME>GST_IS_CV_SMOOTH_CLASS</NAME>
#define GST_IS_CV_SMOOTH_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CV_SMOOTH))
</MACRO>
<STRUCT>
<NAME>GstCvSmooth</NAME>
struct _GstCvSmooth
{
  GstOpencvVideoFilter element;

  gint type;

  gint width;
  gint height;
  gdouble colorsigma;
  gdouble spatialsigma;
};
</STRUCT>
<STRUCT>
<NAME>GstCvSmoothClass</NAME>
struct _GstCvSmoothClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_cv_smooth_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_cv_smooth_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CV_SOBEL</NAME>
#define GST_TYPE_CV_SOBEL \
  (gst_cv_sobel_get_type())
</MACRO>
<MACRO>
<NAME>GST_CV_SOBEL</NAME>
#define GST_CV_SOBEL(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CV_SOBEL,GstCvSobel))
</MACRO>
<MACRO>
<NAME>GST_CV_SOBEL_CLASS</NAME>
#define GST_CV_SOBEL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CV_SOBEL,GstCvSobelClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CV_SOBEL</NAME>
#define GST_IS_CV_SOBEL(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CV_SOBEL))
</MACRO>
<MACRO>
<NAME>GST_IS_CV_SOBEL_CLASS</NAME>
#define GST_IS_CV_SOBEL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CV_SOBEL))
</MACRO>
<STRUCT>
<NAME>GstCvSobel</NAME>
struct _GstCvSobel
{
  GstOpencvVideoFilter element;

  gint x_order;
  gint y_order;
  gint aperture_size;
  gboolean mask;

  IplImage *cvGray;
  IplImage *cvSobel;
};
</STRUCT>
<STRUCT>
<NAME>GstCvSobelClass</NAME>
struct _GstCvSobelClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_cv_sobel_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_cv_sobel_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_EDGE_DETECT</NAME>
#define GST_TYPE_EDGE_DETECT \
  (gst_edge_detect_get_type())
</MACRO>
<MACRO>
<NAME>GST_EDGE_DETECT</NAME>
#define GST_EDGE_DETECT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_EDGE_DETECT,GstEdgeDetect))
</MACRO>
<MACRO>
<NAME>GST_EDGE_DETECT_CLASS</NAME>
#define GST_EDGE_DETECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_EDGE_DETECT,GstEdgeDetectClass))
</MACRO>
<MACRO>
<NAME>GST_IS_EDGE_DETECT</NAME>
#define GST_IS_EDGE_DETECT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_EDGE_DETECT))
</MACRO>
<MACRO>
<NAME>GST_IS_EDGE_DETECT_CLASS</NAME>
#define GST_IS_EDGE_DETECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_EDGE_DETECT))
</MACRO>
<STRUCT>
<NAME>GstEdgeDetect</NAME>
struct _GstEdgeDetect
{
  GstOpencvVideoFilter element;

  gboolean mask;

  int threshold1;
  int threshold2;
  int aperture;

  IplImage *cvEdge;
  IplImage *cvGray;
};
</STRUCT>
<STRUCT>
<NAME>GstEdgeDetectClass</NAME>
struct _GstEdgeDetectClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_edge_detect_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_edge_detect_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FACE_BLUR</NAME>
#define GST_TYPE_FACE_BLUR \
  (gst_face_blur_get_type())
</MACRO>
<MACRO>
<NAME>GST_FACE_BLUR</NAME>
#define GST_FACE_BLUR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FACE_BLUR,GstFaceBlur))
</MACRO>
<MACRO>
<NAME>GST_FACE_BLUR_CLASS</NAME>
#define GST_FACE_BLUR_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FACE_BLUR,GstFaceBlurClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FACE_BLUR</NAME>
#define GST_IS_FACE_BLUR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FACE_BLUR))
</MACRO>
<MACRO>
<NAME>GST_IS_FACE_BLUR_CLASS</NAME>
#define GST_IS_FACE_BLUR_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FACE_BLUR))
</MACRO>
<STRUCT>
<NAME>GstFaceBlur</NAME>
struct _GstFaceBlur
{
  GstOpencvVideoFilter element;

  gboolean sent_profile_load_failed_msg;

  gchar *profile;
  gboolean display;
  gdouble scale_factor;
  gint min_neighbors;
  gint flags;
  gint min_size_width;
  gint min_size_height;

  IplImage *cvGray;
  cv::CascadeClassifier *cvCascade;
};
</STRUCT>
<STRUCT>
<NAME>GstFaceBlurClass</NAME>
struct _GstFaceBlurClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_face_blur_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_face_blur_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FACE_DETECT</NAME>
#define GST_TYPE_FACE_DETECT \
  (gst_face_detect_get_type())
</MACRO>
<MACRO>
<NAME>GST_FACE_DETECT</NAME>
#define GST_FACE_DETECT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FACE_DETECT,GstFaceDetect))
</MACRO>
<MACRO>
<NAME>GST_FACE_DETECT_CLASS</NAME>
#define GST_FACE_DETECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FACE_DETECT,GstFaceDetectClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FACE_DETECT</NAME>
#define GST_IS_FACE_DETECT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FACE_DETECT))
</MACRO>
<MACRO>
<NAME>GST_IS_FACE_DETECT_CLASS</NAME>
#define GST_IS_FACE_DETECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FACE_DETECT))
</MACRO>
<ENUM>
<NAME>GstFaceDetectUpdates</NAME>
enum GstFaceDetectUpdates {
  GST_FACEDETECT_UPDATES_EVERY_FRAME      = 0,
  GST_FACEDETECT_UPDATES_ON_CHANGE        = 1,
  GST_FACEDETECT_UPDATES_ON_FACE          = 2,
  GST_FACEDETECT_UPDATES_NONE             = 3
};
</ENUM>
<STRUCT>
<NAME>GstFaceDetect</NAME>
struct _GstFaceDetect
{
  GstOpencvVideoFilter element;

  gboolean display;
  gboolean face_detected;

  gchar *face_profile;
  gchar *nose_profile;
  gchar *mouth_profile;
  gchar *eyes_profile;
  gdouble scale_factor;
  gint min_neighbors;
  gint flags;
  gint min_size_width;
  gint min_size_height;
  gint min_stddev;
  gint updates;

  IplImage *cvGray;
  cv::CascadeClassifier *cvFaceDetect;
  cv::CascadeClassifier *cvNoseDetect;
  cv::CascadeClassifier *cvMouthDetect;
  cv::CascadeClassifier *cvEyesDetect;
};
</STRUCT>
<STRUCT>
<NAME>GstFaceDetectClass</NAME>
struct _GstFaceDetectClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_face_detect_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_face_detect_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TEMPLATE_MATCH</NAME>
#define GST_TYPE_TEMPLATE_MATCH \
  (gst_template_match_get_type())
</MACRO>
<MACRO>
<NAME>GST_TEMPLATE_MATCH</NAME>
#define GST_TEMPLATE_MATCH(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TEMPLATE_MATCH,GstTemplateMatch))
</MACRO>
<MACRO>
<NAME>GST_TEMPLATE_MATCH_CLASS</NAME>
#define GST_TEMPLATE_MATCH_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TEMPLATE_MATCH,GstTemplateMatchClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TEMPLATE_MATCH</NAME>
#define GST_IS_TEMPLATE_MATCH(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TEMPLATE_MATCH))
</MACRO>
<MACRO>
<NAME>GST_IS_TEMPLATE_MATCH_CLASS</NAME>
#define GST_IS_TEMPLATE_MATCH_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TEMPLATE_MATCH))
</MACRO>
<STRUCT>
<NAME>GstTemplateMatch</NAME>
struct _GstTemplateMatch
{
  GstOpencvVideoFilter element;

  gint method;
  gboolean display;

  gchar *templ;

  IplImage *cvGray, *cvTemplateImage, *cvDistImage;
};
</STRUCT>
<STRUCT>
<NAME>GstTemplateMatchClass</NAME>
struct _GstTemplateMatchClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_template_match_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_template_match_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * templatematch
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OPENCV_TEXT_OVERLAY</NAME>
#define GST_TYPE_OPENCV_TEXT_OVERLAY \
  (gst_opencv_text_overlay_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPENCV_TEXT_OVERLAY</NAME>
#define GST_OPENCV_TEXT_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OPENCV_TEXT_OVERLAY,GstOpencvTextOverlay))
</MACRO>
<MACRO>
<NAME>GST_OPECV_TEXT_OVERLAY_CLASS</NAME>
#define GST_OPECV_TEXT_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OPECV_TEXT_OVERLAY,GstOpencvTextOverlayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENCV_TEXT_OVERLAY</NAME>
#define GST_IS_OPENCV_TEXT_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OPENCV_TEXT_OVERLAY))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENCV_TEXT_OVERLAY_CLASS</NAME>
#define GST_IS_OPENCV_TEXT_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OPENCV_TEXT_OVERLAY))
</MACRO>
<STRUCT>
<NAME>GstOpencvTextOverlay</NAME>
struct _GstOpencvTextOverlay
{
  GstOpencvVideoFilter element;

  CvFont font;

  gint xpos;
  gint ypos;
  gint thickness;
  gint colorR,colorG,colorB;
  gdouble height;
  gdouble width;
  gchar *textbuf;

};
</STRUCT>
<STRUCT>
<NAME>GstOpencvTextOverlayClass</NAME>
struct _GstOpencvTextOverlayClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_opencv_text_overlay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_opencv_text_overlay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OPENNI2_SRC</NAME>
#define GST_TYPE_OPENNI2_SRC \
  (gst_openni2_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPENNI2_SRC</NAME>
#define GST_OPENNI2_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OPENNI2_SRC,GstOpenni2Src))
</MACRO>
<MACRO>
<NAME>GST_OPENNI2_SRC_CLASS</NAME>
#define GST_OPENNI2_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OPENNI2_SRC,GstOpenni2SrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENNI2_SRC</NAME>
#define GST_IS_OPENNI2_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OPENNI2_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENNI2_SRC_CLASS</NAME>
#define GST_IS_OPENNI2_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OPENNI2_SRC))
</MACRO>
<ENUM>
<NAME>GstOpenni2State</NAME>
typedef enum
{
  GST_OPENNI2_SRC_FILE_TRANSFER,
  GST_OPENNI2_SRC_NEXT_PROGRAM_CHAIN,
  GST_OPENNI2_SRC_INVALID_DATA
} GstOpenni2State;
</ENUM>
<STRUCT>
<NAME>GstOpenni2Src</NAME>
struct _GstOpenni2Src
{
  GstPushSrc element;

  GstOpenni2State state;
  gchar *uri_name;
  gint sourcetype;
  GstVideoInfo info;
  GstCaps *gst_caps;

  /* Timestamp of the first frame */
  GstClockTime oni_start_ts;

  /* OpenNI2 variables */
  openni::Device *device;
  openni::VideoStream *depth, *color;
  openni::VideoMode depthVideoMode, colorVideoMode;
  openni::PixelFormat depthpixfmt, colorpixfmt;
  int width, height, fps;
  openni::VideoFrameRef *depthFrame, *colorFrame;
};
</STRUCT>
<STRUCT>
<NAME>GstOpenni2SrcClass</NAME>
struct _GstOpenni2SrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_openni2_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_openni2src_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RSVG_DEC</NAME>
#define GST_TYPE_RSVG_DEC \
  (gst_rsvg_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_RSVG_DEC</NAME>
#define GST_RSVG_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RSVG_DEC,GstRsvgDec))
</MACRO>
<MACRO>
<NAME>GST_RSVG_DEC_CLASS</NAME>
#define GST_RSVG_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RSVG_DEC,GstRsvgDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RSVG_DEC</NAME>
#define GST_IS_RSVG_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RSVG_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_RSVG_DEC_CLASS</NAME>
#define GST_IS_RSVG_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RSVG_DEC))
</MACRO>
<STRUCT>
<NAME>GstRsvgDec</NAME>
struct _GstRsvgDec
{
  GstVideoDecoder  decoder;

  GstPad     *sinkpad;
  GstPad     *srcpad;

  GList *pending_events;

  GstClockTime first_timestamp;
  guint64 frame_count;

  GstVideoCodecState *input_state;

  GstSegment segment;
  gboolean need_newsegment;

  GstAdapter *adapter;
};
</STRUCT>
<STRUCT>
<NAME>GstRsvgDecClass</NAME>
struct _GstRsvgDecClass
{
  GstVideoDecoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rsvg_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RSVG_OVERLAY</NAME>
#define GST_TYPE_RSVG_OVERLAY 	     (gst_rsvg_overlay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RSVG_OVERLAY</NAME>
#define GST_RSVG_OVERLAY(obj) 	     (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RSVG_OVERLAY,GstRsvgOverlay))
</MACRO>
<MACRO>
<NAME>GST_RSVG_OVERLAY_CLASS</NAME>
#define GST_RSVG_OVERLAY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RSVG_OVERLAY,GstRsvgOverlayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RSVG_OVERLAY</NAME>
#define GST_IS_RSVG_OVERLAY(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RSVG_OVERLAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RSVG_OVERLAY_CLASS</NAME>
#define GST_IS_RSVG_OVERLAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RSVG_OVERLAY))
</MACRO>
<STRUCT>
<NAME>GstRsvgOverlay</NAME>
struct _GstRsvgOverlay
{
  GstVideoFilter element;

  /* < private > */
  GMutex rsvg_lock;

  RsvgHandle *handle;

  /* width and height of the SVG data */
  int svg_width;
  int svg_height;

  int x_offset;
  int y_offset;
  float x_relative;
  float y_relative;

  int width;
  int height;
  float width_relative;
  float height_relative;

  GstPad *data_sinkpad;
  GstAdapter *adapter;
};
</STRUCT>
<STRUCT>
<NAME>GstRsvgOverlayClass</NAME>
struct _GstRsvgOverlayClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rsvg_overlay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTMP_SRC</NAME>
#define GST_TYPE_RTMP_SRC \
  (gst_rtmp_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTMP_SRC</NAME>
#define GST_RTMP_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTMP_SRC,GstRTMPSrc))
</MACRO>
<MACRO>
<NAME>GST_RTMP_SRC_CLASS</NAME>
#define GST_RTMP_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTMP_SRC,GstRTMPSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTMP_SRC</NAME>
#define GST_IS_RTMP_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTMP_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_RTMP_SRC_CLASS</NAME>
#define GST_IS_RTMP_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTMP_SRC))
</MACRO>
<STRUCT>
<NAME>GstRTMPSrc</NAME>
struct _GstRTMPSrc
{
  GstPushSrc parent;
  
  /* < private > */
  gchar *uri;
  gchar *swf_url;
  gchar *page_url;

  RTMP *rtmp;
  int timeout;
  gint64 cur_offset;
  GstClockTime last_timestamp;
  gboolean seekable;
  gboolean discont;
};
</STRUCT>
<STRUCT>
<NAME>GstRTMPSrcClass</NAME>
struct _GstRTMPSrcClass
{
  GstPushSrcClass  parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtmp_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTMP_SINK</NAME>
#define GST_TYPE_RTMP_SINK \
  (gst_rtmp_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTMP_SINK</NAME>
#define GST_RTMP_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTMP_SINK,GstRTMPSink))
</MACRO>
<MACRO>
<NAME>GST_RTMP_SINK_CLASS</NAME>
#define GST_RTMP_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTMP_SINK,GstRTMPSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTMP_SINK</NAME>
#define GST_IS_RTMP_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTMP_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_RTMP_SINK_CLASS</NAME>
#define GST_IS_RTMP_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTMP_SINK))
</MACRO>
<STRUCT>
<NAME>GstRTMPSink</NAME>
struct _GstRTMPSink {
  GstBaseSink parent;

  /* < private > */
  gchar *uri;

  RTMP *rtmp;
  gchar *rtmp_uri; /* copy of url for librtmp */

  GstBuffer *header;
  gboolean first;
  gboolean have_write_error;
};
</STRUCT>
<STRUCT>
<NAME>GstRTMPSinkClass</NAME>
struct _GstRTMPSinkClass {
  GstBaseSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtmp_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SPAN_PLC</NAME>
#define GST_TYPE_SPAN_PLC (gst_span_plc_get_type())
</MACRO>
<MACRO>
<NAME>GST_SPAN_PLC</NAME>
#define GST_SPAN_PLC(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPAN_PLC,GstSpanPlc))
</MACRO>
<MACRO>
<NAME>GST_SPAN_PLC_CLASS</NAME>
#define GST_SPAN_PLC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPAN_PLC,GstSpanPlcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SPAN_PLC</NAME>
#define GST_IS_SPAN_PLC(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPAN_PLC))
</MACRO>
<MACRO>
<NAME>GST_IS_SPAN_PLC_CLASS</NAME>
#define GST_IS_SPAN_PLC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPAN_PLC))
</MACRO>
<STRUCT>
<NAME>GstSpanPlc</NAME>
struct _GstSpanPlc
{
  GstElement element;

  GstPad *sinkpad;
  GstPad *srcpad;

  /* <private> */
  plc_state_t *plc_state;
  gint sample_rate;
};
</STRUCT>
<STRUCT>
<NAME>GstSpanPlcClass</NAME>
struct _GstSpanPlcClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_span_plc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DTMF_DETECT</NAME>
#define GST_TYPE_DTMF_DETECT \
  (gst_dtmf_detect_get_type())
</MACRO>
<MACRO>
<NAME>GST_DTMF_DETECT</NAME>
#define GST_DTMF_DETECT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), \
  GST_TYPE_DTMF_DETECT,GstDtmfDetect))
</MACRO>
<MACRO>
<NAME>GST_DTMF_DETECT_CLASS</NAME>
#define GST_DTMF_DETECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), \
  GST_TYPE_DTMF_DETECT,GstDtmfDetectClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DTMF_DETECT</NAME>
#define GST_IS_DTMF_DETECT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DTMF_DETECT))
</MACRO>
<MACRO>
<NAME>GST_IS_DTMF_DETECT_CLASS</NAME>
#define GST_IS_DTMF_DETECT_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DTMF_DETECT))
</MACRO>
<STRUCT>
<NAME>GstDtmfDetect</NAME>
struct _GstDtmfDetect
{
  GstBaseTransform parent;

  dtmf_rx_state_t *dtmf_state;
};
</STRUCT>
<STRUCT>
<NAME>GstDtmfDetectClass</NAME>
struct _GstDtmfDetectClass
{
  GstBaseTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dtmf_detect_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dtmf_detect_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *plugin
</FUNCTION>
<STRUCT>
<NAME>GstDtmfDetectPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_WILDMIDI</NAME>
#define GST_TYPE_WILDMIDI \
  (gst_wildmidi_get_type())
</MACRO>
<MACRO>
<NAME>GST_WILDMIDI</NAME>
#define GST_WILDMIDI(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WILDMIDI,GstWildmidi))
</MACRO>
<MACRO>
<NAME>GST_WILDMIDI_CLASS</NAME>
#define GST_WILDMIDI_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WILDMIDI,GstWildmidiClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WILDMIDI</NAME>
#define GST_IS_WILDMIDI(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WILDMIDI))
</MACRO>
<MACRO>
<NAME>GST_IS_WILDMIDI_CLASS</NAME>
#define GST_IS_WILDMIDI_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WILDMIDI))
</MACRO>
<ENUM>
<NAME>GstWildmidiState</NAME>
typedef enum {
  GST_WILDMIDI_STATE_LOAD,
  GST_WILDMIDI_STATE_PARSE,
  GST_WILDMIDI_STATE_PLAY
} GstWildmidiState;
</ENUM>
<STRUCT>
<NAME>GstWildmidi</NAME>
struct _GstWildmidi
{
  GstElement element;

  GstPad *sinkpad, *srcpad;

  /* input stream properties */
  GstWildmidiState state;
  GstAdapter *adapter;
  midi *song;
  guint64 offset;

  /* output data */
  gboolean discont;
  GstSegment o_segment[1];
  gint64 o_len;

  /* format of the stream */
  guint bytes_per_frame;

  /* wildmidi settings */
  gboolean high_quality;
  gboolean linear_volume;
};
</STRUCT>
<STRUCT>
<NAME>GstWildmidiClass</NAME>
struct _GstWildmidiClass
{
    GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wildmidi_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VOAACENC</NAME>
#define GST_TYPE_VOAACENC \
  (gst_voaacenc_get_type())
</MACRO>
<MACRO>
<NAME>GST_VOAACENC</NAME>
#define GST_VOAACENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_VOAACENC, GstVoAacEnc))
</MACRO>
<MACRO>
<NAME>GST_VOAACENC_CLASS</NAME>
#define GST_VOAACENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_VOAACENC, GstVoAacEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VOAACENC</NAME>
#define GST_IS_VOAACENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_VOAACENC))
</MACRO>
<MACRO>
<NAME>GST_IS_VOAACENC_CLASS</NAME>
#define GST_IS_VOAACENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_VOAACENC))
</MACRO>
<STRUCT>
<NAME>GstVoAacEnc</NAME>
struct _GstVoAacEnc {
  GstAudioEncoder element;

  gboolean discont;

  /* desired bitrate */
  gint bitrate;

  /* caps */
  gint channels;
  gint rate;
  gint output_format;

  gint inbuf_size;

  /* library handle */
  VO_AUDIO_CODECAPI codec_api;
  VO_HANDLE handle;
  VO_MEM_OPERATOR mem_operator;

};
</STRUCT>
<STRUCT>
<NAME>GstVoAacEncClass</NAME>
struct _GstVoAacEncClass {
  GstAudioEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_voaacenc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VOAMRWBENC</NAME>
#define GST_TYPE_VOAMRWBENC			\
  (gst_voamrwbenc_get_type())
</MACRO>
<MACRO>
<NAME>GST_VOAMRWBENC</NAME>
#define GST_VOAMRWBENC(obj)						\
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_VOAMRWBENC, GstVoAmrWbEnc))
</MACRO>
<MACRO>
<NAME>GST_VOAMRWBENC_CLASS</NAME>
#define GST_VOAMRWBENC_CLASS(klass)					\
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_VOAMRWBENC, GstVoAmrWbEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VOAMRWBENC</NAME>
#define GST_IS_VOAMRWBENC(obj)					\
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_VOAMRWBENC))
</MACRO>
<MACRO>
<NAME>GST_IS_VOAMRWBENC_CLASS</NAME>
#define GST_IS_VOAMRWBENC_CLASS(klass)			\
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_VOAMRWBENC))
</MACRO>
<STRUCT>
<NAME>GstVoAmrWbEnc</NAME>
struct _GstVoAmrWbEnc {
  GstAudioEncoder element;

  /* library handle */
  void *handle;

  /* input settings */
  gint bandmode;
  gint channels, rate;
};
</STRUCT>
<STRUCT>
<NAME>GstVoAmrWbEncClass</NAME>
struct _GstVoAmrWbEncClass {
  GstAudioEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_voamrwbenc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WEBRTC_DSP</NAME>
#define GST_TYPE_WEBRTC_DSP            (gst_webrtc_dsp_get_type())
</MACRO>
<MACRO>
<NAME>GST_WEBRTC_DSP</NAME>
#define GST_WEBRTC_DSP(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WEBRTC_DSP,GstWebrtcDsp))
</MACRO>
<MACRO>
<NAME>GST_IS_WEBRTC_DSP</NAME>
#define GST_IS_WEBRTC_DSP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WEBRTC_DSP))
</MACRO>
<MACRO>
<NAME>GST_WEBRTC_DSP_CLASS</NAME>
#define GST_WEBRTC_DSP_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_WEBRTC_DSP,GstWebrtcDspClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WEBRTC_DSP_CLASS</NAME>
#define GST_IS_WEBRTC_DSP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_WEBRTC_DSP))
</MACRO>
<MACRO>
<NAME>GST_WEBRTC_DSP_GET_CLASS</NAME>
#define GST_WEBRTC_DSP_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_WEBRTC_DSP,GstWebrtcDspClass))
</MACRO>
<STRUCT>
<NAME>GstWebrtcDspClass</NAME>
struct _GstWebrtcDspClass
{
  GstAudioFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_webrtc_dsp_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstWebrtcDsp</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_WEBRTC_ECHO_PROBE</NAME>
#define GST_TYPE_WEBRTC_ECHO_PROBE            (gst_webrtc_echo_probe_get_type())
</MACRO>
<MACRO>
<NAME>GST_WEBRTC_ECHO_PROBE</NAME>
#define GST_WEBRTC_ECHO_PROBE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WEBRTC_ECHO_PROBE,GstWebrtcEchoProbe))
</MACRO>
<MACRO>
<NAME>GST_IS_WEBRTC_ECHO_PROBE</NAME>
#define GST_IS_WEBRTC_ECHO_PROBE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WEBRTC_ECHO_PROBE))
</MACRO>
<MACRO>
<NAME>GST_WEBRTC_ECHO_PROBE_CLASS</NAME>
#define GST_WEBRTC_ECHO_PROBE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_WEBRTC_ECHO_PROBE,GstWebrtcEchoProbeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WEBRTC_ECHO_PROBE_CLASS</NAME>
#define GST_IS_WEBRTC_ECHO_PROBE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_WEBRTC_ECHO_PROBE))
</MACRO>
<MACRO>
<NAME>GST_WEBRTC_ECHO_PROBE_GET_CLASS</NAME>
#define GST_WEBRTC_ECHO_PROBE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_WEBRTC_ECHO_PROBE,GstWebrtcEchoProbeClass))
</MACRO>
<MACRO>
<NAME>GST_WEBRTC_ECHO_PROBE_LOCK</NAME>
#define GST_WEBRTC_ECHO_PROBE_LOCK(obj) g_mutex_lock (&GST_WEBRTC_ECHO_PROBE (obj)->lock)
</MACRO>
<MACRO>
<NAME>GST_WEBRTC_ECHO_PROBE_UNLOCK</NAME>
#define GST_WEBRTC_ECHO_PROBE_UNLOCK(obj) g_mutex_unlock (&GST_WEBRTC_ECHO_PROBE (obj)->lock)
</MACRO>
<STRUCT>
<NAME>GstWebrtcEchoProbe</NAME>
struct _GstWebrtcEchoProbe
{
  GstAudioFilter parent;

  /* This lock is required as the DSP may need to lock itself using it's
   * object lock and also lock the probe. The natural order for the DSP is
   * to lock the DSP and then the echo probe. If we where using the probe
   * object lock, we'd be racing with GstBin which will lock sink to src,
   * and may accidently reverse the order. */
  GMutex lock;

  /* Protected by the lock */
  GstAudioInfo info;
  guint period_size;
  GstClockTime latency;
  gint delay;

  GstSegment segment;
  GstAdapter *adapter;

  /* Private */
  gboolean acquired;
};
</STRUCT>
<STRUCT>
<NAME>GstWebrtcEchoProbeClass</NAME>
struct _GstWebrtcEchoProbeClass
{
  GstAudioFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_webrtc_echo_probe_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_webrtc_acquire_echo_probe</NAME>
<RETURNS>GstWebrtcEchoProbe  *</RETURNS>
const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_webrtc_release_echo_probe</NAME>
<RETURNS>void  </RETURNS>
GstWebrtcEchoProbe * probe
</FUNCTION>
<FUNCTION>
<NAME>gst_webrtc_echo_probe_read</NAME>
<RETURNS>gint  </RETURNS>
GstWebrtcEchoProbe * self, GstClockTime rec_time, gpointer frame
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ZBAR</NAME>
#define GST_TYPE_ZBAR \
  (gst_zbar_get_type())
</MACRO>
<MACRO>
<NAME>GST_ZBAR</NAME>
#define GST_ZBAR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ZBAR,GstZBar))
</MACRO>
<MACRO>
<NAME>GST_ZBAR_CLASS</NAME>
#define GST_ZBAR_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ZBAR,GstZBarClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ZBAR</NAME>
#define GST_IS_ZBAR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ZBAR))
</MACRO>
<MACRO>
<NAME>GST_IS_ZBAR_CLASS</NAME>
#define GST_IS_ZBAR_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ZBAR))
</MACRO>
<STRUCT>
<NAME>GstZBar</NAME>
struct _GstZBar
{
  /*< private >*/
  GstVideoFilter videofilter;

  /* properties */
  gboolean message;
  gboolean attach_frame;
  gboolean cache;

  /* internals */
  zbar_image_scanner_t *scanner;
};
</STRUCT>
<STRUCT>
<NAME>GstZBarClass</NAME>
struct _GstZBarClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_zbar_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AIFF_PARSE</NAME>
#define GST_TYPE_AIFF_PARSE \
  (gst_aiff_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_AIFF_PARSE</NAME>
#define GST_AIFF_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AIFF_PARSE,GstAiffParse))
</MACRO>
<MACRO>
<NAME>GST_AIFF_PARSE_CLASS</NAME>
#define GST_AIFF_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AIFF_PARSE,GstAiffParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AIFF_PARSE</NAME>
#define GST_IS_AIFF_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AIFF_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_AIFF_PARSE_CLASS</NAME>
#define GST_IS_AIFF_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AIFF_PARSE))
</MACRO>
<ENUM>
<NAME>GstAiffParseState</NAME>
typedef enum {
  AIFF_PARSE_START,
  AIFF_PARSE_HEADER,
  AIFF_PARSE_DATA
} GstAiffParseState;
</ENUM>
<STRUCT>
<NAME>GstAiffParse</NAME>
struct _GstAiffParse {
  GstElement parent;

  /*< private >*/
  GstPad      *sinkpad;
  GstPad      *srcpad;

  GstEvent    *close_segment;
  GstEvent    *start_segment;

  /* AIFF decoding state */
  GstAiffParseState state;

  /* format of audio, see defines below */
  gint format;

  gboolean is_aifc;

  /* useful audio data */
  guint32 rate;
  guint16 channels;
  guint16 width;
  guint16 depth;
  guint32 endianness;
  gboolean floating_point;

  /* real bytes per second used or 0 when no bitrate is known */
  guint32 bps;

  guint bytes_per_sample;
  guint max_buf_size;

  guint32   total_frames;

  guint32 ssnd_offset;
  guint32 ssnd_blocksize;

  /* position in data part */
  guint64	offset;
  guint64	end_offset;
  guint64 	dataleft;
  /* offset/length of data part */
  guint64 	datastart;
  guint64 	datasize;
  /* duration in time */
  guint64 	duration;

  /* pending seek */
  GstEvent *seek_event;

  /* For streaming */
  GstAdapter *adapter;
  gboolean got_comm;
  gboolean streaming;

  /* configured segment, start/stop expressed in time */
  GstSegment segment;
  gboolean segment_running;

  /* discont after seek */
  gboolean discont;

  /* tags */
  GstTagList *tags;
};
</STRUCT>
<STRUCT>
<NAME>GstAiffParseClass</NAME>
struct _GstAiffParseClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_aiff_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AIFF_MUX</NAME>
#define GST_TYPE_AIFF_MUX \
  (gst_aiff_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_AIFF_MUX</NAME>
#define GST_AIFF_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AIFF_MUX,GstAiffMux))
</MACRO>
<MACRO>
<NAME>GST_AIFF_MUX_CLASS</NAME>
#define GST_AIFF_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AIFF_MUX,GstAiffMuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AIFF_MUX</NAME>
#define GST_IS_AIFF_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AIFF_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_AIFF_MUX_CLASS</NAME>
#define GST_IS_AIFF_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AIFF_MUX))
</MACRO>
<STRUCT>
<NAME>GstAiffMux</NAME>
struct _GstAiffMux
{
  GstElement element;

  /*< private >*/
  GstPad *sinkpad;
  GstPad *srcpad;

  GstAudioInfo info;

  guint32 length;
  gboolean sent_header;
  gboolean overflow;
};
</STRUCT>
<STRUCT>
<NAME>GstAiffMuxClass</NAME>
struct _GstAiffMuxClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_aiff_mux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUTO_CONVERT</NAME>
#define GST_TYPE_AUTO_CONVERT 	        	(gst_auto_convert_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUTO_CONVERT</NAME>
#define GST_AUTO_CONVERT(obj)	                (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_AUTO_CONVERT,GstAutoConvert))
</MACRO>
<MACRO>
<NAME>GST_AUTO_CONVERT_CLASS</NAME>
#define GST_AUTO_CONVERT_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_AUTO_CONVERT,GstAutoConvertClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUTO_CONVERT</NAME>
#define GST_IS_AUTO_CONVERT(obj)              (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_AUTO_CONVERT))
</MACRO>
<MACRO>
<NAME>GST_IS_AUTO_CONVERT_CLASS</NAME>
#define GST_IS_AUTO_CONVERT_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_AUTO_CONVERT))
</MACRO>
<STRUCT>
<NAME>GstAutoConvert</NAME>
struct _GstAutoConvert
{
  /*< private >*/
  GstBin bin;                   /* we extend GstBin */

  volatile GList *factories;

  GstPad *sinkpad;
  GstPad *srcpad;

  /* Have to be set all at once
   * Protected by the object lock and the stream lock
   * Both must be held to modify these
   */
  GstElement *current_subelement;
  GstPad *current_internal_srcpad;
  GstPad *current_internal_sinkpad;
};
</STRUCT>
<STRUCT>
<NAME>GstAutoConvertClass</NAME>
struct _GstAutoConvertClass
{
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_auto_convert_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SPACE_SCOPE</NAME>
#define GST_TYPE_SPACE_SCOPE            (gst_space_scope_get_type())
</MACRO>
<MACRO>
<NAME>GST_SPACE_SCOPE</NAME>
#define GST_SPACE_SCOPE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPACE_SCOPE,GstSpaceScope))
</MACRO>
<MACRO>
<NAME>GST_SPACE_SCOPE_CLASS</NAME>
#define GST_SPACE_SCOPE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPACE_SCOPE,GstSpaceScopeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SPACE_SCOPE</NAME>
#define GST_IS_SPACE_SCOPE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPACE_SCOPE))
</MACRO>
<MACRO>
<NAME>GST_IS_SPACE_SCOPE_CLASS</NAME>
#define GST_IS_SPACE_SCOPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPACE_SCOPE))
</MACRO>
<USER_FUNCTION>
<NAME>GstSpaceScopeProcessFunc</NAME>
<RETURNS>void </RETURNS>
GstAudioVisualizer *, guint32 *, gint16 *, guint
</USER_FUNCTION>
<STRUCT>
<NAME>GstSpaceScope</NAME>
struct _GstSpaceScope
{
  GstAudioVisualizer parent;

  /* < private > */
  GstSpaceScopeProcessFunc process;
  gint style;

  /* filter specific data */
  gdouble f1l_l, f1l_m, f1l_h;
  gdouble f1r_l, f1r_m, f1r_h;
  gdouble f2l_l, f2l_m, f2l_h;
  gdouble f2r_l, f2r_m, f2r_h;
};
</STRUCT>
<STRUCT>
<NAME>GstSpaceScopeClass</NAME>
struct _GstSpaceScopeClass
{
  GstAudioVisualizerClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_space_scope_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_space_scope_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SPECTRA_SCOPE</NAME>
#define GST_TYPE_SPECTRA_SCOPE            (gst_spectra_scope_get_type())
</MACRO>
<MACRO>
<NAME>GST_SPECTRA_SCOPE</NAME>
#define GST_SPECTRA_SCOPE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPECTRA_SCOPE,GstSpectraScope))
</MACRO>
<MACRO>
<NAME>GST_SPECTRA_SCOPE_CLASS</NAME>
#define GST_SPECTRA_SCOPE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPECTRA_SCOPE,GstSpectraScopeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SPECTRA_SCOPE</NAME>
#define GST_IS_SPECTRA_SCOPE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPECTRA_SCOPE))
</MACRO>
<MACRO>
<NAME>GST_IS_SPECTRA_SCOPE_CLASS</NAME>
#define GST_IS_SPECTRA_SCOPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPECTRA_SCOPE))
</MACRO>
<STRUCT>
<NAME>GstSpectraScope</NAME>
struct _GstSpectraScope
{
  GstAudioVisualizer parent;

  GstFFTS16 *fft_ctx;
  GstFFTS16Complex *freq_data;
};
</STRUCT>
<STRUCT>
<NAME>GstSpectraScopeClass</NAME>
struct _GstSpectraScopeClass
{
  GstAudioVisualizerClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_spectra_scope_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_spectra_scope_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SYNAE_SCOPE</NAME>
#define GST_TYPE_SYNAE_SCOPE            (gst_synae_scope_get_type())
</MACRO>
<MACRO>
<NAME>GST_SYNAE_SCOPE</NAME>
#define GST_SYNAE_SCOPE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SYNAE_SCOPE,GstSynaeScope))
</MACRO>
<MACRO>
<NAME>GST_SYNAE_SCOPE_CLASS</NAME>
#define GST_SYNAE_SCOPE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SYNAE_SCOPE,GstSynaeScopeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SYNAE_SCOPE</NAME>
#define GST_IS_SYNAE_SCOPE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SYNAE_SCOPE))
</MACRO>
<MACRO>
<NAME>GST_IS_SYNAE_SCOPE_CLASS</NAME>
#define GST_IS_SYNAE_SCOPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SYNAE_SCOPE))
</MACRO>
<STRUCT>
<NAME>GstSynaeScope</NAME>
struct _GstSynaeScope
{
  GstAudioVisualizer parent;

  GstFFTS16 *fft_ctx;
  GstFFTS16Complex *freq_data_l, *freq_data_r;
  gint16 *adata_l, *adata_r;

  guint32 colors[256];
  guint shade[256];
};
</STRUCT>
<STRUCT>
<NAME>GstSynaeScopeClass</NAME>
struct _GstSynaeScopeClass
{
  GstAudioVisualizerClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_synae_scope_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_synae_scope_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WAVE_SCOPE</NAME>
#define GST_TYPE_WAVE_SCOPE            (gst_wave_scope_get_type())
</MACRO>
<MACRO>
<NAME>GST_WAVE_SCOPE</NAME>
#define GST_WAVE_SCOPE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WAVE_SCOPE,GstWaveScope))
</MACRO>
<MACRO>
<NAME>GST_WAVE_SCOPE_CLASS</NAME>
#define GST_WAVE_SCOPE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WAVE_SCOPE,GstWaveScopeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WAVE_SCOPE</NAME>
#define GST_IS_WAVE_SCOPE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WAVE_SCOPE))
</MACRO>
<MACRO>
<NAME>GST_IS_WAVE_SCOPE_CLASS</NAME>
#define GST_IS_WAVE_SCOPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WAVE_SCOPE))
</MACRO>
<USER_FUNCTION>
<NAME>GstWaveScopeProcessFunc</NAME>
<RETURNS>void </RETURNS>
GstAudioVisualizer *, guint32 *, gint16 *, guint
</USER_FUNCTION>
<STRUCT>
<NAME>GstWaveScope</NAME>
struct _GstWaveScope
{
  GstAudioVisualizer parent;
  
  /* < private > */
  GstWaveScopeProcessFunc process;
  gint style;

  /* filter specific data */
  gdouble *flt;
};
</STRUCT>
<STRUCT>
<NAME>GstWaveScopeClass</NAME>
struct _GstWaveScopeClass
{
  GstAudioVisualizerClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wave_scope_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_wave_scope_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GstCameraBin2</NAME>
#define GstCameraBin2 GstCameraBin
</MACRO>
<MACRO>
<NAME>GstCameraBin2Class</NAME>
#define GstCameraBin2Class GstCameraBinClass
</MACRO>
<MACRO>
<NAME>GST_TYPE_CAMERA_BIN2</NAME>
#define GST_TYPE_CAMERA_BIN2   (gst_camera_bin2_get_type())
</MACRO>
<MACRO>
<NAME>GST_CAMERA_BIN2</NAME>
#define GST_CAMERA_BIN2(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CAMERA_BIN2,GstCameraBin2))
</MACRO>
<MACRO>
<NAME>GST_CAMERA_BIN2_CAST</NAME>
#define GST_CAMERA_BIN2_CAST(obj)   ((GstCameraBin2 *) obj)
</MACRO>
<MACRO>
<NAME>GST_CAMERA_BIN2_CLASS</NAME>
#define GST_CAMERA_BIN2_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CAMERA_BIN2,GstCameraBin2Class))
</MACRO>
<MACRO>
<NAME>GST_IS_CAMERA_BIN2</NAME>
#define GST_IS_CAMERA_BIN2(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CAMERA_BIN2))
</MACRO>
<MACRO>
<NAME>GST_IS_CAMERA_BIN2_CLASS</NAME>
#define GST_IS_CAMERA_BIN2_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CAMERA_BIN2))
</MACRO>
<ENUM>
<NAME>GstCamFlags</NAME>
typedef enum
{
  /* matches GstEncFlags GST_ENC_FLAG_NO_AUDIO_CONVERSION in encodebin */
  GST_CAM_FLAG_NO_AUDIO_CONVERSION = (1 << 0),
  /* matches GstEncFlags GST_ENC_FLAG_NO_VIDEO_CONVERSION in encodebin */
  GST_CAM_FLAG_NO_VIDEO_CONVERSION = (1 << 1),
  /* maps to 'disable-converters' property in viewfinderbin */
  GST_CAM_FLAG_NO_VIEWFINDER_CONVERSION = (1 << 2),
  /* maps to GstEncFlags GST_ENC_FLAG_NO_VIDEO_CONVERSION in the image bin's
   * encodebin */
  GST_CAM_FLAG_NO_IMAGE_CONVERSION = (1 << 3)
} GstCamFlags;
</ENUM>
<ENUM>
<NAME>GstCameraBinVideoState</NAME>
typedef enum _GstCameraBinVideoState
{
  GST_CAMERA_BIN_VIDEO_IDLE=0,
  GST_CAMERA_BIN_VIDEO_STARTING=1,
  GST_CAMERA_BIN_VIDEO_RECORDING=2,
  GST_CAMERA_BIN_VIDEO_FINISHING=3
} GstCameraBinVideoState;
</ENUM>
<FUNCTION>
<NAME>gst_camera_bin2_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_camera_bin2_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<STRUCT>
<NAME>GstCameraBin2</NAME>
</STRUCT>
<STRUCT>
<NAME>GstCameraBin2Class</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_COLOR_EFFECTS</NAME>
#define GST_TYPE_COLOR_EFFECTS \
  (gst_color_effects_get_type())
</MACRO>
<MACRO>
<NAME>GST_COLOR_EFFECTS</NAME>
#define GST_COLOR_EFFECTS(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_COLOR_EFFECTS,GstColorEffects))
</MACRO>
<MACRO>
<NAME>GST_COLOR_EFFECTS_CLASS</NAME>
#define GST_COLOR_EFFECTS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_COLOR_EFFECTS,GstColorEffectsClass))
</MACRO>
<MACRO>
<NAME>GST_IS_COLOR_EFFECTS</NAME>
#define GST_IS_COLOR_EFFECTS(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_COLOR_EFFECTS))
</MACRO>
<MACRO>
<NAME>GST_IS_COLOR_EFFECTS_CLASS</NAME>
#define GST_IS_COLOR_EFFECTS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_COLOR_EFFECTS))
</MACRO>
<ENUM>
<NAME>GstColorEffectsPreset</NAME>
typedef enum
{
  GST_COLOR_EFFECTS_PRESET_NONE,
  GST_COLOR_EFFECTS_PRESET_HEAT,
  GST_COLOR_EFFECTS_PRESET_SEPIA,
  GST_COLOR_EFFECTS_PRESET_XRAY,
  GST_COLOR_EFFECTS_PRESET_XPRO,
  GST_COLOR_EFFECTS_PRESET_YELLOWBLUE,
} GstColorEffectsPreset;
</ENUM>
<STRUCT>
<NAME>GstColorEffects</NAME>
struct _GstColorEffects
{
  GstVideoFilter videofilter;

  /* < private > */
  GstColorEffectsPreset preset;
  const guint8 *table;
  gboolean map_luma;

  /* video format */
  GstVideoFormat format;
  gint width;
  gint height;

  void (*process) (GstColorEffects * filter, GstVideoFrame * frame);
};
</STRUCT>
<STRUCT>
<NAME>GstColorEffectsClass</NAME>
struct _GstColorEffectsClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_color_effects_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FPS_DISPLAY_SINK</NAME>
#define GST_TYPE_FPS_DISPLAY_SINK \
  (fps_display_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_FPS_DISPLAY_SINK</NAME>
#define GST_FPS_DISPLAY_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FPS_DISPLAY_SINK,GstFPSDisplaySink))
</MACRO>
<MACRO>
<NAME>GST_FPS_DISPLAY_SINK_CLASS</NAME>
#define GST_FPS_DISPLAY_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FPS_DISPLAY_SINK,GstFPSDisplaySinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FPS_DISPLAY_SINK</NAME>
#define GST_IS_FPS_DISPLAY_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FPS_DISPLAY_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_FPS_DISPLAY_SINK_CLASS</NAME>
#define GST_IS_FPS_DISPLAY_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FPS_DISPLAY_SINK))
</MACRO>
<FUNCTION>
<NAME>fps_display_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstFPSDisplaySink</NAME>
struct _GstFPSDisplaySink
{
  GstBin bin;

  /*< private >*/
  /* gstreamer components */
  GstElement *text_overlay;
  GstElement *video_sink;
  GstPad *ghost_pad;

  /* statistics */
  gint frames_rendered, frames_dropped;  /* ATOMIC */
  guint64 last_frames_rendered, last_frames_dropped;

  GstClockTime start_ts;
  GstClockTime last_ts;
  GstClockTime interval_ts;
  guint data_probe_id;

  /* properties */
  gboolean sync;
  gboolean use_text_overlay;
  gboolean signal_measurements;
  GstClockTime fps_update_interval;
  gdouble max_fps;
  gdouble min_fps;
  gboolean silent;
  gchar *last_message;
};
</STRUCT>
<STRUCT>
<NAME>GstFPSDisplaySinkClass</NAME>
struct _GstFPSDisplaySinkClass
{
  GstBinClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_DVD_SPU</NAME>
#define GST_TYPE_DVD_SPU \
  (gst_dvd_spu_get_type())
</MACRO>
<MACRO>
<NAME>GST_DVD_SPU</NAME>
#define GST_DVD_SPU(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DVD_SPU,GstDVDSpu))
</MACRO>
<MACRO>
<NAME>GST_DVD_SPU_CLASS</NAME>
#define GST_DVD_SPU_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DVD_SPU,GstDVDSpuClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DVD_SPU</NAME>
#define GST_IS_DVD_SPU(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DVD_SPU))
</MACRO>
<MACRO>
<NAME>GST_IS_DVD_SPU_CLASS</NAME>
#define GST_IS_DVD_SPU_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DVD_SPU))
</MACRO>
<MACRO>
<NAME>DVD_SPU_LOCK</NAME>
#define DVD_SPU_LOCK(s) g_mutex_lock (&(s)->spu_lock);
</MACRO>
<MACRO>
<NAME>DVD_SPU_UNLOCK</NAME>
#define DVD_SPU_UNLOCK(s) g_mutex_unlock (&(s)->spu_lock);
</MACRO>
<TYPEDEF>
<NAME>SpuPacket</NAME>
typedef struct SpuPacket SpuPacket;
</TYPEDEF>
<ENUM>
<NAME>SpuInputType</NAME>
enum SpuInputType {
  SPU_INPUT_TYPE_NONE   = 0x00,
  SPU_INPUT_TYPE_VOBSUB = 0x01,
  SPU_INPUT_TYPE_PGS    = 0x02
};
</ENUM>
<ENUM>
<NAME>SpuStateFlags</NAME>
enum SpuStateFlags {
  SPU_STATE_NONE        = 0x00,
  /* Flags cleared on a flush */
  SPU_STATE_DISPLAY     = 0x01,
  SPU_STATE_FORCED_DSP  = 0x02,
  SPU_STATE_STILL_FRAME = 0x04,
  /* Persistent flags */
  SPU_STATE_FORCED_ONLY = 0x100
};
</ENUM>
<MACRO>
<NAME>SPU_STATE_FLAGS_MASK</NAME>
#define SPU_STATE_FLAGS_MASK (0xff)
</MACRO>
<STRUCT>
<NAME>SpuState</NAME>
struct SpuState {
  GstClockTime next_ts; /* Next event TS in running time */
  SpuStateFlags flags;

  GstVideoInfo info;

  guint32 *comp_bufs[3]; /* Compositing buffers for U+V & A */
  guint16 comp_left;
  guint16 comp_right;

  SpuVobsubState vobsub;
  SpuPgsState pgs;
};
</STRUCT>
<STRUCT>
<NAME>GstDVDSpu</NAME>
struct _GstDVDSpu {
  GstElement element;

  GstPad *videosinkpad;
  GstPad *subpic_sinkpad;
  GstPad *srcpad;

  /* Mutex to protect state we access from different chain funcs */
  GMutex spu_lock;

  GstSegment video_seg;
  GstSegment subp_seg;

  SpuState spu_state;
  SpuInputType spu_input_type;

  /* GQueue of SpuBuf structures */
  GQueue *pending_spus;

  /* Accumulator for collecting partial SPU buffers until they're complete */
  GstBuffer *partial_spu;

  /* Store either a reference or a copy of the last video frame for duplication
   * during still-frame conditions */
  GstBuffer *ref_frame;

  /* Buffer to push after handling a DVD event, if any */
  GstBuffer *pending_frame;
};
</STRUCT>
<STRUCT>
<NAME>GstDVDSpuClass</NAME>
struct _GstDVDSpuClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dvd_spu_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstDVDSPUDebugFlags</NAME>
typedef enum {
  GST_DVD_SPU_DEBUG_RENDER_RECTANGLE = (1 << 0),
  GST_DVD_SPU_DEBUG_HIGHLIGHT_RECTANGLE = (1 << 1)
} GstDVDSPUDebugFlags;
</ENUM>
<VARIABLE>
<NAME>dvdspu_debug_flags</NAME>
extern GstDVDSPUDebugFlags dvdspu_debug_flags;
</VARIABLE>
<MACRO>
<NAME>FESTIVAL_DEFAULT_SERVER_HOST</NAME>
#define FESTIVAL_DEFAULT_SERVER_HOST "localhost"
</MACRO>
<MACRO>
<NAME>FESTIVAL_DEFAULT_SERVER_PORT</NAME>
#define FESTIVAL_DEFAULT_SERVER_PORT 1314
</MACRO>
<MACRO>
<NAME>FESTIVAL_DEFAULT_TEXT_MODE</NAME>
#define FESTIVAL_DEFAULT_TEXT_MODE "fundamental"
</MACRO>
<MACRO>
<NAME>GST_TYPE_FESTIVAL</NAME>
#define GST_TYPE_FESTIVAL \
  (gst_festival_get_type())
</MACRO>
<MACRO>
<NAME>GST_FESTIVAL</NAME>
#define GST_FESTIVAL(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FESTIVAL,GstFestival))
</MACRO>
<MACRO>
<NAME>GST_FESTIVAL_CLASS</NAME>
#define GST_FESTIVAL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FESTIVAL,GstFestivalClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FESTIVAL</NAME>
#define GST_IS_FESTIVAL(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FESTIVAL))
</MACRO>
<MACRO>
<NAME>GST_IS_FESTIVAL_CLASS</NAME>
#define GST_IS_FESTIVAL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FESTIVAL))
</MACRO>
<ENUM>
<NAME>GstFestivalFlags</NAME>
typedef enum {
  GST_FESTIVAL_OPEN             = (GST_ELEMENT_FLAG_LAST << 0),

  GST_FESTIVAL_FLAG_LAST        = (GST_ELEMENT_FLAG_LAST << 2),
} GstFestivalFlags;
</ENUM>
<STRUCT>
<NAME>GstFestival</NAME>
struct _GstFestival {
  GstElement element;

  /* pads */
  GstPad *sinkpad,*srcpad;

  FT_Info *info;
};
</STRUCT>
<STRUCT>
<NAME>GstFestivalClass</NAME>
struct _GstFestivalClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_festival_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_BURN</NAME>
#define GST_TYPE_BURN \
  (gst_burn_get_type())
</MACRO>
<MACRO>
<NAME>GST_BURN</NAME>
#define GST_BURN(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BURN,GstBurn))
</MACRO>
<MACRO>
<NAME>GST_BURN_CLASS</NAME>
#define GST_BURN_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BURN,GstBurnClass))
</MACRO>
<MACRO>
<NAME>GST_IS_BURN</NAME>
#define GST_IS_BURN(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BURN))
</MACRO>
<MACRO>
<NAME>GST_IS_BURN_CLASS</NAME>
#define GST_IS_BURN_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BURN))
</MACRO>
<STRUCT>
<NAME>GstBurn</NAME>
struct _GstBurn
{
  GstVideoFilter videofilter;

  /* < private > */
  gint adjustment;
};
</STRUCT>
<STRUCT>
<NAME>GstBurnClass</NAME>
struct _GstBurnClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_burn_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CHROMIUM</NAME>
#define GST_TYPE_CHROMIUM (gst_chromium_get_type())
</MACRO>
<MACRO>
<NAME>GST_CHROMIUM</NAME>
#define GST_CHROMIUM(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CHROMIUM,GstChromium))
</MACRO>
<MACRO>
<NAME>GST_CHROMIUM_CLASS</NAME>
#define GST_CHROMIUM_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CHROMIUM,GstChromiumClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CHROMIUM</NAME>
#define GST_IS_CHROMIUM(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CHROMIUM))
</MACRO>
<MACRO>
<NAME>GST_IS_CHROMIUM_CLASS</NAME>
#define GST_IS_CHROMIUM_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CHROMIUM))
</MACRO>
<STRUCT>
<NAME>GstChromium</NAME>
struct _GstChromium
{
  GstVideoFilter videofilter;

  /* < private > */
  gint edge_a, edge_b;
};
</STRUCT>
<STRUCT>
<NAME>GstChromiumClass</NAME>
struct _GstChromiumClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_chromium_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DILATE</NAME>
#define GST_TYPE_DILATE \
  (gst_dilate_get_type())
</MACRO>
<MACRO>
<NAME>GST_DILATE</NAME>
#define GST_DILATE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DILATE,GstDilate))
</MACRO>
<MACRO>
<NAME>GST_DILATE_CLASS</NAME>
#define GST_DILATE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DILATE,GstDilateClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DILATE</NAME>
#define GST_IS_DILATE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DILATE))
</MACRO>
<MACRO>
<NAME>GST_IS_DILATE_CLASS</NAME>
#define GST_IS_DILATE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DILATE))
</MACRO>
<STRUCT>
<NAME>GstDilate</NAME>
struct _GstDilate
{
  GstVideoFilter videofilter;

  /* < private > */
  gboolean erode;
};
</STRUCT>
<STRUCT>
<NAME>GstDilateClass</NAME>
struct _GstDilateClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dilate_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DODGE</NAME>
#define GST_TYPE_DODGE \
  (gst_dodge_get_type())
</MACRO>
<MACRO>
<NAME>GST_DODGE</NAME>
#define GST_DODGE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DODGE,GstDodge))
</MACRO>
<MACRO>
<NAME>GST_DODGE_CLASS</NAME>
#define GST_DODGE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DODGE,GstDodgeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DODGE</NAME>
#define GST_IS_DODGE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DODGE))
</MACRO>
<MACRO>
<NAME>GST_IS_DODGE_CLASS</NAME>
#define GST_IS_DODGE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DODGE))
</MACRO>
<STRUCT>
<NAME>GstDodge</NAME>
struct _GstDodge
{
  GstVideoFilter videofilter;
};
</STRUCT>
<STRUCT>
<NAME>GstDodgeClass</NAME>
struct _GstDodgeClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dodge_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_EXCLUSION</NAME>
#define GST_TYPE_EXCLUSION \
  (gst_exclusion_get_type())
</MACRO>
<MACRO>
<NAME>GST_EXCLUSION</NAME>
#define GST_EXCLUSION(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_EXCLUSION,GstExclusion))
</MACRO>
<MACRO>
<NAME>GST_EXCLUSION_CLASS</NAME>
#define GST_EXCLUSION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_EXCLUSION,GstExclusionClass))
</MACRO>
<MACRO>
<NAME>GST_IS_EXCLUSION</NAME>
#define GST_IS_EXCLUSION(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_EXCLUSION))
</MACRO>
<MACRO>
<NAME>GST_IS_EXCLUSION_CLASS</NAME>
#define GST_IS_EXCLUSION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_EXCLUSION))
</MACRO>
<STRUCT>
<NAME>GstExclusion</NAME>
struct _GstExclusion
{
  GstVideoFilter videofilter;

  /* < private > */
  gint factor;
};
</STRUCT>
<STRUCT>
<NAME>GstExclusionClass</NAME>
struct _GstExclusionClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_exclusion_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GAUSSIANBLUR</NAME>
#define GST_TYPE_GAUSSIANBLUR (gst_gaussianblur_get_type())
</MACRO>
<MACRO>
<NAME>GST_GAUSSIANBLUR</NAME>
#define GST_GAUSSIANBLUR(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GAUSSIANBLUR, GstGaussianBlur))
</MACRO>
<STRUCT>
<NAME>GstGaussianBlur</NAME>
struct _GstGaussianBlur
{
  GstVideoFilter videofilter;
  gint width, height, stride;

  float cur_sigma, sigma;
  int windowsize;

  float *kernel;
  float *kernel_sum;
  float *tempim;
  gint16 *smoothedim;
};
</STRUCT>
<STRUCT>
<NAME>GstGaussianBlurClass</NAME>
struct _GstGaussianBlurClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gaussianblur_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_burn_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_chromium_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_dilate_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_dodge_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_exclusion_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_gauss_blur_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_solarize_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SOLARIZE</NAME>
#define GST_TYPE_SOLARIZE \
  (gst_solarize_get_type())
</MACRO>
<MACRO>
<NAME>GST_SOLARIZE</NAME>
#define GST_SOLARIZE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SOLARIZE,GstSolarize))
</MACRO>
<MACRO>
<NAME>GST_SOLARIZE_CLASS</NAME>
#define GST_SOLARIZE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SOLARIZE,GstSolarizeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SOLARIZE</NAME>
#define GST_IS_SOLARIZE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SOLARIZE))
</MACRO>
<MACRO>
<NAME>GST_IS_SOLARIZE_CLASS</NAME>
#define GST_IS_SOLARIZE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SOLARIZE))
</MACRO>
<STRUCT>
<NAME>GstSolarize</NAME>
struct _GstSolarize
{
  GstVideoFilter videofilter;

  /* < private > */
  gint threshold, start, end;
};
</STRUCT>
<STRUCT>
<NAME>GstSolarizeClass</NAME>
struct _GstSolarizeClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_solarize_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_BULGE</NAME>
#define GST_TYPE_BULGE \
  (gst_bulge_get_type())
</MACRO>
<MACRO>
<NAME>GST_BULGE</NAME>
#define GST_BULGE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BULGE,GstBulge))
</MACRO>
<MACRO>
<NAME>GST_BULGE_CAST</NAME>
#define GST_BULGE_CAST(obj) \
  ((GstBulge *)(obj))
</MACRO>
<MACRO>
<NAME>GST_BULGE_CLASS</NAME>
#define GST_BULGE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BULGE,GstBulgeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_BULGE</NAME>
#define GST_IS_BULGE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BULGE))
</MACRO>
<MACRO>
<NAME>GST_IS_BULGE_CLASS</NAME>
#define GST_IS_BULGE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BULGE))
</MACRO>
<STRUCT>
<NAME>GstBulge</NAME>
struct _GstBulge
{
  GstCircleGeometricTransform element;

  gdouble zoom;
};
</STRUCT>
<STRUCT>
<NAME>GstBulgeClass</NAME>
struct _GstBulgeClass
{
  GstCircleGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_bulge_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_bulge_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CIRCLE</NAME>
#define GST_TYPE_CIRCLE \
  (gst_circle_get_type())
</MACRO>
<MACRO>
<NAME>GST_CIRCLE</NAME>
#define GST_CIRCLE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CIRCLE,GstCircle))
</MACRO>
<MACRO>
<NAME>GST_CIRCLE_CAST</NAME>
#define GST_CIRCLE_CAST(obj) \
  ((GstCircle *)(obj))
</MACRO>
<MACRO>
<NAME>GST_CIRCLE_CLASS</NAME>
#define GST_CIRCLE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CIRCLE,GstCircleClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CIRCLE</NAME>
#define GST_IS_CIRCLE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CIRCLE))
</MACRO>
<MACRO>
<NAME>GST_IS_CIRCLE_CLASS</NAME>
#define GST_IS_CIRCLE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CIRCLE))
</MACRO>
<STRUCT>
<NAME>GstCircle</NAME>
struct _GstCircle
{
  GstCircleGeometricTransform element;

  gdouble angle;
  gdouble spread_angle;
  gint height;
};
</STRUCT>
<STRUCT>
<NAME>GstCircleClass</NAME>
struct _GstCircleClass
{
  GstCircleGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_circle_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_circle_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DIFFUSE</NAME>
#define GST_TYPE_DIFFUSE \
  (gst_diffuse_get_type())
</MACRO>
<MACRO>
<NAME>GST_DIFFUSE</NAME>
#define GST_DIFFUSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DIFFUSE,GstDiffuse))
</MACRO>
<MACRO>
<NAME>GST_DIFFUSE_CAST</NAME>
#define GST_DIFFUSE_CAST(obj) \
  ((GstDiffuse *)(obj))
</MACRO>
<MACRO>
<NAME>GST_DIFFUSE_CLASS</NAME>
#define GST_DIFFUSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DIFFUSE,GstDiffuseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DIFFUSE</NAME>
#define GST_IS_DIFFUSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DIFFUSE))
</MACRO>
<MACRO>
<NAME>GST_IS_DIFFUSE_CLASS</NAME>
#define GST_IS_DIFFUSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DIFFUSE))
</MACRO>
<STRUCT>
<NAME>GstDiffuse</NAME>
struct _GstDiffuse
{
  GstGeometricTransform element;

  gdouble scale;

  gdouble *sin_table;
  gdouble *cos_table;
};
</STRUCT>
<STRUCT>
<NAME>GstDiffuseClass</NAME>
struct _GstDiffuseClass
{
  GstGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_diffuse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_diffuse_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FISHEYE</NAME>
#define GST_TYPE_FISHEYE \
  (gst_fisheye_get_type())
</MACRO>
<MACRO>
<NAME>GST_FISHEYE</NAME>
#define GST_FISHEYE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FISHEYE,GstFisheye))
</MACRO>
<MACRO>
<NAME>GST_FISHEYE_CAST</NAME>
#define GST_FISHEYE_CAST(obj) \
  ((GstFisheye *)(obj))
</MACRO>
<MACRO>
<NAME>GST_FISHEYE_CLASS</NAME>
#define GST_FISHEYE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FISHEYE,GstFisheyeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FISHEYE</NAME>
#define GST_IS_FISHEYE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FISHEYE))
</MACRO>
<MACRO>
<NAME>GST_IS_FISHEYE_CLASS</NAME>
#define GST_IS_FISHEYE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FISHEYE))
</MACRO>
<STRUCT>
<NAME>GstFisheye</NAME>
struct _GstFisheye
{
  GstGeometricTransform element;
};
</STRUCT>
<STRUCT>
<NAME>GstFisheyeClass</NAME>
struct _GstFisheyeClass
{
  GstGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_fisheye_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_fisheye_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_KALEIDOSCOPE</NAME>
#define GST_TYPE_KALEIDOSCOPE \
  (gst_kaleidoscope_get_type())
</MACRO>
<MACRO>
<NAME>GST_KALEIDOSCOPE</NAME>
#define GST_KALEIDOSCOPE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_KALEIDOSCOPE,GstKaleidoscope))
</MACRO>
<MACRO>
<NAME>GST_KALEIDOSCOPE_CAST</NAME>
#define GST_KALEIDOSCOPE_CAST(obj) \
  ((GstKaleidoscope *)(obj))
</MACRO>
<MACRO>
<NAME>GST_KALEIDOSCOPE_CLASS</NAME>
#define GST_KALEIDOSCOPE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_KALEIDOSCOPE,GstKaleidoscopeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_KALEIDOSCOPE</NAME>
#define GST_IS_KALEIDOSCOPE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_KALEIDOSCOPE))
</MACRO>
<MACRO>
<NAME>GST_IS_KALEIDOSCOPE_CLASS</NAME>
#define GST_IS_KALEIDOSCOPE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_KALEIDOSCOPE))
</MACRO>
<STRUCT>
<NAME>GstKaleidoscope</NAME>
struct _GstKaleidoscope
{
  GstCircleGeometricTransform element;

  gdouble angle;
  gdouble angle2;
  gint sides;
};
</STRUCT>
<STRUCT>
<NAME>GstKaleidoscopeClass</NAME>
struct _GstKaleidoscopeClass
{
  GstCircleGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_kaleidoscope_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_kaleidoscope_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MARBLE</NAME>
#define GST_TYPE_MARBLE \
  (gst_marble_get_type())
</MACRO>
<MACRO>
<NAME>GST_MARBLE</NAME>
#define GST_MARBLE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MARBLE,GstMarble))
</MACRO>
<MACRO>
<NAME>GST_MARBLE_CAST</NAME>
#define GST_MARBLE_CAST(obj) \
  ((GstMarble *)(obj))
</MACRO>
<MACRO>
<NAME>GST_MARBLE_CLASS</NAME>
#define GST_MARBLE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MARBLE,GstMarbleClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MARBLE</NAME>
#define GST_IS_MARBLE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MARBLE))
</MACRO>
<MACRO>
<NAME>GST_IS_MARBLE_CLASS</NAME>
#define GST_IS_MARBLE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MARBLE))
</MACRO>
<STRUCT>
<NAME>GstMarble</NAME>
struct _GstMarble
{
  GstGeometricTransform element;

  gdouble xscale;
  gdouble yscale;
  gdouble turbulence;
  gdouble amount;

  GstGMNoise *noise;
  gdouble *sin_table;
  gdouble *cos_table;
};
</STRUCT>
<STRUCT>
<NAME>GstMarbleClass</NAME>
struct _GstMarbleClass
{
  GstGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_marble_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_marble_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MIRROR</NAME>
#define GST_TYPE_MIRROR \
  (gst_mirror_get_type())
</MACRO>
<MACRO>
<NAME>GST_MIRROR</NAME>
#define GST_MIRROR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MIRROR,GstMirror))
</MACRO>
<MACRO>
<NAME>GST_MIRROR_CAST</NAME>
#define GST_MIRROR_CAST(obj) \
  ((GstMirror *)(obj))
</MACRO>
<MACRO>
<NAME>GST_MIRROR_CLASS</NAME>
#define GST_MIRROR_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MIRROR,GstMirrorClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MIRROR</NAME>
#define GST_IS_MIRROR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MIRROR))
</MACRO>
<MACRO>
<NAME>GST_IS_MIRROR_CLASS</NAME>
#define GST_IS_MIRROR_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MIRROR))
</MACRO>
<ENUM>
<NAME>GstMirrorMode</NAME>
typedef enum
{
  GST_MIRROR_MODE_LEFT,
  GST_MIRROR_MODE_RIGHT,
  GST_MIRROR_MODE_TOP,
  GST_MIRROR_MODE_BOTTOM
} GstMirrorMode;
</ENUM>
<STRUCT>
<NAME>GstMirror</NAME>
struct _GstMirror
{
  GstGeometricTransform element;

  GstMirrorMode mode;
};
</STRUCT>
<STRUCT>
<NAME>GstMirrorClass</NAME>
struct _GstMirrorClass
{
  GstGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mirror_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_mirror_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PINCH</NAME>
#define GST_TYPE_PINCH \
  (gst_pinch_get_type())
</MACRO>
<MACRO>
<NAME>GST_PINCH</NAME>
#define GST_PINCH(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PINCH,GstPinch))
</MACRO>
<MACRO>
<NAME>GST_PINCH_CAST</NAME>
#define GST_PINCH_CAST(obj) \
  ((GstPinch *)(obj))
</MACRO>
<MACRO>
<NAME>GST_PINCH_CLASS</NAME>
#define GST_PINCH_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PINCH,GstPinchClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PINCH</NAME>
#define GST_IS_PINCH(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PINCH))
</MACRO>
<MACRO>
<NAME>GST_IS_PINCH_CLASS</NAME>
#define GST_IS_PINCH_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PINCH))
</MACRO>
<STRUCT>
<NAME>GstPinch</NAME>
struct _GstPinch
{
  GstCircleGeometricTransform element;

  gdouble intensity;
};
</STRUCT>
<STRUCT>
<NAME>GstPinchClass</NAME>
struct _GstPinchClass
{
  GstCircleGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_pinch_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_pinch_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SPHERE</NAME>
#define GST_TYPE_SPHERE \
  (gst_sphere_get_type())
</MACRO>
<MACRO>
<NAME>GST_SPHERE</NAME>
#define GST_SPHERE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPHERE,GstSphere))
</MACRO>
<MACRO>
<NAME>GST_SPHERE_CAST</NAME>
#define GST_SPHERE_CAST(obj) \
  ((GstSphere *)(obj))
</MACRO>
<MACRO>
<NAME>GST_SPHERE_CLASS</NAME>
#define GST_SPHERE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPHERE,GstSphereClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SPHERE</NAME>
#define GST_IS_SPHERE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPHERE))
</MACRO>
<MACRO>
<NAME>GST_IS_SPHERE_CLASS</NAME>
#define GST_IS_SPHERE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPHERE))
</MACRO>
<STRUCT>
<NAME>GstSphere</NAME>
struct _GstSphere
{
  GstCircleGeometricTransform element;

  gdouble refraction;
};
</STRUCT>
<STRUCT>
<NAME>GstSphereClass</NAME>
struct _GstSphereClass
{
  GstCircleGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_sphere_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_sphere_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SQUARE</NAME>
#define GST_TYPE_SQUARE \
  (gst_square_get_type())
</MACRO>
<MACRO>
<NAME>GST_SQUARE</NAME>
#define GST_SQUARE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SQUARE,GstSquare))
</MACRO>
<MACRO>
<NAME>GST_SQUARE_CAST</NAME>
#define GST_SQUARE_CAST(obj) \
  ((GstSquare *)(obj))
</MACRO>
<MACRO>
<NAME>GST_SQUARE_CLASS</NAME>
#define GST_SQUARE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SQUARE,GstSquareClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SQUARE</NAME>
#define GST_IS_SQUARE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SQUARE))
</MACRO>
<MACRO>
<NAME>GST_IS_SQUARE_CLASS</NAME>
#define GST_IS_SQUARE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SQUARE))
</MACRO>
<STRUCT>
<NAME>GstSquare</NAME>
struct _GstSquare
{
  GstGeometricTransform element;

  gdouble width, height;
  gdouble zoom;
};
</STRUCT>
<STRUCT>
<NAME>GstSquareClass</NAME>
struct _GstSquareClass
{
  GstGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_square_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_square_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_STRETCH</NAME>
#define GST_TYPE_STRETCH \
  (gst_stretch_get_type())
</MACRO>
<MACRO>
<NAME>GST_STRETCH</NAME>
#define GST_STRETCH(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_STRETCH,GstStretch))
</MACRO>
<MACRO>
<NAME>GST_STRETCH_CAST</NAME>
#define GST_STRETCH_CAST(obj) \
  ((GstStretch *)(obj))
</MACRO>
<MACRO>
<NAME>GST_STRETCH_CLASS</NAME>
#define GST_STRETCH_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_STRETCH,GstStretchClass))
</MACRO>
<MACRO>
<NAME>GST_IS_STRETCH</NAME>
#define GST_IS_STRETCH(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_STRETCH))
</MACRO>
<MACRO>
<NAME>GST_IS_STRETCH_CLASS</NAME>
#define GST_IS_STRETCH_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_STRETCH))
</MACRO>
<STRUCT>
<NAME>GstStretch</NAME>
struct _GstStretch
{
  GstCircleGeometricTransform element;

  gdouble intensity;
};
</STRUCT>
<STRUCT>
<NAME>GstStretchClass</NAME>
struct _GstStretchClass
{
  GstCircleGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_stretch_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_stretch_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TUNNEL</NAME>
#define GST_TYPE_TUNNEL \
  (gst_tunnel_get_type())
</MACRO>
<MACRO>
<NAME>GST_TUNNEL</NAME>
#define GST_TUNNEL(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TUNNEL,GstTunnel))
</MACRO>
<MACRO>
<NAME>GST_TUNNEL_CAST</NAME>
#define GST_TUNNEL_CAST(obj) \
  ((GstTunnel *)(obj))
</MACRO>
<MACRO>
<NAME>GST_TUNNEL_CLASS</NAME>
#define GST_TUNNEL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TUNNEL,GstTunnelClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TUNNEL</NAME>
#define GST_IS_TUNNEL(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TUNNEL))
</MACRO>
<MACRO>
<NAME>GST_IS_TUNNEL_CLASS</NAME>
#define GST_IS_TUNNEL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TUNNEL))
</MACRO>
<STRUCT>
<NAME>GstTunnel</NAME>
struct _GstTunnel
{
  GstCircleGeometricTransform element;
};
</STRUCT>
<STRUCT>
<NAME>GstTunnelClass</NAME>
struct _GstTunnelClass
{
  GstCircleGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_tunnel_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_tunnel_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TWIRL</NAME>
#define GST_TYPE_TWIRL \
  (gst_twirl_get_type())
</MACRO>
<MACRO>
<NAME>GST_TWIRL</NAME>
#define GST_TWIRL(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TWIRL,GstTwirl))
</MACRO>
<MACRO>
<NAME>GST_TWIRL_CAST</NAME>
#define GST_TWIRL_CAST(obj) \
  ((GstTwirl *)(obj))
</MACRO>
<MACRO>
<NAME>GST_TWIRL_CLASS</NAME>
#define GST_TWIRL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TWIRL,GstTwirlClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TWIRL</NAME>
#define GST_IS_TWIRL(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TWIRL))
</MACRO>
<MACRO>
<NAME>GST_IS_TWIRL_CLASS</NAME>
#define GST_IS_TWIRL_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TWIRL))
</MACRO>
<STRUCT>
<NAME>GstTwirl</NAME>
struct _GstTwirl
{
  GstCircleGeometricTransform element;

  gdouble angle;
};
</STRUCT>
<STRUCT>
<NAME>GstTwirlClass</NAME>
struct _GstTwirlClass
{
  GstCircleGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_twirl_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_twirl_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WATER_RIPPLE</NAME>
#define GST_TYPE_WATER_RIPPLE \
  (gst_water_ripple_get_type())
</MACRO>
<MACRO>
<NAME>GST_WATER_RIPPLE</NAME>
#define GST_WATER_RIPPLE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WATER_RIPPLE,GstWaterRipple))
</MACRO>
<MACRO>
<NAME>GST_WATER_RIPPLE_CAST</NAME>
#define GST_WATER_RIPPLE_CAST(obj) \
  ((GstWaterRipple *)(obj))
</MACRO>
<MACRO>
<NAME>GST_WATER_RIPPLE_CLASS</NAME>
#define GST_WATER_RIPPLE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WATER_RIPPLE,GstWaterRippleClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WATER_RIPPLE</NAME>
#define GST_IS_WATER_RIPPLE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WATER_RIPPLE))
</MACRO>
<MACRO>
<NAME>GST_IS_WATER_RIPPLE_CLASS</NAME>
#define GST_IS_WATER_RIPPLE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WATER_RIPPLE))
</MACRO>
<STRUCT>
<NAME>GstWaterRipple</NAME>
struct _GstWaterRipple
{
  GstCircleGeometricTransform element;

  gdouble phase;
  gdouble amplitude;
  gdouble wavelength;
};
</STRUCT>
<STRUCT>
<NAME>GstWaterRippleClass</NAME>
struct _GstWaterRippleClass
{
  GstCircleGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_water_ripple_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_water_ripple_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_IVF_PARSE</NAME>
#define GST_TYPE_IVF_PARSE \
  (gst_ivf_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_IVF_PARSE</NAME>
#define GST_IVF_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_IVF_PARSE,GstIvfParse))
</MACRO>
<MACRO>
<NAME>GST_IVF_PARSE_CLASS</NAME>
#define GST_IVF_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_IVF_PARSE,GstIvfParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_IVF_PARSE</NAME>
#define GST_IS_IVF_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_IVF_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_IVF_PARSE_CLASS</NAME>
#define GST_IS_IVF_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_IVF_PARSE))
</MACRO>
<ENUM>
<NAME>GstIvfParseState</NAME>
typedef enum {
  GST_IVF_PARSE_START,
  GST_IVF_PARSE_DATA
} GstIvfParseState;
</ENUM>
<STRUCT>
<NAME>GstIvfParse</NAME>
struct _GstIvfParse
{
  GstBaseParse baseparse;

  GstIvfParseState state;

  guint width;
  guint height;
  guint fps_n;
  guint fps_d;
  guint32 fourcc;
  gboolean update_caps;
};
</STRUCT>
<STRUCT>
<NAME>GstIvfParseClass</NAME>
struct _GstIvfParseClass
{
  GstBaseParseClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ivf_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_JPEG_PARSE</NAME>
#define GST_TYPE_JPEG_PARSE \
  (gst_jpeg_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_JPEG_PARSE</NAME>
#define GST_JPEG_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_JPEG_PARSE,GstJpegParse))
</MACRO>
<MACRO>
<NAME>GST_JPEG_PARSE_CLASS</NAME>
#define GST_JPEG_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_JPEG_PARSE,GstJpegParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_JPEG_PARSE</NAME>
#define GST_IS_JPEG_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_JPEG_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_JPEG_PARSE_CLASS</NAME>
#define GST_IS_JPEG_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_JPEG_PARSE))
</MACRO>
<MACRO>
<NAME>GST_JPEG_PARSE_CAST</NAME>
#define GST_JPEG_PARSE_CAST(obj) ((GstJpegParse *)obj)
</MACRO>
<STRUCT>
<NAME>GstJpegParse</NAME>
struct _GstJpegParse {
  GstBaseParse parse;
  GstJpegParsePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstJpegParseClass</NAME>
struct _GstJpegParseClass {
  GstBaseParseClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_jpeg_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstJpegParsePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_TS_DEMUX</NAME>
#define GST_TYPE_TS_DEMUX \
  (gst_ts_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_TS_DEMUX</NAME>
#define GST_TS_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TS_DEMUX,GstTSDemux))
</MACRO>
<MACRO>
<NAME>GST_TS_DEMUX_CLASS</NAME>
#define GST_TS_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TS_DEMUX,GstTSDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TS_DEMUX</NAME>
#define GST_IS_TS_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TS_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_TS_DEMUX_CLASS</NAME>
#define GST_IS_TS_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TS_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_TS_DEMUX_GET_CLASS</NAME>
#define GST_TS_DEMUX_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_TS_DEMUX, GstTSDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_TS_DEMUX_CAST</NAME>
#define GST_TS_DEMUX_CAST(obj) ((GstTSDemux*) obj)
</MACRO>
<STRUCT>
<NAME>GstTSDemux</NAME>
struct _GstTSDemux
{
  MpegTSBase parent;

  gboolean have_group_id;
  guint group_id;

  /* the following vars must be protected with the OBJECT_LOCK as they can be
   * accessed from the application thread and the streaming thread */
  gint requested_program_number; /* Required program number (ignore:-1) */
  guint program_number;
  gboolean emit_statistics;

  /*< private >*/
  gint program_generation; /* Incremented each time we switch program 0..15 */
  MpegTSBaseProgram *program;	/* Current program */
  MpegTSBaseProgram *previous_program; /* Previous program, to deactivate once
					* the new program becomes active */

  /* segments to be sent */
  GstSegment segment;
  GstEvent *segment_event;
  gboolean reset_segment;

  /* global taglist */
  GstTagList *global_tags;

  /* Full stream duration */
  GstClockTime duration;

  /* Pending seek rate (default 1.0) */
  gdouble rate;

  GstFlowCombiner *flowcombiner;

  /* Used when seeking for a keyframe to go backward in the stream */
  guint64 last_seek_offset;
};
</STRUCT>
<STRUCT>
<NAME>GstTSDemuxClass</NAME>
struct _GstTSDemuxClass
{
  MpegTSBaseClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_MPEG_TSMUX</NAME>
#define GST_TYPE_MPEG_TSMUX  (mpegtsmux_get_type())
</MACRO>
<MACRO>
<NAME>GST_MPEG_TSMUX</NAME>
#define GST_MPEG_TSMUX(obj)  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_MPEG_TSMUX, MpegTsMux))
</MACRO>
<MACRO>
<NAME>CLOCK_BASE</NAME>
#define CLOCK_BASE 9LL
</MACRO>
<MACRO>
<NAME>CLOCK_FREQ</NAME>
#define CLOCK_FREQ (CLOCK_BASE * 10000)   /* 90 kHz PTS clock */
</MACRO>
<MACRO>
<NAME>CLOCK_FREQ_SCR</NAME>
#define CLOCK_FREQ_SCR (CLOCK_FREQ * 300) /* 27 MHz SCR clock */
</MACRO>
<MACRO>
<NAME>GSTTIME_TO_MPEGTIME</NAME>
#define GSTTIME_TO_MPEGTIME(time) \
    (((time) > 0 ? (gint64) 1 : (gint64) -1) * \
    (gint64) gst_util_uint64_scale (ABS(time), CLOCK_BASE, GST_MSECOND/10))
</MACRO>
<MACRO>
<NAME>MPEG_SYS_TIME_TO_GSTTIME</NAME>
#define MPEG_SYS_TIME_TO_GSTTIME(time) (gst_util_uint64_scale ((time), \
                        GST_USECOND, CLOCK_FREQ_SCR / 1000000))
</MACRO>
<MACRO>
<NAME>GSTTIME_TO_MPEG_SYS_TIME</NAME>
#define GSTTIME_TO_MPEG_SYS_TIME(time) (gst_util_uint64_scale ((time), \
                        CLOCK_FREQ_SCR / 1000000, GST_USECOND))
</MACRO>
<MACRO>
<NAME>NORMAL_TS_PACKET_LENGTH</NAME>
#define NORMAL_TS_PACKET_LENGTH 188
</MACRO>
<MACRO>
<NAME>M2TS_PACKET_LENGTH</NAME>
#define M2TS_PACKET_LENGTH      192
</MACRO>
<MACRO>
<NAME>DEFAULT_PROG_ID</NAME>
#define DEFAULT_PROG_ID	0
</MACRO>
<TYPEDEF>
<NAME>MpegTsMux</NAME>
typedef struct MpegTsMux MpegTsMux;
</TYPEDEF>
<TYPEDEF>
<NAME>MpegTsMuxClass</NAME>
typedef struct MpegTsMuxClass MpegTsMuxClass;
</TYPEDEF>
<TYPEDEF>
<NAME>MpegTsPadData</NAME>
typedef struct MpegTsPadData MpegTsPadData;
</TYPEDEF>
<USER_FUNCTION>
<NAME>MpegTsPadDataPrepareFunction</NAME>
<RETURNS>GstBuffer *</RETURNS>
GstBuffer * buf,
    MpegTsPadData * data, MpegTsMux * mux
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>MpegTsPadDataFreePrepareDataFunction</NAME>
<RETURNS>void </RETURNS>
gpointer prepare_data
</USER_FUNCTION>
<FUNCTION>
<NAME>mpegtsmux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MXF_DEMUX</NAME>
#define GST_TYPE_MXF_DEMUX \
  (gst_mxf_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_MXF_DEMUX</NAME>
#define GST_MXF_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MXF_DEMUX,GstMXFDemux))
</MACRO>
<MACRO>
<NAME>GST_MXF_DEMUX_CLASS</NAME>
#define GST_MXF_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MXF_DEMUX,GstMXFDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MXF_DEMUX</NAME>
#define GST_IS_MXF_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MXF_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_MXF_DEMUX_CLASS</NAME>
#define GST_IS_MXF_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MXF_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_TYPE_MXF_DEMUX_PAD</NAME>
#define GST_TYPE_MXF_DEMUX_PAD (gst_mxf_demux_pad_get_type())
</MACRO>
<MACRO>
<NAME>GST_MXF_DEMUX_PAD</NAME>
#define GST_MXF_DEMUX_PAD(pad) (G_TYPE_CHECK_INSTANCE_CAST((pad),GST_TYPE_MXF_DEMUX_PAD,GstMXFDemuxPad))
</MACRO>
<MACRO>
<NAME>GST_MXF_DEMUX_PAD_CAST</NAME>
#define GST_MXF_DEMUX_PAD_CAST(pad) ((GstMXFDemuxPad *) pad)
</MACRO>
<MACRO>
<NAME>GST_IS_MXF_DEMUX_PAD</NAME>
#define GST_IS_MXF_DEMUX_PAD(pad) (G_TYPE_CHECK_INSTANCE_TYPE((pad),GST_TYPE_MXF_DEMUX_PAD))
</MACRO>
<STRUCT>
<NAME>GstMXFDemuxPad</NAME>
struct _GstMXFDemuxPad
{
  GstPad parent;

  guint32 track_id;
  gboolean need_segment;

  GstClockTime position;
  gdouble position_accumulated_error;
  gboolean eos, discont;

  GstTagList *tags;

  MXFMetadataGenericPackage *material_package;
  MXFMetadataTimelineTrack *material_track;

  guint current_component_index;
  MXFMetadataSourceClip *current_component;

  gint64 current_component_start;
  gint64 current_component_duration;

  GstMXFDemuxEssenceTrack *current_essence_track;
  gint64 current_essence_track_position;
};
</STRUCT>
<STRUCT>
<NAME>GstMXFDemuxPadClass</NAME>
struct _GstMXFDemuxPadClass
{
  GstPadClass parent;
};
</STRUCT>
<STRUCT>
<NAME>GstMXFDemux</NAME>
struct _GstMXFDemux
{
  GstElement element;

  GstPad *sinkpad;
  GPtrArray *src;

  /* < private > */
  gboolean have_group_id;
  guint group_id;

  GstAdapter *adapter;

  GstFlowCombiner *flowcombiner;

  GstSegment segment;
  guint32 seqnum;

  GstEvent *close_seg_event;

  guint64 offset;

  gboolean random_access;
  gboolean flushing;

  guint64 run_in;

  guint64 header_partition_pack_offset;
  guint64 footer_partition_pack_offset;

  /* MXF file state */
  GList *partitions;
  GstMXFDemuxPartition *current_partition;

  GArray *essence_tracks;

  GList *pending_index_table_segments;
  GList *index_tables; /* one per BodySID / IndexSID */
  gboolean index_table_segments_collected;

  GArray *random_index_pack;

  /* Metadata */
  GRWLock metadata_lock;
  gboolean update_metadata;
  gboolean pull_footer_metadata;

  gboolean metadata_resolved;
  MXFMetadataPreface *preface;
  GHashTable *metadata;

  MXFUMID current_package_uid;
  MXFMetadataGenericPackage *current_package;
  gchar *current_package_string;

  GstTagList *tags;

  /* Properties */
  gchar *requested_package_string;
  GstClockTime max_drift;
};
</STRUCT>
<STRUCT>
<NAME>GstMXFDemuxClass</NAME>
struct _GstMXFDemuxClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mxf_demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MXF_MUX</NAME>
#define GST_TYPE_MXF_MUX \
  (gst_mxf_mux_get_type ())
</MACRO>
<MACRO>
<NAME>GST_MXF_MUX</NAME>
#define GST_MXF_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_MXF_MUX, GstMXFMux))
</MACRO>
<MACRO>
<NAME>GST_MXF_MUX_CLASS</NAME>
#define GST_MXF_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_MXF_MUX, GstMXFMuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MXF_MUX</NAME>
#define GST_IS_MXF_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_MXF_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_MXF_MUX_CLASS</NAME>
#define GST_IS_MXF_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_MXF_MUX))
</MACRO>
<ENUM>
<NAME>GstMXFMuxState</NAME>
typedef enum
{
  GST_MXF_MUX_STATE_HEADER,
  GST_MXF_MUX_STATE_DATA,
  GST_MXF_MUX_STATE_EOS,
  GST_MXF_MUX_STATE_ERROR
} GstMXFMuxState;
</ENUM>
<STRUCT>
<NAME>GstMXFMux</NAME>
typedef struct _GstMXFMux {
  GstAggregator parent;

  /* <private> */
  GstMXFMuxState state;
  guint n_pads;

  guint64 offset;

  MXFPartitionPack partition;
  MXFPrimerPack primer;

  GHashTable *metadata;
  GList *metadata_list;
  MXFMetadataPreface *preface;

  MXFFraction min_edit_rate;
  guint64 last_gc_position;
  GstClockTime last_gc_timestamp;

  gchar *application;

  GArray *index_table;
  guint current_index_pos;
  guint64 last_keyframe_pos;
} GstMXFMux;
</STRUCT>
<STRUCT>
<NAME>GstMXFMuxClass</NAME>
typedef struct _GstMXFMuxClass {
  GstAggregatorClass parent;
} GstMXFMuxClass;
</STRUCT>
<FUNCTION>
<NAME>gst_mxf_mux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PCAP_PARSE</NAME>
#define GST_TYPE_PCAP_PARSE \
  (gst_pcap_parse_get_type ())
</MACRO>
<MACRO>
<NAME>GST_PCAP_PARSE</NAME>
#define GST_PCAP_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PCAP_PARSE, GstPcapParse))
</MACRO>
<MACRO>
<NAME>GST_PCAP_PARSE_CLASS</NAME>
#define GST_PCAP_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_PCAP_PARSE, GstPcapParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PCAP_PARSE</NAME>
#define GST_IS_PCAP_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PCAP_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_PCAP_PARSE_CLASS</NAME>
#define GST_IS_PCAP_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_PCAP_PARSE))
</MACRO>
<ENUM>
<NAME>GstPcapParseState</NAME>
typedef enum
{
  PCAP_PARSE_STATE_CREATED,
  PCAP_PARSE_STATE_PARSING,
} GstPcapParseState;
</ENUM>
<ENUM>
<NAME>GstPcapParseLinktype</NAME>
typedef enum
{
  LINKTYPE_ETHER  = 1,
  LINKTYPE_RAW = 101,
  LINKTYPE_SLL = 113
} GstPcapParseLinktype;
</ENUM>
<STRUCT>
<NAME>GstPcapParse</NAME>
struct _GstPcapParse
{
  GstElement element;

  /*< private >*/
  GstPad * sink_pad;
  GstPad * src_pad;

  /* properties */
  gint64 src_ip;
  gint64 dst_ip;
  gint32 src_port;
  gint32 dst_port;
  GstCaps *caps;
  gint64 offset;

  /* state */
  GstAdapter * adapter;
  gboolean initialized;
  gboolean swap_endian;
  gint64 cur_packet_size;
  GstClockTime cur_ts;
  GstClockTime base_ts;
  GstPcapParseLinktype linktype;

  gboolean newsegment_sent;
};
</STRUCT>
<STRUCT>
<NAME>GstPcapParseClass</NAME>
struct _GstPcapParseClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_pcap_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_PARSE</NAME>
#define GST_TYPE_AUDIO_PARSE \
  (gst_audio_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_PARSE</NAME>
#define GST_AUDIO_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_PARSE,GstAudioParse))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_PARSE_CLASS</NAME>
#define GST_AUDIO_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AUDIO_PARSE,GstAudioParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_PARSE</NAME>
#define GST_IS_AUDIO_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_PARSE_CLASS</NAME>
#define GST_IS_AUDIO_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_PARSE))
</MACRO>
<STRUCT>
<NAME>GstAudioParse</NAME>
struct _GstAudioParse
{
  GstBin parent;
  GstElement *rawaudioparse;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioParseClass</NAME>
struct _GstAudioParseClass
{
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VIDEO_PARSE</NAME>
#define GST_TYPE_VIDEO_PARSE \
  (gst_video_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_PARSE</NAME>
#define GST_VIDEO_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_PARSE,GstVideoParse))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_PARSE_CLASS</NAME>
#define GST_VIDEO_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_PARSE,GstVideoParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_PARSE</NAME>
#define GST_IS_VIDEO_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_PARSE_CLASS</NAME>
#define GST_IS_VIDEO_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_PARSE))
</MACRO>
<STRUCT>
<NAME>GstVideoParse</NAME>
struct _GstVideoParse
{
  GstBin parent;
  GstElement *rawvideoparse;
};
</STRUCT>
<STRUCT>
<NAME>GstVideoParseClass</NAME>
struct _GstVideoParseClass
{
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SDP_DEMUX</NAME>
#define GST_TYPE_SDP_DEMUX \
  (gst_sdp_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_SDP_DEMUX</NAME>
#define GST_SDP_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SDP_DEMUX,GstSDPDemux))
</MACRO>
<MACRO>
<NAME>GST_SDP_DEMUX_CLASS</NAME>
#define GST_SDP_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SDP_DEMUX,GstSDPDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SDP_DEMUX</NAME>
#define GST_IS_SDP_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SDP_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_SDP_DEMUX_CLASS</NAME>
#define GST_IS_SDP_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SDP_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_SDP_DEMUX_CAST</NAME>
#define GST_SDP_DEMUX_CAST(obj) \
  ((GstSDPDemux *)(obj))
</MACRO>
<MACRO>
<NAME>GST_SDP_STREAM_GET_LOCK</NAME>
#define GST_SDP_STREAM_GET_LOCK(sdp)   (&GST_SDP_DEMUX_CAST(sdp)->stream_rec_lock)
</MACRO>
<MACRO>
<NAME>GST_SDP_STREAM_LOCK</NAME>
#define GST_SDP_STREAM_LOCK(sdp)       (g_rec_mutex_lock (GST_SDP_STREAM_GET_LOCK(sdp)))
</MACRO>
<MACRO>
<NAME>GST_SDP_STREAM_UNLOCK</NAME>
#define GST_SDP_STREAM_UNLOCK(sdp)     (g_rec_mutex_unlock (GST_SDP_STREAM_GET_LOCK(sdp)))
</MACRO>
<STRUCT>
<NAME>GstSDPStream</NAME>
struct _GstSDPStream {
  gint          id;

  GstSDPDemux    *parent; /* parent, no extra ref to parent is taken */

  /* pad we expose or NULL when it does not have an actual pad */
  GstPad       *srcpad;
  GstFlowReturn last_ret;
  gboolean      added;
  gboolean      disabled;
  GstCaps      *caps;
  gboolean      eos;

  /* our udp sources */
  GstElement   *udpsrc[2];
  GstPad       *channelpad[2];
  guint         rtp_port;
  guint         rtcp_port;

  gchar        *destination;
  guint         ttl;
  gboolean      multicast;

  /* our udp sink back to the server */
  GstElement   *udpsink;
  GstPad       *rtcppad;

  /* state */
  gint          pt;
  gboolean      container;
};
</STRUCT>
<STRUCT>
<NAME>GstSDPDemux</NAME>
struct _GstSDPDemux {
  GstBin           parent;

  GstPad          *sinkpad;
  GstAdapter      *adapter;
  GstState         target;

  /* task for UDP loop */
  gboolean         ignore_timeout;

  gint             numstreams;
  GRecMutex        stream_rec_lock;
  GList           *streams;

  /* properties */
  gboolean          debug;
  guint64           udp_timeout;
  guint             latency;
  gboolean          redirect;

  /* session management */
  GstElement      *session;
  gulong           session_sig_id;
  gulong           session_ptmap_id;
  gulong           session_nmp_id;
};
</STRUCT>
<STRUCT>
<NAME>GstSDPDemuxClass</NAME>
struct _GstSDPDemuxClass {
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_sdp_demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SPEED</NAME>
#define GST_TYPE_SPEED \
  (gst_speed_get_type())
</MACRO>
<MACRO>
<NAME>GST_SPEED</NAME>
#define GST_SPEED(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPEED,GstSpeed))
</MACRO>
<MACRO>
<NAME>GST_SPEED_CLASS</NAME>
#define GST_SPEED_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPEED,GstSpeedClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SPEED</NAME>
#define GST_IS_SPEED(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPEED))
</MACRO>
<MACRO>
<NAME>GST_IS_SPEED_CLASS</NAME>
#define GST_IS_SPEED_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPEED))
</MACRO>
<STRUCT>
<NAME>GstSpeed</NAME>
struct _GstSpeed {
  GstElement     element;

  GstPad        *sinkpad;
  GstPad        *srcpad;

  gfloat         speed;

  gint64         offset;
  gint64         timestamp;

  GstAudioInfo   info;
};
</STRUCT>
<STRUCT>
<NAME>GstSpeedClass</NAME>
struct _GstSpeedClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_speed_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_STEREO</NAME>
#define GST_TYPE_STEREO \
  (gst_stereo_get_type())
</MACRO>
<MACRO>
<NAME>GST_STEREO</NAME>
#define GST_STEREO(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_STEREO,GstStereo))
</MACRO>
<MACRO>
<NAME>GST_STEREO_CLASS</NAME>
#define GST_STEREO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_STEREO,GstStereoClass))
</MACRO>
<MACRO>
<NAME>GST_IS_STEREO</NAME>
#define GST_IS_STEREO(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_STEREO))
</MACRO>
<MACRO>
<NAME>GST_IS_STEREO_CLASS</NAME>
#define GST_IS_STEREO_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_STEREO))
</MACRO>
<STRUCT>
<NAME>GstStereo</NAME>
struct _GstStereo {
  GstAudioFilter element;

  gboolean active;
  gfloat stereo;
};
</STRUCT>
<STRUCT>
<NAME>GstStereoClass</NAME>
struct _GstStereoClass {
  GstAudioFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_stereo_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VIDEO_ANALYSE</NAME>
#define GST_TYPE_VIDEO_ANALYSE   (gst_video_analyse_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_ANALYSE</NAME>
#define GST_VIDEO_ANALYSE(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_ANALYSE,GstVideoAnalyse))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_ANALYSE_CLASS</NAME>
#define GST_VIDEO_ANALYSE_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_ANALYSE,GstVideoAnalyseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_ANALYSE</NAME>
#define GST_IS_VIDEO_ANALYSE(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_ANALYSE))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_ANALYSE_CLASS</NAME>
#define GST_IS_VIDEO_ANALYSE_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_ANALYSE))
</MACRO>
<STRUCT>
<NAME>GstVideoAnalyse</NAME>
struct _GstVideoAnalyse
{
  GstVideoFilter base_videoanalyse;

  /* properties */
  gboolean message;
  guint64 interval;
  gdouble luma_average;
  gdouble luma_variance;
};
</STRUCT>
<STRUCT>
<NAME>GstVideoAnalyseClass</NAME>
struct _GstVideoAnalyseClass
{
  GstVideoFilterClass base_videoanalyse_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_analyse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstDvbSrcPol</NAME>
 typedef enum
{
  DVB_POL_H,
  DVB_POL_V,
  DVB_POL_ZERO
} GstDvbSrcPol;
</ENUM>
<MACRO>
<NAME>IPACKS</NAME>
#define IPACKS 2048
</MACRO>
<MACRO>
<NAME>TS_SIZE</NAME>
#define TS_SIZE 188
</MACRO>
<MACRO>
<NAME>IN_SIZE</NAME>
#define IN_SIZE TS_SIZE*10
</MACRO>
<MACRO>
<NAME>MAX_FILTERS</NAME>
#define MAX_FILTERS 32
</MACRO>
<MACRO>
<NAME>GST_TYPE_DVBSRC</NAME>
#define GST_TYPE_DVBSRC \
  (gst_dvbsrc_get_type())
</MACRO>
<MACRO>
<NAME>GST_DVBSRC</NAME>
#define GST_DVBSRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DVBSRC,GstDvbSrc))
</MACRO>
<MACRO>
<NAME>GST_DVBSRC_CLASS</NAME>
#define GST_DVBSRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DVBSRC,GstDvbSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DVBSRC</NAME>
#define GST_IS_DVBSRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DVBSRC))
</MACRO>
<MACRO>
<NAME>GST_IS_DVBSRC_CLASS</NAME>
#define GST_IS_DVBSRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DVBSRC))
</MACRO>
<STRUCT>
<NAME>GstDvbSrc</NAME>
struct _GstDvbSrc
{
  GstPushSrc element;

  GMutex tune_mutex;
  gboolean need_tune;

  GList * supported_delsys;
  guchar delsys;

  int adapter_number;
  int frontend_number;

  int fd_frontend;
  int fd_dvr;
  int fd_filters[MAX_FILTERS];
  GstPoll *poll;
  GstPollFD poll_fd_dvr;

  guint16 pids[MAX_FILTERS];
  unsigned int freq;
  unsigned int sym_rate;
  int tone;
  int diseqc_src;
  gboolean send_diseqc;

  guint bandwidth;
  int code_rate_hp;
  int code_rate_lp;
  int modulation;
  int guard_interval;
  int transmission_mode;
  int hierarchy_information;
  int inversion;
  int pilot;
  int rolloff;
  int stream_id;
  guint64 timeout;
  guint64 tuning_timeout;

  GstDvbSrcPol pol;
  guint stats_interval;
  guint stats_counter;
  gboolean need_unlock;

  guint dvb_buffer_size;

  unsigned int isdbt_layer_enabled;
  int isdbt_partial_reception;
  int isdbt_sound_broadcasting;
  int isdbt_sb_subchannel_id;
  int isdbt_sb_segment_idx;
  unsigned int isdbt_sb_segment_count;
  int isdbt_layera_fec;
  int isdbt_layera_modulation;
  int isdbt_layera_segment_count;
  int isdbt_layera_time_interleaving;
  int isdbt_layerb_fec;
  int isdbt_layerb_modulation;
  int isdbt_layerb_segment_count;
  int isdbt_layerb_time_interleaving;
  int isdbt_layerc_fec;
  int isdbt_layerc_modulation;
  int isdbt_layerc_segment_count;
  int isdbt_layerc_time_interleaving;

  /* LNB properties */
  unsigned int lnb_slof;
  unsigned int lnb_lof1;
  unsigned int lnb_lof2;

  /* Only used for DTMB if available */
  int interleaving;
};
</STRUCT>
<STRUCT>
<NAME>GstDvbSrcClass</NAME>
struct _GstDvbSrcClass
{
  GstPushSrcClass parent_class;

  void (*adapter_type) (GstElement * element, gint type);
  void (*signal_quality) (GstElement * element, gint strength, gint snr);

  void (*do_tune) (GstDvbSrc * self);
};
</STRUCT>
<FUNCTION>
<NAME>gst_dvbsrc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dvbsrc_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<STRUCT>
<NAME>GstDvbSrcParam</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_SHM_SINK</NAME>
#define GST_TYPE_SHM_SINK \
  (gst_shm_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_SHM_SINK</NAME>
#define GST_SHM_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SHM_SINK,GstShmSink))
</MACRO>
<MACRO>
<NAME>GST_SHM_SINK_CLASS</NAME>
#define GST_SHM_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SHM_SINK,GstShmSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SHM_SINK</NAME>
#define GST_IS_SHM_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SHM_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_SHM_SINK_CLASS</NAME>
#define GST_IS_SHM_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SHM_SINK))
</MACRO>
<STRUCT>
<NAME>GstShmSink</NAME>
struct _GstShmSink
{
  GstBaseSink element;

  gchar *socket_path;

  ShmPipe *pipe;

  guint perms;
  guint size;

  GList *clients;

  GThread *pollthread;
  GstPoll *poll;
  GstPollFD serverpollfd;

  gboolean wait_for_connection;
  gboolean stop;
  gboolean unlock;
  GstClockTimeDiff buffer_time;

  GCond cond;

  GstShmSinkAllocator *allocator;

  GstAllocationParams params;
};
</STRUCT>
<STRUCT>
<NAME>GstShmSinkClass</NAME>
struct _GstShmSinkClass
{
  GstBaseSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_shm_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstShmSinkAllocator</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_SHM_SRC</NAME>
#define GST_TYPE_SHM_SRC \
  (gst_shm_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_SHM_SRC</NAME>
#define GST_SHM_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SHM_SRC,GstShmSrc))
</MACRO>
<MACRO>
<NAME>GST_SHM_SRC_CLASS</NAME>
#define GST_SHM_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SHM_SRC,GstShmSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SHM_SRC</NAME>
#define GST_IS_SHM_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SHM_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_SHM_SRC_CLASS</NAME>
#define GST_IS_SHM_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SHM_SRC))
</MACRO>
<STRUCT>
<NAME>GstShmSrc</NAME>
struct _GstShmSrc
{
  GstPushSrc element;

  gchar *socket_path;

  GstShmPipe *pipe;
  GstPoll *poll;
  GstPollFD pollfd;


  GstFlowReturn flow_return;
  gboolean unlocked;
};
</STRUCT>
<STRUCT>
<NAME>GstShmSrcClass</NAME>
struct _GstShmSrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_shm_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstShmPipe</NAME>
struct _GstShmPipe {
  int use_count;

  GstShmSrc *src;
  ShmPipe *pipe;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_VIDEO_SEGMENT_CLIP</NAME>
#define GST_TYPE_VIDEO_SEGMENT_CLIP \
  (gst_video_segment_clip_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_SEGMENT_CLIP</NAME>
#define GST_VIDEO_SEGMENT_CLIP(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_SEGMENT_CLIP,GstVideoSegmentClip))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_SEGMENT_CLIP_CLASS</NAME>
#define GST_VIDEO_SEGMENT_CLIP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_SEGMENT_CLIP,GstVideoSegmentClipClass))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_SEGMENT_CLIP_GET_CLASS</NAME>
#define GST_VIDEO_SEGMENT_CLIP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_VIDEO_SEGMENT_CLIP,GstVideoSegmentClipClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_SEGMENT_CLIP</NAME>
#define GST_IS_VIDEO_SEGMENT_CLIP(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_SEGMENT_CLIP))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_SEGMENT_CLIP_CLASS</NAME>
#define GST_IS_VIDEO_SEGMENT_CLIP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_SEGMENT_CLIP))
</MACRO>
<STRUCT>
<NAME>GstVideoSegmentClip</NAME>
struct _GstVideoSegmentClip
{
  GstSegmentClip parent;

  /* < private > */
  gint fps_n, fps_d;
};
</STRUCT>
<STRUCT>
<NAME>GstVideoSegmentClipClass</NAME>
struct _GstVideoSegmentClipClass
{
  GstSegmentClipClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_segment_clip_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_SEGMENT_CLIP</NAME>
#define GST_TYPE_AUDIO_SEGMENT_CLIP \
  (gst_audio_segment_clip_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_SEGMENT_CLIP</NAME>
#define GST_AUDIO_SEGMENT_CLIP(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_SEGMENT_CLIP,GstAudioSegmentClip))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_SEGMENT_CLIP_CLASS</NAME>
#define GST_AUDIO_SEGMENT_CLIP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AUDIO_SEGMENT_CLIP,GstAudioSegmentClipClass))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_SEGMENT_CLIP_GET_CLASS</NAME>
#define GST_AUDIO_SEGMENT_CLIP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_AUDIO_SEGMENT_CLIP,GstAudioSegmentClipClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_SEGMENT_CLIP</NAME>
#define GST_IS_AUDIO_SEGMENT_CLIP(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_SEGMENT_CLIP))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_SEGMENT_CLIP_CLASS</NAME>
#define GST_IS_AUDIO_SEGMENT_CLIP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_SEGMENT_CLIP))
</MACRO>
<STRUCT>
<NAME>GstAudioSegmentClip</NAME>
struct _GstAudioSegmentClip
{
  GstSegmentClip parent;

  /* < private > */
  gint rate;
  gint framesize;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioSegmentClipClass</NAME>
struct _GstAudioSegmentClipClass
{
  GstSegmentClipClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_segment_clip_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SEGMENT_CLIP</NAME>
#define GST_TYPE_SEGMENT_CLIP \
  (gst_segment_clip_get_type())
</MACRO>
<MACRO>
<NAME>GST_SEGMENT_CLIP</NAME>
#define GST_SEGMENT_CLIP(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SEGMENT_CLIP,GstSegmentClip))
</MACRO>
<MACRO>
<NAME>GST_SEGMENT_CLIP_CLASS</NAME>
#define GST_SEGMENT_CLIP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SEGMENT_CLIP,GstSegmentClipClass))
</MACRO>
<MACRO>
<NAME>GST_SEGMENT_CLIP_GET_CLASS</NAME>
#define GST_SEGMENT_CLIP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_SEGMENT_CLIP,GstSegmentClipClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SEGMENT_CLIP</NAME>
#define GST_IS_SEGMENT_CLIP(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SEGMENT_CLIP))
</MACRO>
<MACRO>
<NAME>GST_IS_SEGMENT_CLIP_CLASS</NAME>
#define GST_IS_SEGMENT_CLIP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SEGMENT_CLIP))
</MACRO>
<STRUCT>
<NAME>GstSegmentClip</NAME>
struct _GstSegmentClip
{
  GstElement parent;

  /* < private > */
  GstPad *sinkpad;
  GstPad *srcpad;

  GstSegment segment;
};
</STRUCT>
<STRUCT>
<NAME>GstSegmentClipClass</NAME>
struct _GstSegmentClipClass
{
  GstElementClass parent_class;

  gboolean      (*set_caps)    (GstSegmentClip *self, GstCaps *caps);
  GstFlowReturn (*clip_buffer) (GstSegmentClip *self, GstBuffer *buffer, GstBuffer **outbuf);
  void          (*reset)       (GstSegmentClip *self);
};
</STRUCT>
<FUNCTION>
<NAME>gst_segment_clip_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_YADIF</NAME>
#define GST_TYPE_YADIF   (gst_yadif_get_type())
</MACRO>
<MACRO>
<NAME>GST_YADIF</NAME>
#define GST_YADIF(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_YADIF,GstYadif))
</MACRO>
<MACRO>
<NAME>GST_YADIF_CLASS</NAME>
#define GST_YADIF_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_YADIF,GstYadifClass))
</MACRO>
<MACRO>
<NAME>GST_IS_YADIF</NAME>
#define GST_IS_YADIF(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_YADIF))
</MACRO>
<MACRO>
<NAME>GST_IS_YADIF_CLASS</NAME>
#define GST_IS_YADIF_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_YADIF))
</MACRO>
<ENUM>
<NAME>GstDeinterlaceMode</NAME>
typedef enum {
  GST_DEINTERLACE_MODE_AUTO,
  GST_DEINTERLACE_MODE_INTERLACED,
  GST_DEINTERLACE_MODE_DISABLED
} GstDeinterlaceMode;
</ENUM>
<STRUCT>
<NAME>GstYadif</NAME>
struct _GstYadif
{
  GstBaseTransform base_yadif;

  GstDeinterlaceMode mode;

  GstVideoInfo video_info;

  GstVideoFrame prev_frame;
  GstVideoFrame cur_frame;
  GstVideoFrame next_frame;
  GstVideoFrame dest_frame;
};
</STRUCT>
<STRUCT>
<NAME>GstYadifClass</NAME>
struct _GstYadifClass
{
  GstBaseTransformClass base_yadif_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_yadif_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_NET_SIM</NAME>
#define GST_TYPE_NET_SIM \
  (gst_net_sim_get_type())
</MACRO>
<MACRO>
<NAME>GST_NET_SIM</NAME>
#define GST_NET_SIM(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), \
  GST_TYPE_NET_SIM,GstNetSim))
</MACRO>
<MACRO>
<NAME>GST_NET_SIM_CLASS</NAME>
#define GST_NET_SIM_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), \
  GST_TYPE_NET_SIM,GstNetSimClass))
</MACRO>
<MACRO>
<NAME>GST_IS_NET_SIM</NAME>
#define GST_IS_NET_SIM(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_NET_SIM))
</MACRO>
<MACRO>
<NAME>GST_IS_NET_SIM_CLASS</NAME>
#define GST_IS_NET_SIM_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_NET_SIM))
</MACRO>
<STRUCT>
<NAME>GstNetSim</NAME>
struct _GstNetSim
{
  GstElement parent;

  GstNetSimPrivate *priv;

  /*< private > */
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstNetSimClass</NAME>
struct _GstNetSimClass
{
  GstElementClass parent_class;

  /*< private > */
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_net_sim_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstNetSimPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_RFB_SRC</NAME>
#define GST_TYPE_RFB_SRC \
  (gst_rfb_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_RFB_SRC</NAME>
#define GST_RFB_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RFB_SRC,GstRfbSrc))
</MACRO>
<MACRO>
<NAME>GST_RFB_SRC_CLASS</NAME>
#define GST_RFB_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RFB_SRC,GstRfbSrc))
</MACRO>
<MACRO>
<NAME>GST_IS_RFB_SRC</NAME>
#define GST_IS_RFB_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RFB_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_RFB_SRC_CLASS</NAME>
#define GST_IS_RFB_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RFB_SRC))
</MACRO>
<STRUCT>
<NAME>GstRfbSrcClass</NAME>
struct _GstRfbSrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GstRfbSrc</NAME>
struct _GstRfbSrc
{
  GstPushSrc element;

  gchar *host;
  gint port;

  RfbDecoder *decoder;
  gboolean go;
  gboolean incremental_update;
  gboolean view_only;

  guint button_mask;

  /* protocol version */
  guint version_major;
  guint version_minor;

};
</STRUCT>
<FUNCTION>
<NAME>gst_rfb_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>EN0</NAME>
#define EN0	0               /* MODE == encrypt */
</MACRO>
<MACRO>
<NAME>DE1</NAME>
#define DE1	1               /* MODE == decrypt */
</MACRO>
<STRUCT>
<NAME>DESContext</NAME>
typedef struct {
  unsigned long KnL[32];
} DESContext;
</STRUCT>
<FUNCTION>
<NAME>deskey</NAME>
<RETURNS>void  </RETURNS>
DESContext * ctx, unsigned char *, int
</FUNCTION>
<FUNCTION>
<NAME>usekey</NAME>
<RETURNS>void  </RETURNS>
DESContext * ctx, unsigned long *
</FUNCTION>
<FUNCTION>
<NAME>cpkey</NAME>
<RETURNS>void  </RETURNS>
DESContext * ctx, unsigned long *
</FUNCTION>
<FUNCTION>
<NAME>des</NAME>
<RETURNS>void  </RETURNS>
DESContext * ctx, unsigned char *, unsigned char *
</FUNCTION>
<MACRO>
<NAME>IS_VERSION</NAME>
#define IS_VERSION(x, ma, mi)   ((x->protocol_major == ma) && (x->protocol_minor == mi))
</MACRO>
<MACRO>
<NAME>IS_VERSION_3_3</NAME>
#define IS_VERSION_3_3(x)       IS_VERSION(x, 3, 3)
</MACRO>
<MACRO>
<NAME>IS_VERSION_3_7</NAME>
#define IS_VERSION_3_7(x)       IS_VERSION(x, 3, 7)
</MACRO>
<MACRO>
<NAME>IS_VERSION_3_8</NAME>
#define IS_VERSION_3_8(x)       IS_VERSION(x, 3, 8)
</MACRO>
<MACRO>
<NAME>MESSAGE_TYPE_FRAMEBUFFER_UPDATE</NAME>
#define MESSAGE_TYPE_FRAMEBUFFER_UPDATE     0
</MACRO>
<MACRO>
<NAME>ENCODING_TYPE_RAW</NAME>
#define ENCODING_TYPE_RAW                   0
</MACRO>
<MACRO>
<NAME>ENCODING_TYPE_COPYRECT</NAME>
#define ENCODING_TYPE_COPYRECT              1
</MACRO>
<MACRO>
<NAME>ENCODING_TYPE_RRE</NAME>
#define ENCODING_TYPE_RRE                   2
</MACRO>
<MACRO>
<NAME>ENCODING_TYPE_CORRE</NAME>
#define ENCODING_TYPE_CORRE                 4
</MACRO>
<MACRO>
<NAME>ENCODING_TYPE_HEXTILE</NAME>
#define ENCODING_TYPE_HEXTILE               5
</MACRO>
<MACRO>
<NAME>SUBENCODING_RAW</NAME>
#define SUBENCODING_RAW                     1
</MACRO>
<MACRO>
<NAME>SUBENCODING_BACKGROUND</NAME>
#define SUBENCODING_BACKGROUND              2
</MACRO>
<MACRO>
<NAME>SUBENCODING_FOREGROUND</NAME>
#define SUBENCODING_FOREGROUND              4
</MACRO>
<MACRO>
<NAME>SUBENCODING_ANYSUBRECTS</NAME>
#define SUBENCODING_ANYSUBRECTS             8
</MACRO>
<MACRO>
<NAME>SUBENCODING_SUBRECTSCOLORED</NAME>
#define SUBENCODING_SUBRECTSCOLORED         16
</MACRO>
<STRUCT>
<NAME>RfbDecoder</NAME>
struct _RfbDecoder
{
  /* callbacks */
  gboolean (*state) (RfbDecoder * decoder);

  gpointer buffer_handler_data;

  GSocketClient *socket_client;
  GSocketConnection *connection;
  GCancellable *cancellable;

  guint8 *data;
  guint32 data_len;
  gpointer decoder_private;
  guint8 *frame;
  guint8 *prev_frame;

  GError *error;

  /* settable properties */
  gboolean shared_flag;

  /* readable properties */
  gboolean inited;

  guint protocol_major;
  guint protocol_minor;
  guint security_type;

  gchar *password;
  gboolean use_copyrect;

  guint width;
  guint height;
  guint bpp;
  guint depth;
  gboolean big_endian;
  gboolean true_colour;
  guint red_max;
  guint green_max;
  guint blue_max;
  guint red_shift;
  guint green_shift;
  guint blue_shift;

  gchar *name;

  /* information if we don't want to update the whole screen */
  guint offset_x;
  guint offset_y;
  guint rect_width;
  guint rect_height;

  gint n_rects;

  /* some many used values */
  guint bytespp;
  guint line_size;

  /* Seriliaze writes operations */
  GMutex write_lock;
};
</STRUCT>
<FUNCTION>
<NAME>rfb_decoder_new</NAME>
<RETURNS>RfbDecoder  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rfb_decoder_free</NAME>
<RETURNS>void  </RETURNS>
RfbDecoder * decoder
</FUNCTION>
<FUNCTION>
<NAME>rfb_decoder_connect_tcp</NAME>
<RETURNS>gboolean  </RETURNS>
RfbDecoder * decoder, gchar * host, guint port
</FUNCTION>
<FUNCTION>
<NAME>rfb_decoder_disconnect</NAME>
<RETURNS>void  </RETURNS>
RfbDecoder * decoder
</FUNCTION>
<FUNCTION>
<NAME>rfb_decoder_iterate</NAME>
<RETURNS>gboolean  </RETURNS>
RfbDecoder * decoder
</FUNCTION>
<FUNCTION>
<NAME>rfb_decoder_send_update_request</NAME>
<RETURNS>void  </RETURNS>
RfbDecoder * decoder, gboolean incremental, gint x, gint y, gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>rfb_decoder_send_key_event</NAME>
<RETURNS>void  </RETURNS>
RfbDecoder * decoder, guint key, gboolean down_flag
</FUNCTION>
<FUNCTION>
<NAME>rfb_decoder_send_pointer_event</NAME>
<RETURNS>void  </RETURNS>
RfbDecoder * decoder, gint button_mask, gint x, gint y
</FUNCTION>
<MACRO>
<NAME>draw_dot</NAME>
#define draw_dot(_vd, _x, _y, _st, _c) G_STMT_START {                          \
  _vd[(_y * _st) + _x] = _c;                                                   \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>draw_dot_c</NAME>
#define draw_dot_c(_vd, _x, _y, _st, _c) G_STMT_START {                        \
  _vd[(_y * _st) + _x] |= _c;                                                  \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>draw_dot_aa</NAME>
#define draw_dot_aa(_vd, _x, _y, _st, _c, _f)  G_STMT_START {                  \
  guint32 _oc, _c1, _c2, _c3;                                                  \
                                                                               \
  _oc = _vd[(_y * _st) + _x];                                                  \
  _c3 = (_oc & 0xff) + ((_c & 0xff) * _f);                                     \
  _c3 = MIN(_c3, 255);                                                         \
  _c2 = ((_oc & 0xff00) >> 8) + (((_c & 0xff00) >> 8) * _f);                   \
  _c2 = MIN(_c2, 255);                                                         \
  _c1 = ((_oc & 0xff0000) >> 16) + (((_c & 0xff0000) >> 16) * _f);             \
  _c1 = MIN(_c1, 255);                                                         \
  _vd[(_y * _st) + _x] = (_c1 << 16) | (_c2 << 8) | _c3;                       \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>draw_line</NAME>
#define draw_line(_vd, _x1, _x2, _y1, _y2, _st, _c) G_STMT_START {             \
  guint _i, _j, _x, _y;                                                        \
  gint _dx = _x2 - _x1, _dy = _y2 - _y1;                                       \
  gfloat _f;                                                                   \
                                                                               \
  _j = abs (_dx) > abs (_dy) ? abs (_dx) : abs (_dy);                          \
  for (_i = 0; _i < _j; _i++) {                                                \
    _f = (gfloat) _i / (gfloat) _j;                                            \
    _x = _x1 + _dx * _f;                                                       \
    _y = _y1 + _dy * _f;                                                       \
    draw_dot (_vd, _x, _y, _st, _c);                                           \
  }                                                                            \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>draw_line_aa</NAME>
#define draw_line_aa(_vd, _x1, _x2, _y1, _y2, _st, _c) G_STMT_START {          \
  guint _i, _j, _x, _y;                                                        \
  gint _dx = _x2 - _x1, _dy = _y2 - _y1;                                       \
  gfloat _f, _rx, _ry, _fx, _fy;                                               \
                                                                               \
  _j = abs (_dx) > abs (_dy) ? abs (_dx) : abs (_dy);                          \
  for (_i = 0; _i < _j; _i++) {                                                \
    _f = (gfloat) _i / (gfloat) _j;                                            \
    _rx = _x1 + _dx * _f;                                                      \
    _ry = _y1 + _dy * _f;                                                      \
    _x = (guint)_rx;                                                           \
    _y = (guint)_ry;                                                           \
    _fx = _rx - (gfloat)_x;                                                    \
    _fy = _ry - (gfloat)_y;                                                    \
                                                                               \
    _f = ((1.0 - _fx) + (1.0 - _fy)) / 2.0;                                    \
    draw_dot_aa (_vd, _x, _y, _st, _c, _f);                                    \
                                                                               \
    _f = (_fx + (1.0 - _fy)) / 2.0;                                            \
    draw_dot_aa (_vd, (_x + 1), _y, _st, _c, _f);                              \
                                                                               \
    _f = ((1.0 - _fx) + _fy) / 2.0;                                            \
    draw_dot_aa (_vd, _x, (_y + 1), _st, _c, _f);                              \
                                                                               \
    _f = (_fx + _fy) / 2.0;                                                    \
    draw_dot_aa (_vd, (_x + 1), (_y + 1), _st, _c, _f);                        \
  }                                                                            \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_TYPE_AUDIO_CHANNEL_MIX</NAME>
#define GST_TYPE_AUDIO_CHANNEL_MIX   (gst_audio_channel_mix_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_CHANNEL_MIX</NAME>
#define GST_AUDIO_CHANNEL_MIX(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_CHANNEL_MIX,GstAudioChannelMix))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_CHANNEL_MIX_CLASS</NAME>
#define GST_AUDIO_CHANNEL_MIX_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AUDIO_CHANNEL_MIX,GstAudioChannelMixClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_CHANNEL_MIX</NAME>
#define GST_IS_AUDIO_CHANNEL_MIX(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_CHANNEL_MIX))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_CHANNEL_MIX_CLASS</NAME>
#define GST_IS_AUDIO_CHANNEL_MIX_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_CHANNEL_MIX))
</MACRO>
<STRUCT>
<NAME>GstAudioChannelMix</NAME>
struct _GstAudioChannelMix
{
  GstAudioFilter base_audiochannelmix;

  double left_to_left;
  double left_to_right;
  double right_to_left;
  double right_to_right;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioChannelMixClass</NAME>
struct _GstAudioChannelMixClass
{
  GstAudioFilterClass base_audiochannelmix_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_channel_mix_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PS_DEMUX</NAME>
#define GST_TYPE_PS_DEMUX		(gst_ps_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_PS_DEMUX</NAME>
#define GST_PS_DEMUX(obj)		(G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PS_DEMUX,GstPsDemux))
</MACRO>
<MACRO>
<NAME>GST_PS_DEMUX_CLASS</NAME>
#define GST_PS_DEMUX_CLASS(klass)	(G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PS_DEMUX,GstPsDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_PS_DEMUX_GET_CLASS</NAME>
#define GST_PS_DEMUX_GET_CLASS(klass) (G_TYPE_INSTANCE_GET_CLASS((klass),GST_TYPE_PS_DEMUX,GstPsDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PS_DEMUX</NAME>
#define GST_IS_PS_DEMUX(obj)		(G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PS_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_PS_DEMUX_CLASS</NAME>
#define GST_IS_PS_DEMUX_CLASS(obj)	(G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PS_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_PS_DEMUX_MAX_STREAMS</NAME>
#define GST_PS_DEMUX_MAX_STREAMS	256
</MACRO>
<MACRO>
<NAME>GST_PS_DEMUX_MAX_PSM</NAME>
#define GST_PS_DEMUX_MAX_PSM		256
</MACRO>
<MACRO>
<NAME>MAX_DVD_AUDIO_STREAMS</NAME>
#define MAX_DVD_AUDIO_STREAMS       8
</MACRO>
<MACRO>
<NAME>MAX_DVD_SUBPICTURE_STREAMS</NAME>
#define MAX_DVD_SUBPICTURE_STREAMS  32
</MACRO>
<ENUM>
<NAME>GstPsDemuxSync</NAME>
typedef enum
{
  GST_PS_DEMUX_SYNC_AUTO = 0,
  GST_PS_DEMUX_SYNC_SCR = 1,
  GST_PS_DEMUX_SYNC_DTS = 2
} GstPsDemuxSync;
</ENUM>
<ENUM>
<NAME>GstPsDemuxState</NAME>
typedef enum
{
  STATE_PS_DEMUX_NEED_SYNC,
  STATE_PS_DEMUX_SYNCED,
  STATE_PS_DEMUX_NEED_MORE_DATA,
} GstPsDemuxState;
</ENUM>
<STRUCT>
<NAME>GstPsStream</NAME>
struct _GstPsStream
{
  GstPad *pad;

  gint id;
  gint type;

  GstClockTime segment_thresh;
  GstClockTime last_ts;

  gboolean discont;
  gboolean notlinked;
  gboolean need_segment;

  GstTagList *pending_tags;
};
</STRUCT>
<STRUCT>
<NAME>GstPsDemux</NAME>
struct _GstPsDemux
{
  GstElement parent;

  GstPad *sinkpad;
  gboolean random_access;       /* If we operate in pull mode */
  gboolean flushing;

  gboolean have_group_id;
  guint group_id;

  GstAdapter *adapter;
  GstAdapter *rev_adapter;
  guint64 adapter_offset;
  guint32 last_sync_code;
  GstPESFilter filter;

  gint64 mux_rate;
  guint64 first_scr;
  guint64 last_scr;
  guint64 first_dts;
  guint64 base_time;
  guint64 current_scr;
  guint64 next_scr;
  guint64 bytes_since_scr;
  gint64 scr_adjust;
  guint64 scr_rate_n;
  guint64 scr_rate_d;
  guint64 first_scr_offset;
  guint64 last_scr_offset;
  guint64 cur_scr_offset;

  guint64 first_pts;
  guint64 last_pts;

  gint16 psm[GST_PS_DEMUX_MAX_PSM];

  GstSegment sink_segment;
  GstSegment src_segment;
  gboolean adjust_segment;

  /* stream output */
  GstPsStream *current_stream;
  guint64 next_pts;
  guint64 next_dts;
  GstPsStream **streams;
  GstPsStream **streams_found;
  gint found_count;
  gboolean need_no_more_pads;

  GstFlowCombiner *flowcombiner;

  /* Indicates an MPEG-2 stream */
  gboolean is_mpeg2_pack;
};
</STRUCT>
<STRUCT>
<NAME>GstPsDemuxClass</NAME>
struct _GstPsDemuxClass
{
  GstElementClass parent_class;

  GstPadTemplate *sink_template;
  GstPadTemplate *video_template;
  GstPadTemplate *audio_template;
  GstPadTemplate *subpicture_template;
  GstPadTemplate *private_template;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ps_demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ID_PS_END_CODE</NAME>
#define ID_PS_END_CODE                          0x000001B9
</MACRO>
<MACRO>
<NAME>ID_PS_PACK_START_CODE</NAME>
#define ID_PS_PACK_START_CODE                   0x000001BA
</MACRO>
<MACRO>
<NAME>ID_PS_SYSTEM_HEADER_START_CODE</NAME>
#define ID_PS_SYSTEM_HEADER_START_CODE          0x000001BB
</MACRO>
<MACRO>
<NAME>ID_PS_PROGRAM_STREAM_MAP</NAME>
#define ID_PS_PROGRAM_STREAM_MAP                0x000001BC
</MACRO>
<MACRO>
<NAME>ID_PRIVATE_STREAM_1</NAME>
#define ID_PRIVATE_STREAM_1                     0x000001BD
</MACRO>
<MACRO>
<NAME>ID_PADDING_STREAM</NAME>
#define ID_PADDING_STREAM                       0x000001BE
</MACRO>
<MACRO>
<NAME>ID_PRIVATE_STREAM_2</NAME>
#define ID_PRIVATE_STREAM_2                     0x000001BF
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_MPEG12_AUDIO_STREAM_0</NAME>
#define ID_ISO_IEC_MPEG12_AUDIO_STREAM_0        0x000001C0
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_MPEG12_AUDIO_STREAM_32</NAME>
#define ID_ISO_IEC_MPEG12_AUDIO_STREAM_32       0x000001DF
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_MPEG12_VIDEO_STREAM_0</NAME>
#define ID_ISO_IEC_MPEG12_VIDEO_STREAM_0        0x000001E0
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_MPEG12_VIDEO_STREAM_16</NAME>
#define ID_ISO_IEC_MPEG12_VIDEO_STREAM_16       0x000001EF
</MACRO>
<MACRO>
<NAME>ID_ECM_STREAM</NAME>
#define ID_ECM_STREAM                           0x000001F0
</MACRO>
<MACRO>
<NAME>ID_EMM_STREAM</NAME>
#define ID_EMM_STREAM                           0x000001F1
</MACRO>
<MACRO>
<NAME>ID_DSMCC_STREAM</NAME>
#define ID_DSMCC_STREAM                         0x000001F2
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_13522_STREAM</NAME>
#define ID_ISO_IEC_13522_STREAM                 0x000001F3
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_A_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_A_STREAM          0x000001F4
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_B_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_B_STREAM          0x000001F5
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_C_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_C_STREAM          0x000001F6
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_D_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_D_STREAM          0x000001F7
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_E_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_E_STREAM          0x000001F8
</MACRO>
<MACRO>
<NAME>ID_ANCILLARY_STREAM</NAME>
#define ID_ANCILLARY_STREAM                     0x000001F9
</MACRO>
<MACRO>
<NAME>ID_RESERVED_STREAM_1</NAME>
#define ID_RESERVED_STREAM_1                    0x000001FA
</MACRO>
<MACRO>
<NAME>ID_RESERVED_STREAM_2</NAME>
#define ID_RESERVED_STREAM_2                    0x000001FB
</MACRO>
<MACRO>
<NAME>ID_EXTENDED_METADATA</NAME>
#define ID_EXTENDED_METADATA                    0x000001FC
</MACRO>
<MACRO>
<NAME>ID_EXTENDED_STREAM_ID</NAME>
#define ID_EXTENDED_STREAM_ID                   0x000001FD
</MACRO>
<MACRO>
<NAME>ID_RESERVED_STREAM_3</NAME>
#define ID_RESERVED_STREAM_3                    0x000001FE
</MACRO>
<MACRO>
<NAME>ID_PROGRAM_STREAM_DIRECTORY</NAME>
#define ID_PROGRAM_STREAM_DIRECTORY             0x000001FF
</MACRO>
<MACRO>
<NAME>PACKET_VIDEO_START_CODE</NAME>
#define PACKET_VIDEO_START_CODE                 0x000001E0
</MACRO>
<MACRO>
<NAME>PACKET_AUDIO_START_CODE</NAME>
#define PACKET_AUDIO_START_CODE                 0x000001C0
</MACRO>
<MACRO>
<NAME>PICTURE_START_CODE</NAME>
#define PICTURE_START_CODE                      0x00000100
</MACRO>
<MACRO>
<NAME>USER_DATA_START_CODE</NAME>
#define USER_DATA_START_CODE                    0x000001B2
</MACRO>
<MACRO>
<NAME>SEQUENCE_HEADER_CODE</NAME>
#define SEQUENCE_HEADER_CODE                    0x000001B3
</MACRO>
<MACRO>
<NAME>SEQUENCE_ERROR_CODE</NAME>
#define SEQUENCE_ERROR_CODE                     0x000001B4
</MACRO>
<MACRO>
<NAME>EXTENSION_START_CODE</NAME>
#define EXTENSION_START_CODE                    0x000001B5
</MACRO>
<MACRO>
<NAME>SEQUENCE_END_CODE</NAME>
#define SEQUENCE_END_CODE                       0x000001B7
</MACRO>
<MACRO>
<NAME>GROUP_START_CODE</NAME>
#define GROUP_START_CODE                        0x000001B8
</MACRO>
<MACRO>
<NAME>AC3_SYNC_WORD</NAME>
#define AC3_SYNC_WORD                           0x0b770000
</MACRO>
<MACRO>
<NAME>MPEG_TS_SYNC_BYTE</NAME>
#define MPEG_TS_SYNC_BYTE                       0x00000047
</MACRO>
<MACRO>
<NAME>PID_PROGRAM_ASSOCIATION_TABLE</NAME>
#define PID_PROGRAM_ASSOCIATION_TABLE          0x0000
</MACRO>
<MACRO>
<NAME>PID_CONDITIONAL_ACCESS_TABLE</NAME>
#define PID_CONDITIONAL_ACCESS_TABLE           0x0001
</MACRO>
<MACRO>
<NAME>PID_RESERVED_FIRST</NAME>
#define PID_RESERVED_FIRST                     0x0002
</MACRO>
<MACRO>
<NAME>PID_RESERVED_LAST</NAME>
#define PID_RESERVED_LAST                      0x0010
</MACRO>
<MACRO>
<NAME>PID_NULL_PACKET</NAME>
#define PID_NULL_PACKET                        0x1FFF
</MACRO>
<MACRO>
<NAME>PID_TYPE_UNKNOWN</NAME>
#define PID_TYPE_UNKNOWN                        0
</MACRO>
<MACRO>
<NAME>PID_TYPE_RESERVED</NAME>
#define PID_TYPE_RESERVED                       1
</MACRO>
<MACRO>
<NAME>PID_TYPE_PROGRAM_ASSOCIATION</NAME>
#define PID_TYPE_PROGRAM_ASSOCIATION            2
</MACRO>
<MACRO>
<NAME>PID_TYPE_CONDITIONAL_ACCESS</NAME>
#define PID_TYPE_CONDITIONAL_ACCESS             3
</MACRO>
<MACRO>
<NAME>PID_TYPE_PROGRAM_MAP</NAME>
#define PID_TYPE_PROGRAM_MAP                    4
</MACRO>
<MACRO>
<NAME>PID_TYPE_ELEMENTARY</NAME>
#define PID_TYPE_ELEMENTARY                     5
</MACRO>
<MACRO>
<NAME>PID_TYPE_NULL_PACKET</NAME>
#define PID_TYPE_NULL_PACKET                    6
</MACRO>
<MACRO>
<NAME>PID_TYPE_PRIVATE_SECTION</NAME>
#define PID_TYPE_PRIVATE_SECTION                7
</MACRO>
<MACRO>
<NAME>ST_RESERVED</NAME>
#define ST_RESERVED                     0x00
</MACRO>
<MACRO>
<NAME>ST_VIDEO_MPEG1</NAME>
#define ST_VIDEO_MPEG1                  0x01
</MACRO>
<MACRO>
<NAME>ST_VIDEO_MPEG2</NAME>
#define ST_VIDEO_MPEG2                  0x02
</MACRO>
<MACRO>
<NAME>ST_AUDIO_MPEG1</NAME>
#define ST_AUDIO_MPEG1                  0x03
</MACRO>
<MACRO>
<NAME>ST_AUDIO_MPEG2</NAME>
#define ST_AUDIO_MPEG2                  0x04
</MACRO>
<MACRO>
<NAME>ST_PRIVATE_SECTIONS</NAME>
#define ST_PRIVATE_SECTIONS             0x05
</MACRO>
<MACRO>
<NAME>ST_PRIVATE_DATA</NAME>
#define ST_PRIVATE_DATA                 0x06
</MACRO>
<MACRO>
<NAME>ST_MHEG</NAME>
#define ST_MHEG                         0x07
</MACRO>
<MACRO>
<NAME>ST_DSMCC</NAME>
#define ST_DSMCC                        0x08
</MACRO>
<MACRO>
<NAME>ST_H222_1</NAME>
#define ST_H222_1                       0x09
</MACRO>
<MACRO>
<NAME>ST_AUDIO_AAC_ADTS</NAME>
#define ST_AUDIO_AAC_ADTS               0x0f
</MACRO>
<MACRO>
<NAME>ST_AUDIO_AAC_LOAS</NAME>
#define ST_AUDIO_AAC_LOAS               0x11
</MACRO>
<MACRO>
<NAME>ST_VIDEO_MPEG4</NAME>
#define ST_VIDEO_MPEG4                  0x10
</MACRO>
<MACRO>
<NAME>ST_VIDEO_H264</NAME>
#define ST_VIDEO_H264                   0x1b
</MACRO>
<MACRO>
<NAME>ST_VIDEO_DIRAC</NAME>
#define ST_VIDEO_DIRAC                  0xd1
</MACRO>
<MACRO>
<NAME>ST_PS_AUDIO_AC3</NAME>
#define ST_PS_AUDIO_AC3                 0x81
</MACRO>
<MACRO>
<NAME>ST_PS_AUDIO_DTS</NAME>
#define ST_PS_AUDIO_DTS                 0x8a
</MACRO>
<MACRO>
<NAME>ST_PS_AUDIO_LPCM</NAME>
#define ST_PS_AUDIO_LPCM                0x8b
</MACRO>
<MACRO>
<NAME>ST_PS_DVD_SUBPICTURE</NAME>
#define ST_PS_DVD_SUBPICTURE            0xff
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_LPCM</NAME>
#define ST_BD_AUDIO_LPCM                0x80
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_AC3</NAME>
#define ST_BD_AUDIO_AC3                 0x81
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_DTS</NAME>
#define ST_BD_AUDIO_DTS                 0x82
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_AC3_TRUE_HD</NAME>
#define ST_BD_AUDIO_AC3_TRUE_HD         0x83
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_AC3_PLUS</NAME>
#define ST_BD_AUDIO_AC3_PLUS            0x84
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_DTS_HD</NAME>
#define ST_BD_AUDIO_DTS_HD              0x85
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_DTS_HD_MASTER_AUDIO</NAME>
#define ST_BD_AUDIO_DTS_HD_MASTER_AUDIO 0x86
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_EAC3</NAME>
#define ST_BD_AUDIO_EAC3                0x87
</MACRO>
<MACRO>
<NAME>ST_BD_PGS_SUBPICTURE</NAME>
#define ST_BD_PGS_SUBPICTURE            0x90
</MACRO>
<MACRO>
<NAME>ST_BD_IGS</NAME>
#define ST_BD_IGS                       0x91
</MACRO>
<MACRO>
<NAME>ST_BD_SUBTITLE</NAME>
#define ST_BD_SUBTITLE                  0x92
</MACRO>
<MACRO>
<NAME>ST_BD_SECONDARY_AC3_PLUS</NAME>
#define ST_BD_SECONDARY_AC3_PLUS        0xa1
</MACRO>
<MACRO>
<NAME>ST_BD_SECONDARY_DTS_HD</NAME>
#define ST_BD_SECONDARY_DTS_HD          0xa2
</MACRO>
<MACRO>
<NAME>ST_PRIVATE_EA</NAME>
#define ST_PRIVATE_EA                   0xea
</MACRO>
<MACRO>
<NAME>ST_HDV_AUX_A</NAME>
#define ST_HDV_AUX_A                    0xa0
</MACRO>
<MACRO>
<NAME>ST_HDV_AUX_V</NAME>
#define ST_HDV_AUX_V                    0xa1
</MACRO>
<MACRO>
<NAME>ST_PS_TIMECODE</NAME>
#define ST_PS_TIMECODE                  0xd2
</MACRO>
<MACRO>
<NAME>ST_GST_AUDIO_RAWA52</NAME>
#define ST_GST_AUDIO_RAWA52             0x181
</MACRO>
<MACRO>
<NAME>ST_GST_VIDEO_MPEG1_OR_2</NAME>
#define ST_GST_VIDEO_MPEG1_OR_2         0x102
</MACRO>
<MACRO>
<NAME>CLOCK_BASE</NAME>
#define CLOCK_BASE 9LL
</MACRO>
<MACRO>
<NAME>CLOCK_FREQ</NAME>
#define CLOCK_FREQ (CLOCK_BASE * 10000)
</MACRO>
<MACRO>
<NAME>MPEGTIME_TO_GSTTIME</NAME>
#define MPEGTIME_TO_GSTTIME(time) (gst_util_uint64_scale ((time), \
            GST_MSECOND/10, CLOCK_BASE))
</MACRO>
<MACRO>
<NAME>GSTTIME_TO_MPEGTIME</NAME>
#define GSTTIME_TO_MPEGTIME(time) (gst_util_uint64_scale ((time), \
            CLOCK_BASE, GST_MSECOND/10))
</MACRO>
<MACRO>
<NAME>MPEG_MUX_RATE_MULT</NAME>
#define MPEG_MUX_RATE_MULT      50
</MACRO>
<MACRO>
<NAME>READ_TS</NAME>
#define READ_TS(data, target, lost_sync_label)          \
    if ((*data & 0x01) != 0x01) goto lost_sync_label;   \
    target  = ((guint64) (*data++ & 0x0E)) << 29;       \
    target |= ((guint64) (*data++       )) << 22;       \
    if ((*data & 0x01) != 0x01) goto lost_sync_label;   \
    target |= ((guint64) (*data++ & 0xFE)) << 14;       \
    target |= ((guint64) (*data++       )) << 7;        \
    if ((*data & 0x01) != 0x01) goto lost_sync_label;   \
    target |= ((guint64) (*data++ & 0xFE)) >> 1;
</MACRO>
<MACRO>
<NAME>GST_FLOW_NEED_MORE_DATA</NAME>
#define GST_FLOW_NEED_MORE_DATA   GST_FLOW_CUSTOM_SUCCESS
</MACRO>
<MACRO>
<NAME>GST_FLOW_LOST_SYNC</NAME>
#define GST_FLOW_LOST_SYNC        GST_FLOW_CUSTOM_SUCCESS_1
</MACRO>
<USER_FUNCTION>
<NAME>GstPESFilterData</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstPESFilter * filter, gboolean first, GstBuffer * buffer, 
                         gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPESFilterResync</NAME>
<RETURNS>void </RETURNS>
GstPESFilter * filter, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPESFilterIndex</NAME>
<RETURNS>void </RETURNS>
GstPESFilter * filter, gpointer user_data
</USER_FUNCTION>
<ENUM>
<NAME>GstPESFilterState</NAME>
typedef enum {
  STATE_HEADER_PARSE,
  STATE_DATA_PUSH, 
  STATE_DATA_SKIP 
} GstPESFilterState;
</ENUM>
<STRUCT>
<NAME>GstPESFilter</NAME>
struct _GstPESFilter {
  GstAdapter         * adapter;
  guint64            * adapter_offset;

  GstPESFilterState  state;
  /* Whether to collect entire PES packets before
   * outputting */
  gboolean           gather_pes;
  /* Whether unbounded packets are allowed in this
   * stream */
  gboolean           allow_unbounded;

  gboolean           first;
  GstPESFilterData   data_cb;
  GstPESFilterResync resync_cb;
  gpointer           user_data;

  guint32            start_code;
  guint8             id;
  gboolean           unbounded_packet;
  guint16            length;

  gint64             pts;
  gint64             dts;
};
</STRUCT>
<FUNCTION>
<NAME>gst_pes_filter_init</NAME>
<RETURNS>void  </RETURNS>
GstPESFilter * filter, GstAdapter * adapter, guint64 * adapter_offset
</FUNCTION>
<FUNCTION>
<NAME>gst_pes_filter_uninit</NAME>
<RETURNS>void  </RETURNS>
GstPESFilter * filter
</FUNCTION>
<FUNCTION>
<NAME>gst_pes_filter_set_callbacks</NAME>
<RETURNS>void  </RETURNS>
GstPESFilter * filter, GstPESFilterData data_cb, GstPESFilterResync resync_cb, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_pes_filter_push</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstPESFilter * filter, GstBuffer * buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_pes_filter_process</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstPESFilter * filter
</FUNCTION>
<FUNCTION>
<NAME>gst_pes_filter_flush</NAME>
<RETURNS>void  </RETURNS>
GstPESFilter * filter
</FUNCTION>
<FUNCTION>
<NAME>gst_pes_filter_drain</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstPESFilter * filter
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CHROMA_HOLD</NAME>
#define GST_TYPE_CHROMA_HOLD \
  (gst_chroma_hold_get_type())
</MACRO>
<MACRO>
<NAME>GST_CHROMA_HOLD</NAME>
#define GST_CHROMA_HOLD(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CHROMA_HOLD,GstChromaHold))
</MACRO>
<MACRO>
<NAME>GST_CHROMA_HOLD_CLASS</NAME>
#define GST_CHROMA_HOLD_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CHROMA_HOLD,GstChromaHoldClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CHROMA_HOLD</NAME>
#define GST_IS_CHROMA_HOLD(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CHROMA_HOLD))
</MACRO>
<MACRO>
<NAME>GST_IS_CHROMA_HOLD_CLASS</NAME>
#define GST_IS_CHROMA_HOLD_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CHROMA_HOLD))
</MACRO>
<STRUCT>
<NAME>GstChromaHold</NAME>
struct _GstChromaHold
{
  GstVideoFilter parent;

  /* <private> */

  /* caps */
  GMutex lock;

  GstVideoFormat format;
  gint width, height;

  guint target_r;
  guint target_g;
  guint target_b;
  guint tolerance;

  /* processing function */
  void (*process) (GstVideoFrame * frame, gint width, gint height,
      GstChromaHold * chroma_hold);

  /* pre-calculated values */
  gint hue;
};
</STRUCT>
<STRUCT>
<NAME>GstChromaHoldClass</NAME>
struct _GstChromaHoldClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_chroma_hold_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gm_noise_new</NAME>
<RETURNS>GstGMNoise  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gm_noise_free</NAME>
<RETURNS>void  </RETURNS>
GstGMNoise * noise
</FUNCTION>
<FUNCTION>
<NAME>gst_gm_noise_2</NAME>
<RETURNS>gdouble  </RETURNS>
GstGMNoise * noise, gdouble x, gdouble y
</FUNCTION>
<FUNCTION>
<NAME>gst_gm_mod_float</NAME>
<RETURNS>gdouble  </RETURNS>
gdouble a, gdouble b
</FUNCTION>
<FUNCTION>
<NAME>gst_gm_triangle</NAME>
<RETURNS>gdouble  </RETURNS>
gdouble x
</FUNCTION>
<FUNCTION>
<NAME>gst_gm_smoothstep</NAME>
<RETURNS>gdouble  </RETURNS>
gdouble edge0, gdouble edge1, gdouble x
</FUNCTION>
<STRUCT>
<NAME>GstGMNoise</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_CIRCLE_GEOMETRIC_TRANSFORM</NAME>
#define GST_TYPE_CIRCLE_GEOMETRIC_TRANSFORM \
  (gst_circle_geometric_transform_get_type())
</MACRO>
<MACRO>
<NAME>GST_CIRCLE_GEOMETRIC_TRANSFORM</NAME>
#define GST_CIRCLE_GEOMETRIC_TRANSFORM(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CIRCLE_GEOMETRIC_TRANSFORM,GstCircleGeometricTransform))
</MACRO>
<MACRO>
<NAME>GST_CIRCLE_GEOMETRIC_TRANSFORM_CAST</NAME>
#define GST_CIRCLE_GEOMETRIC_TRANSFORM_CAST(obj) \
  ((GstCircleGeometricTransform *)(obj))
</MACRO>
<MACRO>
<NAME>GST_CIRCLE_GEOMETRIC_TRANSFORM_CLASS</NAME>
#define GST_CIRCLE_GEOMETRIC_TRANSFORM_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CIRCLE_GEOMETRIC_TRANSFORM,GstCircleGeometricTransformClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CIRCLE_GEOMETRIC_TRANSFORM</NAME>
#define GST_IS_CIRCLE_GEOMETRIC_TRANSFORM(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CIRCLE_GEOMETRIC_TRANSFORM))
</MACRO>
<MACRO>
<NAME>GST_IS_CIRCLE_GEOMETRIC_TRANSFORM_CLASS</NAME>
#define GST_IS_CIRCLE_GEOMETRIC_TRANSFORM_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CIRCLE_GEOMETRIC_TRANSFORM))
</MACRO>
<STRUCT>
<NAME>GstCircleGeometricTransform</NAME>
struct _GstCircleGeometricTransform
{
  GstGeometricTransform element;

  gdouble x_center;
  gdouble y_center;
  gdouble radius;

  gdouble precalc_x_center;
  gdouble precalc_y_center;
  gdouble precalc_radius;
  gdouble precalc_radius2;
};
</STRUCT>
<STRUCT>
<NAME>GstCircleGeometricTransformClass</NAME>
struct _GstCircleGeometricTransformClass
{
  GstGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_circle_geometric_transform_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_circle_geometric_transform_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PERSPECTIVE</NAME>
#define GST_TYPE_PERSPECTIVE \
  (gst_perspective_get_type())
</MACRO>
<MACRO>
<NAME>GST_PERSPECTIVE</NAME>
#define GST_PERSPECTIVE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PERSPECTIVE,GstPerspective))
</MACRO>
<MACRO>
<NAME>GST_PERSPECTIVE_CAST</NAME>
#define GST_PERSPECTIVE_CAST(obj) \
  ((GstPerspective *)(obj))
</MACRO>
<MACRO>
<NAME>GST_PERSPECTIVE_CLASS</NAME>
#define GST_PERSPECTIVE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PERSPECTIVE,GstPerspectiveClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PERSPECTIVE</NAME>
#define GST_IS_PERSPECTIVE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PERSPECTIVE))
</MACRO>
<MACRO>
<NAME>GST_IS_PERSPECTIVE_CLASS</NAME>
#define GST_IS_PERSPECTIVE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PERSPECTIVE))
</MACRO>
<STRUCT>
<NAME>GstPerspective</NAME>
struct _GstPerspective
{
  GstGeometricTransform element;

  gdouble matrix[9];
};
</STRUCT>
<STRUCT>
<NAME>GstPerspectiveClass</NAME>
struct _GstPerspectiveClass
{
  GstGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_perspective_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_perspective_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ROTATE</NAME>
#define GST_TYPE_ROTATE \
  (gst_rotate_get_type())
</MACRO>
<MACRO>
<NAME>GST_ROTATE</NAME>
#define GST_ROTATE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ROTATE,GstRotate))
</MACRO>
<MACRO>
<NAME>GST_ROTATE_CAST</NAME>
#define GST_ROTATE_CAST(obj) \
  ((GstRotate *)(obj))
</MACRO>
<MACRO>
<NAME>GST_ROTATE_CLASS</NAME>
#define GST_ROTATE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ROTATE,GstRotateClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ROTATE</NAME>
#define GST_IS_ROTATE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ROTATE))
</MACRO>
<MACRO>
<NAME>GST_IS_ROTATE_CLASS</NAME>
#define GST_IS_ROTATE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ROTATE))
</MACRO>
<STRUCT>
<NAME>GstRotate</NAME>
struct _GstRotate
{
  GstGeometricTransform element;

  gdouble angle;
};
</STRUCT>
<STRUCT>
<NAME>GstRotateClass</NAME>
struct _GstRotateClass
{
  GstGeometricTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rotate_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rotate_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GEOMETRIC_TRANSFORM</NAME>
#define GST_TYPE_GEOMETRIC_TRANSFORM \
  (gst_geometric_transform_get_type())
</MACRO>
<MACRO>
<NAME>GST_GEOMETRIC_TRANSFORM</NAME>
#define GST_GEOMETRIC_TRANSFORM(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GEOMETRIC_TRANSFORM,GstGeometricTransform))
</MACRO>
<MACRO>
<NAME>GST_GEOMETRIC_TRANSFORM_CAST</NAME>
#define GST_GEOMETRIC_TRANSFORM_CAST(obj) ((GstGeometricTransform *)(obj))
</MACRO>
<MACRO>
<NAME>GST_GEOMETRIC_TRANSFORM_CLASS</NAME>
#define GST_GEOMETRIC_TRANSFORM_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GEOMETRIC_TRANSFORM,GstGeometricTransformClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GEOMETRIC_TRANSFORM</NAME>
#define GST_IS_GEOMETRIC_TRANSFORM(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GEOMETRIC_TRANSFORM))
</MACRO>
<MACRO>
<NAME>GST_IS_GEOMETRIC_TRANSFORM_CLASS</NAME>
#define GST_IS_GEOMETRIC_TRANSFORM_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GEOMETRIC_TRANSFORM))
</MACRO>
<MACRO>
<NAME>GST_GEOMETRIC_TRANSFORM_GET_CLASS</NAME>
#define GST_GEOMETRIC_TRANSFORM_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_GEOMETRIC_TRANSFORM,GstGeometricTransformClass))
</MACRO>
<USER_FUNCTION>
<NAME>GstGeometricTransformMapFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstGeometricTransform * gt,
    gint x, gint y, gdouble * _input_x, gdouble *_input_y
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstGeometricTransformPrepareFunc</NAME>
<RETURNS>gboolean </RETURNS>

    GstGeometricTransform * gt
</USER_FUNCTION>
<STRUCT>
<NAME>GstGeometricTransform</NAME>
struct _GstGeometricTransform {
  GstVideoFilter videofilter;

  gint width, height;
  GstVideoFormat format;
  gint pixel_stride;
  gint row_stride;

  /* Must be set on NULL state.
   * Useful for subclasses that use don't want to use a fixed precalculated
   * pixel mapping table. Like 'diffuse' that uses random values for each pic.
   */
  gboolean precalc_map;
  gboolean needs_remap;

  /* properties */
  gint off_edge_pixels;

  gdouble *map;
};
</STRUCT>
<STRUCT>
<NAME>GstGeometricTransformClass</NAME>
struct _GstGeometricTransformClass {
  GstVideoFilterClass parent_class;

  GstGeometricTransformMapFunc map_func;
  GstGeometricTransformPrepareFunc prepare_func;
};
</STRUCT>
<FUNCTION>
<NAME>gst_geometric_transform_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_geometric_transform_set_need_remap</NAME>
<RETURNS>void  </RETURNS>
GstGeometricTransform * gt
</FUNCTION>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<MACRO>
<NAME>GST_TYPE_COMPOSITOR_PAD</NAME>
#define GST_TYPE_COMPOSITOR_PAD (gst_compositor_pad_get_type())
</MACRO>
<MACRO>
<NAME>GST_COMPOSITOR_PAD</NAME>
#define GST_COMPOSITOR_PAD(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_COMPOSITOR_PAD, GstCompositorPad))
</MACRO>
<MACRO>
<NAME>GST_COMPOSITOR_PAD_CLASS</NAME>
#define GST_COMPOSITOR_PAD_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_COMPOSITOR_PAD, GstCompositorPadClass))
</MACRO>
<MACRO>
<NAME>GST_IS_COMPOSITOR_PAD</NAME>
#define GST_IS_COMPOSITOR_PAD(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_COMPOSITOR_PAD))
</MACRO>
<MACRO>
<NAME>GST_IS_COMPOSITOR_PAD_CLASS</NAME>
#define GST_IS_COMPOSITOR_PAD_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_COMPOSITOR_PAD))
</MACRO>
<STRUCT>
<NAME>GstCompositorPad</NAME>
struct _GstCompositorPad
{
  GstVideoAggregatorPad parent;

  /* properties */
  gint xpos, ypos;
  gint width, height;
  gdouble alpha;

  GstVideoConverter *convert;
  GstVideoInfo conversion_info;
  GstBuffer *converted_buffer;
};
</STRUCT>
<STRUCT>
<NAME>GstCompositorPadClass</NAME>
struct _GstCompositorPadClass
{
  GstVideoAggregatorPadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_compositor_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_COMPOSITOR</NAME>
#define GST_TYPE_COMPOSITOR (gst_compositor_get_type())
</MACRO>
<MACRO>
<NAME>GST_COMPOSITOR</NAME>
#define GST_COMPOSITOR(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_COMPOSITOR, GstCompositor))
</MACRO>
<MACRO>
<NAME>GST_COMPOSITOR_CLASS</NAME>
#define GST_COMPOSITOR_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_COMPOSITOR, GstCompositorClass))
</MACRO>
<MACRO>
<NAME>GST_IS_COMPOSITOR</NAME>
#define GST_IS_COMPOSITOR(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_COMPOSITOR))
</MACRO>
<MACRO>
<NAME>GST_IS_COMPOSITOR_CLASS</NAME>
#define GST_IS_COMPOSITOR_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_COMPOSITOR))
</MACRO>
<ENUM>
<NAME>GstCompositorBackground</NAME>
typedef enum
{
  COMPOSITOR_BACKGROUND_CHECKER,
  COMPOSITOR_BACKGROUND_BLACK,
  COMPOSITOR_BACKGROUND_WHITE,
  COMPOSITOR_BACKGROUND_TRANSPARENT,
}
GstCompositorBackground;
</ENUM>
<STRUCT>
<NAME>GstCompositor</NAME>
struct _GstCompositor
{
  GstVideoAggregator videoaggregator;
  GstCompositorBackground background;

  BlendFunction blend, overlay;
  FillCheckerFunction fill_checker;
  FillColorFunction fill_color;
};
</STRUCT>
<STRUCT>
<NAME>GstCompositorClass</NAME>
struct _GstCompositorClass
{
  GstVideoAggregatorClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_compositor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<USER_FUNCTION>
<NAME>BlendFunction</NAME>
<RETURNS>void </RETURNS>
GstVideoFrame *srcframe, gint xpos, gint ypos, gdouble src_alpha, GstVideoFrame * destframe
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>FillCheckerFunction</NAME>
<RETURNS>void </RETURNS>
GstVideoFrame * frame
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>FillColorFunction</NAME>
<RETURNS>void </RETURNS>
GstVideoFrame * frame, gint c1, gint c2, gint c3
</USER_FUNCTION>
<VARIABLE>
<NAME>gst_compositor_blend_argb</NAME>
extern BlendFunction gst_compositor_blend_argb;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_blend_bgra</NAME>
extern BlendFunction gst_compositor_blend_bgra;
</VARIABLE>
<MACRO>
<NAME>gst_compositor_blend_ayuv</NAME>
#define gst_compositor_blend_ayuv gst_compositor_blend_argb
</MACRO>
<MACRO>
<NAME>gst_compositor_blend_abgr</NAME>
#define gst_compositor_blend_abgr gst_compositor_blend_argb
</MACRO>
<MACRO>
<NAME>gst_compositor_blend_rgba</NAME>
#define gst_compositor_blend_rgba gst_compositor_blend_bgra
</MACRO>
<VARIABLE>
<NAME>gst_compositor_overlay_argb</NAME>
extern BlendFunction gst_compositor_overlay_argb;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_overlay_bgra</NAME>
extern BlendFunction gst_compositor_overlay_bgra;
</VARIABLE>
<MACRO>
<NAME>gst_compositor_overlay_ayuv</NAME>
#define gst_compositor_overlay_ayuv gst_compositor_overlay_argb
</MACRO>
<MACRO>
<NAME>gst_compositor_overlay_abgr</NAME>
#define gst_compositor_overlay_abgr gst_compositor_overlay_argb
</MACRO>
<MACRO>
<NAME>gst_compositor_overlay_rgba</NAME>
#define gst_compositor_overlay_rgba gst_compositor_overlay_bgra
</MACRO>
<VARIABLE>
<NAME>gst_compositor_blend_i420</NAME>
extern BlendFunction gst_compositor_blend_i420;
</VARIABLE>
<MACRO>
<NAME>gst_compositor_blend_yv12</NAME>
#define gst_compositor_blend_yv12 gst_compositor_blend_i420
</MACRO>
<VARIABLE>
<NAME>gst_compositor_blend_nv12</NAME>
extern BlendFunction gst_compositor_blend_nv12;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_blend_nv21</NAME>
extern BlendFunction gst_compositor_blend_nv21;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_blend_y41b</NAME>
extern BlendFunction gst_compositor_blend_y41b;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_blend_y42b</NAME>
extern BlendFunction gst_compositor_blend_y42b;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_blend_y444</NAME>
extern BlendFunction gst_compositor_blend_y444;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_blend_rgb</NAME>
extern BlendFunction gst_compositor_blend_rgb;
</VARIABLE>
<MACRO>
<NAME>gst_compositor_blend_bgr</NAME>
#define gst_compositor_blend_bgr gst_compositor_blend_rgb
</MACRO>
<VARIABLE>
<NAME>gst_compositor_blend_rgbx</NAME>
extern BlendFunction gst_compositor_blend_rgbx;
</VARIABLE>
<MACRO>
<NAME>gst_compositor_blend_bgrx</NAME>
#define gst_compositor_blend_bgrx gst_compositor_blend_rgbx
</MACRO>
<MACRO>
<NAME>gst_compositor_blend_xrgb</NAME>
#define gst_compositor_blend_xrgb gst_compositor_blend_rgbx
</MACRO>
<MACRO>
<NAME>gst_compositor_blend_xbgr</NAME>
#define gst_compositor_blend_xbgr gst_compositor_blend_rgbx
</MACRO>
<VARIABLE>
<NAME>gst_compositor_blend_yuy2</NAME>
extern BlendFunction gst_compositor_blend_yuy2;
</VARIABLE>
<MACRO>
<NAME>gst_compositor_blend_uyvy</NAME>
#define gst_compositor_blend_uyvy gst_compositor_blend_yuy2;
</MACRO>
<MACRO>
<NAME>gst_compositor_blend_yvyu</NAME>
#define gst_compositor_blend_yvyu gst_compositor_blend_yuy2;
</MACRO>
<VARIABLE>
<NAME>gst_compositor_fill_checker_argb</NAME>
extern FillCheckerFunction gst_compositor_fill_checker_argb;
</VARIABLE>
<MACRO>
<NAME>gst_compositor_fill_checker_abgr</NAME>
#define gst_compositor_fill_checker_abgr gst_compositor_fill_checker_argb
</MACRO>
<VARIABLE>
<NAME>gst_compositor_fill_checker_bgra</NAME>
extern FillCheckerFunction gst_compositor_fill_checker_bgra;
</VARIABLE>
<MACRO>
<NAME>gst_compositor_fill_checker_rgba</NAME>
#define gst_compositor_fill_checker_rgba gst_compositor_fill_checker_bgra
</MACRO>
<VARIABLE>
<NAME>gst_compositor_fill_checker_ayuv</NAME>
extern FillCheckerFunction gst_compositor_fill_checker_ayuv;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_checker_i420</NAME>
extern FillCheckerFunction gst_compositor_fill_checker_i420;
</VARIABLE>
<MACRO>
<NAME>gst_compositor_fill_checker_yv12</NAME>
#define gst_compositor_fill_checker_yv12 gst_compositor_fill_checker_i420
</MACRO>
<VARIABLE>
<NAME>gst_compositor_fill_checker_nv12</NAME>
extern FillCheckerFunction gst_compositor_fill_checker_nv12;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_checker_nv21</NAME>
extern FillCheckerFunction gst_compositor_fill_checker_nv21;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_checker_y41b</NAME>
extern FillCheckerFunction gst_compositor_fill_checker_y41b;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_checker_y42b</NAME>
extern FillCheckerFunction gst_compositor_fill_checker_y42b;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_checker_y444</NAME>
extern FillCheckerFunction gst_compositor_fill_checker_y444;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_checker_rgb</NAME>
extern FillCheckerFunction gst_compositor_fill_checker_rgb;
</VARIABLE>
<MACRO>
<NAME>gst_compositor_fill_checker_bgr</NAME>
#define gst_compositor_fill_checker_bgr gst_compositor_fill_checker_rgb
</MACRO>
<VARIABLE>
<NAME>gst_compositor_fill_checker_rgbx</NAME>
extern FillCheckerFunction gst_compositor_fill_checker_rgbx;
</VARIABLE>
<MACRO>
<NAME>gst_compositor_fill_checker_bgrx</NAME>
#define gst_compositor_fill_checker_bgrx gst_compositor_fill_checker_rgbx
</MACRO>
<MACRO>
<NAME>gst_compositor_fill_checker_xrgb</NAME>
#define gst_compositor_fill_checker_xrgb gst_compositor_fill_checker_rgbx
</MACRO>
<MACRO>
<NAME>gst_compositor_fill_checker_xbgr</NAME>
#define gst_compositor_fill_checker_xbgr gst_compositor_fill_checker_rgbx
</MACRO>
<VARIABLE>
<NAME>gst_compositor_fill_checker_yuy2</NAME>
extern FillCheckerFunction gst_compositor_fill_checker_yuy2;
</VARIABLE>
<MACRO>
<NAME>gst_compositor_fill_checker_yvyu</NAME>
#define gst_compositor_fill_checker_yvyu gst_compositor_fill_checker_yuy2;
</MACRO>
<VARIABLE>
<NAME>gst_compositor_fill_checker_uyvy</NAME>
extern FillCheckerFunction gst_compositor_fill_checker_uyvy;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_argb</NAME>
extern FillColorFunction gst_compositor_fill_color_argb;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_abgr</NAME>
extern FillColorFunction gst_compositor_fill_color_abgr;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_bgra</NAME>
extern FillColorFunction gst_compositor_fill_color_bgra;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_rgba</NAME>
extern FillColorFunction gst_compositor_fill_color_rgba;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_ayuv</NAME>
extern FillColorFunction gst_compositor_fill_color_ayuv;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_i420</NAME>
extern FillColorFunction gst_compositor_fill_color_i420;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_yv12</NAME>
extern FillColorFunction gst_compositor_fill_color_yv12;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_nv12</NAME>
extern FillColorFunction gst_compositor_fill_color_nv12;
</VARIABLE>
<MACRO>
<NAME>gst_compositor_fill_color_nv21</NAME>
#define gst_compositor_fill_color_nv21 gst_compositor_fill_color_nv12;
</MACRO>
<VARIABLE>
<NAME>gst_compositor_fill_color_y41b</NAME>
extern FillColorFunction gst_compositor_fill_color_y41b;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_y42b</NAME>
extern FillColorFunction gst_compositor_fill_color_y42b;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_y444</NAME>
extern FillColorFunction gst_compositor_fill_color_y444;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_rgb</NAME>
extern FillColorFunction gst_compositor_fill_color_rgb;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_bgr</NAME>
extern FillColorFunction gst_compositor_fill_color_bgr;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_xrgb</NAME>
extern FillColorFunction gst_compositor_fill_color_xrgb;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_xbgr</NAME>
extern FillColorFunction gst_compositor_fill_color_xbgr;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_rgbx</NAME>
extern FillColorFunction gst_compositor_fill_color_rgbx;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_bgrx</NAME>
extern FillColorFunction gst_compositor_fill_color_bgrx;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_yuy2</NAME>
extern FillColorFunction gst_compositor_fill_color_yuy2;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_yvyu</NAME>
extern FillColorFunction gst_compositor_fill_color_yvyu;
</VARIABLE>
<VARIABLE>
<NAME>gst_compositor_fill_color_uyvy</NAME>
extern FillColorFunction gst_compositor_fill_color_uyvy;
</VARIABLE>
<FUNCTION>
<NAME>gst_compositor_init_blend</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ID3_VERSION_2_3</NAME>
#define ID3_VERSION_2_3 3
</MACRO>
<MACRO>
<NAME>ID3_VERSION_2_4</NAME>
#define ID3_VERSION_2_4 4
</MACRO>
<FUNCTION>
<NAME>id3_mux_render_v2_tag</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstTagMux        * mux, const GstTagList * taglist, int                version
</FUNCTION>
<FUNCTION>
<NAME>id3_mux_render_v1_tag</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstTagMux        * mux, const GstTagList * taglist
</FUNCTION>
<STRUCT>
<NAME>GstId3Mux</NAME>
struct _GstId3Mux {
  GstTagMux  tagmux;

  gboolean write_v1;
  gboolean write_v2;

  gint     v2_major_version;
};
</STRUCT>
<STRUCT>
<NAME>GstId3MuxClass</NAME>
struct _GstId3MuxClass {
  GstTagMuxClass  tagmux_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_ID3_MUX</NAME>
#define GST_TYPE_ID3_MUX \
  (gst_id3_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_ID3_MUX</NAME>
#define GST_ID3_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ID3_MUX,GstId3Mux))
</MACRO>
<MACRO>
<NAME>GST_ID3_MUX_CLASS</NAME>
#define GST_ID3_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ID3_MUX,GstId3MuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ID3_MUX</NAME>
#define GST_IS_ID3_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ID3_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_ID3_MUX_CLASS</NAME>
#define GST_IS_ID3_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ID3_MUX))
</MACRO>
<FUNCTION>
<NAME>gst_id3_mux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_COMB_DETECT</NAME>
#define GST_TYPE_COMB_DETECT   (gst_comb_detect_get_type())
</MACRO>
<MACRO>
<NAME>GST_COMB_DETECT</NAME>
#define GST_COMB_DETECT(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_COMB_DETECT,GstCombDetect))
</MACRO>
<MACRO>
<NAME>GST_COMB_DETECT_CLASS</NAME>
#define GST_COMB_DETECT_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_COMB_DETECT,GstCombDetectClass))
</MACRO>
<MACRO>
<NAME>GST_IS_COMB_DETECT</NAME>
#define GST_IS_COMB_DETECT(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_COMB_DETECT))
</MACRO>
<MACRO>
<NAME>GST_IS_COMB_DETECT_CLASS</NAME>
#define GST_IS_COMB_DETECT_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_COMB_DETECT))
</MACRO>
<STRUCT>
<NAME>GstCombDetect</NAME>
struct _GstCombDetect
{
  GstVideoFilter base_combdetect;

  GstVideoInfo vinfo;
};
</STRUCT>
<STRUCT>
<NAME>GstCombDetectClass</NAME>
struct _GstCombDetectClass
{
  GstVideoFilterClass base_combdetect_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_comb_detect_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_IVTC</NAME>
#define GST_TYPE_IVTC   (gst_ivtc_get_type())
</MACRO>
<MACRO>
<NAME>GST_IVTC</NAME>
#define GST_IVTC(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_IVTC,GstIvtc))
</MACRO>
<MACRO>
<NAME>GST_IVTC_CLASS</NAME>
#define GST_IVTC_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_IVTC,GstIvtcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_IVTC</NAME>
#define GST_IS_IVTC(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_IVTC))
</MACRO>
<MACRO>
<NAME>GST_IS_IVTC_CLASS</NAME>
#define GST_IS_IVTC_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_IVTC))
</MACRO>
<STRUCT>
<NAME>GstIvtcField</NAME>
struct _GstIvtcField
{
  GstBuffer *buffer;
  int parity;
  GstVideoFrame frame;
  GstClockTime ts;
};
</STRUCT>
<MACRO>
<NAME>GST_IVTC_MAX_FIELDS</NAME>
#define GST_IVTC_MAX_FIELDS 10
</MACRO>
<STRUCT>
<NAME>GstIvtc</NAME>
struct _GstIvtc
{
  GstBaseTransform base_ivtc;

  GstSegment segment;

  GstVideoInfo sink_video_info;
  GstVideoInfo src_video_info;
  GstClockTime current_ts;
  GstClockTime field_duration;

  int n_fields;
  GstIvtcField fields[GST_IVTC_MAX_FIELDS];
};
</STRUCT>
<STRUCT>
<NAME>GstIvtcClass</NAME>
struct _GstIvtcClass
{
  GstBaseTransformClass base_ivtc_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ivtc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>calc_crc32</NAME>
<RETURNS>guint32 </RETURNS>
guint8 *data, guint datalen
</FUNCTION>
<FUNCTION>
<NAME>mpegpsmux_prepare_h264</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstBuffer * buf, MpegPsPadData * data, MpegPsMux * mux
</FUNCTION>
<USER_FUNCTION>
<NAME>PsMuxStreamBufferReleaseFunc</NAME>
<RETURNS>void </RETURNS>
guint8 *data, void *user_data
</USER_FUNCTION>
<ENUM>
<NAME>PsMuxStreamType</NAME>
enum PsMuxStreamType { /* Table 2-29 in spec */
  PSMUX_ST_RESERVED                   = 0x00,
  PSMUX_ST_VIDEO_MPEG1                = 0x01,
  PSMUX_ST_VIDEO_MPEG2                = 0x02,
  PSMUX_ST_AUDIO_MPEG1                = 0x03,
  PSMUX_ST_AUDIO_MPEG2                = 0x04,
  PSMUX_ST_PRIVATE_SECTIONS           = 0x05,
  PSMUX_ST_PRIVATE_DATA               = 0x06,
  PSMUX_ST_MHEG                       = 0x07,
  PSMUX_ST_DSMCC                      = 0x08,
  PSMUX_ST_H222_1                     = 0x09,

  /* later extensions */
  PSMUX_ST_AUDIO_AAC                  = 0x0f,
  PSMUX_ST_VIDEO_MPEG4                = 0x10,
  PSMUX_ST_VIDEO_H264                 = 0x1b,

  /* private stream types */
  PSMUX_ST_PS_AUDIO_AC3               = 0x81,
  PSMUX_ST_PS_AUDIO_DTS               = 0x8a,
  PSMUX_ST_PS_AUDIO_LPCM              = 0x8b,
  PSMUX_ST_PS_DVD_SUBPICTURE          = 0xff,

  /* Non-standard definitions */
  PSMUX_ST_VIDEO_DIRAC                = 0xD1
};
</ENUM>
<STRUCT>
<NAME>PsMuxStreamBuffer</NAME>
struct PsMuxStreamBuffer
{
  gboolean keyunit;

  /* PTS & DTS associated with the contents of this buffer */
  GstClockTime pts;
  GstClockTime dts;

  GstBuffer *buf;
  GstMapInfo map;
};
</STRUCT>
<STRUCT>
<NAME>PsMuxStream</NAME>
struct PsMuxStream{
  PsMuxPacketInfo pi;

  PsMuxStreamType stream_type;
  guint8 stream_id;
  guint8 stream_id_ext; /* extended stream id (13818-1 Amdt 2) */

  /* List of data buffers available for writing out */
  GList *buffers;
  guint32 bytes_avail;

  /* Current data buffer being consumed */
  PsMuxStreamBuffer *cur_buffer;
  guint32 cur_buffer_consumed;

  /* PES payload */
  guint16 cur_pes_payload_size;
  guint16 pes_bytes_written; /* delete*/

  /* PTS/DTS to write if the flags in the packet info are set */
  gint64 pts; /* TODO: cur_buffer->pts?*/
  gint64 dts; /* TODO: cur_buffer->dts?*/
  gint64 last_pts;

  /* stream type */
  gboolean is_video_stream;
  gboolean is_audio_stream;

  /* for writing descriptors */
  gint audio_sampling;
  gint audio_channels;
  gint audio_bitrate;

  /* for writing buffer size in system header */
  guint max_buffer_size;
};
</STRUCT>
<FUNCTION>
<NAME>psmux_stream_new</NAME>
<RETURNS>PsMuxStream *    </RETURNS>
PsMux * mux, PsMuxStreamType stream_type
</FUNCTION>
<FUNCTION>
<NAME>psmux_stream_free</NAME>
<RETURNS>void  		</RETURNS>
PsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>psmux_stream_add_data</NAME>
<RETURNS>void  		</RETURNS>
PsMuxStream *stream, GstBuffer * buffer, gint64 pts, gint64 dts, gboolean keyunit
</FUNCTION>
<FUNCTION>
<NAME>psmux_stream_bytes_in_buffer</NAME>
<RETURNS>gint  		</RETURNS>
PsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>psmux_stream_bytes_avail</NAME>
<RETURNS>gint  		</RETURNS>
PsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>psmux_stream_get_data</NAME>
<RETURNS>guint 	 	</RETURNS>
PsMuxStream *stream, guint8 *buf, guint len
</FUNCTION>
<FUNCTION>
<NAME>psmux_stream_get_es_descrs</NAME>
<RETURNS>void  		</RETURNS>
PsMuxStream *stream, guint8 *buf, guint16 *len
</FUNCTION>
<FUNCTION>
<NAME>psmux_stream_get_pts</NAME>
<RETURNS>guint64  	</RETURNS>
PsMuxStream *stream
</FUNCTION>
<MACRO>
<NAME>PSMUX_STREAM_ID_MPGA_INIT</NAME>
#define PSMUX_STREAM_ID_MPGA_INIT       0xc0
</MACRO>
<MACRO>
<NAME>PSMUX_STREAM_ID_MPGA_MAX</NAME>
#define PSMUX_STREAM_ID_MPGA_MAX        0xcf
</MACRO>
<MACRO>
<NAME>PSMUX_STREAM_ID_MPGV_INIT</NAME>
#define PSMUX_STREAM_ID_MPGV_INIT       0xe0
</MACRO>
<MACRO>
<NAME>PSMUX_STREAM_ID_MPGV_MAX</NAME>
#define PSMUX_STREAM_ID_MPGV_MAX        0xef
</MACRO>
<MACRO>
<NAME>PSMUX_STREAM_ID_AC3_INIT</NAME>
#define PSMUX_STREAM_ID_AC3_INIT        0x80
</MACRO>
<MACRO>
<NAME>PSMUX_STREAM_ID_AC3_MAX</NAME>
#define PSMUX_STREAM_ID_AC3_MAX         0x87
</MACRO>
<MACRO>
<NAME>PSMUX_STREAM_ID_SPU_INIT</NAME>
#define PSMUX_STREAM_ID_SPU_INIT        0x20
</MACRO>
<MACRO>
<NAME>PSMUX_STREAM_ID_SPU_MAX</NAME>
#define PSMUX_STREAM_ID_SPU_MAX        	0x3f
</MACRO>
<MACRO>
<NAME>PSMUX_STREAM_ID_DTS_INIT</NAME>
#define PSMUX_STREAM_ID_DTS_INIT        0x88
</MACRO>
<MACRO>
<NAME>PSMUX_STREAM_ID_DTS_MAX</NAME>
#define PSMUX_STREAM_ID_DTS_MAX         0x8f
</MACRO>
<MACRO>
<NAME>PSMUX_STREAM_ID_LPCM_INIT</NAME>
#define PSMUX_STREAM_ID_LPCM_INIT       0xa0
</MACRO>
<MACRO>
<NAME>PSMUX_STREAM_ID_LPCM_MAX</NAME>
#define PSMUX_STREAM_ID_LPCM_MAX        0xaf
</MACRO>
<MACRO>
<NAME>PSMUX_STREAM_ID_DIRAC_INIT</NAME>
#define PSMUX_STREAM_ID_DIRAC_INIT      0x60
</MACRO>
<MACRO>
<NAME>PSMUX_STREAM_ID_DIRAC_MAX</NAME>
#define PSMUX_STREAM_ID_DIRAC_MAX       0x6f
</MACRO>
<STRUCT>
<NAME>PsMuxStreamIdInfo</NAME>
struct PsMuxStreamIdInfo {
    guint8 id_mpga;
    guint8 id_mpgv;
    guint8 id_ac3;
    guint8 id_spu;
    guint8 id_dts;
    guint8 id_lpcm;
    guint8 id_dirac;
};
</STRUCT>
<FUNCTION>
<NAME>psmux_stream_id_info_init</NAME>
<RETURNS>void </RETURNS>
PsMuxStreamIdInfo * info
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEG_PSMUX</NAME>
#define GST_TYPE_MPEG_PSMUX  (mpegpsmux_get_type())
</MACRO>
<MACRO>
<NAME>GST_MPEG_PSMUX</NAME>
#define GST_MPEG_PSMUX(obj)  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_MPEG_PSMUX, MpegPsMux))
</MACRO>
<TYPEDEF>
<NAME>MpegPsMux</NAME>
typedef struct MpegPsMux MpegPsMux;
</TYPEDEF>
<TYPEDEF>
<NAME>MpegPsMuxClass</NAME>
typedef struct MpegPsMuxClass MpegPsMuxClass;
</TYPEDEF>
<TYPEDEF>
<NAME>MpegPsPadData</NAME>
typedef struct MpegPsPadData MpegPsPadData;
</TYPEDEF>
<USER_FUNCTION>
<NAME>MpegPsPadDataPrepareFunction</NAME>
<RETURNS>GstBuffer *</RETURNS>
GstBuffer * buf,
    MpegPsPadData * data, MpegPsMux * mux
</USER_FUNCTION>
<FUNCTION>
<NAME>mpegpsmux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>CLOCK_BASE</NAME>
#define CLOCK_BASE 9LL
</MACRO>
<MACRO>
<NAME>CLOCK_FREQ</NAME>
#define CLOCK_FREQ (CLOCK_BASE * 10000)
</MACRO>
<MACRO>
<NAME>GSTTIME_TO_MPEGTIME</NAME>
#define GSTTIME_TO_MPEGTIME(time) \
    (GST_CLOCK_TIME_IS_VALID(time) ? \
        gst_util_uint64_scale ((time), CLOCK_BASE, GST_MSECOND/10) : \
            -1)
</MACRO>
<MACRO>
<NAME>NORMAL_TS_PACKET_LENGTH</NAME>
#define NORMAL_TS_PACKET_LENGTH 188
</MACRO>
<MACRO>
<NAME>M2TS_PACKET_LENGTH</NAME>
#define M2TS_PACKET_LENGTH      192
</MACRO>
<MACRO>
<NAME>STANDARD_TIME_CLOCK</NAME>
#define STANDARD_TIME_CLOCK     27000000
</MACRO>
<MACRO>
<NAME>TWO_POW_33_MINUS1</NAME>
#define TWO_POW_33_MINUS1     ((0xffffffff * 2) - 1) 
</MACRO>
<MACRO>
<NAME>PSMUX_PACK_HDR_FREQ</NAME>
#define PSMUX_PACK_HDR_FREQ	30
</MACRO>
<MACRO>
<NAME>PSMUX_SYS_HDR_FREQ</NAME>
#define PSMUX_SYS_HDR_FREQ	300
</MACRO>
<MACRO>
<NAME>PSMUX_PSM_FREQ</NAME>
#define PSMUX_PSM_FREQ		300
</MACRO>
<MACRO>
<NAME>PSMUX_PES_MAX_PAYLOAD</NAME>
#define PSMUX_PES_MAX_PAYLOAD 65500 /* from VLC */
</MACRO>
<MACRO>
<NAME>PSMUX_PES_MAX_HDR_LEN</NAME>
#define PSMUX_PES_MAX_HDR_LEN 30
</MACRO>
<MACRO>
<NAME>PSMUX_MAX_PACKET_LEN</NAME>
#define PSMUX_MAX_PACKET_LEN (PSMUX_PES_MAX_PAYLOAD + PSMUX_PES_MAX_HDR_LEN)
</MACRO>
<MACRO>
<NAME>CLOCKBASE</NAME>
#define CLOCKBASE 90000
</MACRO>
<MACRO>
<NAME>PSMUX_PACK_HDR_INTERVAL</NAME>
#define PSMUX_PACK_HDR_INTERVAL		( 0.7 * CLOCKBASE) /* interval to update pack header. 0.7 sec */
</MACRO>
<MACRO>
<NAME>PSMUX_BITRATE_CALC_INTERVAL</NAME>
#define PSMUX_BITRATE_CALC_INTERVAL	CLOCKBASE /* interval to update bitrate in pack header. 1 sec */
</MACRO>
<MACRO>
<NAME>PSMUX_PES_BITRATE_DEFAULT</NAME>
#define PSMUX_PES_BITRATE_DEFAULT 1000 /* Default bit_rate to write in the first pack header */
</MACRO>
<MACRO>
<NAME>PSMUX_START_CODE_PREFIX</NAME>
#define PSMUX_START_CODE_PREFIX         0x01
</MACRO>
<MACRO>
<NAME>PSMUX_PACK_HEADER</NAME>
#define PSMUX_PACK_HEADER               0xba
</MACRO>
<MACRO>
<NAME>PSMUX_SYSTEM_HEADER</NAME>
#define PSMUX_SYSTEM_HEADER             0xbb
</MACRO>
<MACRO>
<NAME>PSMUX_PROGRAM_STREAM_MAP</NAME>
#define PSMUX_PROGRAM_STREAM_MAP        0xbc
</MACRO>
<MACRO>
<NAME>PSMUX_PRIVATE_STREAM_1</NAME>
#define PSMUX_PRIVATE_STREAM_1          0xbd
</MACRO>
<MACRO>
<NAME>PSMUX_PADDING_STREAM</NAME>
#define PSMUX_PADDING_STREAM            0xbe
</MACRO>
<MACRO>
<NAME>PSMUX_PRIVATE_STREAM_2</NAME>
#define PSMUX_PRIVATE_STREAM_2          0xbf
</MACRO>
<MACRO>
<NAME>PSMUX_ECM</NAME>
#define PSMUX_ECM                       0xb0
</MACRO>
<MACRO>
<NAME>PSMUX_EMM</NAME>
#define PSMUX_EMM                       0xb1
</MACRO>
<MACRO>
<NAME>PSMUX_PROGRAM_STREAM_DIRECTORY</NAME>
#define PSMUX_PROGRAM_STREAM_DIRECTORY  0xff
</MACRO>
<MACRO>
<NAME>PSMUX_DSMCC_STREAM</NAME>
#define PSMUX_DSMCC_STREAM              0xf2
</MACRO>
<MACRO>
<NAME>PSMUX_ITU_T_H222_1_TYPE_E</NAME>
#define PSMUX_ITU_T_H222_1_TYPE_E       0xf8
</MACRO>
<MACRO>
<NAME>PSMUX_EXTENDED_STREAM</NAME>
#define PSMUX_EXTENDED_STREAM           0xfd
</MACRO>
<MACRO>
<NAME>PSMUX_PROGRAM_END</NAME>
#define PSMUX_PROGRAM_END               0xb9
</MACRO>
<MACRO>
<NAME>PSMUX_MIN_ES_DESC_LEN</NAME>
#define PSMUX_MIN_ES_DESC_LEN 8
</MACRO>
<MACRO>
<NAME>PSMUX_SYS_CLOCK_FREQ</NAME>
#define PSMUX_SYS_CLOCK_FREQ (27000000L)
</MACRO>
<MACRO>
<NAME>PSMUX_CLOCK_FREQ</NAME>
#define PSMUX_CLOCK_FREQ (PSMUX_SYS_CLOCK_FREQ / 300)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_NONE</NAME>
#define PSMUX_PACKET_FLAG_NONE            (0)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_ADAPTATION</NAME>
#define PSMUX_PACKET_FLAG_ADAPTATION      (1 << 0)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_DISCONT</NAME>
#define PSMUX_PACKET_FLAG_DISCONT         (1 << 1)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_RANDOM_ACCESS</NAME>
#define PSMUX_PACKET_FLAG_RANDOM_ACCESS   (1 << 2)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_PRIORITY</NAME>
#define PSMUX_PACKET_FLAG_PRIORITY        (1 << 3)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_WRITE_PCR</NAME>
#define PSMUX_PACKET_FLAG_WRITE_PCR       (1 << 4)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_WRITE_OPCR</NAME>
#define PSMUX_PACKET_FLAG_WRITE_OPCR      (1 << 5)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_WRITE_SPLICE</NAME>
#define PSMUX_PACKET_FLAG_WRITE_SPLICE    (1 << 6)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_WRITE_ADAPT_EXT</NAME>
#define PSMUX_PACKET_FLAG_WRITE_ADAPT_EXT (1 << 7)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_PES_FULL_HEADER</NAME>
#define PSMUX_PACKET_FLAG_PES_FULL_HEADER   (1 << 8)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_PES_WRITE_PTS</NAME>
#define PSMUX_PACKET_FLAG_PES_WRITE_PTS     (1 << 9)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_PES_WRITE_PTS_DTS</NAME>
#define PSMUX_PACKET_FLAG_PES_WRITE_PTS_DTS (1 << 10)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_PES_WRITE_ESCR</NAME>
#define PSMUX_PACKET_FLAG_PES_WRITE_ESCR    (1 << 11)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_PES_EXT_STREAMID</NAME>
#define PSMUX_PACKET_FLAG_PES_EXT_STREAMID  (1 << 12)
</MACRO>
<MACRO>
<NAME>PSMUX_PACKET_FLAG_PES_DATA_ALIGN</NAME>
#define PSMUX_PACKET_FLAG_PES_DATA_ALIGN    (1 << 13)
</MACRO>
<TYPEDEF>
<NAME>PsMuxPacketInfo</NAME>
typedef struct PsMuxPacketInfo PsMuxPacketInfo;
</TYPEDEF>
<TYPEDEF>
<NAME>PsMuxProgram</NAME>
typedef struct PsMuxProgram PsMuxProgram;
</TYPEDEF>
<TYPEDEF>
<NAME>PsMuxStream</NAME>
typedef struct PsMuxStream PsMuxStream;
</TYPEDEF>
<TYPEDEF>
<NAME>PsMuxStreamIdInfo</NAME>
typedef struct PsMuxStreamIdInfo PsMuxStreamIdInfo;
</TYPEDEF>
<TYPEDEF>
<NAME>PsMux</NAME>
typedef struct PsMux PsMux;
</TYPEDEF>
<TYPEDEF>
<NAME>PsMuxStreamBuffer</NAME>
typedef struct PsMuxStreamBuffer PsMuxStreamBuffer;
</TYPEDEF>
<FUNCTION>
<NAME>psmux_put16</NAME>
<RETURNS>void </RETURNS>
guint8 **pos, guint16 val
</FUNCTION>
<FUNCTION>
<NAME>psmux_put32</NAME>
<RETURNS>void </RETURNS>
guint8 **pos, guint32 val
</FUNCTION>
<FUNCTION>
<NAME>psmux_put_ts</NAME>
<RETURNS>void </RETURNS>
guint8 **pos, guint8 id, gint64 ts
</FUNCTION>
<FUNCTION>
<NAME>mpegpsmux_prepare_aac</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstBuffer * buf, MpegPsPadData * data, MpegPsMux * mux
</FUNCTION>
<MACRO>
<NAME>PSMUX_MAX_ES_INFO_LENGTH</NAME>
#define PSMUX_MAX_ES_INFO_LENGTH ((1 << 12) - 1)
</MACRO>
<USER_FUNCTION>
<NAME>PsMuxWriteFunc</NAME>
<RETURNS>gboolean </RETURNS>
guint8 *data, guint len, void *user_data
</USER_FUNCTION>
<STRUCT>
<NAME>PsMux</NAME>
struct PsMux {
  GList *streams;    /* PsMuxStream* array of all streams */
  guint nb_streams;
  guint nb_private_streams;
  PsMuxStreamIdInfo id_info; /* carrying the info which ids are used */

  /* timestamps: pts */ 
  GstClockTime pts;

  guint32 pes_cnt; /* # of pes that has been created */
  guint16 pes_max_payload; /* maximum payload size in pes packets */

  guint64 bit_size;  /* accumulated bit size of processed data */
  guint bit_rate;  /* bit rate */ 
  GstClockTime bit_pts; /* last time the bit_rate is updated */

  guint pack_hdr_freq; /* PS pack header frequency */
  GstClockTime pack_hdr_pts; /* last time a pack header is written */

  guint sys_hdr_freq; /* system header frequency */ 
  GstClockTime sys_hdr_pts; /* last time a system header is written */

  guint psm_freq; /* program stream map frequency */ 
  GstClockTime psm_pts; /* last time a psm is written */

  guint8 packet_buf[PSMUX_MAX_PACKET_LEN];
  guint packet_bytes_written; /* # of bytes written in the buf */
  PsMuxWriteFunc write_func;
  void *write_func_data;

  /* Scratch space for writing ES_info descriptors */
  guint8 es_info_buf[PSMUX_MAX_ES_INFO_LENGTH];

  /* bounds in system header */ 
  guint8 audio_bound;
  guint8 video_bound;
  guint32 rate_bound;

  /* stream headers */
  GstBuffer *sys_header;
  GstBuffer *psm;
};
</STRUCT>
<FUNCTION>
<NAME>psmux_new</NAME>
<RETURNS>PsMux  *		</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>psmux_free</NAME>
<RETURNS>void  		</RETURNS>
PsMux *mux
</FUNCTION>
<FUNCTION>
<NAME>psmux_set_write_func</NAME>
<RETURNS>void  		</RETURNS>
PsMux *mux, PsMuxWriteFunc func, void *user_data
</FUNCTION>
<FUNCTION>
<NAME>psmux_create_stream</NAME>
<RETURNS>PsMuxStream  *	</RETURNS>
PsMux *mux, PsMuxStreamType stream_type
</FUNCTION>
<FUNCTION>
<NAME>psmux_write_stream_packet</NAME>
<RETURNS>gboolean  	</RETURNS>
PsMux *mux, PsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>psmux_write_end_code</NAME>
<RETURNS>gboolean 	</RETURNS>
PsMux *mux
</FUNCTION>
<FUNCTION>
<NAME>psmux_get_stream_headers</NAME>
<RETURNS>GList  *		</RETURNS>
PsMux *mux
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SIREN_ENC</NAME>
#define GST_TYPE_SIREN_ENC \
  (gst_siren_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_SIREN_ENC</NAME>
#define GST_SIREN_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), \
  GST_TYPE_SIREN_ENC,GstSirenEnc))
</MACRO>
<MACRO>
<NAME>GST_SIREN_ENC_CLASS</NAME>
#define GST_SIREN_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), \
  GST_TYPE_SIREN_ENC,GstSirenEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SIREN_ENC</NAME>
#define GST_IS_SIREN_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SIREN_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_SIREN_ENC_CLASS</NAME>
#define GST_IS_SIREN_ENC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SIREN_ENC))
</MACRO>
<STRUCT>
<NAME>GstSirenEnc</NAME>
struct _GstSirenEnc
{
  GstAudioEncoder parent;

  /* protected by the stream lock */
  SirenEncoder encoder;
};
</STRUCT>
<STRUCT>
<NAME>GstSirenEncClass</NAME>
struct _GstSirenEncClass
{
  GstAudioEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_siren_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_siren_enc_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<STRUCT>
<NAME>RiffHeader</NAME>
typedef struct {
  unsigned int RiffId;
  unsigned int RiffSize;
} RiffHeader;
</STRUCT>
<STRUCT>
<NAME>FmtChunk</NAME>
typedef struct  {
  unsigned short Format;
  unsigned short Channels;
  unsigned int SampleRate;
  unsigned int ByteRate;
  unsigned short BlockAlign;
  unsigned short BitsPerSample;
} FmtChunk;
</STRUCT>
<STRUCT>
<NAME>SirenFmtChunk</NAME>
typedef struct  {
  FmtChunk fmt;
  unsigned short ExtraSize;
  unsigned short DctLength;
} SirenFmtChunk;
</STRUCT>
<STRUCT>
<NAME>SirenWavHeader</NAME>
typedef struct {
  RiffHeader riff;
  unsigned int WaveId;

  unsigned int FmtId;
  unsigned int FmtSize;

  SirenFmtChunk fmt;

  unsigned int FactId;
  unsigned int FactSize;
  unsigned int Samples;

  unsigned int DataId;
  unsigned int DataSize;
} SirenWavHeader;
</STRUCT>
<STRUCT>
<NAME>PCMWavHeader</NAME>
typedef struct {
  RiffHeader riff;
  unsigned int WaveId;

  unsigned int FmtId;
  unsigned int FmtSize;

  FmtChunk fmt;

  unsigned int FactId;
  unsigned int FactSize;
  unsigned int Samples;

  unsigned int DataId;
  unsigned int DataSize;
} PCMWavHeader;
</STRUCT>
<MACRO>
<NAME>RIFF_ID</NAME>
#define RIFF_ID 0x46464952
</MACRO>
<MACRO>
<NAME>WAVE_ID</NAME>
#define WAVE_ID 0x45564157
</MACRO>
<MACRO>
<NAME>FMT__ID</NAME>
#define FMT__ID 0x20746d66
</MACRO>
<MACRO>
<NAME>DATA_ID</NAME>
#define DATA_ID 0x61746164
</MACRO>
<MACRO>
<NAME>FACT_ID</NAME>
#define FACT_ID 0x74636166
</MACRO>
<VARIABLE>
<NAME>region_size</NAME>
extern int region_size;
</VARIABLE>
<VARIABLE>
<NAME>region_size_inverse</NAME>
extern float region_size_inverse;
</VARIABLE>
<FUNCTION>
<NAME>siren_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>categorize_regions</NAME>
<RETURNS>int  </RETURNS>
int number_of_regions, int number_of_available_bits, int *absolute_region_power_index, int *power_categories, int *category_balance
</FUNCTION>
<FUNCTION>
<NAME>GetSirenCodecInfo</NAME>
<RETURNS>int  </RETURNS>
int flag, int sample_rate, int *number_of_coefs, int *sample_rate_bits, int *rate_control_bits, int *rate_control_possibilities, int *checksum_bits, int *esf_adjustment, int *scale_factor, int *number_of_regions, int *sample_rate_code, int *bits_per_frame 
</FUNCTION>
<MACRO>
<NAME>POW_2_8</NAME>
#define POW_2_8 256
</MACRO>
<MACRO>
<NAME>POW_2_16</NAME>
#define POW_2_16 65536
</MACRO>
<MACRO>
<NAME>POW_2_24</NAME>
#define POW_2_24 16777216
</MACRO>
<MACRO>
<NAME>IDX</NAME>
#define IDX(val, i) ((unsigned int) ((unsigned char *) &val)[i])
</MACRO>
<MACRO>
<NAME>ME_FROM_LE16</NAME>
#define ME_FROM_LE16(val) ( (unsigned short) ( IDX(val, 0) + IDX(val, 1) * 256 ))
</MACRO>
<MACRO>
<NAME>ME_FROM_LE32</NAME>
#define ME_FROM_LE32(val) ( (unsigned int) (IDX(val, 0) + IDX(val, 1) * 256 + \
          IDX(val, 2) * 65536 + IDX(val, 3) * 16777216))
</MACRO>
<MACRO>
<NAME>ME_TO_LE16</NAME>
#define ME_TO_LE16(val) ( (unsigned short) (                    \
          (((unsigned short)val % 256) & 0xff) << 8 |           \
          ((((unsigned short)val / POW_2_8) % 256) & 0xff) ))
</MACRO>
<MACRO>
<NAME>ME_TO_LE32</NAME>
#define ME_TO_LE32(val) ( (unsigned int) (                              \
          ((((unsigned int) val           ) % 256)  & 0xff) << 24 |     \
          ((((unsigned int) val / POW_2_8 ) % 256) & 0xff) << 16|       \
          ((((unsigned int) val / POW_2_16) % 256) & 0xff) << 8 |       \
          ((((unsigned int) val / POW_2_24) % 256) & 0xff) ))
</MACRO>
<FUNCTION>
<NAME>siren_rmlt_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>siren_rmlt_encode_samples</NAME>
<RETURNS>int  </RETURNS>
float *samples, float *old_samples, int dct_length, float *rmlt_coefs
</FUNCTION>
<FUNCTION>
<NAME>siren_rmlt_decode_samples</NAME>
<RETURNS>int  </RETURNS>
float *coefs, float *old_coefs, int dct_length, float *samples
</FUNCTION>
<FUNCTION>
<NAME>compute_region_powers</NAME>
<RETURNS>int  </RETURNS>
int number_of_regions, float *coefs, int *drp_num_bits, int *drp_code_bits, int *absolute_region_power_index, int esf_adjustment
</FUNCTION>
<FUNCTION>
<NAME>quantize_mlt</NAME>
<RETURNS>int  </RETURNS>
int number_of_regions, int rate_control_possibilities, int number_of_available_bits, float *coefs, int *absolute_region_power_index, int *power_categories, int *category_balance, int *region_mlt_bit_counts, int *region_mlt_bits
</FUNCTION>
<FUNCTION>
<NAME>decode_envelope</NAME>
<RETURNS>int  </RETURNS>
int number_of_regions, float *decoder_standard_deviation, int *absolute_region_power_index, int esf_adjustment
</FUNCTION>
<FUNCTION>
<NAME>decode_vector</NAME>
<RETURNS>int  </RETURNS>
SirenDecoder decoder, int number_of_regions, int number_of_available_bits, float *decoder_standard_deviation, int *power_categories, float *coefs, int scale_factor
</FUNCTION>
<FUNCTION>
<NAME>set_bitstream</NAME>
<RETURNS>void  </RETURNS>
int *stream
</FUNCTION>
<FUNCTION>
<NAME>next_bit</NAME>
<RETURNS>int  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>siren_dct4_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>siren_dct4</NAME>
<RETURNS>void  </RETURNS>
float *Source, float *Destination, int dct_length
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SIREN_DEC</NAME>
#define GST_TYPE_SIREN_DEC \
  (gst_siren_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_SIREN_DEC</NAME>
#define GST_SIREN_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), \
  GST_TYPE_SIREN_DEC,GstSirenDec))
</MACRO>
<MACRO>
<NAME>GST_SIREN_DEC_CLASS</NAME>
#define GST_SIREN_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), \
  GST_TYPE_SIREN_DEC,GstSirenDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SIREN_DEC</NAME>
#define GST_IS_SIREN_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SIREN_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_SIREN_DEC_CLASS</NAME>
#define GST_IS_SIREN_DEC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SIREN_DEC))
</MACRO>
<STRUCT>
<NAME>GstSirenDec</NAME>
struct _GstSirenDec
{
  GstAudioDecoder parent;

  /* Protected by stream lock */
  SirenDecoder decoder;
};
</STRUCT>
<STRUCT>
<NAME>GstSirenDecClass</NAME>
struct _GstSirenDecClass
{
  GstAudioDecoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_siren_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_siren_dec_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_ONVIF_PARSE</NAME>
#define GST_TYPE_RTP_ONVIF_PARSE \
  (gst_rtp_onvif_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_ONVIF_PARSE</NAME>
#define GST_RTP_ONVIF_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_ONVIF_PARSE,GstRtpOnvifParse))
</MACRO>
<MACRO>
<NAME>GST_RTP_ONVIF_PARSE_CLASS</NAME>
#define GST_RTP_ONVIF_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_ONVIF_PARSE,GstRtpOnvifParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_ONVIF_PARSE</NAME>
#define GST_IS_RTP_ONVIF_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_ONVIF_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_ONVIF_PARSE_CLASS</NAME>
#define GST_IS_RTP_ONVIF_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_ONVIF_PARSE))
</MACRO>
<STRUCT>
<NAME>GstRtpOnvifParse</NAME>
struct _GstRtpOnvifParse {
  GstElement element;

  /* pads */
  GstPad *sinkpad,*srcpad;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpOnvifParseClass</NAME>
struct _GstRtpOnvifParseClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_onvif_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RTP_ONVIF_TIMESTAMP</NAME>
#define GST_TYPE_RTP_ONVIF_TIMESTAMP \
  (gst_rtp_onvif_timestamp_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_ONVIF_TIMESTAMP</NAME>
#define GST_RTP_ONVIF_TIMESTAMP(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_ONVIF_TIMESTAMP,GstRtpOnvifTimestamp))
</MACRO>
<MACRO>
<NAME>GST_RTP_ONVIF_TIMESTAMP_CLASS</NAME>
#define GST_RTP_ONVIF_TIMESTAMP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_ONVIF_TIMESTAMP,GstRtpOnvifTimestampClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_ONVIF_TIMESTAMP</NAME>
#define GST_IS_RTP_ONVIF_TIMESTAMP(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_ONVIF_TIMESTAMP))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_ONVIF_TIMESTAMP_CLASS</NAME>
#define GST_IS_RTP_ONVIF_TIMESTAMP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_ONVIF_TIMESTAMP))
</MACRO>
<STRUCT>
<NAME>GstRtpOnvifTimestamp</NAME>
struct _GstRtpOnvifTimestamp {
  GstElement element;

  /* pads */
  GstPad *sinkpad,*srcpad;

  GstClockTime prop_ntp_offset;
  guint prop_cseq;
  gboolean prop_set_e_bit;

  /* currently used ntp-offset
   *(can be changed runtime with a GstNtpOffset event)
   */
  GstClockTime ntp_offset;
  /* a GstNtpOffset event might mark the stream as discontinued */
  gboolean set_d_bit;
  gboolean set_e_bit;

  GstSegment segment;
  /* Buffer waiting to be handled, only used if prop_set_e_bit is TRUE */
  GQueue *event_queue;
  GstBuffer *buffer;
  GstBufferList *list;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpOnvifTimestampClass</NAME>
struct _GstRtpOnvifTimestampClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_onvif_timestamp_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_JP2K_DECIMATOR</NAME>
#define GST_TYPE_JP2K_DECIMATOR   (gst_jp2k_decimator_get_type())
</MACRO>
<MACRO>
<NAME>GST_JP2K_DECIMATOR</NAME>
#define GST_JP2K_DECIMATOR(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_JP2K_DECIMATOR,GstJP2kDecimator))
</MACRO>
<MACRO>
<NAME>GST_JP2K_DECIMATOR_CLASS</NAME>
#define GST_JP2K_DECIMATOR_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_JP2K_DECIMATOR,GstJP2kDecimatorClass))
</MACRO>
<MACRO>
<NAME>GST_IS_JP2K_DECIMATOR</NAME>
#define GST_IS_JP2K_DECIMATOR(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_JP2K_DECIMATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_JP2K_DECIMATOR_CLASS</NAME>
#define GST_IS_JP2K_DECIMATOR_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_JP2K_DECIMATOR))
</MACRO>
<STRUCT>
<NAME>GstJP2kDecimator</NAME>
struct _GstJP2kDecimator
{
  GstElement parent;

  GstPad *sinkpad;
  GstPad *srcpad;

  gint max_layers;
  gint max_decomposition_levels;
};
</STRUCT>
<STRUCT>
<NAME>GstJP2kDecimatorClass</NAME>
struct _GstJP2kDecimatorClass
{
  GstElementClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_jp2k_decimator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>ProgressionOrder</NAME>
typedef enum
{
  PROGRESSION_ORDER_LRCP = 0,
  PROGRESSION_ORDER_RLCP,
  PROGRESSION_ORDER_RPCL,
  PROGRESSION_ORDER_PCRL,
  PROGRESSION_ORDER_CPRL,
  PROGRESSION_ORDER_MAX
} ProgressionOrder;
</ENUM>
<STRUCT>
<NAME>PacketIterator</NAME>
struct _PacketIterator
{
  gboolean (*next) (PacketIterator * it);
  const MainHeader *header;
  const Tile *tile;

  gboolean first;

  gint cur_layer;
  gint cur_resolution;
  gint cur_component;
  gint cur_precinct;
  gint cur_x, cur_y;

  gint n_layers;
  gint n_resolutions;
  gint n_components;
  gint n_precincts, n_precincts_w, n_precincts_h;

  gint tx0, tx1, ty0, ty1;
  gint x_step, y_step;

  /* cached calculated values */
  /* depends on resolution and component */
  gint tcx0, tcx1, tcy0, tcy1;
  gint trx0, trx1, try0, try1;
  gint tpx0, tpx1, tpy0, tpy1;
  gint yr, xr;
  gint two_nl_r, two_ppx, two_ppy;

  gint cur_packet;
};
</STRUCT>
<FUNCTION>
<NAME>parse_main_header</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstJP2kDecimator * self, GstByteReader * reader, MainHeader * header
</FUNCTION>
<FUNCTION>
<NAME>sizeof_main_header</NAME>
<RETURNS>guint  </RETURNS>
GstJP2kDecimator * self, const MainHeader * header
</FUNCTION>
<FUNCTION>
<NAME>reset_main_header</NAME>
<RETURNS>void  </RETURNS>
GstJP2kDecimator * self, MainHeader * header
</FUNCTION>
<FUNCTION>
<NAME>write_main_header</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstJP2kDecimator * self, GstByteWriter * writer, const MainHeader * header
</FUNCTION>
<FUNCTION>
<NAME>decimate_main_header</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstJP2kDecimator * self, MainHeader * header
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_MIX_MATRIX</NAME>
#define GST_TYPE_AUDIO_MIX_MATRIX            (gst_audio_mix_matrix_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_MIX_MATRIX</NAME>
#define GST_AUDIO_MIX_MATRIX(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_MIX_MATRIX,GstAudioMixMatrix))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_MIX_MATRIX_CLASS</NAME>
#define GST_AUDIO_MIX_MATRIX_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_AUDIO_MIX_MATRIX,GstAudioMixMatrixClass))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_MIX_MATRIX_GET_CLASS</NAME>
#define GST_AUDIO_MIX_MATRIX_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj), GST_TYPE_AUDIO_MIX_MATRIX,GstAudioMixMatrixClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_MIX_MATRIX</NAME>
#define GST_IS_AUDIO_MIX_MATRIX(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_MIX_MATRIX))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_MIX_MATRIX_CLASS</NAME>
#define GST_IS_AUDIO_MIX_MATRIX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_AUDIO_MIX_MATRIX))
</MACRO>
<MACRO>
<NAME>GST_TYPE_AUDIO_MIX_MATRIX_MODE</NAME>
#define GST_TYPE_AUDIO_MIX_MATRIX_MODE (gst_audio_mix_matrix_mode_get_type())
</MACRO>
<ENUM>
<NAME>GstAudioMixMatrixMode</NAME>
typedef enum _GstAudioMixMatrixMode
{
  GST_AUDIO_MIX_MATRIX_MODE_MANUAL = 0,
  GST_AUDIO_MIX_MATRIX_MODE_FIRST_CHANNELS = 1
} GstAudioMixMatrixMode;
</ENUM>
<STRUCT>
<NAME>GstAudioMixMatrix</NAME>
struct _GstAudioMixMatrix
{
  GstBaseTransform audiofilter;

  /* < private > */
  guint in_channels;
  guint out_channels;
  gdouble *matrix;
  guint64 channel_mask;
  GstAudioMixMatrixMode mode;
  gint32 *s16_conv_matrix;
  gint64 *s32_conv_matrix;
  gint shift_bytes;

  GstAudioFormat format;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioMixMatrixClass</NAME>
struct _GstAudioMixMatrixClass
{
  GstBaseTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_mix_matrix_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_audio_mix_matrix_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_BUFFER_SPLIT</NAME>
#define GST_TYPE_AUDIO_BUFFER_SPLIT            (gst_audio_buffer_split_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_BUFFER_SPLIT</NAME>
#define GST_AUDIO_BUFFER_SPLIT(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_BUFFER_SPLIT,GstAudioBufferSplit))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_BUFFER_SPLIT</NAME>
#define GST_IS_AUDIO_BUFFER_SPLIT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_BUFFER_SPLIT))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_BUFFER_SPLIT_CLASS</NAME>
#define GST_AUDIO_BUFFER_SPLIT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AUDIO_BUFFER_SPLIT,GstAudioBufferSplitClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_BUFFER_SPLIT_CLASS</NAME>
#define GST_IS_AUDIO_BUFFER_SPLIT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AUDIO_BUFFER_SPLIT))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_BUFFER_SPLIT_GET_CLASS</NAME>
#define GST_AUDIO_BUFFER_SPLIT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AUDIO_BUFFER_SPLIT,GstAudioBufferSplitClass))
</MACRO>
<STRUCT>
<NAME>GstAudioBufferSplit</NAME>
struct _GstAudioBufferSplit {
  GstElement parent;

  GstPad *srcpad, *sinkpad;

  /* Properties */
  gint output_buffer_duration_n;
  gint output_buffer_duration_d;
  GstClockTime alignment_threshold;
  GstClockTime discont_wait;

  /* State */
  GstSegment segment;
  GstAudioInfo info;

  GstAdapter *adapter;

  GstClockTime discont_time; /* timestamp of last discont */
  guint64 next_offset; /* expected next input sample offset */

  GstClockTime resync_time; /* timestamp of resync after discont */
  guint64 current_offset; /* offset from start time in samples */

  guint samples_per_buffer;
  guint error_per_buffer;
  guint accumulated_error;

  gboolean strict_buffer_size;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioBufferSplitClass</NAME>
struct _GstAudioBufferSplitClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_buffer_split_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MIME_BM</NAME>
#define MIME_BM "image/x-portable-bitmap"
</MACRO>
<MACRO>
<NAME>MIME_GM</NAME>
#define MIME_GM "image/x-portable-graymap"
</MACRO>
<MACRO>
<NAME>MIME_PM</NAME>
#define MIME_PM "image/x-portable-pixmap"
</MACRO>
<MACRO>
<NAME>MIME_AM</NAME>
#define MIME_AM "image/x-portable-anymap"
</MACRO>
<MACRO>
<NAME>MIME_ALL</NAME>
#define MIME_ALL MIME_BM "; " MIME_GM "; " MIME_PM "; " MIME_AM
</MACRO>
<ENUM>
<NAME>GstPnmInfoFields</NAME>
typedef enum
{
  GST_PNM_INFO_FIELDS_TYPE = 1 << 0,
  GST_PNM_INFO_FIELDS_WIDTH = 1 << 1,
  GST_PNM_INFO_FIELDS_HEIGHT = 1 << 2,
  GST_PNM_INFO_FIELDS_MAX = 1 << 3,
  GST_PNM_INFO_FIELDS_ENCODING = 1 << 4
} GstPnmInfoFields;
</ENUM>
<MACRO>
<NAME>GST_PNM_INFO_FIELDS_ALL</NAME>
#define GST_PNM_INFO_FIELDS_ALL (GST_PNM_INFO_FIELDS_TYPE | GST_PNM_INFO_FIELDS_WIDTH | GST_PNM_INFO_FIELDS_HEIGHT | GST_PNM_INFO_FIELDS_MAX | GST_PNM_INFO_FIELDS_ENCODING)
</MACRO>
<ENUM>
<NAME>GstPnmType</NAME>
typedef enum
{
  GST_PNM_TYPE_BITMAP = 1,
  GST_PNM_TYPE_GRAYMAP = 2,
  GST_PNM_TYPE_PIXMAP = 3
} GstPnmType;
</ENUM>
<ENUM>
<NAME>GstPnmEncoding</NAME>
typedef enum
{
  GST_PNM_ENCODING_RAW = 0,
  GST_PNM_ENCODING_ASCII = 1
} GstPnmEncoding;
</ENUM>
<ENUM>
<NAME>GstPnmInfoMngrState</NAME>
typedef enum
{
  GST_PNM_INFO_MNGR_STATE_NONE = 0,
  GST_PNM_INFO_MNGR_STATE_DATA_TYPE,
  GST_PNM_INFO_MNGR_STATE_DATA_WIDTH,
  GST_PNM_INFO_MNGR_STATE_DATA_HEIGHT,
  GST_PNM_INFO_MNGR_STATE_DATA_MAX,
  GST_PNM_INFO_MNGR_STATE_COMMENT,
  GST_PNM_INFO_MNGR_STATE_WHITE_SPACE
} GstPnmInfoMngrState;
</ENUM>
<ENUM>
<NAME>GstPnmInfoMngrResult</NAME>
typedef enum
{
  GST_PNM_INFO_MNGR_RESULT_FAILED,
  GST_PNM_INFO_MNGR_RESULT_READING,
  GST_PNM_INFO_MNGR_RESULT_FINISHED
} GstPnmInfoMngrResult;
</ENUM>
<FUNCTION>
<NAME>gst_pnm_info_mngr_scan</NAME>
<RETURNS>GstPnmInfoMngrResult  </RETURNS>
GstPnmInfoMngr *, const guint8 *, guint
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PNMENC</NAME>
#define GST_TYPE_PNMENC  (gst_pnmenc_get_type())
</MACRO>
<MACRO>
<NAME>GST_PNMENC</NAME>
#define GST_PNMENC(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PNMENC,GstPnmenc))
</MACRO>
<MACRO>
<NAME>GST_PNMENC_CLASS</NAME>
#define GST_PNMENC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PNMENC,GstPnmenc))
</MACRO>
<MACRO>
<NAME>GST_IS_PNMENC</NAME>
#define GST_IS_PNMENC(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PNMENC))
</MACRO>
<MACRO>
<NAME>GST_IS_PNMENC_CLASS</NAME>
#define GST_IS_PNMENC_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PNMENC))
</MACRO>
<STRUCT>
<NAME>GstPnmenc</NAME>
struct _GstPnmenc
{
  GstVideoEncoder parent;
  GstVideoCodecState *input_state;
  GstPnmInfo info;

  GstPad *src;
};
</STRUCT>
<STRUCT>
<NAME>GstPnmencClass</NAME>
struct _GstPnmencClass
{
  GstVideoEncoderClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_pnmenc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PNMDEC</NAME>
#define GST_TYPE_PNMDEC (gst_pnmdec_get_type())
</MACRO>
<MACRO>
<NAME>GST_PNMDEC</NAME>
#define GST_PNMDEC(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PNMDEC,GstPnmdec))
</MACRO>
<MACRO>
<NAME>GST_PNMDEC_CLASS</NAME>
#define GST_PNMDEC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PNMDEC,GstPnmdec))
</MACRO>
<MACRO>
<NAME>GST_IS_PNMDEC</NAME>
#define GST_IS_PNMDEC(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PNMDEC))
</MACRO>
<MACRO>
<NAME>GST_IS_PNMDEC_CLASS</NAME>
#define GST_IS_PNMDEC_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PNMDEC))
</MACRO>
<STRUCT>
<NAME>GstPnmdec</NAME>
struct _GstPnmdec
{
  GstElement element;
  GstVideoDecoder decoder;
  GstPnmInfoMngr mngr;
  GstVideoCodecState *input_state;
  guint size, last_val, current_size ;
  gboolean have_last_val;
  GstBuffer *buf;
  GstVideoFormat out_format;
};
</STRUCT>
<STRUCT>
<NAME>GstPnmdecClass</NAME>
struct _GstPnmdecClass
{
  GstVideoDecoderClass parent_class ;
};
</STRUCT>
<FUNCTION>
<NAME>gst_pnmdec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WATCHDOG</NAME>
#define GST_TYPE_WATCHDOG   (gst_watchdog_get_type())
</MACRO>
<MACRO>
<NAME>GST_WATCHDOG</NAME>
#define GST_WATCHDOG(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WATCHDOG,GstWatchdog))
</MACRO>
<MACRO>
<NAME>GST_WATCHDOG_CLASS</NAME>
#define GST_WATCHDOG_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WATCHDOG,GstWatchdogClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WATCHDOG</NAME>
#define GST_IS_WATCHDOG(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WATCHDOG))
</MACRO>
<MACRO>
<NAME>GST_IS_WATCHDOG_CLASS</NAME>
#define GST_IS_WATCHDOG_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WATCHDOG))
</MACRO>
<STRUCT>
<NAME>GstWatchdog</NAME>
struct _GstWatchdog
{
  GstBaseTransform base_watchdog;

  /* properties */
  int timeout;

  GMainContext *main_context;
  GMainLoop *main_loop;
  GThread *thread;
  GSource *source;

  gboolean waiting_for_a_buffer;
  gboolean waiting_for_flush_start;
  gboolean waiting_for_flush_stop;
};
</STRUCT>
<STRUCT>
<NAME>GstWatchdogClass</NAME>
struct _GstWatchdogClass
{
  GstBaseTransformClass base_watchdog_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_watchdog_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CHOP_MY_DATA</NAME>
#define GST_TYPE_CHOP_MY_DATA   (gst_chop_my_data_get_type())
</MACRO>
<MACRO>
<NAME>GST_CHOP_MY_DATA</NAME>
#define GST_CHOP_MY_DATA(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CHOP_MY_DATA,GstChopMyData))
</MACRO>
<MACRO>
<NAME>GST_CHOP_MY_DATA_CLASS</NAME>
#define GST_CHOP_MY_DATA_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CHOP_MY_DATA,GstChopMyDataClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CHOP_MY_DATA</NAME>
#define GST_IS_CHOP_MY_DATA(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CHOP_MY_DATA))
</MACRO>
<MACRO>
<NAME>GST_IS_CHOP_MY_DATA_CLASS</NAME>
#define GST_IS_CHOP_MY_DATA_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CHOP_MY_DATA))
</MACRO>
<STRUCT>
<NAME>GstChopMyData</NAME>
struct _GstChopMyData
{
  GstElement base_chopmydata;

  GstPad *srcpad;
  GstPad *sinkpad;
  GstAdapter *adapter;
  GRand *rand;

  /* properties */
  int step_size;
  int min_size;
  int max_size;

  /* state */
  int next_size;
};
</STRUCT>
<STRUCT>
<NAME>GstChopMyDataClass</NAME>
struct _GstChopMyDataClass
{
  GstElementClass base_chopmydata_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_chop_my_data_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ERROR_IGNORE</NAME>
#define GST_TYPE_ERROR_IGNORE            (gst_error_ignore_get_type())
</MACRO>
<MACRO>
<NAME>GST_ERROR_IGNORE</NAME>
#define GST_ERROR_IGNORE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ERROR_IGNORE,GstErrorIgnore))
</MACRO>
<MACRO>
<NAME>GST_IS_ERROR_IGNORE</NAME>
#define GST_IS_ERROR_IGNORE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ERROR_IGNORE))
</MACRO>
<MACRO>
<NAME>GST_ERROR_IGNORE_CLASS</NAME>
#define GST_ERROR_IGNORE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_ERROR_IGNORE,GstErrorIgnoreClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ERROR_IGNORE_CLASS</NAME>
#define GST_IS_ERROR_IGNORE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_ERROR_IGNORE))
</MACRO>
<MACRO>
<NAME>GST_ERROR_IGNORE_GET_CLASS</NAME>
#define GST_ERROR_IGNORE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_ERROR_IGNORE,GstErrorIgnoreClass))
</MACRO>
<STRUCT>
<NAME>GstErrorIgnore</NAME>
struct _GstErrorIgnore {
  GstElement parent;

  GstPad *srcpad, *sinkpad;

  gboolean keep_pushing;
  gboolean ignore_error;
  gboolean ignore_notlinked;
  gboolean ignore_notnegotiated;
  GstFlowReturn convert_to;
};
</STRUCT>
<STRUCT>
<NAME>GstErrorIgnoreClass</NAME>
struct _GstErrorIgnoreClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_error_ignore_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_error_ignore_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DEBUGSPY</NAME>
#define GST_TYPE_DEBUGSPY \
  (gst_debug_spy_get_type())
</MACRO>
<MACRO>
<NAME>GST_DEBUGSPY</NAME>
#define GST_DEBUGSPY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DEBUGSPY,GstDebugSpy))
</MACRO>
<MACRO>
<NAME>GST_DEBUGSPY_CLASS</NAME>
#define GST_DEBUGSPY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DEBUGSPY,GstDebugSpyClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DEBUGSPY</NAME>
#define GST_IS_DEBUGSPY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DEBUGSPY))
</MACRO>
<MACRO>
<NAME>GST_IS_DEBUGSPY_CLASS</NAME>
#define GST_IS_DEBUGSPY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DEBUGSPY))
</MACRO>
<STRUCT>
<NAME>GstDebugSpy</NAME>
struct _GstDebugSpy
{
  GstBaseTransform transform;

  gboolean silent;
  GChecksumType checksum_type;
};
</STRUCT>
<STRUCT>
<NAME>GstDebugSpyClass</NAME>
struct _GstDebugSpyClass
{
  GstBaseTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_debug_spy_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CHECKSUM_SINK</NAME>
#define GST_TYPE_CHECKSUM_SINK   (gst_checksum_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_CHECKSUM_SINK</NAME>
#define GST_CHECKSUM_SINK(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CHECKSUM_SINK,GstChecksumSink))
</MACRO>
<MACRO>
<NAME>GST_CHECKSUM_SINK_CLASS</NAME>
#define GST_CHECKSUM_SINK_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CHECKSUM_SINK,GstChecksumSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CHECKSUM_SINK</NAME>
#define GST_IS_CHECKSUM_SINK(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CHECKSUM_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_CHECKSUM_SINK_CLASS</NAME>
#define GST_IS_CHECKSUM_SINK_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CHECKSUM_SINK))
</MACRO>
<STRUCT>
<NAME>GstChecksumSink</NAME>
struct _GstChecksumSink
{
  GstBaseSink base_checksumsink;
  GChecksumType hash;
};
</STRUCT>
<STRUCT>
<NAME>GstChecksumSinkClass</NAME>
struct _GstChecksumSinkClass
{
  GstBaseSinkClass base_checksumsink_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_checksum_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_COMPARE</NAME>
#define GST_TYPE_COMPARE \
  (gst_compare_get_type())
</MACRO>
<MACRO>
<NAME>GST_COMPARE</NAME>
#define GST_COMPARE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_COMPARE, GstCompare))
</MACRO>
<MACRO>
<NAME>GST_COMPARE_CLASS</NAME>
#define GST_COMPARE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_COMPARE, GstCompareClass))
</MACRO>
<MACRO>
<NAME>GST_COMPARE_GET_CLASS</NAME>
#define GST_COMPARE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj), GST_TYPE_COMPARE, GstCompareClass))
</MACRO>
<MACRO>
<NAME>GST_IS_COMPARE</NAME>
#define GST_IS_COMPARE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_COMPARE))
</MACRO>
<MACRO>
<NAME>GST_IS_COMPARE_CLASS</NAME>
#define GST_IS_COMPARE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_COMPARE))
</MACRO>
<STRUCT>
<NAME>GstCompare</NAME>
struct _GstCompare {
  GstElement element;

  GstPad *srcpad;
  GstPad *sinkpad;
  GstPad *checkpad;

  GstCollectPads *cpads;

  gint count;

  /* properties */
  GstBufferCopyFlags meta;
  gboolean offset_ts;
  gint method;
  gdouble threshold;
  gboolean upper;
};
</STRUCT>
<STRUCT>
<NAME>GstCompareClass</NAME>
struct _GstCompareClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_compare_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VIDEO_DIFF</NAME>
#define GST_TYPE_VIDEO_DIFF   (gst_video_diff_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_DIFF</NAME>
#define GST_VIDEO_DIFF(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_DIFF,GstVideoDiff))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_DIFF_CLASS</NAME>
#define GST_VIDEO_DIFF_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_DIFF,GstVideoDiffClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_DIFF</NAME>
#define GST_IS_VIDEO_DIFF(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_DIFF))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_DIFF_CLASS</NAME>
#define GST_IS_VIDEO_DIFF_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_DIFF))
</MACRO>
<STRUCT>
<NAME>GstVideoDiff</NAME>
struct _GstVideoDiff
{
  GstVideoFilter base_videodiff;

  GstBuffer *previous_buffer;
  GstVideoInfo oldinfo;

  int threshold;
  int t;
};
</STRUCT>
<STRUCT>
<NAME>GstVideoDiffClass</NAME>
struct _GstVideoDiffClass
{
  GstVideoFilterClass base_videodiff_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_diff_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SCENE_CHANGE</NAME>
#define GST_TYPE_SCENE_CHANGE   (gst_scene_change_get_type())
</MACRO>
<MACRO>
<NAME>GST_SCENE_CHANGE</NAME>
#define GST_SCENE_CHANGE(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SCENE_CHANGE,GstSceneChange))
</MACRO>
<MACRO>
<NAME>GST_SCENE_CHANGE_CLASS</NAME>
#define GST_SCENE_CHANGE_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SCENE_CHANGE,GstSceneChangeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SCENE_CHANGE</NAME>
#define GST_IS_SCENE_CHANGE(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SCENE_CHANGE))
</MACRO>
<MACRO>
<NAME>GST_IS_SCENE_CHANGE_CLASS</NAME>
#define GST_IS_SCENE_CHANGE_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SCENE_CHANGE))
</MACRO>
<MACRO>
<NAME>SC_N_DIFFS</NAME>
#define SC_N_DIFFS 5
</MACRO>
<STRUCT>
<NAME>GstSceneChange</NAME>
struct _GstSceneChange
{
  GstVideoFilter base_scenechange;

  int n_diffs;
  double diffs[SC_N_DIFFS];
  GstBuffer *oldbuf;
  GstVideoInfo oldinfo;
  int count;
};
</STRUCT>
<STRUCT>
<NAME>GstSceneChangeClass</NAME>
struct _GstSceneChangeClass
{
  GstVideoFilterClass base_scenechange_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_scene_change_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ZEBRA_STRIPE</NAME>
#define GST_TYPE_ZEBRA_STRIPE   (gst_zebra_stripe_get_type())
</MACRO>
<MACRO>
<NAME>GST_ZEBRA_STRIPE</NAME>
#define GST_ZEBRA_STRIPE(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ZEBRA_STRIPE,GstZebraStripe))
</MACRO>
<MACRO>
<NAME>GST_ZEBRA_STRIPE_CLASS</NAME>
#define GST_ZEBRA_STRIPE_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ZEBRA_STRIPE,GstZebraStripeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ZEBRA_STRIPE</NAME>
#define GST_IS_ZEBRA_STRIPE(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ZEBRA_STRIPE))
</MACRO>
<MACRO>
<NAME>GST_IS_ZEBRA_STRIPE_CLASS</NAME>
#define GST_IS_ZEBRA_STRIPE_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ZEBRA_STRIPE))
</MACRO>
<STRUCT>
<NAME>GstZebraStripe</NAME>
struct _GstZebraStripe
{
  GstVideoFilter base_zebrastripe;

  /* properties */
  int threshold;

  /* state */
  int t;
  int y_threshold;
};
</STRUCT>
<STRUCT>
<NAME>GstZebraStripeClass</NAME>
struct _GstZebraStripeClass
{
  GstVideoFilterClass base_zebrastripe_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_zebra_stripe_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mpegtsmux_prepare_aac</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstBuffer * buf, MpegTsPadData * data, MpegTsMux * mux
</FUNCTION>
<FUNCTION>
<NAME>mpegtsmux_prepare_opus</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstBuffer * buf, MpegTsPadData * data, MpegTsMux * mux
</FUNCTION>
<FUNCTION>
<NAME>mpegtsmux_prepare_teletext</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstBuffer * buf, MpegTsPadData * data, MpegTsMux * mux
</FUNCTION>
<TYPEDEF>
<NAME>TsMuxStreamBuffer</NAME>
typedef struct TsMuxStreamBuffer TsMuxStreamBuffer;
</TYPEDEF>
<USER_FUNCTION>
<NAME>TsMuxStreamBufferReleaseFunc</NAME>
<RETURNS>void </RETURNS>
guint8 *data, void *user_data
</USER_FUNCTION>
<ENUM>
<NAME>TsMuxStreamType</NAME>
enum TsMuxStreamType {
  TSMUX_ST_RESERVED                   = 0x00,
  TSMUX_ST_VIDEO_MPEG1                = 0x01,
  TSMUX_ST_VIDEO_MPEG2                = 0x02,
  TSMUX_ST_AUDIO_MPEG1                = 0x03,
  TSMUX_ST_AUDIO_MPEG2                = 0x04,
  TSMUX_ST_PRIVATE_SECTIONS           = 0x05,
  TSMUX_ST_PRIVATE_DATA               = 0x06,
  TSMUX_ST_MHEG                       = 0x07,
  TSMUX_ST_DSMCC                      = 0x08,
  TSMUX_ST_H222_1                     = 0x09,

  /* later extensions */
  TSMUX_ST_AUDIO_AAC                  = 0x0f,
  TSMUX_ST_VIDEO_MPEG4                = 0x10,
  TSMUX_ST_VIDEO_H264                 = 0x1b,
  TSMUX_ST_VIDEO_HEVC                 = 0x24,

  /* private stream types */
  TSMUX_ST_PS_AUDIO_AC3               = 0x81,
  TSMUX_ST_PS_AUDIO_DTS               = 0x8a,
  TSMUX_ST_PS_AUDIO_LPCM              = 0x8b,
  TSMUX_ST_PS_DVB_SUBPICTURE          = 0x8c,
  TSMUX_ST_PS_TELETEXT                = 0x8d,
  TSMUX_ST_PS_KLV                     = 0x8e,    /* only used internally */
  TSMUX_ST_PS_OPUS                    = 0x8f,    /* only used internally */
  TSMUX_ST_PS_DVD_SUBPICTURE          = 0xff,

  /* Non-standard definitions */
  TSMUX_ST_VIDEO_DIRAC                = 0xD1
};
</ENUM>
<ENUM>
<NAME>TsMuxStreamState</NAME>
enum TsMuxStreamState {
    TSMUX_STREAM_STATE_HEADER,
    TSMUX_STREAM_STATE_PACKET
};
</ENUM>
<STRUCT>
<NAME>TsMuxStream</NAME>
struct TsMuxStream {
  TsMuxStreamState state;
  TsMuxPacketInfo pi;
  TsMuxStreamType stream_type;

  /* stream_id (13818-1) */
  guint8 id;
  /* extended stream id (13818-1 Amdt 2) */
  guint8 id_extended;

  gboolean is_video_stream;

  /* data available for writing out
   * and total sum of sizes */
  GList *buffers;
  guint32 bytes_avail;

  /* current data buffer being consumed
   * and amount already consumed */
  TsMuxStreamBuffer *cur_buffer;
  guint32 cur_buffer_consumed;

  /* helper to release collected buffers */
  TsMuxStreamBufferReleaseFunc buffer_release;

  /* optional fixed PES size for stream type */
  guint16 pes_payload_size;
  /* current PES payload size being written */
  guint16 cur_pes_payload_size;
  /* ... of which already this much written */
  guint16 pes_bytes_written;

  /* PTS/DTS to write if the flags in the packet info are set */
  /* in MPEG PTS clock time */
  gint64 pts;
  gint64 dts;

  /* last ts written, or maybe next one ... ?! */
  gint64 last_dts;
  gint64 last_pts;

  /* count of programs using this as PCR */
  gint   pcr_ref;
  /* last time PCR written */
  gint64 last_pcr;

  /* audio parameters for stream
   * (used in stream descriptor) */
  gint audio_sampling;
  gint audio_channels;
  gint audio_bitrate;

  gboolean is_dvb_sub;
  gchar language[4];

  gboolean is_meta;
  gboolean is_audio;

  /* Opus */
  gboolean is_opus;
  guint8 opus_channel_config_code;
};
</STRUCT>
<FUNCTION>
<NAME>tsmux_stream_new</NAME>
<RETURNS>TsMuxStream  *	</RETURNS>
guint16 pid, TsMuxStreamType stream_type
</FUNCTION>
<FUNCTION>
<NAME>tsmux_stream_free</NAME>
<RETURNS>void  		</RETURNS>
TsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>tsmux_stream_get_pid</NAME>
<RETURNS>guint16          </RETURNS>
TsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>tsmux_stream_set_buffer_release_func</NAME>
<RETURNS>void  		</RETURNS>
TsMuxStream *stream, TsMuxStreamBufferReleaseFunc func
</FUNCTION>
<FUNCTION>
<NAME>tsmux_stream_add_data</NAME>
<RETURNS>void  		</RETURNS>
TsMuxStream *stream, guint8 *data, guint len, void *user_data, gint64 pts, gint64 dts, gboolean random_access
</FUNCTION>
<FUNCTION>
<NAME>tsmux_stream_pcr_ref</NAME>
<RETURNS>void  		</RETURNS>
TsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>tsmux_stream_pcr_unref</NAME>
<RETURNS>void  		</RETURNS>
TsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>tsmux_stream_is_pcr</NAME>
<RETURNS>gboolean 	</RETURNS>
TsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>tsmux_stream_at_pes_start</NAME>
<RETURNS>gboolean  	</RETURNS>
TsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>tsmux_stream_get_es_descrs</NAME>
<RETURNS>void  		</RETURNS>
TsMuxStream *stream, GstMpegtsPMTStream *pmt_stream
</FUNCTION>
<FUNCTION>
<NAME>tsmux_stream_bytes_in_buffer</NAME>
<RETURNS>gint  		</RETURNS>
TsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>tsmux_stream_bytes_avail</NAME>
<RETURNS>gint  		</RETURNS>
TsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>tsmux_stream_initialize_pes_packet</NAME>
<RETURNS>gboolean  	</RETURNS>
TsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>tsmux_stream_get_data</NAME>
<RETURNS>gboolean  	</RETURNS>
TsMuxStream *stream, guint8 *buf, guint len
</FUNCTION>
<FUNCTION>
<NAME>tsmux_stream_get_pts</NAME>
<RETURNS>guint64  	</RETURNS>
TsMuxStream *stream
</FUNCTION>
<MACRO>
<NAME>TSMUX_SYNC_BYTE</NAME>
#define TSMUX_SYNC_BYTE 0x47
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_LENGTH</NAME>
#define TSMUX_PACKET_LENGTH 188
</MACRO>
<MACRO>
<NAME>TSMUX_HEADER_LENGTH</NAME>
#define TSMUX_HEADER_LENGTH 4
</MACRO>
<MACRO>
<NAME>TSMUX_PAYLOAD_LENGTH</NAME>
#define TSMUX_PAYLOAD_LENGTH (TSMUX_PACKET_LENGTH - TSMUX_HEADER_LENGTH)
</MACRO>
<MACRO>
<NAME>TSMUX_MIN_ES_DESC_LEN</NAME>
#define TSMUX_MIN_ES_DESC_LEN 8
</MACRO>
<MACRO>
<NAME>TSMUX_SYS_CLOCK_FREQ</NAME>
#define TSMUX_SYS_CLOCK_FREQ ((gint64) 27000000)
</MACRO>
<MACRO>
<NAME>TSMUX_CLOCK_FREQ</NAME>
#define TSMUX_CLOCK_FREQ (TSMUX_SYS_CLOCK_FREQ / 300)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_NONE</NAME>
#define TSMUX_PACKET_FLAG_NONE            (0)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_ADAPTATION</NAME>
#define TSMUX_PACKET_FLAG_ADAPTATION      (1 << 0)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_DISCONT</NAME>
#define TSMUX_PACKET_FLAG_DISCONT         (1 << 1)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_RANDOM_ACCESS</NAME>
#define TSMUX_PACKET_FLAG_RANDOM_ACCESS   (1 << 2)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_PRIORITY</NAME>
#define TSMUX_PACKET_FLAG_PRIORITY        (1 << 3)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_WRITE_PCR</NAME>
#define TSMUX_PACKET_FLAG_WRITE_PCR       (1 << 4)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_WRITE_OPCR</NAME>
#define TSMUX_PACKET_FLAG_WRITE_OPCR      (1 << 5)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_WRITE_SPLICE</NAME>
#define TSMUX_PACKET_FLAG_WRITE_SPLICE    (1 << 6)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_WRITE_ADAPT_EXT</NAME>
#define TSMUX_PACKET_FLAG_WRITE_ADAPT_EXT (1 << 7)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_PES_FULL_HEADER</NAME>
#define TSMUX_PACKET_FLAG_PES_FULL_HEADER   (1 << 8)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_PES_WRITE_PTS</NAME>
#define TSMUX_PACKET_FLAG_PES_WRITE_PTS     (1 << 9)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_PES_WRITE_PTS_DTS</NAME>
#define TSMUX_PACKET_FLAG_PES_WRITE_PTS_DTS (1 << 10)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_PES_WRITE_ESCR</NAME>
#define TSMUX_PACKET_FLAG_PES_WRITE_ESCR    (1 << 11)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_PES_EXT_STREAMID</NAME>
#define TSMUX_PACKET_FLAG_PES_EXT_STREAMID  (1 << 12)
</MACRO>
<MACRO>
<NAME>TSMUX_PACKET_FLAG_PES_DATA_ALIGNMENT</NAME>
#define TSMUX_PACKET_FLAG_PES_DATA_ALIGNMENT (1 << 13)
</MACRO>
<MACRO>
<NAME>TSMUX_DEFAULT_PAT_INTERVAL</NAME>
#define TSMUX_DEFAULT_PAT_INTERVAL (TSMUX_CLOCK_FREQ / 10)
</MACRO>
<MACRO>
<NAME>TSMUX_DEFAULT_PMT_INTERVAL</NAME>
#define TSMUX_DEFAULT_PMT_INTERVAL (TSMUX_CLOCK_FREQ / 10)
</MACRO>
<MACRO>
<NAME>TSMUX_DEFAULT_SI_INTERVAL</NAME>
#define TSMUX_DEFAULT_SI_INTERVAL  (TSMUX_CLOCK_FREQ / 10)
</MACRO>
<TYPEDEF>
<NAME>TsMuxPacketInfo</NAME>
typedef struct TsMuxPacketInfo TsMuxPacketInfo;
</TYPEDEF>
<TYPEDEF>
<NAME>TsMuxProgram</NAME>
typedef struct TsMuxProgram TsMuxProgram;
</TYPEDEF>
<TYPEDEF>
<NAME>TsMuxStream</NAME>
typedef struct TsMuxStream TsMuxStream;
</TYPEDEF>
<FUNCTION>
<NAME>tsmux_put16</NAME>
<RETURNS>void </RETURNS>
guint8 **pos, guint16 val
</FUNCTION>
<FUNCTION>
<NAME>tsmux_put32</NAME>
<RETURNS>void </RETURNS>
guint8 **pos, guint32 val
</FUNCTION>
<FUNCTION>
<NAME>tsmux_put_ts</NAME>
<RETURNS>void </RETURNS>
guint8 **pos, guint8 id, gint64 ts
</FUNCTION>
<MACRO>
<NAME>TS_DEBUG</NAME>
#define TS_DEBUG GST_DEBUG
</MACRO>
<MACRO>
<NAME>TSMUX_MAX_ES_INFO_LENGTH</NAME>
#define TSMUX_MAX_ES_INFO_LENGTH ((1 << 12) - 1)
</MACRO>
<MACRO>
<NAME>TSMUX_PID_AUTO</NAME>
#define TSMUX_PID_AUTO ((guint16)-1)
</MACRO>
<MACRO>
<NAME>TSMUX_START_PROGRAM_ID</NAME>
#define TSMUX_START_PROGRAM_ID 0x0001
</MACRO>
<MACRO>
<NAME>TSMUX_START_PMT_PID</NAME>
#define TSMUX_START_PMT_PID 0x0020
</MACRO>
<MACRO>
<NAME>TSMUX_START_ES_PID</NAME>
#define TSMUX_START_ES_PID 0x0040
</MACRO>
<TYPEDEF>
<NAME>TsMuxSection</NAME>
typedef struct TsMuxSection TsMuxSection;
</TYPEDEF>
<TYPEDEF>
<NAME>TsMux</NAME>
typedef struct TsMux TsMux;
</TYPEDEF>
<USER_FUNCTION>
<NAME>TsMuxWriteFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstBuffer * buf, void *user_data, gint64 new_pcr
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>TsMuxAllocFunc</NAME>
<RETURNS>void </RETURNS>
GstBuffer ** buf, void *user_data
</USER_FUNCTION>
<STRUCT>
<NAME>TsMuxProgram</NAME>
struct TsMuxProgram {
  TsMuxSection pmt;
  /* PMT version */
  guint8   pmt_version;
  /* trigger for writing PMT */
  gboolean pmt_changed;

  /* interval between PMT in MPEG PTS clock time */
  guint    pmt_interval;
  /* last time PMT written in MPEG PTS clock time */
  gint64   last_pmt_ts;

  /* program ID for the PAT */
  guint16 pgm_number;
  /* PID to write the PMT */
  guint16 pmt_pid;

  /* stream which carries the PCR */
  TsMuxStream *pcr_stream;

  /* programs TsMuxStream's */
  GArray *streams;
};
</STRUCT>
<FUNCTION>
<NAME>tsmux_new</NAME>
<RETURNS>TsMux  *		</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>tsmux_free</NAME>
<RETURNS>void  		</RETURNS>
TsMux *mux
</FUNCTION>
<FUNCTION>
<NAME>tsmux_set_write_func</NAME>
<RETURNS>void  		</RETURNS>
TsMux *mux, TsMuxWriteFunc func, void *user_data
</FUNCTION>
<FUNCTION>
<NAME>tsmux_set_alloc_func</NAME>
<RETURNS>void  		</RETURNS>
TsMux *mux, TsMuxAllocFunc func, void *user_data
</FUNCTION>
<FUNCTION>
<NAME>tsmux_set_pat_interval</NAME>
<RETURNS>void  		</RETURNS>
TsMux *mux, guint interval
</FUNCTION>
<FUNCTION>
<NAME>tsmux_get_pat_interval</NAME>
<RETURNS>guint  		</RETURNS>
TsMux *mux
</FUNCTION>
<FUNCTION>
<NAME>tsmux_get_new_pid</NAME>
<RETURNS>guint16 		</RETURNS>
TsMux *mux
</FUNCTION>
<FUNCTION>
<NAME>tsmux_program_new</NAME>
<RETURNS>TsMuxProgram  *	</RETURNS>
TsMux *mux, gint prog_id
</FUNCTION>
<FUNCTION>
<NAME>tsmux_program_free</NAME>
<RETURNS>void  		</RETURNS>
TsMuxProgram *program
</FUNCTION>
<FUNCTION>
<NAME>tsmux_set_pmt_interval</NAME>
<RETURNS>void  		</RETURNS>
TsMuxProgram *program, guint interval
</FUNCTION>
<FUNCTION>
<NAME>tsmux_get_pmt_interval</NAME>
<RETURNS>guint  		</RETURNS>
TsMuxProgram *program
</FUNCTION>
<FUNCTION>
<NAME>tsmux_set_si_interval</NAME>
<RETURNS>void             </RETURNS>
TsMux *mux, guint interval
</FUNCTION>
<FUNCTION>
<NAME>tsmux_get_si_interval</NAME>
<RETURNS>guint            </RETURNS>
TsMux *mux
</FUNCTION>
<FUNCTION>
<NAME>tsmux_add_mpegts_si_section</NAME>
<RETURNS>gboolean         </RETURNS>
TsMux * mux, GstMpegtsSection * section
</FUNCTION>
<FUNCTION>
<NAME>tsmux_create_stream</NAME>
<RETURNS>TsMuxStream  *	</RETURNS>
TsMux *mux, TsMuxStreamType stream_type, guint16 pid, gchar *language
</FUNCTION>
<FUNCTION>
<NAME>tsmux_find_stream</NAME>
<RETURNS>TsMuxStream  *	</RETURNS>
TsMux *mux, guint16 pid
</FUNCTION>
<FUNCTION>
<NAME>tsmux_program_add_stream</NAME>
<RETURNS>void  		</RETURNS>
TsMuxProgram *program, TsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>tsmux_program_set_pcr_stream</NAME>
<RETURNS>void  		</RETURNS>
TsMuxProgram *program, TsMuxStream *stream
</FUNCTION>
<FUNCTION>
<NAME>tsmux_write_stream_packet</NAME>
<RETURNS>gboolean  	</RETURNS>
TsMux *mux, TsMuxStream *stream
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FACEOVERLAY</NAME>
#define GST_TYPE_FACEOVERLAY \
  (gst_face_overlay_get_type())
</MACRO>
<MACRO>
<NAME>GST_FACEOVERLAY</NAME>
#define GST_FACEOVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FACEOVERLAY,GstFaceOverlay))
</MACRO>
<MACRO>
<NAME>GST_FACEOVERLAY_CLASS</NAME>
#define GST_FACEOVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FACEOVERLAY,GstFaceOverlayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FACEOVERLAY</NAME>
#define GST_IS_FACEOVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FACEOVERLAY))
</MACRO>
<MACRO>
<NAME>GST_IS_FACEOVERLAY_CLASS</NAME>
#define GST_IS_FACEOVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FACEOVERLAY))
</MACRO>
<STRUCT>
<NAME>GstFaceOverlay</NAME>
struct _GstFaceOverlay
{
  GstBin parent;

  GstPad *sinkpad, *srcpad;

  GstElement *face_detect;
  GstElement *colorspace;
  GstElement *svg_overlay;

  gboolean process_message;

  gboolean update_svg;

  gchar *location;
  gfloat x;
  gfloat y;
  gfloat w;
  gfloat h;
};
</STRUCT>
<STRUCT>
<NAME>GstFaceOverlayClass</NAME>
struct _GstFaceOverlayClass
{
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_face_overlay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SMOOTH</NAME>
#define GST_TYPE_SMOOTH \
  (gst_smooth_get_type())
</MACRO>
<MACRO>
<NAME>GST_SMOOTH</NAME>
#define GST_SMOOTH(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SMOOTH,GstSmooth))
</MACRO>
<MACRO>
<NAME>GST_SMOOTH_CLASS</NAME>
#define GST_SMOOTH_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SMOOTH,GstSmoothClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SMOOTH</NAME>
#define GST_IS_SMOOTH(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SMOOTH))
</MACRO>
<MACRO>
<NAME>GST_IS_SMOOTH_CLASS</NAME>
#define GST_IS_SMOOTH_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SMOOTH))
</MACRO>
<STRUCT>
<NAME>GstSmooth</NAME>
struct _GstSmooth {
  GstVideoFilter element;

  int format;
  int width;
  int height;

  gboolean active;
  int tolerance;
  int filtersize;
  gboolean luma_only;

  GstPad *sinkpad,*srcpad;
};
</STRUCT>
<STRUCT>
<NAME>GstSmoothClass</NAME>
struct _GstSmoothClass {
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_smooth_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<STRUCT>
<NAME>GstInterSurface</NAME>
struct _GstInterSurface
{
  GMutex mutex;
  gint ref_count;

  char *name;

  /* video */
  GstVideoInfo video_info;
  int video_buffer_count;

  /* audio */
  GstAudioInfo audio_info;
  guint64 audio_buffer_time;
  guint64 audio_latency_time;
  guint64 audio_period_time;

  GstBuffer *video_buffer;
  GstBuffer *sub_buffer;
  GstAdapter *audio_adapter;
};
</STRUCT>
<MACRO>
<NAME>DEFAULT_AUDIO_BUFFER_TIME</NAME>
#define DEFAULT_AUDIO_BUFFER_TIME  (GST_SECOND)
</MACRO>
<MACRO>
<NAME>DEFAULT_AUDIO_LATENCY_TIME</NAME>
#define DEFAULT_AUDIO_LATENCY_TIME (100 * GST_MSECOND)
</MACRO>
<MACRO>
<NAME>DEFAULT_AUDIO_PERIOD_TIME</NAME>
#define DEFAULT_AUDIO_PERIOD_TIME  (25 * GST_MSECOND)
</MACRO>
<FUNCTION>
<NAME>gst_inter_surface_get</NAME>
<RETURNS>GstInterSurface  * </RETURNS>
const char *name
</FUNCTION>
<FUNCTION>
<NAME>gst_inter_surface_unref</NAME>
<RETURNS>void  </RETURNS>
GstInterSurface *surface
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_INTER_VIDEO_SINK</NAME>
#define GST_TYPE_INTER_VIDEO_SINK   (gst_inter_video_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_INTER_VIDEO_SINK</NAME>
#define GST_INTER_VIDEO_SINK(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_INTER_VIDEO_SINK,GstInterVideoSink))
</MACRO>
<MACRO>
<NAME>GST_INTER_VIDEO_SINK_CLASS</NAME>
#define GST_INTER_VIDEO_SINK_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_INTER_VIDEO_SINK,GstInterVideoSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_INTER_VIDEO_SINK</NAME>
#define GST_IS_INTER_VIDEO_SINK(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_INTER_VIDEO_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_INTER_VIDEO_SINK_CLASS</NAME>
#define GST_IS_INTER_VIDEO_SINK_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_INTER_VIDEO_SINK))
</MACRO>
<STRUCT>
<NAME>GstInterVideoSink</NAME>
struct _GstInterVideoSink
{
  GstVideoSink videosink;

  GstInterSurface *surface;
  char *channel;

  GstVideoInfo info;
};
</STRUCT>
<STRUCT>
<NAME>GstInterVideoSinkClass</NAME>
struct _GstInterVideoSinkClass
{
  GstVideoSinkClass videosinkclass;
};
</STRUCT>
<FUNCTION>
<NAME>gst_inter_video_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_INTER_VIDEO_SRC</NAME>
#define GST_TYPE_INTER_VIDEO_SRC   (gst_inter_video_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_INTER_VIDEO_SRC</NAME>
#define GST_INTER_VIDEO_SRC(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_INTER_VIDEO_SRC,GstInterVideoSrc))
</MACRO>
<MACRO>
<NAME>GST_INTER_VIDEO_SRC_CLASS</NAME>
#define GST_INTER_VIDEO_SRC_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_INTER_VIDEO_SRC,GstInterVideoSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_INTER_VIDEO_SRC</NAME>
#define GST_IS_INTER_VIDEO_SRC(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_INTER_VIDEO_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_INTER_VIDEO_SRC_CLASS</NAME>
#define GST_IS_INTER_VIDEO_SRC_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_INTER_VIDEO_SRC))
</MACRO>
<STRUCT>
<NAME>GstInterVideoSrc</NAME>
struct _GstInterVideoSrc
{
  GstBaseSrc base_intervideosrc;

  GstInterSurface *surface;

  char *channel;
  guint64 timeout;

  GstVideoInfo info;
  GstBuffer *black_frame;
  int n_frames;
  GstClockTime timestamp_offset;
};
</STRUCT>
<STRUCT>
<NAME>GstInterVideoSrcClass</NAME>
struct _GstInterVideoSrcClass
{
  GstBaseSrcClass base_intervideosrc_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_inter_video_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_INTER_SUB_SINK</NAME>
#define GST_TYPE_INTER_SUB_SINK   (gst_inter_sub_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_INTER_SUB_SINK</NAME>
#define GST_INTER_SUB_SINK(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_INTER_SUB_SINK,GstInterSubSink))
</MACRO>
<MACRO>
<NAME>GST_INTER_SUB_SINK_CLASS</NAME>
#define GST_INTER_SUB_SINK_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_INTER_SUB_SINK,GstInterSubSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_INTER_SUB_SINK</NAME>
#define GST_IS_INTER_SUB_SINK(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_INTER_SUB_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_INTER_SUB_SINK_CLASS</NAME>
#define GST_IS_INTER_SUB_SINK_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_INTER_SUB_SINK))
</MACRO>
<STRUCT>
<NAME>GstInterSubSink</NAME>
struct _GstInterSubSink
{
  GstBaseSink base_intersubsink;

  GstPad *sinkpad;
  GstInterSurface *surface;
  char *channel;

  int fps_n;
  int fps_d;
};
</STRUCT>
<STRUCT>
<NAME>GstInterSubSinkClass</NAME>
struct _GstInterSubSinkClass
{
  GstBaseSinkClass base_intersubsink_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_inter_sub_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_INTER_SUB_SRC</NAME>
#define GST_TYPE_INTER_SUB_SRC   (gst_inter_sub_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_INTER_SUB_SRC</NAME>
#define GST_INTER_SUB_SRC(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_INTER_SUB_SRC,GstInterSubSrc))
</MACRO>
<MACRO>
<NAME>GST_INTER_SUB_SRC_CLASS</NAME>
#define GST_INTER_SUB_SRC_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_INTER_SUB_SRC,GstInterSubSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_INTER_SUB_SRC</NAME>
#define GST_IS_INTER_SUB_SRC(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_INTER_SUB_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_INTER_SUB_SRC_CLASS</NAME>
#define GST_IS_INTER_SUB_SRC_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_INTER_SUB_SRC))
</MACRO>
<STRUCT>
<NAME>GstInterSubSrc</NAME>
struct _GstInterSubSrc
{
  GstBaseSrc base_intersubsrc;

  GstInterSurface *surface;
  char *channel;

  int rate;
  int n_frames;
};
</STRUCT>
<STRUCT>
<NAME>GstInterSubSrcClass</NAME>
struct _GstInterSubSrcClass
{
  GstBaseSrcClass base_intersubsrc_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_inter_sub_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_INTER_AUDIO_SRC</NAME>
#define GST_TYPE_INTER_AUDIO_SRC   (gst_inter_audio_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_INTER_AUDIO_SRC</NAME>
#define GST_INTER_AUDIO_SRC(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_INTER_AUDIO_SRC,GstInterAudioSrc))
</MACRO>
<MACRO>
<NAME>GST_INTER_AUDIO_SRC_CLASS</NAME>
#define GST_INTER_AUDIO_SRC_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_INTER_AUDIO_SRC,GstInterAudioSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_INTER_AUDIO_SRC</NAME>
#define GST_IS_INTER_AUDIO_SRC(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_INTER_AUDIO_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_INTER_AUDIO_SRC_CLASS</NAME>
#define GST_IS_INTER_AUDIO_SRC_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_INTER_AUDIO_SRC))
</MACRO>
<STRUCT>
<NAME>GstInterAudioSrc</NAME>
struct _GstInterAudioSrc
{
  GstBaseSrc base_interaudiosrc;

  GstInterSurface *surface;
  char *channel;

  guint64 n_samples;
  GstClockTime timestamp_offset;
  GstAudioInfo info;
  guint64 buffer_time, latency_time, period_time;
};
</STRUCT>
<STRUCT>
<NAME>GstInterAudioSrcClass</NAME>
struct _GstInterAudioSrcClass
{
  GstBaseSrcClass base_interaudiosrc_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_inter_audio_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_INTER_AUDIO_SINK</NAME>
#define GST_TYPE_INTER_AUDIO_SINK   (gst_inter_audio_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_INTER_AUDIO_SINK</NAME>
#define GST_INTER_AUDIO_SINK(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_INTER_AUDIO_SINK,GstInterAudioSink))
</MACRO>
<MACRO>
<NAME>GST_INTER_AUDIO_SINK_CLASS</NAME>
#define GST_INTER_AUDIO_SINK_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_INTER_AUDIO_SINK,GstInterAudioSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_INTER_AUDIO_SINK</NAME>
#define GST_IS_INTER_AUDIO_SINK(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_INTER_AUDIO_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_INTER_AUDIO_SINK_CLASS</NAME>
#define GST_IS_INTER_AUDIO_SINK_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_INTER_AUDIO_SINK))
</MACRO>
<STRUCT>
<NAME>GstInterAudioSink</NAME>
struct _GstInterAudioSink
{
  GstBaseSink base_interaudiosink;

  GstInterSurface *surface;
  char *channel;

  GstAdapter *input_adapter;
  GstAudioInfo info;
};
</STRUCT>
<STRUCT>
<NAME>GstInterAudioSinkClass</NAME>
struct _GstInterAudioSinkClass
{
  GstBaseSinkClass base_interaudiosink_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_inter_audio_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_JIF_MUX</NAME>
#define GST_TYPE_JIF_MUX \
  (gst_jif_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_JIF_MUX</NAME>
#define GST_JIF_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_JIF_MUX,GstJifMux))
</MACRO>
<MACRO>
<NAME>GST_JIF_MUX_CLASS</NAME>
#define GST_JIF_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_JIF_MUX,GstJifMuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_JIF_MUX</NAME>
#define GST_IS_JIF_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_JIF_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_JIF_MUX_CLASS</NAME>
#define GST_IS_JIF_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_JIF_MUX))
</MACRO>
<MACRO>
<NAME>GST_JIF_MUX_CAST</NAME>
#define GST_JIF_MUX_CAST(obj) ((GstJifMux *) (obj))
</MACRO>
<STRUCT>
<NAME>GstJifMux</NAME>
struct _GstJifMux {
  GstElement element;
  GstJifMuxPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstJifMuxClass</NAME>
struct _GstJifMuxClass {
  GstElementClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_jif_mux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstJifMuxPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>SOF0</NAME>
#define SOF0      0xc0  /* Baseline DCT */
</MACRO>
<MACRO>
<NAME>SOF1</NAME>
#define SOF1      0xc1  /* Extended sequential DCT */
</MACRO>
<MACRO>
<NAME>SOF2</NAME>
#define SOF2      0xc2  /* Progressive DCT */
</MACRO>
<MACRO>
<NAME>SOF3</NAME>
#define SOF3      0xc3  /* Lossless */
</MACRO>
<MACRO>
<NAME>SOF5</NAME>
#define SOF5      0xc5
</MACRO>
<MACRO>
<NAME>SOF6</NAME>
#define SOF6      0xc6
</MACRO>
<MACRO>
<NAME>SOF7</NAME>
#define SOF7      0xc7
</MACRO>
<MACRO>
<NAME>JPG</NAME>
#define JPG       0xc8  /* Reserved */
</MACRO>
<MACRO>
<NAME>SOF9</NAME>
#define SOF9      0xc9
</MACRO>
<MACRO>
<NAME>SOF10</NAME>
#define SOF10     0xca
</MACRO>
<MACRO>
<NAME>SOF11</NAME>
#define SOF11     0xcb
</MACRO>
<MACRO>
<NAME>SOF13</NAME>
#define SOF13     0xcd
</MACRO>
<MACRO>
<NAME>SOF14</NAME>
#define SOF14     0xce
</MACRO>
<MACRO>
<NAME>SOF15</NAME>
#define SOF15     0xcf
</MACRO>
<MACRO>
<NAME>RST0</NAME>
#define RST0      0xd0  /* Restart ... */
</MACRO>
<MACRO>
<NAME>RST1</NAME>
#define RST1      0xd1
</MACRO>
<MACRO>
<NAME>RST2</NAME>
#define RST2      0xd2
</MACRO>
<MACRO>
<NAME>RST3</NAME>
#define RST3      0xd3
</MACRO>
<MACRO>
<NAME>RST4</NAME>
#define RST4      0xd4
</MACRO>
<MACRO>
<NAME>RST5</NAME>
#define RST5      0xd5
</MACRO>
<MACRO>
<NAME>RST6</NAME>
#define RST6      0xd6
</MACRO>
<MACRO>
<NAME>RST7</NAME>
#define RST7      0xd7
</MACRO>
<MACRO>
<NAME>SOI</NAME>
#define SOI       0xd8  /* Start of image */
</MACRO>
<MACRO>
<NAME>EOI</NAME>
#define EOI       0xd9  /* End Of Image */
</MACRO>
<MACRO>
<NAME>SOS</NAME>
#define SOS       0xda  /* Start Of Scan */
</MACRO>
<MACRO>
<NAME>DHT</NAME>
#define DHT       0xc4  /* Huffman Table(s) */
</MACRO>
<MACRO>
<NAME>DAC</NAME>
#define DAC       0xcc  /* Algorithmic Coding Table */
</MACRO>
<MACRO>
<NAME>DQT</NAME>
#define DQT       0xdb  /* Quantisation Table(s) */
</MACRO>
<MACRO>
<NAME>DNL</NAME>
#define DNL       0xdc  /* Number of lines */
</MACRO>
<MACRO>
<NAME>DRI</NAME>
#define DRI       0xdd  /* Restart Interval */
</MACRO>
<MACRO>
<NAME>DHP</NAME>
#define DHP       0xde  /* Hierarchical progression */
</MACRO>
<MACRO>
<NAME>EXP</NAME>
#define EXP       0xdf
</MACRO>
<MACRO>
<NAME>APP0</NAME>
#define APP0      0xe0  /* Application marker */
</MACRO>
<MACRO>
<NAME>APP1</NAME>
#define APP1      0xe1
</MACRO>
<MACRO>
<NAME>APP2</NAME>
#define APP2      0xe2
</MACRO>
<MACRO>
<NAME>APP13</NAME>
#define APP13     0xed
</MACRO>
<MACRO>
<NAME>APP14</NAME>
#define APP14     0xee
</MACRO>
<MACRO>
<NAME>APP15</NAME>
#define APP15     0xef
</MACRO>
<MACRO>
<NAME>JPG0</NAME>
#define JPG0      0xf0  /* Reserved ... */
</MACRO>
<MACRO>
<NAME>JPG13</NAME>
#define JPG13     0xfd
</MACRO>
<MACRO>
<NAME>COM</NAME>
#define COM       0xfe  /* Comment */
</MACRO>
<MACRO>
<NAME>TEM</NAME>
#define TEM       0x01
</MACRO>
<MACRO>
<NAME>GST_TYPE_WEBVTT_ENC</NAME>
#define GST_TYPE_WEBVTT_ENC \
  (gst_webvtt_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_WEBVTT_ENC</NAME>
#define GST_WEBVTT_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WEBVTT_ENC,GstWebvttEnc))
</MACRO>
<MACRO>
<NAME>GST_WEBVTT_ENC_CLASS</NAME>
#define GST_WEBVTT_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WEBVTT_ENC,GstWebvttEnc))
</MACRO>
<MACRO>
<NAME>GST_IS_WEBVTT_ENC</NAME>
#define GST_IS_WEBVTT_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WEBVTT_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_WEBVTT_ENC_CLASS</NAME>
#define GST_IS_WEBVTT_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WEBVTT_ENC))
</MACRO>
<STRUCT>
<NAME>GstWebvttEncClass</NAME>
struct _GstWebvttEncClass
{
  GstElementClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GstWebvttEnc</NAME>
struct _GstWebvttEnc
{
  GstElement element;

  GstPad *sinkpad;
  GstPad *srcpad;

  gboolean pushed_header;

  /* properties */
  gint64 timestamp;
  gint64 duration;

  /* counter for subtitle entry */
  guint counter;
};
</STRUCT>
<FUNCTION>
<NAME>gst_webvtt_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SRT_ENC</NAME>
#define GST_TYPE_SRT_ENC \
  (gst_srt_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_SRT_ENC</NAME>
#define GST_SRT_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SRT_ENC,GstSrtEnc))
</MACRO>
<MACRO>
<NAME>GST_SRT_ENC_CLASS</NAME>
#define GST_SRT_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SRT_ENC,GstSrtEnc))
</MACRO>
<MACRO>
<NAME>GST_IS_SRT_ENC</NAME>
#define GST_IS_SRT_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SRT_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_SRT_ENC_CLASS</NAME>
#define GST_IS_SRT_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SRT_ENC))
</MACRO>
<STRUCT>
<NAME>GstSrtEncClass</NAME>
struct _GstSrtEncClass
{
  GstElementClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GstSrtEnc</NAME>
struct _GstSrtEnc
{
  GstElement element;

  GstPad *sinkpad;
  GstPad *srcpad;

  /* properties */
  gint64 timestamp;
  gint64 duration;

  /* counter for subtitle entry */
  guint counter;
};
</STRUCT>
<FUNCTION>
<NAME>gst_srt_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>FREI0R_MAJOR_VERSION</NAME>
#define FREI0R_MAJOR_VERSION 1
</MACRO>
<MACRO>
<NAME>FREI0R_MINOR_VERSION</NAME>
#define FREI0R_MINOR_VERSION 2
</MACRO>
<FUNCTION>
<NAME>f0r_init</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>f0r_deinit</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<MACRO>
<NAME>F0R_PLUGIN_TYPE_FILTER</NAME>
#define F0R_PLUGIN_TYPE_FILTER 0
</MACRO>
<MACRO>
<NAME>F0R_PLUGIN_TYPE_SOURCE</NAME>
#define F0R_PLUGIN_TYPE_SOURCE 1
</MACRO>
<MACRO>
<NAME>F0R_PLUGIN_TYPE_MIXER2</NAME>
#define F0R_PLUGIN_TYPE_MIXER2 2
</MACRO>
<MACRO>
<NAME>F0R_PLUGIN_TYPE_MIXER3</NAME>
#define F0R_PLUGIN_TYPE_MIXER3 3
</MACRO>
<MACRO>
<NAME>F0R_COLOR_MODEL_BGRA8888</NAME>
#define F0R_COLOR_MODEL_BGRA8888 0
</MACRO>
<MACRO>
<NAME>F0R_COLOR_MODEL_RGBA8888</NAME>
#define F0R_COLOR_MODEL_RGBA8888 1
</MACRO>
<MACRO>
<NAME>F0R_COLOR_MODEL_PACKED32</NAME>
#define F0R_COLOR_MODEL_PACKED32 2
</MACRO>
<FUNCTION>
<NAME>f0r_get_plugin_info</NAME>
<RETURNS>void  </RETURNS>
f0r_plugin_info_t* info
</FUNCTION>
<MACRO>
<NAME>F0R_PARAM_BOOL</NAME>
#define F0R_PARAM_BOOL      0
</MACRO>
<MACRO>
<NAME>F0R_PARAM_DOUBLE</NAME>
#define F0R_PARAM_DOUBLE    1
</MACRO>
<MACRO>
<NAME>F0R_PARAM_COLOR</NAME>
#define F0R_PARAM_COLOR     2
</MACRO>
<MACRO>
<NAME>F0R_PARAM_POSITION</NAME>
#define F0R_PARAM_POSITION  3
</MACRO>
<MACRO>
<NAME>F0R_PARAM_STRING</NAME>
#define F0R_PARAM_STRING  4
</MACRO>
<TYPEDEF>
<NAME>f0r_param_bool</NAME>
typedef double f0r_param_bool;
</TYPEDEF>
<TYPEDEF>
<NAME>f0r_param_double</NAME>
typedef double f0r_param_double;
</TYPEDEF>
<TYPEDEF>
<NAME>f0r_param_string</NAME>
typedef char f0r_param_string;
</TYPEDEF>
<FUNCTION>
<NAME>f0r_get_param_info</NAME>
<RETURNS>void  </RETURNS>
f0r_param_info_t* info, int param_index
</FUNCTION>
<TYPEDEF>
<NAME>f0r_instance_t</NAME>
typedef void* f0r_instance_t;
</TYPEDEF>
<FUNCTION>
<NAME>f0r_construct</NAME>
<RETURNS>f0r_instance_t  </RETURNS>
unsigned int width, unsigned int height
</FUNCTION>
<FUNCTION>
<NAME>f0r_destruct</NAME>
<RETURNS>void  </RETURNS>
f0r_instance_t instance
</FUNCTION>
<TYPEDEF>
<NAME>f0r_param_t</NAME>
typedef void* f0r_param_t;
</TYPEDEF>
<FUNCTION>
<NAME>f0r_set_param_value</NAME>
<RETURNS>void  </RETURNS>
f0r_instance_t instance, f0r_param_t param, int param_index
</FUNCTION>
<FUNCTION>
<NAME>f0r_get_param_value</NAME>
<RETURNS>void  </RETURNS>
f0r_instance_t instance, f0r_param_t param, int param_index
</FUNCTION>
<FUNCTION>
<NAME>f0r_update</NAME>
<RETURNS>void  </RETURNS>
f0r_instance_t instance, double time, const guint32* inframe, guint32* outframe
</FUNCTION>
<FUNCTION>
<NAME>f0r_update2</NAME>
<RETURNS>void  </RETURNS>
f0r_instance_t instance, double time, const guint32* inframe1, const guint32* inframe2, const guint32* inframe3, guint32* outframe
</FUNCTION>
<MACRO>
<NAME>GST_FREI0R_SRC</NAME>
#define GST_FREI0R_SRC(obj) \
  ((GstFrei0rSrc *) obj)
</MACRO>
<MACRO>
<NAME>GST_FREI0R_SRC_CLASS</NAME>
#define GST_FREI0R_SRC_CLASS(klass) \
  ((GstFrei0rSrcClass *) klass)
</MACRO>
<MACRO>
<NAME>GST_FREI0R_SRC_GET_CLASS</NAME>
#define GST_FREI0R_SRC_GET_CLASS(obj) \
  ((GstFrei0rSrcClass *) g_type_class_peek (G_TYPE_FROM_INSTANCE (obj)))
</MACRO>
<STRUCT>
<NAME>GstFrei0rSrc</NAME>
struct _GstFrei0rSrc {
  GstPushSrc parent;

  f0r_instance_t *f0r_instance;
  GstFrei0rPropertyValue *property_cache;

  GstVideoInfo info;

  guint64 n_frames;
};
</STRUCT>
<STRUCT>
<NAME>GstFrei0rSrcClass</NAME>
struct _GstFrei0rSrcClass {
  GstPushSrcClass parent;

  f0r_plugin_info_t *info;
  GstFrei0rFuncTable *ftable;

  GstFrei0rProperty *properties;
  gint n_properties;
};
</STRUCT>
<FUNCTION>
<NAME>gst_frei0r_src_register</NAME>
<RETURNS>GstFrei0rPluginRegisterReturn  </RETURNS>
GstPlugin *plugin, const gchar * vendor, const f0r_plugin_info_t *info, const GstFrei0rFuncTable *ftable
</FUNCTION>
<MACRO>
<NAME>GST_FREI0R_MIXER</NAME>
#define GST_FREI0R_MIXER(obj) \
  ((GstFrei0rMixer *) obj)
</MACRO>
<MACRO>
<NAME>GST_FREI0R_MIXER_CLASS</NAME>
#define GST_FREI0R_MIXER_CLASS(klass) \
  ((GstFrei0rMixerClass *) klass)
</MACRO>
<MACRO>
<NAME>GST_FREI0R_MIXER_GET_CLASS</NAME>
#define GST_FREI0R_MIXER_GET_CLASS(obj) \
  ((GstFrei0rMixerClass *) g_type_class_peek (G_TYPE_FROM_INSTANCE (obj)))
</MACRO>
<STRUCT>
<NAME>GstFrei0rMixer</NAME>
struct _GstFrei0rMixer {
  GstElement parent;

  GstCollectPads *collect;
  GstPad *src;
  GstPad *sink0, *sink1, *sink2;

  GstCaps *caps;
  GstVideoInfo info;

  GstEvent *segment_event;

  GstPadEventFunction collect_event;

  f0r_instance_t *f0r_instance;
  GstFrei0rPropertyValue *property_cache;
};
</STRUCT>
<STRUCT>
<NAME>GstFrei0rMixerClass</NAME>
struct _GstFrei0rMixerClass {
  GstElementClass parent;

  f0r_plugin_info_t *info;
  GstFrei0rFuncTable *ftable;

  GstFrei0rProperty *properties;
  gint n_properties;
};
</STRUCT>
<FUNCTION>
<NAME>gst_frei0r_mixer_register</NAME>
<RETURNS>GstFrei0rPluginRegisterReturn  </RETURNS>
GstPlugin *plugin, const gchar * vendor, const f0r_plugin_info_t *info, const GstFrei0rFuncTable *ftable
</FUNCTION>
<MACRO>
<NAME>GST_FREI0R_FILTER</NAME>
#define GST_FREI0R_FILTER(obj) \
  ((GstFrei0rFilter *) obj)
</MACRO>
<MACRO>
<NAME>GST_FREI0R_FILTER_CLASS</NAME>
#define GST_FREI0R_FILTER_CLASS(klass) \
  ((GstFrei0rFilterClass *) klass)
</MACRO>
<MACRO>
<NAME>GST_FREI0R_FILTER_GET_CLASS</NAME>
#define GST_FREI0R_FILTER_GET_CLASS(obj) \
  ((GstFrei0rFilterClass *) g_type_class_peek (G_TYPE_FROM_INSTANCE (obj)))
</MACRO>
<STRUCT>
<NAME>GstFrei0rFilter</NAME>
struct _GstFrei0rFilter {
  GstVideoFilter parent;

  gint width, height;

  f0r_instance_t *f0r_instance;
  GstFrei0rPropertyValue *property_cache;
};
</STRUCT>
<STRUCT>
<NAME>GstFrei0rFilterClass</NAME>
struct _GstFrei0rFilterClass {
  GstVideoFilterClass parent;

  f0r_plugin_info_t *info;
  GstFrei0rFuncTable *ftable;

  GstFrei0rProperty *properties;
  gint n_properties;
};
</STRUCT>
<FUNCTION>
<NAME>gst_frei0r_filter_register</NAME>
<RETURNS>GstFrei0rPluginRegisterReturn  </RETURNS>
GstPlugin *plugin, const gchar * vendor, const f0r_plugin_info_t *info, const GstFrei0rFuncTable *ftable
</FUNCTION>
<STRUCT>
<NAME>GstFrei0rPropertyValue</NAME>
struct _GstFrei0rPropertyValue {
  union {
    f0r_param_bool b;
    f0r_param_double d;
    f0r_param_string *s;
    f0r_param_position_t position;
    f0r_param_color_t color;
  } data;
};
</STRUCT>
<STRUCT>
<NAME>GstFrei0rProperty</NAME>
struct _GstFrei0rProperty {
  guint prop_id;
  guint n_prop_ids;

  gint prop_idx;
  f0r_param_info_t info;

  GstFrei0rPropertyValue default_value;
};
</STRUCT>
<STRUCT>
<NAME>GstFrei0rFuncTable</NAME>
struct _GstFrei0rFuncTable {
  int (*init) (void);
  void (*deinit) (void);

  f0r_instance_t (*construct) (unsigned int width, unsigned int height);
  void (*destruct) (f0r_instance_t instance);

  void (*get_plugin_info) (f0r_plugin_info_t* info);  
  void (*get_param_info) (f0r_param_info_t* info, int param_index);

  void (*set_param_value) (f0r_instance_t instance, 
			   f0r_param_t param, int param_index);
  void (*get_param_value) (f0r_instance_t instance,
			   f0r_param_t param, int param_index);
  
  void (*update) (f0r_instance_t instance, 
		  double time, const guint32* inframe, guint32* outframe);
  void (*update2) (f0r_instance_t instance,
		   double time,
		   const guint32* inframe1,
		   const guint32* inframe2,
		   const guint32* inframe3,
		   guint32* outframe);
};
</STRUCT>
<ENUM>
<NAME>GstFrei0rPluginRegisterReturn</NAME>
typedef enum {
  GST_FREI0R_PLUGIN_REGISTER_RETURN_OK,
  GST_FREI0R_PLUGIN_REGISTER_RETURN_FAILED,
  GST_FREI0R_PLUGIN_REGISTER_RETURN_ALREADY_REGISTERED
} GstFrei0rPluginRegisterReturn;
</ENUM>
<FUNCTION>
<NAME>gst_frei0r_klass_install_properties</NAME>
<RETURNS>void  </RETURNS>
GObjectClass *gobject_class, GstFrei0rFuncTable *ftable, GstFrei0rProperty *properties, gint n_properties
</FUNCTION>
<FUNCTION>
<NAME>gst_frei0r_instance_construct</NAME>
<RETURNS>f0r_instance_t  * </RETURNS>
GstFrei0rFuncTable *ftable, GstFrei0rProperty *properties, gint n_properties, GstFrei0rPropertyValue *property_cache, gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>gst_frei0r_property_cache_init</NAME>
<RETURNS>GstFrei0rPropertyValue  * </RETURNS>
GstFrei0rProperty *properties, gint n_properties
</FUNCTION>
<FUNCTION>
<NAME>gst_frei0r_property_cache_free</NAME>
<RETURNS>void  </RETURNS>
GstFrei0rProperty *properties, GstFrei0rPropertyValue *property_cache, gint n_properties
</FUNCTION>
<FUNCTION>
<NAME>gst_frei0r_caps_from_color_model</NAME>
<RETURNS>GstCaps  * </RETURNS>
gint color_model
</FUNCTION>
<FUNCTION>
<NAME>gst_frei0r_get_property</NAME>
<RETURNS>gboolean  </RETURNS>
f0r_instance_t *instance, GstFrei0rFuncTable *ftable, GstFrei0rProperty *properties, gint n_properties, GstFrei0rPropertyValue *property_cache, guint prop_id, GValue *value
</FUNCTION>
<FUNCTION>
<NAME>gst_frei0r_set_property</NAME>
<RETURNS>gboolean  </RETURNS>
f0r_instance_t *instance, GstFrei0rFuncTable *ftable, GstFrei0rProperty *properties, gint n_properties, GstFrei0rPropertyValue *property_cache, guint prop_id, const GValue *value
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VIDEOFRAME_AUDIOLEVEL</NAME>
#define GST_TYPE_VIDEOFRAME_AUDIOLEVEL                    (gst_videoframe_audiolevel_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEOFRAME_AUDIOLEVEL</NAME>
#define GST_VIDEOFRAME_AUDIOLEVEL(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEOFRAME_AUDIOLEVEL,GstVideoFrameAudioLevel))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEOFRAME_AUDIOLEVEL</NAME>
#define GST_IS_VIDEOFRAME_AUDIOLEVEL(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEOFRAME_AUDIOLEVEL))
</MACRO>
<MACRO>
<NAME>GST_VIDEOFRAME_AUDIOLEVEL_CLASS</NAME>
#define GST_VIDEOFRAME_AUDIOLEVEL_CLASS(klass)            (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_VIDEOFRAME_AUDIOLEVEL,GstVideoFrameAudioLevelClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEOFRAME_AUDIOLEVEL_CLASS</NAME>
#define GST_IS_VIDEOFRAME_AUDIOLEVEL_CLASS(klass)         (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_VIDEOFRAME_AUDIOLEVEL))
</MACRO>
<MACRO>
<NAME>GST_VIDEOFRAME_AUDIOLEVEL_GET_CLASS</NAME>
#define GST_VIDEOFRAME_AUDIOLEVEL_GET_CLASS(obj)          (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_VIDEOFRAME_AUDIOLEVEL,GstVideoFrameAudioLevelClass))
</MACRO>
<STRUCT>
<NAME>GstVideoFrameAudioLevel</NAME>
struct _GstVideoFrameAudioLevel
{
  GstElement parent;

  GstPad *asrcpad, *asinkpad, *vsrcpad, *vsinkpad;

  GstAudioInfo ainfo;

  gdouble *CS;                  /* normalized Cumulative Square */

  GstSegment asegment, vsegment;

  void (*process) (gpointer, guint, guint, gdouble *);

  GQueue vtimeq;
  GstAdapter *adapter;
  GstClockTime first_time;
  guint total_frames;
  guint64 next_offset, alignment_threshold, discont_time, discont_wait;

  gboolean video_eos_flag;
  gboolean audio_flush_flag;
  gboolean shutdown_flag;

  GCond cond;
  GMutex mutex;
};
</STRUCT>
<STRUCT>
<NAME>GstVideoFrameAudioLevelClass</NAME>
struct _GstVideoFrameAudioLevelClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_videoframe_audiolevel_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ACCURIP</NAME>
#define GST_TYPE_ACCURIP \
  (gst_accurip_get_type())
</MACRO>
<MACRO>
<NAME>GST_ACCURIP</NAME>
#define GST_ACCURIP(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ACCURIP,GstAccurip))
</MACRO>
<MACRO>
<NAME>GST_ACCURIP_CLASS</NAME>
#define GST_ACCURIP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ACCURIP,GstAccuripClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ACCURIP</NAME>
#define GST_IS_ACCURIP(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ACCURIP))
</MACRO>
<MACRO>
<NAME>GST_IS_ACCURIP_CLASS</NAME>
#define GST_IS_ACCURIP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ACCURIP))
</MACRO>
<MACRO>
<NAME>GST_TAG_ACCURIP_CRC</NAME>
#define GST_TAG_ACCURIP_CRC    "accurip-crc"
</MACRO>
<MACRO>
<NAME>GST_TAG_ACCURIP_CRC_V2</NAME>
#define GST_TAG_ACCURIP_CRC_V2 "accurip-crcv2"
</MACRO>
<STRUCT>
<NAME>GstAccurip</NAME>
struct _GstAccurip
{
  GstAudioFilter element;

  /*< private >*/
  guint32              crc;
  guint32              crc_v2;
  guint64              num_samples;
  gboolean             is_first;
  gboolean             is_last;

  /* Needed when 'is_last' is true */
  guint32             *crcs_ring;
  guint32             *crcs_v2_ring;
  guint64              ring_samples;
};
</STRUCT>
<STRUCT>
<NAME>GstAccuripClass</NAME>
struct _GstAccuripClass
{
  GstAudioFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_accurip_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SDP_SRC</NAME>
#define GST_TYPE_SDP_SRC \
  (gst_sdp_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_SDP_SRC</NAME>
#define GST_SDP_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_SDP_SRC, GstSdpSrc))
</MACRO>
<MACRO>
<NAME>GST_SDP_SRC_CAST</NAME>
#define GST_SDP_SRC_CAST(obj) \
  ((GstSdpSrc *) obj)
</MACRO>
<MACRO>
<NAME>GST_SDP_SRC_CLASS</NAME>
#define GST_SDP_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_SDP_SRC, GstSdpSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SDP_SRC</NAME>
#define GST_IS_SDP_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_SDP_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_SDP_SRC_CLASS</NAME>
#define GST_IS_SDP_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_SDP_SRC))
</MACRO>
<STRUCT>
<NAME>GstSdpSrc</NAME>
struct _GstSdpSrc
{
  GstBin parent;

  gchar *location;
  gchar *sdp;

  GstBuffer *sdp_buffer;
  GstElement *src;
  GstElement *demux;
};
</STRUCT>
<STRUCT>
<NAME>GstSdpSrcClass</NAME>
struct _GstSdpSrcClass
{
  GstBinClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_sdp_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>SpuState</NAME>
typedef struct SpuState SpuState;
</TYPEDEF>
<TYPEDEF>
<NAME>SpuColour</NAME>
typedef struct SpuColour SpuColour;
</TYPEDEF>
<TYPEDEF>
<NAME>SpuRect</NAME>
typedef struct SpuRect SpuRect;
</TYPEDEF>
<FUNCTION>
<NAME>gstspu_clear_comp_buffers</NAME>
<RETURNS>void  </RETURNS>
SpuState * state
</FUNCTION>
<FUNCTION>
<NAME>gstspu_blend_comp_buffers</NAME>
<RETURNS>void  </RETURNS>
SpuState * state, guint8 * planes[3]
</FUNCTION>
<STRUCT>
<NAME>GstDVDSpu</NAME>
</STRUCT>
<TYPEDEF>
<NAME>SpuVobsubState</NAME>
typedef struct SpuVobsubState SpuVobsubState;
</TYPEDEF>
<TYPEDEF>
<NAME>SpuVobsubPixCtrlI</NAME>
typedef struct SpuVobsubPixCtrlI SpuVobsubPixCtrlI;
</TYPEDEF>
<TYPEDEF>
<NAME>SpuVobsubLineCtrlI</NAME>
typedef struct SpuVobsubLineCtrlI SpuVobsubLineCtrlI;
</TYPEDEF>
<FUNCTION>
<NAME>gstspu_vobsub_handle_new_buf</NAME>
<RETURNS>void  </RETURNS>
GstDVDSpu * dvdspu, GstClockTime event_ts, GstBuffer *buf
</FUNCTION>
<FUNCTION>
<NAME>gstspu_vobsub_execute_event</NAME>
<RETURNS>gboolean  </RETURNS>
GstDVDSpu *dvdspu
</FUNCTION>
<FUNCTION>
<NAME>gstspu_vobsub_render</NAME>
<RETURNS>void  </RETURNS>
GstDVDSpu *dvdspu, GstVideoFrame *frame
</FUNCTION>
<FUNCTION>
<NAME>gstspu_vobsub_handle_dvd_event</NAME>
<RETURNS>gboolean  </RETURNS>
GstDVDSpu *dvdspu, GstEvent *event
</FUNCTION>
<FUNCTION>
<NAME>gstspu_vobsub_flush</NAME>
<RETURNS>void  </RETURNS>
GstDVDSpu *dvdspu
</FUNCTION>
<TYPEDEF>
<NAME>SpuPgsState</NAME>
typedef struct SpuPgsState SpuPgsState;
</TYPEDEF>
<TYPEDEF>
<NAME>PgsPresentationSegment</NAME>
typedef struct PgsPresentationSegment PgsPresentationSegment;
</TYPEDEF>
<TYPEDEF>
<NAME>PgsCompositionObject</NAME>
typedef struct PgsCompositionObject PgsCompositionObject;
</TYPEDEF>
<FUNCTION>
<NAME>gstspu_pgs_handle_new_buf</NAME>
<RETURNS>void  </RETURNS>
GstDVDSpu * dvdspu, GstClockTime event_ts, GstBuffer *buf
</FUNCTION>
<FUNCTION>
<NAME>gstspu_pgs_execute_event</NAME>
<RETURNS>gboolean  </RETURNS>
GstDVDSpu *dvdspu
</FUNCTION>
<FUNCTION>
<NAME>gstspu_pgs_render</NAME>
<RETURNS>void  </RETURNS>
GstDVDSpu *dvdspu, GstVideoFrame *frame
</FUNCTION>
<FUNCTION>
<NAME>gstspu_pgs_handle_dvd_event</NAME>
<RETURNS>gboolean  </RETURNS>
GstDVDSpu *dvdspu, GstEvent *event
</FUNCTION>
<FUNCTION>
<NAME>gstspu_pgs_flush</NAME>
<RETURNS>void  </RETURNS>
GstDVDSpu *dvdspu
</FUNCTION>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<MACRO>
<NAME>GST_TYPE_FIELDANALYSIS</NAME>
#define GST_TYPE_FIELDANALYSIS \
  (gst_field_analysis_get_type())
</MACRO>
<MACRO>
<NAME>GST_FIELDANALYSIS</NAME>
#define GST_FIELDANALYSIS(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FIELDANALYSIS,GstFieldAnalysis))
</MACRO>
<MACRO>
<NAME>GST_FIELDANALYSIS_CLASS</NAME>
#define GST_FIELDANALYSIS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FIELDANALYSIS,GstFieldAnalysisClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FIELDANALYSIS</NAME>
#define GST_IS_FIELDANALYSIS(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FIELDANALYSIS))
</MACRO>
<MACRO>
<NAME>GST_IS_FIELDANALYSIS_CLASS</NAME>
#define GST_IS_FIELDANALYSIS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FIELDANALYSIS))
</MACRO>
<ENUM>
<NAME>FieldAnalysisConclusion</NAME>
typedef enum
{
  FIELD_ANALYSIS_PROGRESSIVE,
  FIELD_ANALYSIS_INTERLACED,
  FIELD_ANALYSIS_TELECINE_PROGRESSIVE,
  FIELD_ANALYSIS_TELECINE_MIXED
} FieldAnalysisConclusion;
</ENUM>
<STRUCT>
<NAME>FieldAnalysis</NAME>
struct _FieldAnalysis
{
  /* frame, top, bottom, top with prev bottom, bottom with prev top */
  gfloat f, t, b, t_b, b_t;
  FieldAnalysisConclusion conclusion;
  /* -1 - unknown; 0 - holding none; 1 - top field; 2 - bottom field; 3 - both */
  gint holding;
  gboolean drop;
};
</STRUCT>
<STRUCT>
<NAME>FieldAnalysisFields</NAME>
struct _FieldAnalysisFields
{
  GstVideoFrame frame;
  gboolean parity;
};
</STRUCT>
<STRUCT>
<NAME>FieldAnalysisHistory</NAME>
struct _FieldAnalysisHistory
{
  GstVideoFrame frame;
  FieldAnalysis results;
};
</STRUCT>
<ENUM>
<NAME>FieldAnalysisCombMethod</NAME>
typedef enum
{
  METHOD_32DETECT,
  METHOD_IS_COMBED,
  METHOD_5_TAP
} FieldAnalysisCombMethod;
</ENUM>
<STRUCT>
<NAME>GstFieldAnalysis</NAME>
struct _GstFieldAnalysis
{
  GstElement element;

  GstPad *sinkpad, *srcpad;

  guint nframes;
  FieldAnalysisHistory frames[2];
  GstVideoInfo vinfo;
  gfloat (*same_field) (GstFieldAnalysis *, FieldAnalysisFields (*)[2]);
  gfloat (*same_frame) (GstFieldAnalysis *, FieldAnalysisFields (*)[2]);
  guint64 (*block_score_for_row) (GstFieldAnalysis *, FieldAnalysisFields (*)[2], guint8 *, guint8 *);
  gboolean is_telecine;
  gboolean first_buffer; /* indicates the first buffer for which a buffer will be output
                          * after a discont or flushing seek */
  guint8 *comb_mask;
  guint *block_scores;
  gboolean flushing;     /* indicates whether we are flushing or not */

  /* properties */
  guint32 noise_floor; /* threshold for the result of a metric to be valid */
  gfloat field_thresh; /* threshold used for the same parity field metric */
  gfloat frame_thresh; /* threshold used for the opposite parity field metric */
  gint64 spatial_thresh; /* threshold used spatial comb detection */
  guint64 block_width, block_height; /* width/height of window used for comb clusted detection */
  guint64 block_thresh;
  guint64 ignored_lines;
};
</STRUCT>
<STRUCT>
<NAME>GstFieldAnalysisClass</NAME>
struct _GstFieldAnalysisClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_field_analysis_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<MACRO>
<NAME>GST_TYPE_AUDIO_MIXER</NAME>
#define GST_TYPE_AUDIO_MIXER            (gst_audiomixer_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_MIXER</NAME>
#define GST_AUDIO_MIXER(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_MIXER,GstAudioMixer))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_MIXER</NAME>
#define GST_IS_AUDIO_MIXER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_MIXER))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_MIXER_CLASS</NAME>
#define GST_AUDIO_MIXER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AUDIO_MIXER,GstAudioMixerClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_MIXER_CLASS</NAME>
#define GST_IS_AUDIO_MIXER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AUDIO_MIXER))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_MIXER_GET_CLASS</NAME>
#define GST_AUDIO_MIXER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AUDIO_MIXER,GstAudioMixerClass))
</MACRO>
<STRUCT>
<NAME>GstAudioMixer</NAME>
struct _GstAudioMixer {
  GstAudioAggregator element;

  /* target caps (set via property) */
  GstCaps *filter_caps;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioMixerClass</NAME>
struct _GstAudioMixerClass {
  GstAudioAggregatorClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audiomixer_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_MIXER_PAD</NAME>
#define GST_TYPE_AUDIO_MIXER_PAD            (gst_audiomixer_pad_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_MIXER_PAD</NAME>
#define GST_AUDIO_MIXER_PAD(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_MIXER_PAD,GstAudioMixerPad))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_MIXER_PAD</NAME>
#define GST_IS_AUDIO_MIXER_PAD(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_MIXER_PAD))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_MIXER_PAD_CLASS</NAME>
#define GST_AUDIO_MIXER_PAD_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AUDIO_MIXER_PAD,GstAudioMixerPadClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_MIXER_PAD_CLASS</NAME>
#define GST_IS_AUDIO_MIXER_PAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AUDIO_MIXER_PAD))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_MIXER_PAD_GET_CLASS</NAME>
#define GST_AUDIO_MIXER_PAD_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AUDIO_MIXER_PAD,GstAudioMixerPadClass))
</MACRO>
<STRUCT>
<NAME>GstAudioMixerPad</NAME>
struct _GstAudioMixerPad {
  GstAudioAggregatorPad parent;

  gdouble volume;
  gint volume_i32;
  gint volume_i16;
  gint volume_i8;
  gboolean mute;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioMixerPadClass</NAME>
struct _GstAudioMixerPadClass {
  GstAudioAggregatorPadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audiomixer_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<MACRO>
<NAME>GST_TYPE_AUDIO_INTERLEAVE</NAME>
#define GST_TYPE_AUDIO_INTERLEAVE            (gst_audio_interleave_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_INTERLEAVE</NAME>
#define GST_AUDIO_INTERLEAVE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_INTERLEAVE,GstAudioInterleave))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_INTERLEAVE</NAME>
#define GST_IS_AUDIO_INTERLEAVE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_INTERLEAVE))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_INTERLEAVE_CLASS</NAME>
#define GST_AUDIO_INTERLEAVE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AUDIO_INTERLEAVE,GstAudioInterleaveClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_INTERLEAVE_CLASS</NAME>
#define GST_IS_AUDIO_INTERLEAVE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AUDIO_INTERLEAVE))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_INTERLEAVE_GET_CLASS</NAME>
#define GST_AUDIO_INTERLEAVE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AUDIO_INTERLEAVE,GstAudioInterleaveClass))
</MACRO>
<USER_FUNCTION>
<NAME>GstInterleaveFunc</NAME>
<RETURNS>void </RETURNS>
gpointer out, gpointer in, guint stride,
    guint nframes
</USER_FUNCTION>
<STRUCT>
<NAME>GstAudioInterleave</NAME>
struct _GstAudioInterleave {
  GstAudioAggregator parent;

  gint padcounter;
  guint channels;

  gboolean new_caps;
  GstCaps *sinkcaps;

  GValueArray *channel_positions;
  GValueArray *input_channel_positions;
  gboolean channel_positions_from_input;

  gint default_channels_ordering_map[64];

  GstInterleaveFunc func;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioInterleaveClass</NAME>
struct _GstAudioInterleaveClass {
  GstAudioAggregatorClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_interleave_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_INTERLEAVE_PAD</NAME>
#define GST_TYPE_AUDIO_INTERLEAVE_PAD            (gst_audio_interleave_pad_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_INTERLEAVE_PAD</NAME>
#define GST_AUDIO_INTERLEAVE_PAD(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_INTERLEAVE_PAD,GstAudioInterleavePad))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_INTERLEAVE_PAD</NAME>
#define GST_IS_AUDIO_INTERLEAVE_PAD(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_INTERLEAVE_PAD))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_INTERLEAVE_PAD_CLASS</NAME>
#define GST_AUDIO_INTERLEAVE_PAD_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AUDIO_INTERLEAVE_PAD,GstAudioInterleavePadClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_INTERLEAVE_PAD_CLASS</NAME>
#define GST_IS_AUDIO_INTERLEAVE_PAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AUDIO_INTERLEAVE_PAD))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_INTERLEAVE_PAD_GET_CLASS</NAME>
#define GST_AUDIO_INTERLEAVE_PAD_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AUDIO_INTERLEAVE_PAD,GstAudioInterleavePadClass))
</MACRO>
<STRUCT>
<NAME>GstAudioInterleavePad</NAME>
struct _GstAudioInterleavePad {
  GstAudioAggregatorPad parent;

  guint channel;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioInterleavePadClass</NAME>
struct _GstAudioInterleavePadClass {
  GstAudioAggregatorPadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_interleave_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MIDI_PARSE</NAME>
#define GST_TYPE_MIDI_PARSE \
  (gst_midi_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_MIDI_PARSE</NAME>
#define GST_MIDI_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MIDI_PARSE,GstMidiParse))
</MACRO>
<MACRO>
<NAME>GST_MIDI_PARSE_CLASS</NAME>
#define GST_MIDI_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MIDI_PARSE,GstMidiParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MIDI_PARSE</NAME>
#define GST_IS_MIDI_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MIDI_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_MIDI_PARSE_CLASS</NAME>
#define GST_IS_MIDI_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MIDI_PARSE))
</MACRO>
<ENUM>
<NAME>GstMidiParseState</NAME>
typedef enum {
  GST_MIDI_PARSE_STATE_LOAD,
  GST_MIDI_PARSE_STATE_PARSE,
  GST_MIDI_PARSE_STATE_PLAY
} GstMidiParseState;
</ENUM>
<STRUCT>
<NAME>GstMidiParse</NAME>
struct _GstMidiParse
{
  GstElement element;

  GstPad *sinkpad, *srcpad;

  gboolean have_group_id;
  guint group_id;

  /* input stream properties */
  GstMidiParseState state;

  guint tempo;
  guint16 ntracks;
  guint16 division;

  GList *tracks;
  guint  track_count;

  guint64 offset;
  GstAdapter *adapter;
  guint8 *data;

  /* output data */
  gboolean discont;
  GstSegment segment;
  gboolean segment_pending;
  guint32 seqnum;

  guint64 pulse;
};
</STRUCT>
<STRUCT>
<NAME>GstMidiParseClass</NAME>
struct _GstMidiParseClass
{
    GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_midi_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VMNC_DEC</NAME>
#define GST_TYPE_VMNC_DEC \
  (gst_vmnc_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_VMNC_DEC</NAME>
#define GST_VMNC_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VMNC_DEC,GstVMncDec))
</MACRO>
<MACRO>
<NAME>MAKE_TYPE</NAME>
#define MAKE_TYPE(a,b,c,d) ((a<<24)|(b<<16)|(c<<8)|d)
</MACRO>
<STRUCT>
<NAME>RFBFormat</NAME>
struct RFBFormat
{
  int width;
  int height;
  int stride;
  int bytes_per_pixel;
  int depth;
  int big_endian;

  guint8 descriptor[16];        /* The raw format descriptor block */
};
</STRUCT>
<STRUCT>
<NAME>Cursor</NAME>
struct Cursor
{
  enum CursorType type;
  int visible;
  int x;
  int y;
  int width;
  int height;
  int hot_x;
  int hot_y;
  guint8 *cursordata;
  guint8 *cursormask;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vmnc_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGTS_PARSE</NAME>
#define GST_TYPE_MPEGTS_PARSE \
  (mpegts_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_MPEGTS_PARSE</NAME>
#define GST_MPEGTS_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MPEGTS_PARSE,MpegTSParse2))
</MACRO>
<MACRO>
<NAME>GST_MPEGTS_PARSE_CLASS</NAME>
#define GST_MPEGTS_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MPEGTS_PARSE,MpegTSParse2Class))
</MACRO>
<MACRO>
<NAME>GST_IS_MPEGTS_PARSE</NAME>
#define GST_IS_MPEGTS_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MPEGTS_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_MPEGTS_PARSE_CLASS</NAME>
#define GST_IS_MPEGTS_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MPEGTS_PARSE))
</MACRO>
<STRUCT>
<NAME>MpegTSParse2</NAME>
struct _MpegTSParse2 {
  MpegTSBase parent;

  gboolean have_group_id;
  guint group_id;

  GstClockTime smoothing_latency;
  GstClockTime base_pcr;
  GstClockTime ts_offset;
  GstClockTime current_pcr;
  gint user_pcr_pid;
  gint pcr_pid;

  /* Always present source pad */
  GstPad *srcpad;

  /* Request source (single program) pads */
  GList *srcpads;

  GstFlowCombiner *flowcombiner;
  
  /* state */
  gboolean first;
  gboolean set_timestamps;

  /* Pending buffer state */
  GList *pending_buffers;
  GstClockTime previous_pcr;
  guint bytes_since_pcr;
};
</STRUCT>
<STRUCT>
<NAME>MpegTSParse2Class</NAME>
struct _MpegTSParse2Class {
  MpegTSBaseClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_MPEGTS_BASE</NAME>
#define GST_TYPE_MPEGTS_BASE \
  (mpegts_base_get_type())
</MACRO>
<MACRO>
<NAME>GST_MPEGTS_BASE</NAME>
#define GST_MPEGTS_BASE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MPEGTS_BASE,MpegTSBase))
</MACRO>
<MACRO>
<NAME>GST_MPEGTS_BASE_CLASS</NAME>
#define GST_MPEGTS_BASE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MPEGTS_BASE,MpegTSBaseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MPEGTS_BASE</NAME>
#define GST_IS_MPEGTS_BASE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MPEGTS_BASE))
</MACRO>
<MACRO>
<NAME>GST_IS_MPEGTS_BASE_CLASS</NAME>
#define GST_IS_MPEGTS_BASE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MPEGTS_BASE))
</MACRO>
<MACRO>
<NAME>GST_MPEGTS_BASE_GET_CLASS</NAME>
#define GST_MPEGTS_BASE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_MPEGTS_BASE, MpegTSBaseClass))
</MACRO>
<MACRO>
<NAME>MPEG_TS_BASE_PACKETIZER</NAME>
#define MPEG_TS_BASE_PACKETIZER(b) (((MpegTSBase*)b)->packetizer)
</MACRO>
<STRUCT>
<NAME>MpegTSBaseStream</NAME>
struct _MpegTSBaseStream
{
  guint16             pid;
  guint8              stream_type;

  /* Content of the registration descriptor (if present) */
  guint32             registration_id;

  GstMpegtsPMTStream *stream;
  GstStream          *stream_object;
  gchar              *stream_id;
};
</STRUCT>
<STRUCT>
<NAME>MpegTSBaseProgram</NAME>
struct _MpegTSBaseProgram
{
  gint                program_number;
  guint16             pmt_pid;
  guint16             pcr_pid;

  /* Content of the registration descriptor (if present) */
  guint32             registration_id;

  GstMpegtsSection   *section;
  const GstMpegtsPMT *pmt;

  MpegTSBaseStream  **streams;
  GList              *stream_list;
  gint                patcount;

  GstStreamCollection *collection;

  /* Pending Tags for the program */
  GstTagList *tags;
  guint event_id;

  /* TRUE if the program is currently being used */
  gboolean active;
  /* TRUE if this is the first program created */
  gboolean initial_program;
};
</STRUCT>
<ENUM>
<NAME>MpegTSBaseMode</NAME>
typedef enum {
  /* PULL MODE */
  BASE_MODE_SCANNING,		/* Looking for PAT/PMT */
  BASE_MODE_SEEKING,		/* Seeking */
  BASE_MODE_STREAMING,		/* Normal mode (pushing out data) */

  /* PUSH MODE */
  BASE_MODE_PUSHING
} MpegTSBaseMode;
</ENUM>
<STRUCT>
<NAME>MpegTSBase</NAME>
struct _MpegTSBase {
  GstElement element;

  GstPad *sinkpad;

  /* pull-based behaviour */
  MpegTSBaseMode mode;

  /* Current pull offset (also set by seek handler) */
  guint64	seek_offset;

  /* Cached packetsize */
  guint16	packetsize;

  /* the following vars must be protected with the OBJECT_LOCK as they can be
   * accessed from the application thread and the streaming thread */
  GHashTable *programs;

  GPtrArray  *pat;
  MpegTSPacketizer2 *packetizer;

  /* arrays that say whether a pid is a known psi pid or a pes pid */
  /* Use MPEGTS_BIT_* to set/unset/check the values */
  guint8 *known_psi;
  guint8 *is_pes;

  gboolean disposed;

  /* size of the MpegTSBaseProgram structure, can be overridden
   * by subclasses if they have their own MpegTSBaseProgram subclasses. */
  gsize program_size;

  /* size of the MpegTSBaseStream structure, can be overridden
   * by subclasses if they have their own MpegTSBaseStream subclasses */
  gsize stream_size;

  /* Whether we saw a PAT yet */
  gboolean seen_pat;

  /* Upstream segment */
  GstSegment segment;

  /* Last received seek event seqnum (default -1) */
  guint last_seek_seqnum;

  /* Whether to parse private section or not */
  gboolean parse_private_sections;

  /* Whether to push data and/or sections to subclasses */
  gboolean push_data;
  gboolean push_section;

  /* Whether the parent bin is streams-aware, meaning we can
   * add/remove streams at any point in time */
  gboolean streams_aware;
};
</STRUCT>
<STRUCT>
<NAME>MpegTSBaseClass</NAME>
struct _MpegTSBaseClass {
  GstElementClass parent_class;

  /* Virtual methods */
  void (*reset) (MpegTSBase *base);
  GstFlowReturn (*push) (MpegTSBase *base, MpegTSPacketizerPacket *packet, GstMpegtsSection * section);
  void (*inspect_packet) (MpegTSBase *base, MpegTSPacketizerPacket *packet);
  /* takes ownership of @event */
  gboolean (*push_event) (MpegTSBase *base, GstEvent * event);

  /* program_started gets called when program's pmt arrives for first time */
  void (*program_started) (MpegTSBase *base, MpegTSBaseProgram *program);
  /* program_stopped gets called when pat no longer has program's pmt */
  void (*program_stopped) (MpegTSBase *base, MpegTSBaseProgram *program);
  void (*update_program) (MpegTSBase *base, MpegTSBaseProgram *program);
  /* Whether mpegtbase can deactivate/free a program or whether the subclass will do it
   * If the subclass responds TRUE, it should call mpegts_base_deactivate_and_free_program()
   * when it wants to remove it */
  gboolean (*can_remove_program) (MpegTSBase *base, MpegTSBaseProgram *program);

  /* stream_added is called whenever a new stream has been identified */
  gboolean (*stream_added) (MpegTSBase *base, MpegTSBaseStream *stream, MpegTSBaseProgram *program);
  /* stream_removed is called whenever a stream is no longer referenced */
  void (*stream_removed) (MpegTSBase *base, MpegTSBaseStream *stream);

  /* find_timestamps is called to find PCR */
  GstFlowReturn (*find_timestamps) (MpegTSBase * base, guint64 initoff, guint64 *offset);

  /* seek is called to wait for seeking */
  GstFlowReturn (*seek) (MpegTSBase * base, GstEvent * event);

  /* Drain all currently pending data */
  GstFlowReturn (*drain) (MpegTSBase * base);

  /* flush all streams
   * The hard inicator is used to flush completelly on FLUSH_STOP events
   * or partially in pull mode seeks of tsdemux */
  void (*flush) (MpegTSBase * base, gboolean hard);

  /* Notifies subclasses input buffer has been handled */
  GstFlowReturn (*input_done) (MpegTSBase *base, GstBuffer *buffer);

  /* signals */
  void (*pat_info) (GstStructure *pat);
  void (*pmt_info) (GstStructure *pmt);
  void (*nit_info) (GstStructure *nit);
  void (*sdt_info) (GstStructure *sdt);
  void (*eit_info) (GstStructure *eit);
};
</STRUCT>
<MACRO>
<NAME>MPEGTS_BIT_SET</NAME>
#define MPEGTS_BIT_SET(field, offs)    ((field)[(offs) >> 3] |=  (1 << ((offs) & 0x7)))
</MACRO>
<MACRO>
<NAME>MPEGTS_BIT_UNSET</NAME>
#define MPEGTS_BIT_UNSET(field, offs)  ((field)[(offs) >> 3] &= ~(1 << ((offs) & 0x7)))
</MACRO>
<MACRO>
<NAME>MPEGTS_BIT_IS_SET</NAME>
#define MPEGTS_BIT_IS_SET(field, offs) ((field)[(offs) >> 3] &   (1 << ((offs) & 0x7)))
</MACRO>
<MACRO>
<NAME>SAFE_FOURCC_FORMAT</NAME>
#define SAFE_FOURCC_FORMAT "02x%02x%02x%02x (%c%c%c%c)"
</MACRO>
<MACRO>
<NAME>SAFE_CHAR</NAME>
#define SAFE_CHAR(a) (g_ascii_isalnum((gchar) (a)) ? ((gchar)(a)) : '.')
</MACRO>
<MACRO>
<NAME>SAFE_FOURCC_ARGS</NAME>
#define SAFE_FOURCC_ARGS(a)				\
  ((guint8) ((a)>>24)),					\
    ((guint8) ((a) >> 16 & 0xff)),			\
    ((guint8) ((a) >> 8 & 0xff)),			\
    ((guint8) ((a) & 0xff)),				\
    SAFE_CHAR((a)>>24),					\
    SAFE_CHAR((a) >> 16 & 0xff),			\
    SAFE_CHAR((a) >> 8 & 0xff),				\
    SAFE_CHAR(a & 0xff)
</MACRO>
<MACRO>
<NAME>ST_VIDEO_DIRAC</NAME>
#define ST_VIDEO_DIRAC                  0xd1
</MACRO>
<MACRO>
<NAME>ST_PS_VIDEO_MPEG2_DCII</NAME>
#define ST_PS_VIDEO_MPEG2_DCII          0x80
</MACRO>
<MACRO>
<NAME>ST_PS_AUDIO_AC3</NAME>
#define ST_PS_AUDIO_AC3                 0x81
</MACRO>
<MACRO>
<NAME>ST_PS_AUDIO_EAC3</NAME>
#define ST_PS_AUDIO_EAC3                0x87
</MACRO>
<MACRO>
<NAME>ST_PS_AUDIO_LPCM2</NAME>
#define ST_PS_AUDIO_LPCM2               0x83
</MACRO>
<MACRO>
<NAME>ST_PS_AUDIO_DTS</NAME>
#define ST_PS_AUDIO_DTS                 0x8a
</MACRO>
<MACRO>
<NAME>ST_PS_AUDIO_LPCM</NAME>
#define ST_PS_AUDIO_LPCM                0x8b
</MACRO>
<MACRO>
<NAME>ST_PS_DVD_SUBPICTURE</NAME>
#define ST_PS_DVD_SUBPICTURE            0xff
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_LPCM</NAME>
#define ST_BD_AUDIO_LPCM                0x80
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_AC3</NAME>
#define ST_BD_AUDIO_AC3                 0x81
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_DTS</NAME>
#define ST_BD_AUDIO_DTS                 0x82
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_AC3_TRUE_HD</NAME>
#define ST_BD_AUDIO_AC3_TRUE_HD         0x83
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_AC3_PLUS</NAME>
#define ST_BD_AUDIO_AC3_PLUS            0x84
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_DTS_HD</NAME>
#define ST_BD_AUDIO_DTS_HD              0x85
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_DTS_HD_MASTER_AUDIO</NAME>
#define ST_BD_AUDIO_DTS_HD_MASTER_AUDIO 0x86
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_EAC3</NAME>
#define ST_BD_AUDIO_EAC3                0x87
</MACRO>
<MACRO>
<NAME>ST_BD_PGS_SUBPICTURE</NAME>
#define ST_BD_PGS_SUBPICTURE            0x90
</MACRO>
<MACRO>
<NAME>ST_BD_IGS</NAME>
#define ST_BD_IGS                       0x91
</MACRO>
<MACRO>
<NAME>ST_BD_SUBTITLE</NAME>
#define ST_BD_SUBTITLE                  0x92
</MACRO>
<MACRO>
<NAME>ST_BD_SECONDARY_AC3_PLUS</NAME>
#define ST_BD_SECONDARY_AC3_PLUS        0xa1
</MACRO>
<MACRO>
<NAME>ST_BD_SECONDARY_DTS_HD</NAME>
#define ST_BD_SECONDARY_DTS_HD          0xa2
</MACRO>
<MACRO>
<NAME>ST_PRIVATE_EA</NAME>
#define ST_PRIVATE_EA                   0xea
</MACRO>
<MACRO>
<NAME>ST_HDV_AUX_A</NAME>
#define ST_HDV_AUX_A                    0xa0
</MACRO>
<MACRO>
<NAME>ST_HDV_AUX_V</NAME>
#define ST_HDV_AUX_V                    0xa1
</MACRO>
<MACRO>
<NAME>CLOCK_BASE</NAME>
#define CLOCK_BASE 9LL
</MACRO>
<MACRO>
<NAME>CLOCK_FREQ</NAME>
#define CLOCK_FREQ (CLOCK_BASE * 10000)
</MACRO>
<MACRO>
<NAME>PCR_SECOND</NAME>
#define PCR_SECOND 27000000
</MACRO>
<MACRO>
<NAME>PCR_MSECOND</NAME>
#define PCR_MSECOND 27000
</MACRO>
<MACRO>
<NAME>PCRTIME_TO_GSTTIME</NAME>
#define PCRTIME_TO_GSTTIME(t) (((t) * (guint64)1000) / 27)
</MACRO>
<MACRO>
<NAME>MPEGTIME_TO_GSTTIME</NAME>
#define MPEGTIME_TO_GSTTIME(t) ((t) * (guint64)100000 / 9)
</MACRO>
<MACRO>
<NAME>GSTTIME_TO_MPEGTIME</NAME>
#define GSTTIME_TO_MPEGTIME(time) (gst_util_uint64_scale ((time), \
            CLOCK_BASE, GST_MSECOND/10))
</MACRO>
<MACRO>
<NAME>GSTTIME_TO_PCRTIME</NAME>
#define GSTTIME_TO_PCRTIME(time) (gst_util_uint64_scale ((time), \
            300 * CLOCK_BASE, GST_MSECOND/10))
</MACRO>
<MACRO>
<NAME>MPEG_MUX_RATE_MULT</NAME>
#define MPEG_MUX_RATE_MULT      50
</MACRO>
<MACRO>
<NAME>READ_TS</NAME>
#define READ_TS(data, target, lost_sync_label)          \
    if ((*data & 0x01) != 0x01) goto lost_sync_label;   \
    target  = ((guint64) (*data++ & 0x0E)) << 29;       \
    target |= ((guint64) (*data++       )) << 22;       \
    if ((*data & 0x01) != 0x01) goto lost_sync_label;   \
    target |= ((guint64) (*data++ & 0xFE)) << 14;       \
    target |= ((guint64) (*data++       )) << 7;        \
    if ((*data & 0x01) != 0x01) goto lost_sync_label;   \
    target |= ((guint64) (*data++ & 0xFE)) >> 1;
</MACRO>
<MACRO>
<NAME>MPEGTS_NORMAL_PACKETSIZE</NAME>
#define MPEGTS_NORMAL_PACKETSIZE  188
</MACRO>
<MACRO>
<NAME>MPEGTS_M2TS_PACKETSIZE</NAME>
#define MPEGTS_M2TS_PACKETSIZE    192
</MACRO>
<MACRO>
<NAME>MPEGTS_DVB_ASI_PACKETSIZE</NAME>
#define MPEGTS_DVB_ASI_PACKETSIZE 204
</MACRO>
<MACRO>
<NAME>MPEGTS_ATSC_PACKETSIZE</NAME>
#define MPEGTS_ATSC_PACKETSIZE    208
</MACRO>
<MACRO>
<NAME>MPEGTS_MIN_PACKETSIZE</NAME>
#define MPEGTS_MIN_PACKETSIZE MPEGTS_NORMAL_PACKETSIZE
</MACRO>
<MACRO>
<NAME>MPEGTS_MAX_PACKETSIZE</NAME>
#define MPEGTS_MAX_PACKETSIZE MPEGTS_ATSC_PACKETSIZE
</MACRO>
<MACRO>
<NAME>MPEGTS_AFC_DISCONTINUITY_FLAG</NAME>
#define MPEGTS_AFC_DISCONTINUITY_FLAG           0x80
</MACRO>
<MACRO>
<NAME>MPEGTS_AFC_RANDOM_ACCES_FLAGS</NAME>
#define MPEGTS_AFC_RANDOM_ACCES_FLAGS           0x40
</MACRO>
<MACRO>
<NAME>MPEGTS_AFC_ELEMENTARY_STREAM_PRIORITY</NAME>
#define MPEGTS_AFC_ELEMENTARY_STREAM_PRIORITY   0x20
</MACRO>
<MACRO>
<NAME>MPEGTS_AFC_PCR_FLAG</NAME>
#define MPEGTS_AFC_PCR_FLAG                     0x10
</MACRO>
<MACRO>
<NAME>MPEGTS_AFC_OPCR_FLAG</NAME>
#define MPEGTS_AFC_OPCR_FLAG                    0x08
</MACRO>
<MACRO>
<NAME>MPEGTS_AFC_SPLICING_POINT_FLAG</NAME>
#define MPEGTS_AFC_SPLICING_POINT_FLAG          0x04
</MACRO>
<MACRO>
<NAME>MPEGTS_AFC_TRANSPORT_PRIVATE_DATA_FLAG</NAME>
#define MPEGTS_AFC_TRANSPORT_PRIVATE_DATA_FLAG  0x02
</MACRO>
<MACRO>
<NAME>MPEGTS_AFC_EXTENSION_FLAG</NAME>
#define MPEGTS_AFC_EXTENSION_FLAG               0x01
</MACRO>
<MACRO>
<NAME>MAX_WINDOW</NAME>
#define MAX_WINDOW 512
</MACRO>
<MACRO>
<NAME>GST_TYPE_MPEGTS_PACKETIZER</NAME>
#define GST_TYPE_MPEGTS_PACKETIZER \
  (mpegts_packetizer_get_type())
</MACRO>
<MACRO>
<NAME>GST_MPEGTS_PACKETIZER</NAME>
#define GST_MPEGTS_PACKETIZER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MPEGTS_PACKETIZER,MpegTSPacketizer2))
</MACRO>
<MACRO>
<NAME>GST_MPEGTS_PACKETIZER_CLASS</NAME>
#define GST_MPEGTS_PACKETIZER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MPEGTS_PACKETIZER,MpegTSPacketizer2Class))
</MACRO>
<MACRO>
<NAME>GST_IS_MPEGTS_PACKETIZER</NAME>
#define GST_IS_MPEGTS_PACKETIZER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MPEGTS_PACKETIZER))
</MACRO>
<MACRO>
<NAME>GST_IS_MPEGTS_PACKETIZER_CLASS</NAME>
#define GST_IS_MPEGTS_PACKETIZER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MPEGTS_PACKETIZER))
</MACRO>
<MACRO>
<NAME>MAX_PCR_OBS_CHANNELS</NAME>
#define MAX_PCR_OBS_CHANNELS 256
</MACRO>
<MACRO>
<NAME>DEFAULT_ALLOCATED_OFFSET</NAME>
#define DEFAULT_ALLOCATED_OFFSET 16
</MACRO>
<MACRO>
<NAME>PCR_BITRATE_NEEDED</NAME>
#define PCR_BITRATE_NEEDED 10
</MACRO>
<STRUCT>
<NAME>MpegTSPacketizer2</NAME>
struct _MpegTSPacketizer2 {
  GObject     parent;

  GMutex group_lock;

  GstAdapter *adapter;
  /* streams hashed by pid */
  /* FIXME : be more memory efficient (see how it's done in mpegtsbase) */
  MpegTSPacketizerStream **streams;
  gboolean    disposed;
  guint16     packet_size;

  /* current offset of the tip of the adapter */
  guint64  offset;
  gboolean empty;

  /* clock skew calculation */
  gboolean       calculate_skew;

  /* offset/bitrate calculator */
  gboolean       calculate_offset;

  /* Shortcuts for adapter usage */
  guint8 *map_data;
  gsize map_offset;
  gsize map_size;
  gboolean need_sync;

  /* Reference offset */
  guint64 refoffset;

  /* Number of seen pcr/offset observations (FIXME : kill later) */
  guint nb_seen_offsets;

  /* Last inputted timestamp */
  GstClockTime last_in_time;

  /* offset to observations table */
  guint8 pcrtablelut[0x2000];
  MpegTSPCR *observations[MAX_PCR_OBS_CHANNELS];
  guint8 lastobsid;
  GstClockTime pcr_discont_threshold;
};
</STRUCT>
<STRUCT>
<NAME>MpegTSPacketizer2Class</NAME>
struct _MpegTSPacketizer2Class {
  GObjectClass object_class;
};
</STRUCT>
<MACRO>
<NAME>FLAGS_SCRAMBLED</NAME>
#define FLAGS_SCRAMBLED(f) (f & 0xc0)
</MACRO>
<MACRO>
<NAME>FLAGS_HAS_AFC</NAME>
#define FLAGS_HAS_AFC(f) (f & 0x20)
</MACRO>
<MACRO>
<NAME>FLAGS_HAS_PAYLOAD</NAME>
#define FLAGS_HAS_PAYLOAD(f) (f & 0x10)
</MACRO>
<MACRO>
<NAME>FLAGS_CONTINUITY_COUNTER</NAME>
#define FLAGS_CONTINUITY_COUNTER(f) (f & 0x0f)
</MACRO>
<MACRO>
<NAME>MPEGTS_BIT_SET</NAME>
#define MPEGTS_BIT_SET(field, offs)    ((field)[(offs) >> 3] |=  (1 << ((offs) & 0x7)))
</MACRO>
<MACRO>
<NAME>MPEGTS_BIT_UNSET</NAME>
#define MPEGTS_BIT_UNSET(field, offs)  ((field)[(offs) >> 3] &= ~(1 << ((offs) & 0x7)))
</MACRO>
<MACRO>
<NAME>MPEGTS_BIT_IS_SET</NAME>
#define MPEGTS_BIT_IS_SET(field, offs) ((field)[(offs) >> 3] &   (1 << ((offs) & 0x7)))
</MACRO>
<ENUM>
<NAME>MpegTSPacketizerPacketReturn</NAME>
typedef enum {
  PACKET_BAD       = FALSE,
  PACKET_OK        = TRUE,
  PACKET_NEED_MORE
} MpegTSPacketizerPacketReturn;
</ENUM>
<MACRO>
<NAME>DESC_TAG</NAME>
#define DESC_TAG(desc) 		(desc[0])
</MACRO>
<MACRO>
<NAME>DESC_LENGTH</NAME>
#define DESC_LENGTH(desc) 	(desc[1])
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_multiple_framerate_flag</NAME>
#define DESC_VIDEO_STREAM_multiple_framerate_flag(desc) 	(((desc)[2] & 0x80) == 0x80)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_frame_rate_code</NAME>
#define DESC_VIDEO_STREAM_frame_rate_code(desc) 		(((desc)[2] & 0x38) >> 3)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_MPEG_1_only_flag</NAME>
#define DESC_VIDEO_STREAM_MPEG_1_only_flag(desc) 		(((desc)[2] & 0x04) == 0x04)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_constrained_parameter_flag</NAME>
#define DESC_VIDEO_STREAM_constrained_parameter_flag(desc) 	(((desc)[2] & 0x02) == 0x02)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_still_picture_flag</NAME>
#define DESC_VIDEO_STREAM_still_picture_flag(desc) 	 	(((desc)[2] & 0x01) == 0x01)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_profile_and_level_indication</NAME>
#define DESC_VIDEO_STREAM_profile_and_level_indication(desc)	((desc)[3])
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_chroma_format</NAME>
#define DESC_VIDEO_STREAM_chroma_format(desc)			(((desc)[4] & 0xc0) >> 6)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_frame_rate_extension_flag</NAME>
#define DESC_VIDEO_STREAM_frame_rate_extension_flag(desc)	(((desc)[4] & 0x20) == 0x20)
</MACRO>
<MACRO>
<NAME>DESC_AUDIO_STREAM_free_format_flag</NAME>
#define DESC_AUDIO_STREAM_free_format_flag(desc) 		(((desc)[2] & 0x80) == 0x80)
</MACRO>
<MACRO>
<NAME>DESC_AUDIO_STREAM_ID</NAME>
#define DESC_AUDIO_STREAM_ID(desc) 				(((desc)[2] & 0x40) == 0x40)
</MACRO>
<MACRO>
<NAME>DESC_AUDIO_STREAM_layer</NAME>
#define DESC_AUDIO_STREAM_layer(desc) 				(((desc)[2] & 0x30) >> 4)
</MACRO>
<MACRO>
<NAME>DESC_AUDIO_STREAM_variable_rate_audio_indicator</NAME>
#define DESC_AUDIO_STREAM_variable_rate_audio_indicator(desc) 	(((desc)[2] & 0x08) == 0x08)
</MACRO>
<MACRO>
<NAME>DESC_HIERARCHY_hierarchy_type</NAME>
#define DESC_HIERARCHY_hierarchy_type(desc)			(((desc)[2] & 0x0f))
</MACRO>
<MACRO>
<NAME>DESC_HIERARCHY_hierarchy_layer_index</NAME>
#define DESC_HIERARCHY_hierarchy_layer_index(desc)		(((desc)[3] & 0x3f))
</MACRO>
<MACRO>
<NAME>DESC_HIERARCHY_hierarchy_embedded_layer_index</NAME>
#define DESC_HIERARCHY_hierarchy_embedded_layer_index(desc)	(((desc)[4] & 0x3f))
</MACRO>
<MACRO>
<NAME>DESC_HIERARCHY_hierarchy_channel</NAME>
#define DESC_HIERARCHY_hierarchy_channel(desc)			(((desc)[5] & 0x3f))
</MACRO>
<MACRO>
<NAME>DESC_REGISTRATION_format_identifier</NAME>
#define DESC_REGISTRATION_format_identifier(desc)		(GST_READ_UINT32_BE ((desc)+2))
</MACRO>
<MACRO>
<NAME>DESC_REGISTRATION_additional_ident_info_len</NAME>
#define DESC_REGISTRATION_additional_ident_info_len(desc)	((desc)[1] - 4)
</MACRO>
<MACRO>
<NAME>DESC_REGISTRATION_additional_ident_info</NAME>
#define DESC_REGISTRATION_additional_ident_info(desc)		(&(desc)[6])
</MACRO>
<MACRO>
<NAME>DESC_DATA_STREAM_ALIGNMENT_alignment_type</NAME>
#define DESC_DATA_STREAM_ALIGNMENT_alignment_type(desc)		((desc)[2])
</MACRO>
<MACRO>
<NAME>DESC_TARGET_BACKGROUND_GRID_horizontal_size</NAME>
#define DESC_TARGET_BACKGROUND_GRID_horizontal_size(desc)	(GST_READ_UINT16_BE ((desc)+2) >> 2)
</MACRO>
<MACRO>
<NAME>DESC_TARGET_BACKGROUND_GRID_vertical_size</NAME>
#define DESC_TARGET_BACKGROUND_GRID_vertical_size(desc)		((GST_READ_UINT32_BE ((desc)+2) & 0x0003fff0) >> 4)
</MACRO>
<MACRO>
<NAME>DESC_TARGET_BACKGROUND_GRID_aspect_ratio_information</NAME>
#define DESC_TARGET_BACKGROUND_GRID_aspect_ratio_information(desc) ((desc)[5] & 0x0f)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_WINDOW_horizontal_offset</NAME>
#define DESC_VIDEO_WINDOW_horizontal_offset(desc)		(GST_READ_UINT16_BE ((desc)+2) >> 2)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_WINDOW_vertical_offset</NAME>
#define DESC_VIDEO_WINDOW_vertical_offset(desc)			((GST_READ_UINT32_BE ((desc)+2) & 0x0003fff0) >> 4)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_WINDOW_window_priority</NAME>
#define DESC_VIDEO_WINDOW_window_priority(desc)	 		((desc)[5] & 0x0f)
</MACRO>
<MACRO>
<NAME>DESC_CA_system_ID</NAME>
#define DESC_CA_system_ID(desc)					(GST_READ_UINT16_BE ((desc)+2))
</MACRO>
<MACRO>
<NAME>DESC_CA_PID</NAME>
#define DESC_CA_PID(desc)					(GST_READ_UINT16_BE ((desc)+2) & 0x1fff)
</MACRO>
<MACRO>
<NAME>DESC_ISO_639_LANGUAGE_codes_n</NAME>
#define DESC_ISO_639_LANGUAGE_codes_n(desc)			((desc[1]) >> 2)
</MACRO>
<MACRO>
<NAME>DESC_ISO_639_LANGUAGE_language_code_nth</NAME>
#define DESC_ISO_639_LANGUAGE_language_code_nth(desc,i)		(&(desc[2 + (4*i)]))
</MACRO>
<MACRO>
<NAME>DESC_ISO_639_LANGUAGE_audio_type_nth</NAME>
#define DESC_ISO_639_LANGUAGE_audio_type_nth(desc,i)		((desc)[5 + (4*i)])
</MACRO>
<MACRO>
<NAME>DESC_SYSTEM_CLOCK_external_clock_reference_indicator</NAME>
#define DESC_SYSTEM_CLOCK_external_clock_reference_indicator(desc) (((desc)[2] & 0x80) == 0x80)
</MACRO>
<MACRO>
<NAME>DESC_SYSTEM_CLOCK_clock_accuracy_integer</NAME>
#define DESC_SYSTEM_CLOCK_clock_accuracy_integer(desc)		((desc)[2] & 0x3f)
</MACRO>
<MACRO>
<NAME>DESC_SYSTEM_CLOCK_clock_accuracy_exponent</NAME>
#define DESC_SYSTEM_CLOCK_clock_accuracy_exponent(desc)		(((desc)[3] & 0xe0) >> 5)
</MACRO>
<MACRO>
<NAME>DESC_MULTIPLEX_BUFFER_UTILISATION_bound_valid_flag</NAME>
#define DESC_MULTIPLEX_BUFFER_UTILISATION_bound_valid_flag(desc)	(((desc)[2] & 0x80) == 0x80)
</MACRO>
<MACRO>
<NAME>DESC_MULTIPLEX_BUFFER_UTILISATION_LTW_offset_lower_bound</NAME>
#define DESC_MULTIPLEX_BUFFER_UTILISATION_LTW_offset_lower_bound(desc)	(GST_READ_UINT16_BE ((desc)+2) & 0x7fff)
</MACRO>
<MACRO>
<NAME>DESC_MULTIPLEX_BUFFER_UTILISATION_LTW_offset_upper_bound</NAME>
#define DESC_MULTIPLEX_BUFFER_UTILISATION_LTW_offset_upper_bound(desc)	(GST_READ_UINT16_BE ((desc)+4) & 0x7fff)
</MACRO>
<MACRO>
<NAME>DESC_COPYRIGHT_copyright_identifier</NAME>
#define DESC_COPYRIGHT_copyright_identifier(desc)		(GST_READ_UINT32_BE ((desc)+2))
</MACRO>
<MACRO>
<NAME>DESC_COPYRIGHT_additional_copyright_info_len</NAME>
#define DESC_COPYRIGHT_additional_copyright_info_len(desc)	((desc)[1] - 4)
</MACRO>
<MACRO>
<NAME>DESC_COPYRIGHT_additional_copyright_info</NAME>
#define DESC_COPYRIGHT_additional_copyright_info(desc)		(&(desc)[6])
</MACRO>
<MACRO>
<NAME>DESC_MAXIMUM_BITRAT_maximum_bitrate</NAME>
#define DESC_MAXIMUM_BITRAT_maximum_bitrate(desc)		(((((guint32)desc[2]) & 0x3f) << 16) | \
								 GST_READ_UINT16_BE ((desc)+3))
</MACRO>
<MACRO>
<NAME>DESC_PRIVATE_DATA_INDICATOR_indicator</NAME>
#define DESC_PRIVATE_DATA_INDICATOR_indicator(desc)		(GST_READ_UINT32_BE(&desc[2]))
</MACRO>
<MACRO>
<NAME>DESC_SMOOTHING_BUFFER_sb_leak_rate</NAME>
#define DESC_SMOOTHING_BUFFER_sb_leak_rate(desc)		(((((guint32)desc[2]) & 0x3f) << 16) | \
                                                                 GST_READ_UINT16_BE ((desc)+3))
</MACRO>
<MACRO>
<NAME>DESC_SMOOTHING_BUFFER_sb_size</NAME>
#define DESC_SMOOTHING_BUFFER_sb_size(desc)			(((((guint32)desc[5]) & 0x3f) << 16) | \
                                                                 GST_READ_UINT16_BE ((desc)+6))
</MACRO>
<MACRO>
<NAME>DESC_STD_leak_valid_flag</NAME>
#define DESC_STD_leak_valid_flag(desc)				(((desc)[2] & 0x01) == 0x01)
</MACRO>
<MACRO>
<NAME>DESC_IBP_closed_gop_flag</NAME>
#define DESC_IBP_closed_gop_flag(desc)				(((desc)[2] & 0x80) == 0x80)
</MACRO>
<MACRO>
<NAME>DESC_IBP_identical_gop_flag</NAME>
#define DESC_IBP_identical_gop_flag(desc)			(((desc)[2] & 0x40) == 0x40)
</MACRO>
<MACRO>
<NAME>DESC_IBP_max_gop_length</NAME>
#define DESC_IBP_max_gop_length(desc)				(GST_READ_UINT16_BE ((desc)+6) & 0x3fff)
</MACRO>
<MACRO>
<NAME>DESC_TIMECODE_video_pid</NAME>
#define DESC_TIMECODE_video_pid(desc)                           (GST_READ_UINT16_BE ((desc) + 2) & 0x1fff)
</MACRO>
<MACRO>
<NAME>DESC_DVB_STREAM_IDENTIFIER_component_tag</NAME>
#define DESC_DVB_STREAM_IDENTIFIER_component_tag(desc)  (desc[2])
</MACRO>
<MACRO>
<NAME>DESC_DVB_NETWORK_NAME_length</NAME>
#define DESC_DVB_NETWORK_NAME_length(desc)  (GST_READ_UINT8((desc)+1))
</MACRO>
<MACRO>
<NAME>DESC_DVB_NETWORK_NAME_text</NAME>
#define DESC_DVB_NETWORK_NAME_text(desc)    (desc+2)
</MACRO>
<MACRO>
<NAME>DESC_DVB_SERVICE_type</NAME>
#define DESC_DVB_SERVICE_type(desc) (desc[2])
</MACRO>
<MACRO>
<NAME>DESC_DVB_SERVICE_provider_name_length</NAME>
#define DESC_DVB_SERVICE_provider_name_length(desc) (desc[3])
</MACRO>
<MACRO>
<NAME>DESC_DVB_SERVICE_provider_name_text</NAME>
#define DESC_DVB_SERVICE_provider_name_text(desc)   (desc+4)
</MACRO>
<MACRO>
<NAME>DESC_DVB_SERVICE_name_length</NAME>
#define DESC_DVB_SERVICE_name_length(desc)  (desc[4 + DESC_DVB_SERVICE_provider_name_length(desc)])
</MACRO>
<MACRO>
<NAME>DESC_DVB_SERVICE_name_text</NAME>
#define DESC_DVB_SERVICE_name_text(desc)    (desc + 5 + DESC_DVB_SERVICE_provider_name_length(desc))
</MACRO>
<MACRO>
<NAME>DESC_DVB_COMPONENT_stream_content</NAME>
#define DESC_DVB_COMPONENT_stream_content(desc) (desc[2] & 0x0F)
</MACRO>
<MACRO>
<NAME>DESC_DVB_COMPONENT_type</NAME>
#define DESC_DVB_COMPONENT_type(desc)   (desc[3])
</MACRO>
<MACRO>
<NAME>DESC_DVB_COMPONENT_tag</NAME>
#define DESC_DVB_COMPONENT_tag(desc)    (desc[4])
</MACRO>
<MACRO>
<NAME>DESC_DVB_COMPONENT_language</NAME>
#define DESC_DVB_COMPONENT_language(desc)   (desc + 5)
</MACRO>
<MACRO>
<NAME>DESC_DVB_BOUQUET_NAME_text</NAME>
#define DESC_DVB_BOUQUET_NAME_text(desc)    (desc + 2)
</MACRO>
<MACRO>
<NAME>DESC_DVB_SHORT_EVENT_name_text</NAME>
#define DESC_DVB_SHORT_EVENT_name_text(desc)	(desc + 6)
</MACRO>
<MACRO>
<NAME>DESC_DVB_SHORT_EVENT_name_length</NAME>
#define DESC_DVB_SHORT_EVENT_name_length(desc)	(desc[5])
</MACRO>
<MACRO>
<NAME>DESC_DVB_SHORT_EVENT_description_text</NAME>
#define DESC_DVB_SHORT_EVENT_description_text(desc) (desc + 6 + DESC_DVB_SHORT_EVENT_name_length(desc) + 1)
</MACRO>
<MACRO>
<NAME>DESC_DVB_SHORT_EVENT_description_length</NAME>
#define DESC_DVB_SHORT_EVENT_description_length(desc)	(desc[6 + DESC_DVB_SHORT_EVENT_name_length(desc)])
</MACRO>
<MACRO>
<NAME>DESC_DVB_EXTENDED_EVENT_descriptor_number</NAME>
#define DESC_DVB_EXTENDED_EVENT_descriptor_number(desc) ((desc[2] & 0xF0) >> 4)
</MACRO>
<MACRO>
<NAME>DESC_DVB_EXTENDED_EVENT_last_descriptor_number</NAME>
#define DESC_DVB_EXTENDED_EVENT_last_descriptor_number(desc) (desc[2] & 0x0F)
</MACRO>
<MACRO>
<NAME>DESC_DVB_EXTENDED_EVENT_iso639_language_code</NAME>
#define DESC_DVB_EXTENDED_EVENT_iso639_language_code(desc) (desc + 3)
</MACRO>
<MACRO>
<NAME>DESC_DVB_EXTENDED_EVENT_items_length</NAME>
#define DESC_DVB_EXTENDED_EVENT_items_length(desc) (desc[6])
</MACRO>
<MACRO>
<NAME>DESC_DVB_EXTENDED_EVENT_items</NAME>
#define DESC_DVB_EXTENDED_EVENT_items(desc) (desc + 7)
</MACRO>
<MACRO>
<NAME>DESC_DVB_EXTENDED_EVENT_text_length</NAME>
#define DESC_DVB_EXTENDED_EVENT_text_length(desc) (desc[7 + DESC_DVB_EXTENDED_EVENT_items_length(desc)])
</MACRO>
<MACRO>
<NAME>DESC_DVB_EXTENDED_EVENT_text</NAME>
#define DESC_DVB_EXTENDED_EVENT_text(desc) (desc + 7 + DESC_DVB_EXTENDED_EVENT_items_length(desc) + 1)
</MACRO>
<MACRO>
<NAME>DESC_DVB_SATELLITE_DELIVERY_SYSTEM_frequency</NAME>
#define DESC_DVB_SATELLITE_DELIVERY_SYSTEM_frequency(desc)	(desc + 2)
</MACRO>
<MACRO>
<NAME>DESC_DVB_SATELLITE_DELIVERY_SYSTEM_orbital_position</NAME>
#define DESC_DVB_SATELLITE_DELIVERY_SYSTEM_orbital_position(desc)	(desc + 6)
</MACRO>
<MACRO>
<NAME>DESC_DVB_SATELLITE_DELIVERY_SYSTEM_west_east_flag</NAME>
#define DESC_DVB_SATELLITE_DELIVERY_SYSTEM_west_east_flag(desc)	((desc[8] & 0x80) == 0x80)
</MACRO>
<MACRO>
<NAME>DESC_DVB_SATELLITE_DELIVERY_SYSTEM_polarization</NAME>
#define DESC_DVB_SATELLITE_DELIVERY_SYSTEM_polarization(desc)	((desc[8] >> 5) & 0x3)
</MACRO>
<MACRO>
<NAME>DESC_DVB_SATELLITE_DELIVERY_SYSTEM_modulation</NAME>
#define DESC_DVB_SATELLITE_DELIVERY_SYSTEM_modulation(desc)	(desc[8] & 0x3)
</MACRO>
<MACRO>
<NAME>DESC_DVB_SATELLITE_DELIVERY_SYSTEM_symbol_rate</NAME>
#define DESC_DVB_SATELLITE_DELIVERY_SYSTEM_symbol_rate(desc)	(desc + 9)
</MACRO>
<MACRO>
<NAME>DESC_DVB_SATELLITE_DELIVERY_SYSTEM_fec_inner</NAME>
#define DESC_DVB_SATELLITE_DELIVERY_SYSTEM_fec_inner(desc)	(desc[12] & 0x0F)
</MACRO>
<MACRO>
<NAME>DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_frequency</NAME>
#define DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_frequency(desc)	(GST_READ_UINT32_BE((desc) + 2))
</MACRO>
<MACRO>
<NAME>DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_bandwidth</NAME>
#define DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_bandwidth(desc)	((desc[6] >> 5) & 0x7)
</MACRO>
<MACRO>
<NAME>DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_constellation</NAME>
#define DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_constellation(desc)	((desc[7] >> 6) & 0x3)
</MACRO>
<MACRO>
<NAME>DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_hierarchy</NAME>
#define DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_hierarchy(desc)	((desc[7] >> 3) & 0x7)
</MACRO>
<MACRO>
<NAME>DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_code_rate_hp</NAME>
#define DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_code_rate_hp(desc)	(desc[7] & 0x7)
</MACRO>
<MACRO>
<NAME>DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_code_rate_lp</NAME>
#define DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_code_rate_lp(desc)	((desc[8] >> 5) & 0x7)
</MACRO>
<MACRO>
<NAME>DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_guard_interval</NAME>
#define DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_guard_interval(desc)	((desc[8] >> 3) & 0x3)
</MACRO>
<MACRO>
<NAME>DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_transmission_mode</NAME>
#define DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_transmission_mode(desc)	((desc[8] >> 1) & 0x3)
</MACRO>
<MACRO>
<NAME>DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_other_frequency</NAME>
#define DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM_other_frequency(desc)	((desc[8] & 0x01) == 0x01)
</MACRO>
<MACRO>
<NAME>DESC_DVB_CABLE_DELIVERY_SYSTEM_frequency</NAME>
#define DESC_DVB_CABLE_DELIVERY_SYSTEM_frequency(desc)		(desc + 2)
</MACRO>
<MACRO>
<NAME>DESC_DVB_CABLE_DELIVERY_SYSTEM_fec_outer</NAME>
#define DESC_DVB_CABLE_DELIVERY_SYSTEM_fec_outer(desc)		(desc[7] & 0x0F)
</MACRO>
<MACRO>
<NAME>DESC_DVB_CABLE_DELIVERY_SYSTEM_modulation</NAME>
#define DESC_DVB_CABLE_DELIVERY_SYSTEM_modulation(desc)		(desc[8])
</MACRO>
<MACRO>
<NAME>DESC_DVB_CABLE_DELIVERY_SYSTEM_symbol_rate</NAME>
#define DESC_DVB_CABLE_DELIVERY_SYSTEM_symbol_rate(desc)	(desc + 9)
</MACRO>
<MACRO>
<NAME>DESC_DVB_CABLE_DELIVERY_SYSTEM_fec_inner</NAME>
#define DESC_DVB_CABLE_DELIVERY_SYSTEM_fec_inner(desc)		(desc[12] & 0x0F)
</MACRO>
<MACRO>
<NAME>DESC_DVB_DATA_BROADCAST_data_broadcast_id</NAME>
#define DESC_DVB_DATA_BROADCAST_data_broadcast_id(desc)		(GST_READ_UINT16_BE((desc) + 2))
</MACRO>
<MACRO>
<NAME>DESC_DVB_DATA_BROADCAST_component_tag</NAME>
#define DESC_DVB_DATA_BROADCAST_component_tag(desc)		(desc[4])
</MACRO>
<MACRO>
<NAME>DESC_DVB_DATA_BROADCAST_selector_length</NAME>
#define DESC_DVB_DATA_BROADCAST_selector_length(desc)		(desc[5])
</MACRO>
<MACRO>
<NAME>DESC_DVB_DATA_BROADCAST_selector</NAME>
#define DESC_DVB_DATA_BROADCAST_selector(desc)			(desc + 6)
</MACRO>
<MACRO>
<NAME>DESC_DVB_DATA_BROADCAST_iso639_language_code</NAME>
#define DESC_DVB_DATA_BROADCAST_iso639_language_code(desc)	(desc + 6 + DESC_DVB_DATA_BROADCAST_selector_length(desc))
</MACRO>
<MACRO>
<NAME>DESC_DVB_DATA_BROADCAST_text_length</NAME>
#define DESC_DVB_DATA_BROADCAST_text_length(desc)		(desc + 9 + DESC_DVB_DATA_BROADCAST_selector_length(desc))
</MACRO>
<MACRO>
<NAME>DESC_DVB_DATA_BROADCAST_text</NAME>
#define DESC_DVB_DATA_BROADCAST_text(desc)			(desc + 10 + DESC_DVB_DATA_BROADCAST_selector_length(desc))
</MACRO>
<MACRO>
<NAME>DESC_DVB_DATA_BROADCAST_ID_data_broadcast_id</NAME>
#define DESC_DVB_DATA_BROADCAST_ID_data_broadcast_id(desc)	(GST_READ_UINT16_BE((desc) + 2))
</MACRO>
<MACRO>
<NAME>DESC_DVB_DATA_BROADCAST_ID_id_selector_byte</NAME>
#define DESC_DVB_DATA_BROADCAST_ID_id_selector_byte(desc)	(desc + 4)
</MACRO>
<MACRO>
<NAME>DESC_DVB_CAROUSEL_IDENTIFIER_carousel_id</NAME>
#define DESC_DVB_CAROUSEL_IDENTIFIER_carousel_id(desc)		(GST_READ_UINT32_BE((desc) + 2))
</MACRO>
<MACRO>
<NAME>DESC_AC_AUDIO_STREAM_bsid</NAME>
#define DESC_AC_AUDIO_STREAM_bsid(desc)             ((desc)[2] & 0x1f)
</MACRO>
<MACRO>
<NAME>DRF_ID_HDMV</NAME>
#define DRF_ID_HDMV       0x48444d56
</MACRO>
<MACRO>
<NAME>DRF_ID_VC1</NAME>
#define DRF_ID_VC1        0x56432D31   /* defined in RP227 */
</MACRO>
<MACRO>
<NAME>DRF_ID_DTS1</NAME>
#define DRF_ID_DTS1       0x44545331
</MACRO>
<MACRO>
<NAME>DRF_ID_DTS2</NAME>
#define DRF_ID_DTS2       0x44545332
</MACRO>
<MACRO>
<NAME>DRF_ID_DTS3</NAME>
#define DRF_ID_DTS3       0x44545333
</MACRO>
<MACRO>
<NAME>DRF_ID_S302M</NAME>
#define DRF_ID_S302M      0x42535344
</MACRO>
<MACRO>
<NAME>DRF_ID_TSHV</NAME>
#define DRF_ID_TSHV       0x54534856
</MACRO>
<MACRO>
<NAME>DRF_ID_AC3</NAME>
#define DRF_ID_AC3        0x41432d33
</MACRO>
<MACRO>
<NAME>DRF_ID_GA94</NAME>
#define DRF_ID_GA94       0x47413934
</MACRO>
<MACRO>
<NAME>DRF_ID_CUEI</NAME>
#define DRF_ID_CUEI       0x43554549
</MACRO>
<MACRO>
<NAME>DRF_ID_ETV1</NAME>
#define DRF_ID_ETV1       0x45545631
</MACRO>
<MACRO>
<NAME>DRF_ID_HEVC</NAME>
#define DRF_ID_HEVC       0x48455643
</MACRO>
<MACRO>
<NAME>DRF_ID_KLVA</NAME>
#define DRF_ID_KLVA       0x4b4c5641   /* defined in RP217 */
</MACRO>
<MACRO>
<NAME>DRF_ID_OPUS</NAME>
#define DRF_ID_OPUS       0x4f707573
</MACRO>
<MACRO>
<NAME>DRF_ID_EAC3</NAME>
#define DRF_ID_EAC3       0x45414333   /* defined in A/52 Annex G */
</MACRO>
<MACRO>
<NAME>ID_PS_END_CODE</NAME>
#define ID_PS_END_CODE                          0xB9
</MACRO>
<MACRO>
<NAME>ID_PS_PACK_START_CODE</NAME>
#define ID_PS_PACK_START_CODE                   0xBA
</MACRO>
<MACRO>
<NAME>ID_PS_SYSTEM_HEADER_START_CODE</NAME>
#define ID_PS_SYSTEM_HEADER_START_CODE          0xBB
</MACRO>
<MACRO>
<NAME>ID_PS_PROGRAM_STREAM_MAP</NAME>
#define ID_PS_PROGRAM_STREAM_MAP                0xBC
</MACRO>
<MACRO>
<NAME>ID_PRIVATE_STREAM_1</NAME>
#define ID_PRIVATE_STREAM_1                     0xBD
</MACRO>
<MACRO>
<NAME>ID_PADDING_STREAM</NAME>
#define ID_PADDING_STREAM                       0xBE
</MACRO>
<MACRO>
<NAME>ID_PRIVATE_STREAM_2</NAME>
#define ID_PRIVATE_STREAM_2                     0xBF
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_MPEG12_AUDIO_STREAM_0</NAME>
#define ID_ISO_IEC_MPEG12_AUDIO_STREAM_0        0xC0
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_MPEG12_AUDIO_STREAM_32</NAME>
#define ID_ISO_IEC_MPEG12_AUDIO_STREAM_32       0xDF
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_MPEG12_VIDEO_STREAM_0</NAME>
#define ID_ISO_IEC_MPEG12_VIDEO_STREAM_0        0xE0
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_MPEG12_VIDEO_STREAM_16</NAME>
#define ID_ISO_IEC_MPEG12_VIDEO_STREAM_16       0xEF
</MACRO>
<MACRO>
<NAME>ID_ECM_STREAM</NAME>
#define ID_ECM_STREAM                           0xF0
</MACRO>
<MACRO>
<NAME>ID_EMM_STREAM</NAME>
#define ID_EMM_STREAM                           0xF1
</MACRO>
<MACRO>
<NAME>ID_DSMCC_STREAM</NAME>
#define ID_DSMCC_STREAM                         0xF2
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_13522_STREAM</NAME>
#define ID_ISO_IEC_13522_STREAM                 0xF3
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_A_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_A_STREAM          0xF4
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_B_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_B_STREAM          0xF5
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_C_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_C_STREAM          0xF6
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_D_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_D_STREAM          0xF7
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_E_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_E_STREAM          0xF8
</MACRO>
<MACRO>
<NAME>ID_ANCILLARY_STREAM</NAME>
#define ID_ANCILLARY_STREAM                     0xF9
</MACRO>
<MACRO>
<NAME>ID_14496_1_SL_PACKETIZED_STREAM</NAME>
#define ID_14496_1_SL_PACKETIZED_STREAM         0xFA
</MACRO>
<MACRO>
<NAME>ID_14496_1_SL_FLEXMUX_STREAM</NAME>
#define ID_14496_1_SL_FLEXMUX_STREAM            0xFB
</MACRO>
<MACRO>
<NAME>ID_METADATA_STREAM</NAME>
#define ID_METADATA_STREAM                      0xFC
</MACRO>
<MACRO>
<NAME>ID_EXTENDED_STREAM_ID</NAME>
#define ID_EXTENDED_STREAM_ID                   0xFD
</MACRO>
<MACRO>
<NAME>ID_RESERVED_STREAM_3</NAME>
#define ID_RESERVED_STREAM_3                    0xFE
</MACRO>
<MACRO>
<NAME>ID_PROGRAM_STREAM_DIRECTORY</NAME>
#define ID_PROGRAM_STREAM_DIRECTORY             0xFF
</MACRO>
<MACRO>
<NAME>EXT_ID_IPMP_CONTORL_INFORMATION_STREAM</NAME>
#define EXT_ID_IPMP_CONTORL_INFORMATION_STREAM  0x00
</MACRO>
<MACRO>
<NAME>EXT_ID_IPMP_STREAM</NAME>
#define EXT_ID_IPMP_STREAM			0x01
</MACRO>
<MACRO>
<NAME>EXT_ID_VC1_FIRST</NAME>
#define EXT_ID_VC1_FIRST			0x55
</MACRO>
<MACRO>
<NAME>EXT_ID_VC1_LAST</NAME>
#define EXT_ID_VC1_LAST 			0x5F
</MACRO>
<ENUM>
<NAME>PESHeaderFlags</NAME>
typedef enum {
  PES_FLAG_PRIORITY		= 1 << 3,	/* PES_priority (present: high-priority) */
  PES_FLAG_DATA_ALIGNMENT	= 1 << 2,	/* data_alignment_indicator */
  PES_FLAG_COPYRIGHT		= 1 << 1,	/* copyright */
  PES_FLAG_ORIGINAL_OR_COPY	= 1 << 0	/* original_or_copy */
} PESHeaderFlags;
</ENUM>
<ENUM>
<NAME>PESTrickModeControl</NAME>
typedef enum {
  PES_TRICK_MODE_FAST_FORWARD	= 0x000,
  PES_TRICK_MODE_SLOW_MOTION    = 0x001,
  PES_TRICK_MODE_FREEZE_FRAME	= 0x010,
  PES_TRICK_MODE_FAST_REVERSE	= 0x011,
  PES_TRICK_MODE_SLOW_REVERSE	= 0x100,
  /* ... */
  PES_TRICK_MODE_INVALID	= 0xfff	/* Not present or invalid */
} PESTrickModeControl;
</ENUM>
<ENUM>
<NAME>PESFieldID</NAME>
typedef enum {
  PES_FIELD_ID_TOP_ONLY		= 0x00, /* Display from top field only */
  PES_FIELD_ID_BOTTOM_ONLY	= 0x01, /* Display from bottom field only */
  PES_FIELD_ID_COMPLETE_FRAME	= 0x10, /* Display complete frame */
  PES_FIELD_ID_INVALID		= 0x11	/* Reserved/Invalid */
} PESFieldID;
</ENUM>
<ENUM>
<NAME>PESParsingResult</NAME>
typedef enum {
  PES_PARSING_OK	= 0,	/* Header fully parsed and valid */
  PES_PARSING_BAD	= 1,	/* Header invalid (CRC error for ex) */
  PES_PARSING_NEED_MORE = 2	/* Not enough data to parse header */
} PESParsingResult;
</ENUM>
<STRUCT>
<NAME>PESHeader</NAME>
typedef struct {
  guint8	stream_id;	/* See ID_* above */
  guint32	packet_length;	/* The size of the PES header and PES data
				 * (if 0 => unbounded packet) */
  guint16	header_size;	/* The complete size of the PES header */

  /* All remaining entries in this structure are optional */
  guint8	scrambling_control; /* 0x00  : Not scrambled/unspecified,
				     * The following are according to ETSI TS 101 154
				     * 0x01  : reserved for future DVB use
				     * 0x10  : PES packet scrambled with Even key
				     * 0x11  : PES packet scrambled with Odd key
				     */
  PESHeaderFlags flags;

  guint64	PTS;		/* PTS (-1 if not present or invalid) */
  guint64	DTS;		/* DTS (-1 if not present or invalid) */
  guint64	ESCR;		/* ESCR (-1 if not present or invalid) */

  guint32	ES_rate;	/* in bytes/seconds (0 if not present or invalid) */
  PESTrickModeControl	trick_mode;
  
  /* Only valid for _FAST_FORWARD, _FAST_REVERSE and _FREEZE_FRAME */
  PESFieldID	field_id;
  /* Only valid for _FAST_FORWARD and _FAST_REVERSE */
  gboolean	intra_slice_refresh;
  guint8	frequency_truncation;
  /* Only valid for _SLOW_FORWARD and _SLOW_REVERSE */
  guint8	rep_cntrl;

  guint8	additional_copy_info; /* Private data */
  guint16	previous_PES_packet_CRC;

  /* Extension fields */
  const guint8*	private_data;			/* PES_private_data, 16 bytes long */
  guint8	pack_header_size;		/* Size of pack_header in bytes */
  const guint8*	pack_header;
  gint8		program_packet_sequence_counter; /* -1 if not present or invalid */
  gboolean	MPEG1_MPEG2_identifier;
  guint8	original_stuff_length;

  guint32	P_STD_buffer_size; /* P-STD buffer size in bytes (0 if invalid
				    * or not present */

  guint8	stream_id_extension; /* Public range (0x00 - 0x3f) only valid if stream_id == ID_EXTENDED_STREAM_ID
				      * Private range (0x40 - 0xff) can be present in any stream type */

  gsize		extension_field_length;   /* Length of remaining extension field data */
  const guint8*	stream_id_extension_data; /* Valid if extension_field_length != 0 */
} PESHeader;
</STRUCT>
<MACRO>
<NAME>GST_TYPE_RTP_ASF_PAY</NAME>
#define GST_TYPE_RTP_ASF_PAY \
  (gst_rtp_asf_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_RTP_ASF_PAY</NAME>
#define GST_RTP_ASF_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_ASF_PAY,GstRtpAsfPay))
</MACRO>
<MACRO>
<NAME>GST_RTP_ASF_PAY_CLASS</NAME>
#define GST_RTP_ASF_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_ASF_PAY,GstRtpAsfPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_ASF_PAY</NAME>
#define GST_IS_RTP_ASF_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_ASF_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_RTP_ASF_PAY_CLASS</NAME>
#define GST_IS_RTP_ASF_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_ASF_PAY))
</MACRO>
<MACRO>
<NAME>GST_RTP_ASF_PAY_CAST</NAME>
#define GST_RTP_ASF_PAY_CAST(obj) ((GstRtpAsfPay*)(obj))
</MACRO>
<STRUCT>
<NAME>GstRtpAsfPay</NAME>
struct _GstRtpAsfPay
{
  GstRTPBasePayload rtppay;

  enum GstRtpAsfPayState state;

  guint32 first_ts;
  gchar *config;
  guint64 packets_count;
  GstAsfFileInfo asfinfo;

  /* current output buffer */
  GstBuffer *current;
  guint32 cur_off;
  guint32 ts;
  gboolean has_ts;
  gboolean marker;

  /* keeping it here to avoid allocs/frees */
  GstAsfPacketInfo packetinfo;

  GstBuffer *headers;
};
</STRUCT>
<STRUCT>
<NAME>GstRtpAsfPayClass</NAME>
struct _GstRtpAsfPayClass
{
  GstRTPBasePayloadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rtp_asf_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_rtp_asf_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ASF_MUX</NAME>
#define GST_TYPE_ASF_MUX \
  (gst_asf_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_ASF_MUX</NAME>
#define GST_ASF_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ASF_MUX,GstAsfMux))
</MACRO>
<MACRO>
<NAME>GST_ASF_MUX_CLASS</NAME>
#define GST_ASF_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ASF_MUX,GstAsfMuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ASF_MUX</NAME>
#define GST_IS_ASF_MUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ASF_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_ASF_MUX_CLASS</NAME>
#define GST_IS_ASF_MUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ASF_MUX))
</MACRO>
<MACRO>
<NAME>GST_ASF_MUX_CAST</NAME>
#define GST_ASF_MUX_CAST(obj) ((GstAsfMux*)(obj))
</MACRO>
<STRUCT>
<NAME>GstAsfPad</NAME>
struct _GstAsfPad
{
  GstCollectData collect;

  gboolean is_audio;
  guint8 stream_number;
  guint8 media_object_number;
  guint32 bitrate;

  GstClockTime play_duration;
  GstClockTime first_ts;

  GstBuffer *codec_data;

  /* stream only metadata */
  GstTagList *taglist;
};
</STRUCT>
<STRUCT>
<NAME>GstAsfAudioPad</NAME>
struct _GstAsfAudioPad
{
  GstAsfPad pad;

  gst_riff_strf_auds audioinfo;
};
</STRUCT>
<STRUCT>
<NAME>GstAsfVideoPad</NAME>
struct _GstAsfVideoPad
{
  GstAsfPad pad;

  gst_riff_strf_vids vidinfo;

  /* Simple Index Entries */
  GSList *simple_index;
  gboolean has_keyframe;        /* if we have received one at least */
  guint32 last_keyframe_packet;
  guint16 last_keyframe_packet_count;
  guint16 max_keyframe_packet_count;
  GstClockTime next_index_time;
  guint64 time_interval;
};
</STRUCT>
<STRUCT>
<NAME>GstAsfMux</NAME>
struct _GstAsfMux
{
  GstElement element;

  /* output stream state */
  GstAsfMuxState state;

  /* counter to assign stream numbers */
  guint8 stream_number;

  /* counting variables */
  guint64 file_size;
  guint64 data_object_size;
  guint64 total_data_packets;

  /*
   * data object size field position
   * needed for updating when finishing the file
   */
  guint64 data_object_position;
  guint64 file_properties_object_position;

  /* payloads still to be sent in a packet */
  guint32 payload_data_size;
  guint32 payload_parsing_info_size;
  GSList *payloads;

  Guid file_id;

  /* properties */
  guint32 prop_packet_size;
  guint64 prop_preroll;
  gboolean prop_merge_stream_tags;
  guint64 prop_padding;
  gboolean prop_streamable;

  /* same as properties, but those are stored here to be
   * used without modification while muxing a single file */
  guint32 packet_size;
  guint64 preroll;              /* milisecs */
  gboolean merge_stream_tags;

  GstClockTime first_ts;

  /* pads */
  GstPad *srcpad;

  GstCollectPads *collect;
};
</STRUCT>
<STRUCT>
<NAME>GstAsfMuxClass</NAME>
struct _GstAsfMuxClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_asf_mux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_mux_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ASF_PARSE</NAME>
#define GST_TYPE_ASF_PARSE \
  (gst_asf_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_ASF_PARSE</NAME>
#define GST_ASF_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ASF_PARSE,GstAsfParse))
</MACRO>
<MACRO>
<NAME>GST_ASF_PARSE_CLASS</NAME>
#define GST_ASF_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ASF_PARSE,GstAsfParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ASF_PARSE</NAME>
#define GST_IS_ASF_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ASF_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_ASF_PARSE_CLASS</NAME>
#define GST_IS_ASF_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ASF_PARSE))
</MACRO>
<MACRO>
<NAME>GST_ASF_PARSE_CAST</NAME>
#define GST_ASF_PARSE_CAST(obj) ((GstAsfParse*)(obj))
</MACRO>
<ENUM>
<NAME>GstAsfParsingState</NAME>
enum GstAsfParsingState {
  ASF_PARSING_HEADERS,
  ASF_PARSING_DATA,
  ASF_PARSING_PACKETS,
  ASF_PARSING_INDEXES
};
</ENUM>
<STRUCT>
<NAME>GstAsfParse</NAME>
struct _GstAsfParse {
  GstBaseParse baseparse;

  enum GstAsfParsingState parse_state;

  guint64 parsed_packets;

  /* parsed info */
  GstAsfFileInfo *asfinfo;
  GstAsfPacketInfo *packetinfo;
};
</STRUCT>
<STRUCT>
<NAME>GstAsfParseClass</NAME>
struct _GstAsfParseClass {
  GstBaseParseClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_asf_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_parse_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>ASF_PAYLOAD_IS_KEYFRAME</NAME>
#define ASF_PAYLOAD_IS_KEYFRAME(pay) ((pay->stream_number & 0x80) != 0)
</MACRO>
<MACRO>
<NAME>ASF_MILI_TO_100NANO</NAME>
#define ASF_MILI_TO_100NANO(v) (v * 10000)
</MACRO>
<MACRO>
<NAME>ASF_GUID_SIZE</NAME>
#define ASF_GUID_SIZE 16
</MACRO>
<MACRO>
<NAME>ASF_GUID_OBJSIZE_SIZE</NAME>
#define ASF_GUID_OBJSIZE_SIZE 24
</MACRO>
<FUNCTION>
<NAME>gst_asf_generate_file_id</NAME>
<RETURNS>void  </RETURNS>
Guid *guid
</FUNCTION>
<FUNCTION>
<NAME>gst_byte_reader_get_asf_var_size_field</NAME>
<RETURNS>gboolean  </RETURNS>
GstByteReader * reader, guint8 field_type, guint32 * var
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_read_var_size_field</NAME>
<RETURNS>guint32  </RETURNS>
guint8 * data, guint8 field_type
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_get_var_size_field_len</NAME>
<RETURNS>guint  </RETURNS>
guint8 field_type
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_file_info_new</NAME>
<RETURNS>GstAsfFileInfo  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_file_info_reset</NAME>
<RETURNS>void  </RETURNS>
GstAsfFileInfo * info
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_file_info_free</NAME>
<RETURNS>void  </RETURNS>
GstAsfFileInfo * info
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_payload_get_size</NAME>
<RETURNS>guint32  </RETURNS>
AsfPayload * payload
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_payload_free</NAME>
<RETURNS>void  </RETURNS>
AsfPayload * payload
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_get_current_time</NAME>
<RETURNS>guint64  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_match_guid</NAME>
<RETURNS>gboolean  </RETURNS>
const guint8 * data, const Guid * g
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_put_i32</NAME>
<RETURNS>void  </RETURNS>
guint8 * buf, gint32 data
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_put_time</NAME>
<RETURNS>void  </RETURNS>
guint8 * buf, guint64 time
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_put_guid</NAME>
<RETURNS>void  </RETURNS>
guint8 * buf, Guid guid
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_put_payload</NAME>
<RETURNS>void  </RETURNS>
guint8 * buf, AsfPayload * payload
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_put_subpayload</NAME>
<RETURNS>guint16  </RETURNS>
guint8 * buf, AsfPayload * payload, guint16 size
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_parse_packet</NAME>
<RETURNS>gboolean  </RETURNS>
GstBuffer * buffer, GstAsfPacketInfo * packet, gboolean trust_delta_flag, guint packet_size
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_parse_packet_from_data</NAME>
<RETURNS>gboolean  </RETURNS>
guint8 * data, gsize size, GstBuffer * buffer, GstAsfPacketInfo * packet, gboolean trust_delta_flag, guint packet_size
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_match_and_peek_obj_size</NAME>
<RETURNS>guint64  </RETURNS>
const guint8 * data, const Guid * guid
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_match_and_peek_obj_size_buf</NAME>
<RETURNS>guint64  </RETURNS>
GstBuffer * buf, const Guid * guid
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_parse_headers</NAME>
<RETURNS>gboolean  </RETURNS>
GstBuffer * buffer, GstAsfFileInfo * file_info
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_parse_headers_from_data</NAME>
<RETURNS>gboolean  </RETURNS>
guint8 * data, guint size, GstAsfFileInfo * file_info
</FUNCTION>
<MACRO>
<NAME>ASF_TAG_TITLE</NAME>
#define ASF_TAG_TITLE "Title\0"
</MACRO>
<MACRO>
<NAME>ASF_TAG_TITLE_SORTNAME</NAME>
#define ASF_TAG_TITLE_SORTNAME "TitleSortOrder\0"
</MACRO>
<MACRO>
<NAME>ASF_TAG_ARTIST</NAME>
#define ASF_TAG_ARTIST "WM/AlbumArtist\0"
</MACRO>
<MACRO>
<NAME>ASF_TAG_ARTIST_SORTNAME</NAME>
#define ASF_TAG_ARTIST_SORTNAME "AlbumArtistSortOrder\0"
</MACRO>
<MACRO>
<NAME>ASF_TAG_ALBUM_TITLE</NAME>
#define ASF_TAG_ALBUM_TITLE "WM/AlbumTitle\0"
</MACRO>
<MACRO>
<NAME>ASF_TAG_ALBUM_TITLE_SORTNAME</NAME>
#define ASF_TAG_ALBUM_TITLE_SORTNAME "AlbumTitleSortOrder\0"
</MACRO>
<MACRO>
<NAME>ASF_TAG_GENRE</NAME>
#define ASF_TAG_GENRE "WM/Genre\0"
</MACRO>
<MACRO>
<NAME>ASF_TAG_COMMENT</NAME>
#define ASF_TAG_COMMENT "Comment\0"
</MACRO>
<MACRO>
<NAME>ASF_TAG_TRACK_NUMBER</NAME>
#define ASF_TAG_TRACK_NUMBER "WM/TrackNumber\0"
</MACRO>
<MACRO>
<NAME>ASF_TAG_COPYRIGHT</NAME>
#define ASF_TAG_COPYRIGHT "Copyright\0"
</MACRO>
<MACRO>
<NAME>ASF_TAG_COMPOSER</NAME>
#define ASF_TAG_COMPOSER "WM/Composer\0"
</MACRO>
<FUNCTION>
<NAME>gst_asf_get_asf_tag</NAME>
<RETURNS>const gchar  *</RETURNS>
const gchar * gsttag
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_get_tag_field_type</NAME>
<RETURNS>guint  </RETURNS>
GValue * value
</FUNCTION>
<FUNCTION>
<NAME>gst_asf_tag_present_in_content_description</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar * tag
</FUNCTION>
<MACRO>
<NAME>ASF_HEADER_OBJECT_SIZE</NAME>
#define ASF_HEADER_OBJECT_SIZE 30
</MACRO>
<MACRO>
<NAME>ASF_FILE_PROPERTIES_OBJECT_SIZE</NAME>
#define ASF_FILE_PROPERTIES_OBJECT_SIZE 104
</MACRO>
<MACRO>
<NAME>ASF_STREAM_PROPERTIES_OBJECT_SIZE</NAME>
#define ASF_STREAM_PROPERTIES_OBJECT_SIZE 78
</MACRO>
<MACRO>
<NAME>ASF_HEADER_EXTENSION_OBJECT_SIZE</NAME>
#define ASF_HEADER_EXTENSION_OBJECT_SIZE 46
</MACRO>
<MACRO>
<NAME>ASF_AUDIO_SPECIFIC_DATA_SIZE</NAME>
#define ASF_AUDIO_SPECIFIC_DATA_SIZE 18
</MACRO>
<MACRO>
<NAME>ASF_VIDEO_SPECIFIC_DATA_SIZE</NAME>
#define ASF_VIDEO_SPECIFIC_DATA_SIZE 51
</MACRO>
<MACRO>
<NAME>ASF_DATA_OBJECT_SIZE</NAME>
#define ASF_DATA_OBJECT_SIZE 50
</MACRO>
<MACRO>
<NAME>ASF_SINGLE_PAYLOAD_HEADER_SIZE</NAME>
#define ASF_SINGLE_PAYLOAD_HEADER_SIZE 15
</MACRO>
<MACRO>
<NAME>ASF_MULTIPLE_PAYLOAD_HEADER_SIZE</NAME>
#define ASF_MULTIPLE_PAYLOAD_HEADER_SIZE 17
</MACRO>
<MACRO>
<NAME>ASF_EXTENDED_STREAM_PROPERTIES_OBJECT_SIZE</NAME>
#define ASF_EXTENDED_STREAM_PROPERTIES_OBJECT_SIZE 88
</MACRO>
<MACRO>
<NAME>ASF_CONTENT_DESCRIPTION_OBJECT_SIZE</NAME>
#define ASF_CONTENT_DESCRIPTION_OBJECT_SIZE 34
</MACRO>
<MACRO>
<NAME>ASF_EXT_CONTENT_DESCRIPTION_OBJECT_SIZE</NAME>
#define ASF_EXT_CONTENT_DESCRIPTION_OBJECT_SIZE 26
</MACRO>
<MACRO>
<NAME>ASF_SIMPLE_INDEX_OBJECT_SIZE</NAME>
#define ASF_SIMPLE_INDEX_OBJECT_SIZE 56
</MACRO>
<MACRO>
<NAME>ASF_SIMPLE_INDEX_ENTRY_SIZE</NAME>
#define ASF_SIMPLE_INDEX_ENTRY_SIZE 6
</MACRO>
<MACRO>
<NAME>ASF_METADATA_OBJECT_SIZE</NAME>
#define ASF_METADATA_OBJECT_SIZE 26
</MACRO>
<MACRO>
<NAME>ASF_PADDING_OBJECT_SIZE</NAME>
#define ASF_PADDING_OBJECT_SIZE 24
</MACRO>
<MACRO>
<NAME>ASF_FIELD_TYPE_NONE</NAME>
#define ASF_FIELD_TYPE_NONE 0
</MACRO>
<MACRO>
<NAME>ASF_FIELD_TYPE_BYTE</NAME>
#define ASF_FIELD_TYPE_BYTE 1
</MACRO>
<MACRO>
<NAME>ASF_FIELD_TYPE_WORD</NAME>
#define ASF_FIELD_TYPE_WORD 2
</MACRO>
<MACRO>
<NAME>ASF_FIELD_TYPE_DWORD</NAME>
#define ASF_FIELD_TYPE_DWORD 3
</MACRO>
<MACRO>
<NAME>ASF_FIELD_TYPE_MASK</NAME>
#define ASF_FIELD_TYPE_MASK 3
</MACRO>
<MACRO>
<NAME>ASF_TAG_TYPE_UNICODE_STR</NAME>
#define ASF_TAG_TYPE_UNICODE_STR 0
</MACRO>
<MACRO>
<NAME>ASF_TAG_TYPE_BYTES</NAME>
#define ASF_TAG_TYPE_BYTES 1
</MACRO>
<MACRO>
<NAME>ASF_TAG_TYPE_BOOL</NAME>
#define ASF_TAG_TYPE_BOOL 2
</MACRO>
<MACRO>
<NAME>ASF_TAG_TYPE_DWORD</NAME>
#define ASF_TAG_TYPE_DWORD 3
</MACRO>
<MACRO>
<NAME>ASF_TAG_TYPE_QWORD</NAME>
#define ASF_TAG_TYPE_QWORD 4
</MACRO>
<MACRO>
<NAME>ASF_TAG_TYPE_WORD</NAME>
#define ASF_TAG_TYPE_WORD 5
</MACRO>
<MACRO>
<NAME>ASF_HEADER_OBJECT_INDEX</NAME>
#define ASF_HEADER_OBJECT_INDEX 0
</MACRO>
<MACRO>
<NAME>ASF_FILE_PROPERTIES_OBJECT_INDEX</NAME>
#define ASF_FILE_PROPERTIES_OBJECT_INDEX 1
</MACRO>
<MACRO>
<NAME>ASF_STREAM_PROPERTIES_OBJECT_INDEX</NAME>
#define ASF_STREAM_PROPERTIES_OBJECT_INDEX 2
</MACRO>
<MACRO>
<NAME>ASF_AUDIO_MEDIA_INDEX</NAME>
#define ASF_AUDIO_MEDIA_INDEX 3
</MACRO>
<MACRO>
<NAME>ASF_NO_ERROR_CORRECTION_INDEX</NAME>
#define ASF_NO_ERROR_CORRECTION_INDEX 4
</MACRO>
<MACRO>
<NAME>ASF_AUDIO_SPREAD_INDEX</NAME>
#define ASF_AUDIO_SPREAD_INDEX 5
</MACRO>
<MACRO>
<NAME>ASF_HEADER_EXTENSION_OBJECT_INDEX</NAME>
#define ASF_HEADER_EXTENSION_OBJECT_INDEX 6
</MACRO>
<MACRO>
<NAME>ASF_RESERVED_1_INDEX</NAME>
#define ASF_RESERVED_1_INDEX 7
</MACRO>
<MACRO>
<NAME>ASF_DATA_OBJECT_INDEX</NAME>
#define ASF_DATA_OBJECT_INDEX 8
</MACRO>
<MACRO>
<NAME>ASF_EXTENDED_STREAM_PROPERTIES_OBJECT_INDEX</NAME>
#define ASF_EXTENDED_STREAM_PROPERTIES_OBJECT_INDEX 9
</MACRO>
<MACRO>
<NAME>ASF_VIDEO_MEDIA_INDEX</NAME>
#define ASF_VIDEO_MEDIA_INDEX 10
</MACRO>
<MACRO>
<NAME>ASF_SIMPLE_INDEX_OBJECT_INDEX</NAME>
#define ASF_SIMPLE_INDEX_OBJECT_INDEX 11
</MACRO>
<MACRO>
<NAME>ASF_CONTENT_DESCRIPTION_INDEX</NAME>
#define ASF_CONTENT_DESCRIPTION_INDEX 12
</MACRO>
<MACRO>
<NAME>ASF_EXT_CONTENT_DESCRIPTION_INDEX</NAME>
#define ASF_EXT_CONTENT_DESCRIPTION_INDEX 13
</MACRO>
<MACRO>
<NAME>ASF_METADATA_OBJECT_INDEX</NAME>
#define ASF_METADATA_OBJECT_INDEX 14
</MACRO>
<MACRO>
<NAME>ASF_PADDING_OBJECT_INDEX</NAME>
#define ASF_PADDING_OBJECT_INDEX 15
</MACRO>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<MACRO>
<NAME>GST_TYPE_RGB_2_BAYER</NAME>
#define GST_TYPE_RGB_2_BAYER   (gst_rgb2bayer_get_type())
</MACRO>
<MACRO>
<NAME>GST_RGB_2_BAYER</NAME>
#define GST_RGB_2_BAYER(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RGB_2_BAYER,GstRGB2Bayer))
</MACRO>
<MACRO>
<NAME>GST_RGB_2_BAYER_CLASS</NAME>
#define GST_RGB_2_BAYER_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RGB_2_BAYER,GstRGB2BayerClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RGB_2_BAYER</NAME>
#define GST_IS_RGB_2_BAYER(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RGB_2_BAYER))
</MACRO>
<MACRO>
<NAME>GST_IS_RGB_2_BAYER_CLASS</NAME>
#define GST_IS_RGB_2_BAYER_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RGB_2_BAYER))
</MACRO>
<STRUCT>
<NAME>GstRGB2Bayer</NAME>
struct _GstRGB2Bayer
{
  GstBaseTransform base_rgb2bayer;

  GstVideoInfo info;
  int width, height;
  int format;
};
</STRUCT>
<STRUCT>
<NAME>GstRGB2BayerClass</NAME>
struct _GstRGB2BayerClass
{
  GstBaseTransformClass base_rgb2bayer_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_rgb2bayer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>orc_int8</NAME>
typedef int8_t orc_int8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int16</NAME>
typedef int16_t orc_int16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int32</NAME>
typedef int32_t orc_int32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_int64</NAME>
typedef int64_t orc_int64;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint8</NAME>
typedef uint8_t orc_uint8;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint16</NAME>
typedef uint16_t orc_uint16;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint32</NAME>
typedef uint32_t orc_uint32;
</TYPEDEF>
<TYPEDEF>
<NAME>orc_uint64</NAME>
typedef uint64_t orc_uint64;
</TYPEDEF>
<MACRO>
<NAME>ORC_UINT64_C</NAME>
#define ORC_UINT64_C(x) UINT64_C(x)
</MACRO>
<MACRO>
<NAME>inline</NAME>
#define inline __inline
</MACRO>
<FUNCTION>
<NAME>mxf_jpeg2000_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>MXFUL</NAME>
typedef struct {
  guint8 u[16];
} MXFUL;
</STRUCT>
<ENUM>
<NAME>MXFULId</NAME>
typedef enum {
  MXF_UL_SMPTE,
  MXF_UL_FILL,
  MXF_UL_PARTITION_PACK,
  MXF_UL_PRIMER_PACK,
  MXF_UL_METADATA,
  MXF_UL_DESCRIPTIVE_METADATA,
  MXF_UL_RANDOM_INDEX_PACK,
  MXF_UL_INDEX_TABLE_SEGMENT,
  MXF_UL_GENERIC_CONTAINER_SYSTEM_ITEM,
  MXF_UL_GENERIC_CONTAINER_ESSENCE_ELEMENT,
  MXF_UL_GENERIC_CONTAINER_ESSENCE_CONTAINER_LABEL,
  MXF_UL_AVID_ESSENCE_CONTAINER_ESSENCE_ELEMENT,
  MXF_UL_AVID_ESSENCE_CONTAINER_ESSENCE_LABEL,
  MXF_UL_OPERATIONAL_PATTERN_IDENTIFICATION,
  MXF_UL_TRACK_TIMECODE_12M_INACTIVE,
  MXF_UL_TRACK_TIMECODE_12M_ACTIVE,
  MXF_UL_TRACK_TIMECODE_309M,
  MXF_UL_TRACK_METADATA,
  MXF_UL_TRACK_PICTURE_ESSENCE,
  MXF_UL_TRACK_SOUND_ESSENCE,
  MXF_UL_TRACK_DATA_ESSENCE,
  MXF_UL_TRACK_AUXILIARY_DATA,
  MXF_UL_TRACK_PARSED_TEXT,
  MXF_UL_TRACK_AVID_PICTURE_ESSENCE,
  MXF_UL_INSTANCE_UID,
  MXF_UL_GENERATION_UID,
  MXF_UL_LAST_MODIFIED_DATE,
  MXF_UL_VERSION,
  MXF_UL_OBJECT_MODEL_VERSION,
  MXF_UL_PRIMARY_PACKAGE,
  MXF_UL_IDENTIFICATIONS,
  MXF_UL_CONTENT_STORAGE,
  MXF_UL_OPERATIONAL_PATTERN,
  MXF_UL_ESSENCE_CONTAINERS,
  MXF_UL_DM_SCHEMES,
  MXF_UL_THIS_GENERATION_UID,
  MXF_UL_COMPANY_NAME,
  MXF_UL_PRODUCT_NAME,
  MXF_UL_PRODUCT_VERSION,
  MXF_UL_VERSION_STRING,
  MXF_UL_PRODUCT_UID,
  MXF_UL_MODIFICATION_DATE,
  MXF_UL_TOOLKIT_VERSION,
  MXF_UL_PLATFORM,
  MXF_UL_PACKAGES,
  MXF_UL_ESSENCE_CONTAINER_DATA,
  MXF_UL_LINKED_PACKAGE_UID,
  MXF_UL_BODY_SID,
  MXF_UL_INDEX_SID,
  MXF_UL_PACKAGE_UID,
  MXF_UL_PACKAGE_NAME,
  MXF_UL_PACKAGE_CREATION_DATE,
  MXF_UL_PACKAGE_MODIFIED_DATE,
  MXF_UL_TRACKS,
  MXF_UL_DESCRIPTOR,
  MXF_UL_TRACK_ID,
  MXF_UL_TRACK_NUMBER,
  MXF_UL_TRACK_NAME,
  MXF_UL_SEQUENCE,
  MXF_UL_EDIT_RATE,
  MXF_UL_ORIGIN,
  MXF_UL_EVENT_EDIT_RATE,
  MXF_UL_EVENT_ORIGIN,
  MXF_UL_DATA_DEFINITION,
  MXF_UL_DURATION,
  MXF_UL_STRUCTURAL_COMPONENTS,
  MXF_UL_ROUNDED_TIMECODE_BASE,
  MXF_UL_START_TIMECODE,
  MXF_UL_DROP_FRAME,
  MXF_UL_START_POSITION,
  MXF_UL_SOURCE_PACKAGE_ID,
  MXF_UL_SOURCE_TRACK_ID,
  MXF_UL_DM_SOURCECLIP_TRACK_IDS,
  MXF_UL_EVENT_START_POSITION,
  MXF_UL_EVENT_COMMENT,
  MXF_UL_DM_SEGMENT_TRACK_IDS,
  MXF_UL_DM_FRAMEWORK,
  MXF_UL_LOCATORS,
  MXF_UL_LINKED_TRACK_ID,
  MXF_UL_SAMPLE_RATE,
  MXF_UL_CONTAINER_DURATION,
  MXF_UL_ESSENCE_CONTAINER,
  MXF_UL_CODEC,
  MXF_UL_SIGNAL_STANDARD,
  MXF_UL_FRAME_LAYOUT,
  MXF_UL_STORED_WIDTH,
  MXF_UL_STORED_HEIGHT,
  MXF_UL_STORED_F2_OFFSET,
  MXF_UL_SAMPLED_WIDTH,
  MXF_UL_SAMPLED_HEIGHT,
  MXF_UL_SAMPLED_X_OFFSET,
  MXF_UL_SAMPLED_Y_OFFSET,
  MXF_UL_DISPLAY_HEIGHT,
  MXF_UL_DISPLAY_WIDTH,
  MXF_UL_DISPLAY_X_OFFSET,
  MXF_UL_DISPLAY_Y_OFFSET,
  MXF_UL_DISPLAY_F2_OFFSET,
  MXF_UL_ASPECT_RATIO,
  MXF_UL_ACTIVE_FORMAT_DESCRIPTOR,
  MXF_UL_VIDEO_LINE_MAP,
  MXF_UL_ALPHA_TRANSPARENCY,
  MXF_UL_CAPTURE_GAMMA,
  MXF_UL_IMAGE_ALIGNMENT_OFFSET,
  MXF_UL_IMAGE_START_OFFSET,
  MXF_UL_IMAGE_END_OFFSET,
  MXF_UL_FIELD_DOMINANCE,
  MXF_UL_PICTURE_ESSENCE_CODING,
  MXF_UL_AUDIO_SAMPLING_RATE,
  MXF_UL_LOCKED,
  MXF_UL_AUDIO_REF_LEVEL,
  MXF_UL_ELECTRO_SPATIAL_FORMULATION,
  MXF_UL_CHANNEL_COUNT,
  MXF_UL_QUANTIZATION_BITS,
  MXF_UL_DIAL_NORM,
  MXF_UL_SOUND_ESSENCE_COMPRESSION,
  MXF_UL_COMPONENT_DEPTH,
  MXF_UL_HORIZONTAL_SUBSAMPLING,
  MXF_UL_VERTICAL_SUBSAMPLING,
  MXF_UL_COLOR_SITING,
  MXF_UL_REVERSED_BYTE_ORDER,
  MXF_UL_PADDING_BITS,
  MXF_UL_ALPHA_SAMPLE_DEPTH,
  MXF_UL_BLACK_REF_LEVEL,
  MXF_UL_WHITE_REF_LEVEL,
  MXF_UL_COLOR_RANGE,
  MXF_UL_COMPONENT_MAX_REF,
  MXF_UL_COMPONENT_MIN_REF,
  MXF_UL_ALPHA_MAX_REF,
  MXF_UL_ALPHA_MIN_REF,
  MXF_UL_SCANNING_DIRECTION,
  MXF_UL_PIXEL_LAYOUT,
  MXF_UL_DATA_ESSENCE_CODING,
  MXF_UL_SUB_DESCRIPTORS,
  MXF_UL_LOCATOR_NAME,
  MXF_UL_URL_STRING,
  MXF_UL_MAX
} MXFULId;
</ENUM>
<MACRO>
<NAME>MXF_UL</NAME>
#define MXF_UL(id) (&_mxf_ul_table[MXF_UL_##id])
</MACRO>
<FUNCTION>
<NAME>mxf_ul_is_equal</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *a, const MXFUL *b
</FUNCTION>
<FUNCTION>
<NAME>mxf_ul_is_subclass</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *class, const MXFUL *subclass
</FUNCTION>
<FUNCTION>
<NAME>mxf_ul_is_zero</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_ul_is_valid</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_ul_hash</NAME>
<RETURNS>guint  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_ul_to_string</NAME>
<RETURNS>gchar  * </RETURNS>
const MXFUL *ul, gchar str[48]
</FUNCTION>
<FUNCTION>
<NAME>mxf_ul_from_string</NAME>
<RETURNS>MXFUL  * </RETURNS>
const gchar *str, MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_ul_array_parse</NAME>
<RETURNS>gboolean  </RETURNS>
MXFUL **array, guint32 *count, const guint8 *data, guint size
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_BASE</NAME>
#define MXF_TYPE_METADATA_BASE \
  (mxf_metadata_base_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_BASE</NAME>
#define MXF_METADATA_BASE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_BASE, MXFMetadataBase))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_BASE</NAME>
#define MXF_IS_METADATA_BASE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_BASE))
</MACRO>
<MACRO>
<NAME>MXF_METADATA_BASE_GET_CLASS</NAME>
#define MXF_METADATA_BASE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), MXF_TYPE_METADATA_BASE, MXFMetadataBaseClass))
</MACRO>
<MACRO>
<NAME>MXF_METADATA_BASE_CLASS</NAME>
#define MXF_METADATA_BASE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),MXF_TYPE_METADATA_BASE,MXFMetadataBaseClass))
</MACRO>
<FUNCTION>
<NAME>mxf_metadata_base_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA</NAME>
#define MXF_TYPE_METADATA \
  (mxf_metadata_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA</NAME>
#define MXF_METADATA(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA, MXFMetadata))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA</NAME>
#define MXF_IS_METADATA(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA))
</MACRO>
<MACRO>
<NAME>MXF_METADATA_GET_CLASS</NAME>
#define MXF_METADATA_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), MXF_TYPE_METADATA, MXFMetadataClass))
</MACRO>
<MACRO>
<NAME>MXF_METADATA_CLASS</NAME>
#define MXF_METADATA_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),MXF_TYPE_METADATA,MXFMetadataClass))
</MACRO>
<FUNCTION>
<NAME>mxf_metadata_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_PREFACE</NAME>
#define MXF_TYPE_METADATA_PREFACE \
  (mxf_metadata_preface_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_PREFACE</NAME>
#define MXF_METADATA_PREFACE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_PREFACE,MXFMetadataPreface))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_PREFACE</NAME>
#define MXF_IS_METADATA_PREFACE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_PREFACE))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataPrefaceClass</NAME>
typedef MXFMetadataClass MXFMetadataPrefaceClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_preface_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_IDENTIFICATION</NAME>
#define MXF_TYPE_METADATA_IDENTIFICATION \
  (mxf_metadata_identification_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_IDENTIFICATION</NAME>
#define MXF_METADATA_IDENTIFICATION(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_IDENTIFICATION,MXFMetadataIdentification))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_IDENTIFICATION</NAME>
#define MXF_IS_METADATA_IDENTIFICATION(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_IDENTIFICATION))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataIdentificationClass</NAME>
typedef MXFMetadataClass MXFMetadataIdentificationClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_identification_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_CONTENT_STORAGE</NAME>
#define MXF_TYPE_METADATA_CONTENT_STORAGE \
  (mxf_metadata_content_storage_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_CONTENT_STORAGE</NAME>
#define MXF_METADATA_CONTENT_STORAGE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_CONTENT_STORAGE, MXFMetadataContentStorage))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_CONTENT_STORAGE</NAME>
#define MXF_IS_METADATA_CONTENT_STORAGE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_CONTENT_STORAGE))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataContentStorageClass</NAME>
typedef MXFMetadataClass MXFMetadataContentStorageClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_content_storage_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_ESSENCE_CONTAINER_DATA</NAME>
#define MXF_TYPE_METADATA_ESSENCE_CONTAINER_DATA \
  (mxf_metadata_essence_container_data_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_ESSENCE_CONTAINER_DATA</NAME>
#define MXF_METADATA_ESSENCE_CONTAINER_DATA(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_ESSENCE_CONTAINER_DATA, MXFMetadataEssenceContainerData))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_ESSENCE_CONTAINER_DATA</NAME>
#define MXF_IS_METADATA_ESSENCE_CONTAINER_DATA(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_ESSENCE_CONTAINER_DATA))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataEssenceContainerDataClass</NAME>
typedef MXFMetadataClass MXFMetadataEssenceContainerDataClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_essence_container_data_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_GENERIC_PACKAGE</NAME>
#define MXF_TYPE_METADATA_GENERIC_PACKAGE \
  (mxf_metadata_generic_package_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_GENERIC_PACKAGE</NAME>
#define MXF_METADATA_GENERIC_PACKAGE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_GENERIC_PACKAGE, MXFMetadataGenericPackage))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_GENERIC_PACKAGE</NAME>
#define MXF_IS_METADATA_GENERIC_PACKAGE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_GENERIC_PACKAGE))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataGenericPackageClass</NAME>
typedef MXFMetadataClass MXFMetadataGenericPackageClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_generic_package_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_MATERIAL_PACKAGE</NAME>
#define MXF_TYPE_METADATA_MATERIAL_PACKAGE \
  (mxf_metadata_material_package_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_MATERIAL_PACKAGE</NAME>
#define MXF_METADATA_MATERIAL_PACKAGE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_MATERIAL_PACKAGE, MXFMetadataMaterialPackage))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_MATERIAL_PACKAGE</NAME>
#define MXF_IS_METADATA_MATERIAL_PACKAGE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_MATERIAL_PACKAGE))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataMaterialPackage</NAME>
typedef MXFMetadataGenericPackage MXFMetadataMaterialPackage;
</TYPEDEF>
<TYPEDEF>
<NAME>MXFMetadataMaterialPackageClass</NAME>
typedef MXFMetadataClass MXFMetadataMaterialPackageClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_material_package_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_SOURCE_PACKAGE</NAME>
#define MXF_TYPE_METADATA_SOURCE_PACKAGE \
  (mxf_metadata_source_package_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_SOURCE_PACKAGE</NAME>
#define MXF_METADATA_SOURCE_PACKAGE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_SOURCE_PACKAGE, MXFMetadataSourcePackage))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_SOURCE_PACKAGE</NAME>
#define MXF_IS_METADATA_SOURCE_PACKAGE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_SOURCE_PACKAGE))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataSourcePackageClass</NAME>
typedef MXFMetadataClass MXFMetadataSourcePackageClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_source_package_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_TRACK</NAME>
#define MXF_TYPE_METADATA_TRACK \
  (mxf_metadata_track_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_TRACK</NAME>
#define MXF_METADATA_TRACK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_TRACK, MXFMetadataTrack))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_TRACK</NAME>
#define MXF_IS_METADATA_TRACK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_TRACK))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataTrackClass</NAME>
typedef MXFMetadataClass MXFMetadataTrackClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_track_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_TIMELINE_TRACK</NAME>
#define MXF_TYPE_METADATA_TIMELINE_TRACK \
  (mxf_metadata_timeline_track_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_TIMELINE_TRACK</NAME>
#define MXF_METADATA_TIMELINE_TRACK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_TIMELINE_TRACK, MXFMetadataTimelineTrack))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_TIMELINE_TRACK</NAME>
#define MXF_IS_METADATA_TIMELINE_TRACK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_TIMELINE_TRACK))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataTimelineTrackClass</NAME>
typedef MXFMetadataClass MXFMetadataTimelineTrackClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_timeline_track_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_EVENT_TRACK</NAME>
#define MXF_TYPE_METADATA_EVENT_TRACK \
  (mxf_metadata_event_track_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_EVENT_TRACK</NAME>
#define MXF_METADATA_EVENT_TRACK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_EVENT_TRACK, MXFMetadataEventTrack))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_EVENT_TRACK</NAME>
#define MXF_IS_METADATA_EVENT_TRACK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_EVENT_TRACK))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataEventTrackClass</NAME>
typedef MXFMetadataClass MXFMetadataEventTrackClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_event_track_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_STATIC_TRACK</NAME>
#define MXF_TYPE_METADATA_STATIC_TRACK \
  (mxf_metadata_static_track_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_STATIC_TRACK</NAME>
#define MXF_METADATA_STATIC_TRACK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_STATIC_TRACK, MXFMetadataStaticTrack))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_STATIC_TRACK</NAME>
#define MXF_IS_METADATA_STATIC_TRACK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_STATIC_TRACK))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataStaticTrack</NAME>
typedef MXFMetadataTrack MXFMetadataStaticTrack;
</TYPEDEF>
<TYPEDEF>
<NAME>MXFMetadataStaticTrackClass</NAME>
typedef MXFMetadataClass MXFMetadataStaticTrackClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_static_track_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_SEQUENCE</NAME>
#define MXF_TYPE_METADATA_SEQUENCE \
  (mxf_metadata_sequence_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_SEQUENCE</NAME>
#define MXF_METADATA_SEQUENCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_SEQUENCE, MXFMetadataSequence))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_SEQUENCE</NAME>
#define MXF_IS_METADATA_SEQUENCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_SEQUENCE))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataSequenceClass</NAME>
typedef MXFMetadataClass MXFMetadataSequenceClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_sequence_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_STRUCTURAL_COMPONENT</NAME>
#define MXF_TYPE_METADATA_STRUCTURAL_COMPONENT \
  (mxf_metadata_structural_component_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_STRUCTURAL_COMPONENT</NAME>
#define MXF_METADATA_STRUCTURAL_COMPONENT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_STRUCTURAL_COMPONENT, MXFMetadataStructuralComponent))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_STRUCTURAL_COMPONENT</NAME>
#define MXF_IS_METADATA_STRUCTURAL_COMPONENT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_STRUCTURAL_COMPONENT))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataStructuralComponentClass</NAME>
typedef MXFMetadataClass MXFMetadataStructuralComponentClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_structural_component_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_SOURCE_CLIP</NAME>
#define MXF_TYPE_METADATA_SOURCE_CLIP \
  (mxf_metadata_source_clip_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_SOURCE_CLIP</NAME>
#define MXF_METADATA_SOURCE_CLIP(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_SOURCE_CLIP, MXFMetadataSourceClip))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_SOURCE_CLIP</NAME>
#define MXF_IS_METADATA_SOURCE_CLIP(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_SOURCE_CLIP))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataSourceClipClass</NAME>
typedef MXFMetadataClass MXFMetadataSourceClipClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_source_clip_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_FILLER</NAME>
#define MXF_TYPE_METADATA_FILLER \
  (mxf_metadata_filler_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_FILLER</NAME>
#define MXF_METADATA_FILLER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_FILLER, MXFMetadataFiller))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_FILLER</NAME>
#define MXF_IS_METADATA_FILLER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_FILLER))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataFillerClass</NAME>
typedef MXFMetadataClass MXFMetadataFillerClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_filler_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_TIMECODE_COMPONENT</NAME>
#define MXF_TYPE_METADATA_TIMECODE_COMPONENT \
  (mxf_metadata_timecode_component_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_TIMECODE_COMPONENT</NAME>
#define MXF_METADATA_TIMECODE_COMPONENT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_TIMECODE_COMPONENT, MXFMetadataTimecodeComponent))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_TIMECODE_COMPONENT</NAME>
#define MXF_IS_METADATA_TIMECODE_COMPONENT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_TIMECODE_COMPONENT))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataTimecodeComponentClass</NAME>
typedef MXFMetadataClass MXFMetadataTimecodeComponentClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_timecode_component_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_DM_SOURCE_CLIP</NAME>
#define MXF_TYPE_METADATA_DM_SOURCE_CLIP \
  (mxf_metadata_dm_source_clip_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_DM_SOURCE_CLIP</NAME>
#define MXF_METADATA_DM_SOURCE_CLIP(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_DM_SOURCE_CLIP, MXFMetadataDMSourceClip))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_DM_SOURCE_CLIP</NAME>
#define MXF_IS_METADATA_DM_SOURCE_CLIP(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_DM_SOURCE_CLIP))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataDMSourceClipClass</NAME>
typedef MXFMetadataClass MXFMetadataDMSourceClipClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_dm_source_clip_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_DM_SEGMENT</NAME>
#define MXF_TYPE_METADATA_DM_SEGMENT \
  (mxf_metadata_dm_segment_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_DM_SEGMENT</NAME>
#define MXF_METADATA_DM_SEGMENT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_DM_SEGMENT, MXFMetadataDMSegment))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_DM_SEGMENT</NAME>
#define MXF_IS_METADATA_DM_SEGMENT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_DM_SEGMENT))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataDMSegmentClass</NAME>
typedef MXFMetadataClass MXFMetadataDMSegmentClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_dm_segment_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_GENERIC_DESCRIPTOR</NAME>
#define MXF_TYPE_METADATA_GENERIC_DESCRIPTOR \
  (mxf_metadata_generic_descriptor_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_GENERIC_DESCRIPTOR</NAME>
#define MXF_METADATA_GENERIC_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_GENERIC_DESCRIPTOR, MXFMetadataGenericDescriptor))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_GENERIC_DESCRIPTOR</NAME>
#define MXF_IS_METADATA_GENERIC_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_GENERIC_DESCRIPTOR))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataGenericDescriptorClass</NAME>
typedef MXFMetadataClass MXFMetadataGenericDescriptorClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_generic_descriptor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_FILE_DESCRIPTOR</NAME>
#define MXF_TYPE_METADATA_FILE_DESCRIPTOR \
  (mxf_metadata_file_descriptor_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_FILE_DESCRIPTOR</NAME>
#define MXF_METADATA_FILE_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_FILE_DESCRIPTOR, MXFMetadataFileDescriptor))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_FILE_DESCRIPTOR</NAME>
#define MXF_IS_METADATA_FILE_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_FILE_DESCRIPTOR))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataFileDescriptorClass</NAME>
typedef MXFMetadataClass MXFMetadataFileDescriptorClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_file_descriptor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_GENERIC_PICTURE_ESSENCE_DESCRIPTOR</NAME>
#define MXF_TYPE_METADATA_GENERIC_PICTURE_ESSENCE_DESCRIPTOR \
  (mxf_metadata_generic_picture_essence_descriptor_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_GENERIC_PICTURE_ESSENCE_DESCRIPTOR</NAME>
#define MXF_METADATA_GENERIC_PICTURE_ESSENCE_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_GENERIC_PICTURE_ESSENCE_DESCRIPTOR, MXFMetadataGenericPictureEssenceDescriptor))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_GENERIC_PICTURE_ESSENCE_DESCRIPTOR</NAME>
#define MXF_IS_METADATA_GENERIC_PICTURE_ESSENCE_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_GENERIC_PICTURE_ESSENCE_DESCRIPTOR))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataGenericPictureEssenceDescriptorClass</NAME>
typedef MXFMetadataClass MXFMetadataGenericPictureEssenceDescriptorClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_generic_picture_essence_descriptor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_CDCI_PICTURE_ESSENCE_DESCRIPTOR</NAME>
#define MXF_TYPE_METADATA_CDCI_PICTURE_ESSENCE_DESCRIPTOR \
  (mxf_metadata_cdci_picture_essence_descriptor_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_CDCI_PICTURE_ESSENCE_DESCRIPTOR</NAME>
#define MXF_METADATA_CDCI_PICTURE_ESSENCE_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_CDCI_PICTURE_ESSENCE_DESCRIPTOR, MXFMetadataCDCIPictureEssenceDescriptor))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_CDCI_PICTURE_ESSENCE_DESCRIPTOR</NAME>
#define MXF_IS_METADATA_CDCI_PICTURE_ESSENCE_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_CDCI_PICTURE_ESSENCE_DESCRIPTOR))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataCDCIPictureEssenceDescriptorClass</NAME>
typedef MXFMetadataClass MXFMetadataCDCIPictureEssenceDescriptorClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_cdci_picture_essence_descriptor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_RGBA_PICTURE_ESSENCE_DESCRIPTOR</NAME>
#define MXF_TYPE_METADATA_RGBA_PICTURE_ESSENCE_DESCRIPTOR \
  (mxf_metadata_rgba_picture_essence_descriptor_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_RGBA_PICTURE_ESSENCE_DESCRIPTOR</NAME>
#define MXF_METADATA_RGBA_PICTURE_ESSENCE_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_RGBA_PICTURE_ESSENCE_DESCRIPTOR, MXFMetadataRGBAPictureEssenceDescriptor))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_RGBA_PICTURE_ESSENCE_DESCRIPTOR</NAME>
#define MXF_IS_METADATA_RGBA_PICTURE_ESSENCE_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_RGBA_PICTURE_ESSENCE_DESCRIPTOR))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataRGBAPictureEssenceDescriptorClass</NAME>
typedef MXFMetadataClass MXFMetadataRGBAPictureEssenceDescriptorClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_rgba_picture_essence_descriptor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_GENERIC_SOUND_ESSENCE_DESCRIPTOR</NAME>
#define MXF_TYPE_METADATA_GENERIC_SOUND_ESSENCE_DESCRIPTOR \
  (mxf_metadata_generic_sound_essence_descriptor_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_GENERIC_SOUND_ESSENCE_DESCRIPTOR</NAME>
#define MXF_METADATA_GENERIC_SOUND_ESSENCE_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_GENERIC_SOUND_ESSENCE_DESCRIPTOR, MXFMetadataGenericSoundEssenceDescriptor))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_GENERIC_SOUND_ESSENCE_DESCRIPTOR</NAME>
#define MXF_IS_METADATA_GENERIC_SOUND_ESSENCE_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_GENERIC_SOUND_ESSENCE_DESCRIPTOR))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataGenericSoundEssenceDescriptorClass</NAME>
typedef MXFMetadataClass MXFMetadataGenericSoundEssenceDescriptorClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_generic_sound_essence_descriptor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_GENERIC_DATA_ESSENCE_DESCRIPTOR</NAME>
#define MXF_TYPE_METADATA_GENERIC_DATA_ESSENCE_DESCRIPTOR \
  (mxf_metadata_generic_data_essence_descriptor_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_GENERIC_DATA_ESSENCE_DESCRIPTOR</NAME>
#define MXF_METADATA_GENERIC_DATA_ESSENCE_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_GENERIC_DATA_ESSENCE_DESCRIPTOR, MXFMetadataGenericDataEssenceDescriptor))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_GENERIC_DATA_ESSENCE_DESCRIPTOR</NAME>
#define MXF_IS_METADATA_GENERIC_DATA_ESSENCE_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_GENERIC_DATA_ESSENCE_DESCRIPTOR))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataGenericDataEssenceDescriptorClass</NAME>
typedef MXFMetadataClass MXFMetadataGenericDataEssenceDescriptorClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_generic_data_essence_descriptor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_MULTIPLE_DESCRIPTOR</NAME>
#define MXF_TYPE_METADATA_MULTIPLE_DESCRIPTOR \
  (mxf_metadata_multiple_descriptor_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_MULTIPLE_DESCRIPTOR</NAME>
#define MXF_METADATA_MULTIPLE_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_MULTIPLE_DESCRIPTOR, MXFMetadataMultipleDescriptor))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_MULTIPLE_DESCRIPTOR</NAME>
#define MXF_IS_METADATA_MULTIPLE_DESCRIPTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_MULTIPLE_DESCRIPTOR))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataMultipleDescriptorClass</NAME>
typedef MXFMetadataClass MXFMetadataMultipleDescriptorClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_multiple_descriptor_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_LOCATOR</NAME>
#define MXF_TYPE_METADATA_LOCATOR \
  (mxf_metadata_locator_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_LOCATOR</NAME>
#define MXF_METADATA_LOCATOR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_LOCATOR, MXFMetadataLocator))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_LOCATOR</NAME>
#define MXF_IS_METADATA_LOCATOR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_LOCATOR))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataLocatorClass</NAME>
typedef MXFMetadataClass MXFMetadataLocatorClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_locator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_NETWORK_LOCATOR</NAME>
#define MXF_TYPE_METADATA_NETWORK_LOCATOR \
  (mxf_metadata_network_locator_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_NETWORK_LOCATOR</NAME>
#define MXF_METADATA_NETWORK_LOCATOR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_NETWORK_LOCATOR, MXFMetadataNetworkLocator))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_NETWORK_LOCATOR</NAME>
#define MXF_IS_METADATA_NETWORK_LOCATOR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_NETWORK_LOCATOR))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataNetworkLocatorClass</NAME>
typedef MXFMetadataClass MXFMetadataNetworkLocatorClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_network_locator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_METADATA_TEXT_LOCATOR</NAME>
#define MXF_TYPE_METADATA_TEXT_LOCATOR \
  (mxf_metadata_text_locator_get_type())
</MACRO>
<MACRO>
<NAME>MXF_METADATA_TEXT_LOCATOR</NAME>
#define MXF_METADATA_TEXT_LOCATOR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_METADATA_TEXT_LOCATOR, MXFMetadataTextLocator))
</MACRO>
<MACRO>
<NAME>MXF_IS_METADATA_TEXT_LOCATOR</NAME>
#define MXF_IS_METADATA_TEXT_LOCATOR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_METADATA_TEXT_LOCATOR))
</MACRO>
<TYPEDEF>
<NAME>MXFMetadataTextLocatorClass</NAME>
typedef MXFMetadataClass MXFMetadataTextLocatorClass;
</TYPEDEF>
<FUNCTION>
<NAME>mxf_metadata_text_locator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_DESCRIPTIVE_METADATA</NAME>
#define MXF_TYPE_DESCRIPTIVE_METADATA \
  (mxf_descriptive_metadata_get_type())
</MACRO>
<MACRO>
<NAME>MXF_DESCRIPTIVE_METADATA</NAME>
#define MXF_DESCRIPTIVE_METADATA(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),MXF_TYPE_DESCRIPTIVE_METADATA,MXFDescriptiveMetadata))
</MACRO>
<MACRO>
<NAME>MXF_IS_DESCRIPTIVE_METADATA</NAME>
#define MXF_IS_DESCRIPTIVE_METADATA(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),MXF_TYPE_DESCRIPTIVE_METADATA))
</MACRO>
<MACRO>
<NAME>MXF_DESCRIPTIVE_METADATA_GET_CLASS</NAME>
#define MXF_DESCRIPTIVE_METADATA_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), MXF_TYPE_DESCRIPTIVE_METADATA, MXFDescriptiveMetadataClass))
</MACRO>
<MACRO>
<NAME>MXF_DESCRIPTIVE_METADATA_CLASS</NAME>
#define MXF_DESCRIPTIVE_METADATA_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),MXF_TYPE_DESCRIPTIVE_METADATA,MXFDescriptiveMetadataClass))
</MACRO>
<FUNCTION>
<NAME>mxf_descriptive_metadata_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>MXF_TYPE_DESCRIPTIVE_METADATA_FRAMEWORK</NAME>
#define MXF_TYPE_DESCRIPTIVE_METADATA_FRAMEWORK \
  (mxf_descriptive_metadata_framework_get_type ())
</MACRO>
<MACRO>
<NAME>MXF_DESCRIPTIVE_METADATA_FRAMEWORK</NAME>
#define MXF_DESCRIPTIVE_METADATA_FRAMEWORK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), MXF_TYPE_DESCRIPTIVE_METADATA_FRAMEWORK, MXFDescriptiveMetadataFramework))
</MACRO>
<MACRO>
<NAME>MXF_IS_DESCRIPTIVE_METADATA_FRAMEWORK</NAME>
#define MXF_IS_DESCRIPTIVE_METADATA_FRAMEWORK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MXF_TYPE_DESCRIPTIVE_METADATA_FRAMEWORK))
</MACRO>
<MACRO>
<NAME>MXF_DESCRIPTIVE_METADATA_FRAMEWORK_GET_INTERFACE</NAME>
#define MXF_DESCRIPTIVE_METADATA_FRAMEWORK_GET_INTERFACE(inst) \
  (G_TYPE_INSTANCE_GET_INTERFACE ((inst), MXF_TYPE_DESCRIPTIVE_METADATA_FRAMEWORK, MXFDescriptiveMetadataFrameworkInterface))
</MACRO>
<FUNCTION>
<NAME>mxf_descriptive_metadata_framework_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>MXFMetadataBaseResolveState</NAME>
typedef enum {
  MXF_METADATA_BASE_RESOLVE_STATE_NONE = 0,
  MXF_METADATA_BASE_RESOLVE_STATE_SUCCESS,
  MXF_METADATA_BASE_RESOLVE_STATE_FAILURE,
  MXF_METADATA_BASE_RESOLVE_STATE_RUNNING
} MXFMetadataBaseResolveState;
</ENUM>
<STRUCT>
<NAME>MXFMetadataBase</NAME>
struct _MXFMetadataBase {
  GObject parent;

  MXFUUID instance_uid;
  MXFUUID generation_uid;

  guint64 offset;

  MXFMetadataBaseResolveState resolved;

  GHashTable *other_tags;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataBaseClass</NAME>
struct _MXFMetadataBaseClass {
  GObjectClass parent;

  gboolean (*handle_tag) (MXFMetadataBase *self, MXFPrimerPack *primer, guint16 tag, const guint8 *tag_data, guint tag_size);
  gboolean (*resolve) (MXFMetadataBase *self, GHashTable *metadata);
  GstStructure * (*to_structure) (MXFMetadataBase *self);
  GList * (*write_tags) (MXFMetadataBase *self, MXFPrimerPack *primer);

  GQuark name_quark;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadata</NAME>
struct _MXFMetadata {
  MXFMetadataBase parent;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataClass</NAME>
struct _MXFMetadataClass {
  MXFMetadataBaseClass parent;

  guint16 type;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataPreface</NAME>
struct _MXFMetadataPreface {
  MXFMetadata parent;

  MXFTimestamp last_modified_date;
  guint16 version;

  guint32 object_model_version;

  MXFUUID primary_package_uid;
  MXFMetadataGenericPackage *primary_package;

  guint32 n_identifications;
  MXFUUID *identifications_uids;
  MXFMetadataIdentification **identifications;

  MXFUUID content_storage_uid;
  MXFMetadataContentStorage *content_storage;

  MXFUL operational_pattern;

  guint32 n_essence_containers;
  MXFUL *essence_containers;

  guint32 n_dm_schemes;
  MXFUL *dm_schemes;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataIdentification</NAME>
struct _MXFMetadataIdentification {
  MXFMetadata parent;

  MXFUUID this_generation_uid;

  gchar *company_name;

  gchar *product_name;
  MXFProductVersion product_version;
  
  gchar *version_string;

  MXFUUID product_uid;

  MXFTimestamp modification_date;

  MXFProductVersion toolkit_version;

  gchar *platform;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataContentStorage</NAME>
struct _MXFMetadataContentStorage {
  MXFMetadata parent;

  guint32 n_packages;
  MXFUUID *packages_uids;
  MXFMetadataGenericPackage **packages;

  guint32 n_essence_container_data;
  MXFUUID *essence_container_data_uids;
  MXFMetadataEssenceContainerData **essence_container_data;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataEssenceContainerData</NAME>
struct _MXFMetadataEssenceContainerData {
  MXFMetadata parent;

  MXFUMID linked_package_uid;
  MXFMetadataSourcePackage *linked_package;

  guint32 index_sid;
  guint32 body_sid;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataGenericPackage</NAME>
struct _MXFMetadataGenericPackage {
  MXFMetadata parent;

  MXFUMID package_uid;

  gchar *name;
  MXFTimestamp package_creation_date;
  MXFTimestamp package_modified_date;

  guint32 n_tracks;
  MXFUUID *tracks_uids;
  MXFMetadataTrack **tracks;

  guint n_timecode_tracks;
  guint n_metadata_tracks;
  guint n_essence_tracks;
  guint n_other_tracks;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataSourcePackage</NAME>
struct _MXFMetadataSourcePackage
{
  MXFMetadataGenericPackage parent;

  MXFUUID descriptor_uid;
  MXFMetadataGenericDescriptor *descriptor;

  gboolean top_level;
};
</STRUCT>
<ENUM>
<NAME>MXFMetadataTrackType</NAME>
typedef enum {
  MXF_METADATA_TRACK_UNKNOWN               = 0x00,
  MXF_METADATA_TRACK_TIMECODE_12M_INACTIVE = 0x10,
  MXF_METADATA_TRACK_TIMECODE_12M_ACTIVE   = 0x11,
  MXF_METADATA_TRACK_TIMECODE_309M         = 0x12,
  MXF_METADATA_TRACK_METADATA              = 0x20,
  MXF_METADATA_TRACK_PICTURE_ESSENCE       = 0x30,
  MXF_METADATA_TRACK_SOUND_ESSENCE         = 0x31,
  MXF_METADATA_TRACK_DATA_ESSENCE          = 0x32,
  MXF_METADATA_TRACK_AUXILIARY_DATA        = 0x40,
  MXF_METADATA_TRACK_PARSED_TEXT           = 0x41
} MXFMetadataTrackType;
</ENUM>
<STRUCT>
<NAME>MXFMetadataTrack</NAME>
struct _MXFMetadataTrack {
  MXFMetadata parent;

  guint32 track_id;
  guint32 track_number;

  gchar *track_name;

  MXFUUID sequence_uid;
  MXFMetadataSequence *sequence;

  MXFMetadataTrackType type;

  MXFMetadataFileDescriptor **descriptor;
  guint n_descriptor;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataTimelineTrack</NAME>
struct _MXFMetadataTimelineTrack {
  MXFMetadataTrack parent;

  MXFFraction edit_rate;
  gint64 origin;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataEventTrack</NAME>
struct _MXFMetadataEventTrack {
  MXFMetadataTrack parent;

  MXFFraction event_edit_rate;
  gint64 event_origin;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataSequence</NAME>
struct _MXFMetadataSequence {
  MXFMetadata parent;

  MXFUL data_definition;

  gint64 duration;

  guint32 n_structural_components;
  MXFUUID *structural_components_uids;
  MXFMetadataStructuralComponent **structural_components;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataStructuralComponent</NAME>
struct _MXFMetadataStructuralComponent {
  MXFMetadata parent;

  MXFUL data_definition;
  gint64 duration;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataTimecodeComponent</NAME>
struct _MXFMetadataTimecodeComponent {
  MXFMetadataStructuralComponent parent;

  gint64 start_timecode;
  guint16 rounded_timecode_base;
  gboolean drop_frame;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataSourceClip</NAME>
struct _MXFMetadataSourceClip {
  MXFMetadataStructuralComponent parent;

  gint64 start_position;
  MXFUMID source_package_id;
  MXFMetadataSourcePackage *source_package;

  guint32 source_track_id;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataFiller</NAME>
struct _MXFMetadataFiller {
  MXFMetadataStructuralComponent parent;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataDMSourceClip</NAME>
struct _MXFMetadataDMSourceClip {
  MXFMetadataSourceClip parent;

  guint32 n_track_ids;
  guint32 *track_ids;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataDMSegment</NAME>
struct _MXFMetadataDMSegment {
  MXFMetadataStructuralComponent parent;

  gint64 event_start_position;
  gchar *event_comment;

  guint32 n_track_ids;
  guint32 *track_ids;
      
  MXFUUID dm_framework_uid;
  MXFDescriptiveMetadataFramework *dm_framework;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataGenericDescriptor</NAME>
struct _MXFMetadataGenericDescriptor {
  MXFMetadata parent;

  guint32 n_locators;
  MXFUUID *locators_uids;
  MXFMetadataLocator **locators;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataFileDescriptor</NAME>
struct _MXFMetadataFileDescriptor {
  MXFMetadataGenericDescriptor parent;

  guint32 linked_track_id;

  MXFFraction sample_rate;
  gint64 container_duration;

  MXFUL essence_container;
  MXFUL codec;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataGenericPictureEssenceDescriptor</NAME>
struct _MXFMetadataGenericPictureEssenceDescriptor {
  MXFMetadataFileDescriptor parent;

  guint8 signal_standard;
  guint8 frame_layout;

  guint32 stored_width;
  guint32 stored_height;
  gint32 stored_f2_offset;
  guint32 sampled_width;
  guint32 sampled_height;
  gint32 sampled_x_offset;
  gint32 sampled_y_offset;
  guint32 display_height;
  guint32 display_width;
  gint32 display_x_offset;
  gint32 display_y_offset;
  gint32 display_f2_offset;
  MXFFraction aspect_ratio;

  guint8 active_format_descriptor;
  gint32 video_line_map[2];
  guint8 alpha_transparency;
  MXFUL capture_gamma;

  guint32 image_alignment_offset;
  guint32 image_start_offset;
  guint32 image_end_offset;

  guint8 field_dominance;

  MXFUL picture_essence_coding;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataCDCIPictureEssenceDescriptor</NAME>
struct _MXFMetadataCDCIPictureEssenceDescriptor {
  MXFMetadataGenericPictureEssenceDescriptor parent;

  guint32 component_depth;
  guint32 horizontal_subsampling;
  guint32 vertical_subsampling;
  guint8 color_siting;
  gboolean reversed_byte_order;
  gint16 padding_bits;
  guint32 alpha_sample_depth;
  guint32 black_ref_level;
  guint32 white_ref_level;
  guint32 color_range;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataRGBAPictureEssenceDescriptor</NAME>
struct _MXFMetadataRGBAPictureEssenceDescriptor {
  MXFMetadataGenericPictureEssenceDescriptor parent;

  guint32 component_max_ref;
  guint32 component_min_ref;
  guint32 alpha_max_ref;
  guint32 alpha_min_ref;
  guint8 scanning_direction;

  guint32 n_pixel_layout;
  guint8 *pixel_layout;

  /* TODO: palette & palette layout */
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataGenericSoundEssenceDescriptor</NAME>
struct _MXFMetadataGenericSoundEssenceDescriptor {
  MXFMetadataFileDescriptor parent;

  MXFFraction audio_sampling_rate;

  gboolean locked;

  gint8 audio_ref_level;

  guint8 electro_spatial_formulation;

  guint32 channel_count;
  guint32 quantization_bits;

  gint8 dial_norm;

  MXFUL sound_essence_compression;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataGenericDataEssenceDescriptor</NAME>
struct _MXFMetadataGenericDataEssenceDescriptor {
  MXFMetadataFileDescriptor parent;

  MXFUL data_essence_coding;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataMultipleDescriptor</NAME>
struct _MXFMetadataMultipleDescriptor {
  MXFMetadataFileDescriptor parent;
  
  MXFUUID *sub_descriptors_uids;
  guint32 n_sub_descriptors;
  MXFMetadataGenericDescriptor **sub_descriptors;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataLocator</NAME>
struct _MXFMetadataLocator {
  MXFMetadata parent;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataNetworkLocator</NAME>
struct _MXFMetadataNetworkLocator {
  MXFMetadataLocator parent;

  gchar *url_string;
};
</STRUCT>
<STRUCT>
<NAME>MXFMetadataTextLocator</NAME>
struct _MXFMetadataTextLocator {
  MXFMetadataLocator parent;

  gchar *locator_name;
};
</STRUCT>
<STRUCT>
<NAME>MXFDescriptiveMetadata</NAME>
struct _MXFDescriptiveMetadata {
  MXFMetadataBase parent;
};
</STRUCT>
<STRUCT>
<NAME>MXFDescriptiveMetadataClass</NAME>
struct _MXFDescriptiveMetadataClass {
  MXFMetadataBaseClass parent;

  guint8 scheme;
  guint32 type;
};
</STRUCT>
<STRUCT>
<NAME>MXFDescriptiveMetadataFrameworkInterface</NAME>
struct _MXFDescriptiveMetadataFrameworkInterface {
  GTypeInterface parent;
};
</STRUCT>
<FUNCTION>
<NAME>mxf_metadata_base_parse</NAME>
<RETURNS>gboolean  </RETURNS>
MXFMetadataBase *self, MXFPrimerPack *primer, const guint8 *data, guint size
</FUNCTION>
<FUNCTION>
<NAME>mxf_metadata_base_resolve</NAME>
<RETURNS>gboolean  </RETURNS>
MXFMetadataBase *self, GHashTable *metadata
</FUNCTION>
<FUNCTION>
<NAME>mxf_metadata_base_to_structure</NAME>
<RETURNS>GstStructure  * </RETURNS>
MXFMetadataBase *self
</FUNCTION>
<FUNCTION>
<NAME>mxf_metadata_base_to_buffer</NAME>
<RETURNS>GstBuffer  * </RETURNS>
MXFMetadataBase *self, MXFPrimerPack *primer
</FUNCTION>
<FUNCTION>
<NAME>mxf_metadata_new</NAME>
<RETURNS>MXFMetadata  *</RETURNS>
guint16 type, MXFPrimerPack *primer, guint64 offset, const guint8 *data, guint size
</FUNCTION>
<FUNCTION>
<NAME>mxf_metadata_register</NAME>
<RETURNS>void  </RETURNS>
GType type
</FUNCTION>
<FUNCTION>
<NAME>mxf_metadata_init_types</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxf_metadata_track_identifier_parse</NAME>
<RETURNS>MXFMetadataTrackType  </RETURNS>
const MXFUL * track_identifier
</FUNCTION>
<FUNCTION>
<NAME>mxf_metadata_track_identifier_get</NAME>
<RETURNS>const MXFUL  * </RETURNS>
MXFMetadataTrackType type
</FUNCTION>
<FUNCTION>
<NAME>mxf_metadata_generic_picture_essence_descriptor_set_caps</NAME>
<RETURNS>void  </RETURNS>
MXFMetadataGenericPictureEssenceDescriptor * self, GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>mxf_metadata_generic_picture_essence_descriptor_from_caps</NAME>
<RETURNS>gboolean  </RETURNS>
MXFMetadataGenericPictureEssenceDescriptor * self, GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>mxf_metadata_generic_sound_essence_descriptor_create_caps</NAME>
<RETURNS>GstCaps  *</RETURNS>
MXFMetadataGenericSoundEssenceDescriptor * self, GstAudioFormat *format
</FUNCTION>
<FUNCTION>
<NAME>mxf_metadata_generic_sound_essence_descriptor_set_caps</NAME>
<RETURNS>void  </RETURNS>
MXFMetadataGenericSoundEssenceDescriptor * self, GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>mxf_metadata_generic_sound_essence_descriptor_from_caps</NAME>
<RETURNS>gboolean  </RETURNS>
MXFMetadataGenericSoundEssenceDescriptor * self, GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>mxf_descriptive_metadata_register</NAME>
<RETURNS>void  </RETURNS>
guint8 scheme, GType *types
</FUNCTION>
<FUNCTION>
<NAME>mxf_descriptive_metadata_new</NAME>
<RETURNS>MXFDescriptiveMetadata  * </RETURNS>
guint8 scheme, guint32 type, MXFPrimerPack * primer, guint64 offset, const guint8 * data, guint size
</FUNCTION>
<FUNCTION>
<NAME>mxf_metadata_hash_table_new</NAME>
<RETURNS>GHashTable  *</RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>MXFDescriptiveMetadataFramework</NAME>
</STRUCT>
<FUNCTION>
<NAME>mxf_alaw_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxf_vc3_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxf_d10_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>MXFQuarkId</NAME>
typedef enum {
  MXF_QUARK_INSTANCE_UID = 0,
  MXF_QUARK_GENERATION_UID = 1,
  MXF_QUARK_OTHER_TAGS = 2,
  MXF_QUARK_TAG = 3,
  MXF_QUARK_DATA = 4,
  MXF_QUARK_PREFACE = 5,
  MXF_QUARK_LAST_MODIFIED_DATE = 6,
  MXF_QUARK_VERSION = 7,
  MXF_QUARK_OBJECT_MODEL_VERSION = 8,
  MXF_QUARK_PRIMARY_PACKAGE = 9,
  MXF_QUARK_IDENTIFICATIONS = 10,
  MXF_QUARK_CONTENT_STORAGE = 11,
  MXF_QUARK_OPERATIONAL_PATTERN = 12,
  MXF_QUARK_ESSENCE_CONTAINERS = 13,
  MXF_QUARK_DM_SCHEMES = 14,
  MXF_QUARK_IDENTIFICATION = 15,
  MXF_QUARK_THIS_GENERATION_UID = 16,
  MXF_QUARK_COMPANY_NAME = 17,
  MXF_QUARK_PRODUCT_NAME = 18,
  MXF_QUARK_PRODUCT_VERSION = 19,
  MXF_QUARK_VERSION_STRING = 20,
  MXF_QUARK_PRODUCT_UID = 21,
  MXF_QUARK_MODIFICATION_DATE = 22,
  MXF_QUARK_TOOLKIT_VERSION = 23,
  MXF_QUARK_PLATFORM = 24,
  MXF_QUARK_PACKAGES = 25,
  MXF_QUARK_ESSENCE_CONTAINER_DATA = 26,
  MXF_QUARK_LINKED_PACKAGE = 27,
  MXF_QUARK_INDEX_SID = 28,
  MXF_QUARK_BODY_SID = 29,
  MXF_QUARK_PACKAGE_UID = 30,
  MXF_QUARK_NAME = 31,
  MXF_QUARK_PACKAGE_CREATION_DATE = 32,
  MXF_QUARK_PACKAGE_MODIFIED_DATE = 33,
  MXF_QUARK_TRACKS = 34,
  MXF_QUARK_MATERIAL_PACKAGE = 35,
  MXF_QUARK_SOURCE_PACKAGE = 36,
  MXF_QUARK_DESCRIPTOR = 37,
  MXF_QUARK_TRACK_ID = 38,
  MXF_QUARK_TRACK_NUMBER = 39,
  MXF_QUARK_TRACK_NAME = 40,
  MXF_QUARK_SEQUENCE = 41,
  MXF_QUARK_TIMELINE_TRACK = 42,
  MXF_QUARK_EDIT_RATE = 43,
  MXF_QUARK_ORIGIN = 44,
  MXF_QUARK_EVENT_TRACK = 45,
  MXF_QUARK_EVENT_EDIT_RATE = 46,
  MXF_QUARK_EVENT_ORIGIN = 47,
  MXF_QUARK_STATIC_TRACK = 48,
  MXF_QUARK_DATA_DEFINITION = 49,
  MXF_QUARK_DURATION = 50,
  MXF_QUARK_STRUCTURAL_COMPONENTS = 51,
  MXF_QUARK_TIMECODE_COMPONENT = 52,
  MXF_QUARK_START_TIMECODE = 53,
  MXF_QUARK_ROUNDED_TIMECODE_BASE = 54,
  MXF_QUARK_DROP_FRAME = 55,
  MXF_QUARK_SOURCE_CLIP = 56,
  MXF_QUARK_START_POSITION = 57,
  MXF_QUARK_SOURCE_TRACK_ID = 58,
  MXF_QUARK_DM_SOURCE_CLIP = 59,
  MXF_QUARK_TRACK_IDS = 60,
  MXF_QUARK_DM_SEGMENT = 61,
  MXF_QUARK_EVENT_START_POSITION = 62,
  MXF_QUARK_EVENT_COMMENT = 63,
  MXF_QUARK_DM_FRAMEWORK = 64,
  MXF_QUARK_LOCATORS = 65,
  MXF_QUARK_FILE_DESCRIPTOR = 66,
  MXF_QUARK_LINKED_TRACK_ID = 67,
  MXF_QUARK_SAMPLE_RATE = 68,
  MXF_QUARK_CONTAINER_DURATION = 69,
  MXF_QUARK_ESSENCE_CONTAINER = 70,
  MXF_QUARK_CODEC = 71,
  MXF_QUARK_GENERIC_PICTURE_ESSENCE_DESCRIPTOR = 72,
  MXF_QUARK_SIGNAL_STANDARD = 73,
  MXF_QUARK_FRAME_LAYOUT = 74,
  MXF_QUARK_STORED_WIDTH = 75,
  MXF_QUARK_STORED_HEIGHT = 76,
  MXF_QUARK_STORED_F2_OFFSET = 77,
  MXF_QUARK_SAMPLED_WIDTH = 78,
  MXF_QUARK_SAMPLED_HEIGHT = 79,
  MXF_QUARK_SAMPLED_X_OFFSET = 80,
  MXF_QUARK_SAMPLED_Y_OFFSET = 81,
  MXF_QUARK_DISPLAY_HEIGHT = 82,
  MXF_QUARK_DISPLAY_WIDTH = 83,
  MXF_QUARK_DISPLAY_X_OFFSET = 84,
  MXF_QUARK_DISPLAY_Y_OFFSET = 85,
  MXF_QUARK_DISPLAY_F2_OFFSET = 86,
  MXF_QUARK_ASPECT_RATIO = 87,
  MXF_QUARK_ACTIVE_FORMAT_DESCRIPTOR = 88,
  MXF_QUARK_VIDEO_LINE_MAP_0 = 89,
  MXF_QUARK_VIDEO_LINE_MAP_1 = 90,
  MXF_QUARK_ALPHA_TRANSPARENCY = 91,
  MXF_QUARK_CAPTURE_GAMMA = 92,
  MXF_QUARK_IMAGE_ALIGNMENT_OFFSET = 93,
  MXF_QUARK_IMAGE_START_OFFSET = 94,
  MXF_QUARK_IMAGE_END_OFFSET = 95,
  MXF_QUARK_FIELD_DOMINANCE = 96,
  MXF_QUARK_PICTURE_ESSENCE_CODING = 97,
  MXF_QUARK_CDCI_PICTURE_ESSENCE_DESCRIPTOR = 98,
  MXF_QUARK_COMPONENT_DEPTH = 99,
  MXF_QUARK_HORIZONTAL_SUBSAMPLING = 100,
  MXF_QUARK_VERTICAL_SUBSAMPLING = 101,
  MXF_QUARK_COLOR_SITING = 102,
  MXF_QUARK_REVERSED_BYTE_ORDER = 103,
  MXF_QUARK_PADDING_BITS = 104,
  MXF_QUARK_ALPHA_SAMPLE_DEPTH = 105,
  MXF_QUARK_BLACK_REF_LEVEL = 106,
  MXF_QUARK_WHITE_REF_LEVEL = 107,
  MXF_QUARK_COLOR_RANGE = 108,
  MXF_QUARK_RGBA_PICTURE_ESSENCE_DESCRIPTOR = 109,
  MXF_QUARK_COMPONENT_MAX_REF = 110,
  MXF_QUARK_COMPONENT_MIN_REF = 111,
  MXF_QUARK_ALPHA_MAX_REF = 112,
  MXF_QUARK_ALPHA_MIN_REF = 113,
  MXF_QUARK_SCANNING_DIRECTION = 114,
  MXF_QUARK_PIXEL_LAYOUT = 115,
  MXF_QUARK_GENERIC_SOUND_ESSENCE_DESCRIPTOR = 116,
  MXF_QUARK_AUDIO_SAMPLING_RATE = 117,
  MXF_QUARK_LOCKED = 118,
  MXF_QUARK_AUDIO_REF_LEVEL = 119,
  MXF_QUARK_ELECTRO_SPATIAL_FORMULATION = 120,
  MXF_QUARK_CHANNEL_COUNT = 121,
  MXF_QUARK_QUANTIZATION_BITS = 122,
  MXF_QUARK_DIAL_NORM = 123,
  MXF_QUARK_SOUND_ESSENCE_COMPRESSION = 124,
  MXF_QUARK_GENERIC_DATA_ESSENCE_DESCRIPTOR = 125,
  MXF_QUARK_DATA_ESSENCE_CODING = 126,
  MXF_QUARK_MULTIPLE_DESCRIPTOR = 127,
  MXF_QUARK_SUB_DESCRIPTORS = 128,
  MXF_QUARK_TEXT_LOCATOR = 129,
  MXF_QUARK_LOCATOR_NAME = 130,
  MXF_QUARK_NETWORK_LOCATOR = 131,
  MXF_QUARK_URL_STRING = 132,
  MXF_QUARK_WAVE_AUDIO_ESSENCE_DESCRIPTOR = 133,
  MXF_QUARK_BLOCK_ALIGN = 134,
  MXF_QUARK_SEQUENCE_OFFSET = 135,
  MXF_QUARK_AVG_BPS = 136,
  MXF_QUARK_CHANNEL_ASSIGNMENT = 137,
  MXF_QUARK_PEAK_ENVELOPE_VERSION = 138,
  MXF_QUARK_PEAK_ENVELOPE_FORMAT = 139,
  MXF_QUARK_POINTS_PER_PEAK_VALUE = 140,
  MXF_QUARK_PEAK_ENVELOPE_BLOCK_SIZE = 141,
  MXF_QUARK_PEAK_CHANNELS = 142,
  MXF_QUARK_PEAK_FRAMES = 143,
  MXF_QUARK_PEAK_OF_PEAKS_POSITION = 144,
  MXF_QUARK_PEAK_ENVELOPE_TIMESTAMP = 145,
  MXF_QUARK_PEAK_ENVELOPE_DATA = 146,
  MXF_QUARK_AES3_AUDIO_ESSENCE_DESCRIPTOR = 147,
  MXF_QUARK_EMPHASIS = 148,
  MXF_QUARK_BLOCK_START_OFFSET = 149,
  MXF_QUARK_AUXILIARY_BITS_MODE = 150,
  MXF_QUARK_CHANNEL_STATUS_MODE = 151,
  MXF_QUARK_FIXED_CHANNEL_STATUS_DATA = 152,
  MXF_QUARK_USER_DATA_MODE = 153,
  MXF_QUARK_FIXED_USER_DATA = 154,
  MXF_QUARK_LINKED_TIMECODE_TRACK_ID = 155,
  MXF_QUARK_STREAM_NUMBER = 156,
  MXF_QUARK_MPEG_VIDEO_DESCRIPTOR = 157,
  MXF_QUARK_SINGLE_SEQUENCE = 158,
  MXF_QUARK_CONST_B_FRAMES = 159,
  MXF_QUARK_CODED_CONTENT_TYPE = 160,
  MXF_QUARK_LOW_DELAY = 161,
  MXF_QUARK_CLOSED_GOP = 162,
  MXF_QUARK_IDENTICAL_GOP = 163,
  MXF_QUARK_MAX_GOP = 164,
  MXF_QUARK_B_PICTURE_COUNT = 165,
  MXF_QUARK_BITRATE = 166,
  MXF_QUARK_PROFILE_AND_LEVEL = 167,
  MXF_QUARK_FILLER = 168,

  MXF_QUARK_MAX
} MXFQuarkId;
</ENUM>
<MACRO>
<NAME>MXF_QUARK</NAME>
#define MXF_QUARK(q) _mxf_quark_table[MXF_QUARK_##q]
</MACRO>
<FUNCTION>
<NAME>mxf_quark_initialize</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>MXFEssenceWrapping</NAME>
typedef enum {
  MXF_ESSENCE_WRAPPING_FRAME_WRAPPING,
  MXF_ESSENCE_WRAPPING_CLIP_WRAPPING,
  MXF_ESSENCE_WRAPPING_CUSTOM_WRAPPING
} MXFEssenceWrapping;
</ENUM>
<USER_FUNCTION>
<NAME>MXFEssenceElementHandleFunc</NAME>
<RETURNS>GstFlowReturn </RETURNS>
const MXFUL *key, GstBuffer *buffer, GstCaps *caps, MXFMetadataTimelineTrack *track, gpointer mapping_data, GstBuffer **outbuf
</USER_FUNCTION>
<STRUCT>
<NAME>MXFEssenceElementHandler</NAME>
typedef struct {
  gboolean (*handles_track) (const MXFMetadataTimelineTrack *track);
  MXFEssenceWrapping (*get_track_wrapping) (const MXFMetadataTimelineTrack *track);
  GstCaps * (*create_caps) (MXFMetadataTimelineTrack *track, GstTagList **tags, gboolean * intra_only, MXFEssenceElementHandleFunc *handler, gpointer *mapping_data);
} MXFEssenceElementHandler;
</STRUCT>
<USER_FUNCTION>
<NAME>MXFEssenceElementWriteFunc</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstBuffer *buffer, gpointer mapping_data, GstAdapter *adapter, GstBuffer **outbuf, gboolean flush
</USER_FUNCTION>
<STRUCT>
<NAME>MXFEssenceElementWriter</NAME>
typedef struct {
   MXFMetadataFileDescriptor * (*get_descriptor) (GstPadTemplate *tmpl, GstCaps *caps, MXFEssenceElementWriteFunc *handler, gpointer *mapping_data);
   void (*update_descriptor) (MXFMetadataFileDescriptor *d, GstCaps *caps, gpointer mapping_data, GstBuffer *buf);
   void (*get_edit_rate) (MXFMetadataFileDescriptor *a, GstCaps *caps, gpointer mapping_data, GstBuffer *buf, MXFMetadataSourcePackage *package, MXFMetadataTimelineTrack *track, MXFFraction *edit_rate);
   guint32 (*get_track_number_template) (MXFMetadataFileDescriptor *a, GstCaps *caps, gpointer mapping_data);
   const GstPadTemplate *pad_template;
   MXFUL data_definition;
} MXFEssenceElementWriter;
</STRUCT>
<FUNCTION>
<NAME>mxf_essence_element_handler_register</NAME>
<RETURNS>void  </RETURNS>
const MXFEssenceElementHandler *handler
</FUNCTION>
<FUNCTION>
<NAME>mxf_essence_element_handler_find</NAME>
<RETURNS>const MXFEssenceElementHandler  * </RETURNS>
const MXFMetadataTimelineTrack *track
</FUNCTION>
<FUNCTION>
<NAME>mxf_essence_element_writer_register</NAME>
<RETURNS>void  </RETURNS>
const MXFEssenceElementWriter *writer
</FUNCTION>
<FUNCTION>
<NAME>mxf_essence_element_writer_get_pad_templates</NAME>
<RETURNS>const GstPadTemplate  ** </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxf_essence_element_writer_find</NAME>
<RETURNS>const MXFEssenceElementWriter  *</RETURNS>
const GstPadTemplate *templ
</FUNCTION>
<FUNCTION>
<NAME>mxf_up_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxf_aes_bwf_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxf_mpeg_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>mxf_mpeg_is_mpeg2_keyframe</NAME>
<RETURNS>gboolean  </RETURNS>
GstBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>mxf_dv_dif_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>MXFUUID</NAME>
typedef struct {
  guint8 u[16];
} MXFUUID;
</STRUCT>
<STRUCT>
<NAME>MXFUMID</NAME>
typedef struct {
  guint8 u[32];
} MXFUMID;
</STRUCT>
<STRUCT>
<NAME>MXFTimestamp</NAME>
typedef struct {
  gint16 year;
  guint8 month;
  guint8 day;
  guint8 hour;
  guint8 minute;
  guint8 second;
  guint16 msecond;
} MXFTimestamp;
</STRUCT>
<STRUCT>
<NAME>MXFProductVersion</NAME>
typedef struct {
  guint16 major;
  guint16 minor;
  guint16 patch;
  guint16 build;
  guint16 release;
} MXFProductVersion;
</STRUCT>
<STRUCT>
<NAME>MXFFraction</NAME>
typedef struct {
  gint32 n;
  gint32 d;
} MXFFraction;
</STRUCT>
<STRUCT>
<NAME>MXFLocalTag</NAME>
typedef struct {
  MXFUL ul;
  guint16 size;
  guint8 *data;
  
  gboolean g_slice; /* TRUE if data was allocated by GSlice */
} MXFLocalTag;
</STRUCT>
<STRUCT>
<NAME>MXFRandomIndexPackEntry</NAME>
typedef struct {
  guint32 body_sid;
  guint64 offset;
} MXFRandomIndexPackEntry;
</STRUCT>
<ENUM>
<NAME>MXFOperationalPattern</NAME>
typedef enum {
  MXF_OP_UNKNOWN = 0,
  MXF_OP_ATOM,
  MXF_OP_1a,
  MXF_OP_1b,
  MXF_OP_1c,
  MXF_OP_2a,
  MXF_OP_2b,
  MXF_OP_2c,
  MXF_OP_3a,
  MXF_OP_3b,
  MXF_OP_3c,
} MXFOperationalPattern;
</ENUM>
<ENUM>
<NAME>MXFPartitionPackType</NAME>
typedef enum {
  MXF_PARTITION_PACK_HEADER,
  MXF_PARTITION_PACK_BODY,
  MXF_PARTITION_PACK_FOOTER
} MXFPartitionPackType;
</ENUM>
<STRUCT>
<NAME>MXFPartitionPack</NAME>
typedef struct {
  MXFPartitionPackType type;

  gboolean closed;
  gboolean complete;

  guint16 major_version;
  guint16 minor_version;

  guint32 kag_size;

  guint64 this_partition;
  guint64 prev_partition;
  guint64 footer_partition;

  guint64 header_byte_count;
  guint64 index_byte_count;

  guint32 index_sid;

  guint64 body_offset;

  guint32 body_sid;

  MXFUL operational_pattern;

  guint32 n_essence_containers;
  MXFUL *essence_containers;
} MXFPartitionPack;
</STRUCT>
<STRUCT>
<NAME>MXFPrimerPack</NAME>
typedef struct {
  guint64 offset;
  GHashTable *mappings;
  GHashTable *reverse_mappings;
  guint16 next_free_tag;
} MXFPrimerPack;
</STRUCT>
<STRUCT>
<NAME>MXFDeltaEntry</NAME>
typedef struct {
  gint8 pos_table_index;
  guint8 slice;
  guint32 element_delta;
} MXFDeltaEntry;
</STRUCT>
<STRUCT>
<NAME>MXFIndexEntry</NAME>
typedef struct {
  gint8 temporal_offset;
  gint8 key_frame_offset;

  guint8 flags;
  guint64 stream_offset;

  guint32 *slice_offset;
  MXFFraction *pos_table;
} MXFIndexEntry;
</STRUCT>
<STRUCT>
<NAME>MXFIndexTableSegment</NAME>
typedef struct {
  MXFUUID instance_id;
  MXFFraction index_edit_rate;
  gint64 index_start_position;
  gint64 index_duration;
  guint32 edit_unit_byte_count;
  guint32 index_sid;
  guint32 body_sid;
  guint8 slice_count;
  guint8 pos_table_count;

  guint32 n_delta_entries;
  MXFDeltaEntry *delta_entries;

  guint32 n_index_entries;
  MXFIndexEntry *index_entries;
} MXFIndexTableSegment;
</STRUCT>
<MACRO>
<NAME>GST_TAG_MXF_UMID</NAME>
#define GST_TAG_MXF_UMID "mxf-umid"
</MACRO>
<MACRO>
<NAME>GST_TAG_MXF_STRUCTURE</NAME>
#define GST_TAG_MXF_STRUCTURE "mxf-structure"
</MACRO>
<MACRO>
<NAME>GST_TAG_MXF_DESCRIPTIVE_METADATA_FRAMEWORK</NAME>
#define GST_TAG_MXF_DESCRIPTIVE_METADATA_FRAMEWORK "mxf-descriptive-metadata-framework"
</MACRO>
<FUNCTION>
<NAME>mxf_uuid_init</NAME>
<RETURNS>void  </RETURNS>
MXFUUID *uuid, GHashTable *hashtable
</FUNCTION>
<FUNCTION>
<NAME>mxf_uuid_is_equal</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUUID *a, const MXFUUID *b
</FUNCTION>
<FUNCTION>
<NAME>mxf_uuid_is_zero</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUUID *uuid
</FUNCTION>
<FUNCTION>
<NAME>mxf_uuid_hash</NAME>
<RETURNS>guint  </RETURNS>
const MXFUUID *uuid
</FUNCTION>
<FUNCTION>
<NAME>mxf_uuid_to_string</NAME>
<RETURNS>gchar  * </RETURNS>
const MXFUUID *uuid, gchar str[48]
</FUNCTION>
<FUNCTION>
<NAME>mxf_uuid_from_string</NAME>
<RETURNS>MXFUUID  * </RETURNS>
const gchar *str, MXFUUID *uuid
</FUNCTION>
<FUNCTION>
<NAME>mxf_uuid_array_parse</NAME>
<RETURNS>gboolean  </RETURNS>
MXFUUID ** array, guint32 * count, const guint8 * data, guint size
</FUNCTION>
<FUNCTION>
<NAME>mxf_umid_to_string</NAME>
<RETURNS>gchar  *</RETURNS>
const MXFUMID * umid, gchar str[96]
</FUNCTION>
<FUNCTION>
<NAME>mxf_umid_from_string</NAME>
<RETURNS>MXFUMID  *</RETURNS>
const gchar *str, MXFUMID * umid
</FUNCTION>
<FUNCTION>
<NAME>mxf_umid_is_equal</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUMID *a, const MXFUMID *b
</FUNCTION>
<FUNCTION>
<NAME>mxf_umid_is_zero</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUMID *umid
</FUNCTION>
<FUNCTION>
<NAME>mxf_umid_init</NAME>
<RETURNS>void  </RETURNS>
MXFUMID *umid
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_mxf_packet</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_partition_pack</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_header_partition_pack</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_body_partition_pack</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_footer_partition_pack</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_primer_pack</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_metadata</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_descriptive_metadata</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_random_index_pack</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_index_table_segment</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_generic_container_system_item</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_generic_container_essence_element</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_avid_essence_container_essence_element</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL * key
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_generic_container_essence_container_label</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_avid_essence_container_label</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_is_fill</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_ber_encode_size</NAME>
<RETURNS>guint  </RETURNS>
guint size, guint8 ber[9]
</FUNCTION>
<FUNCTION>
<NAME>mxf_utf16_to_utf8</NAME>
<RETURNS>gchar  * </RETURNS>
const guint8 * data, guint size
</FUNCTION>
<FUNCTION>
<NAME>mxf_utf8_to_utf16</NAME>
<RETURNS>guint8  * </RETURNS>
const gchar *str, guint16 *size
</FUNCTION>
<FUNCTION>
<NAME>mxf_product_version_parse</NAME>
<RETURNS>gboolean  </RETURNS>
MXFProductVersion * product_version, const guint8 * data, guint size
</FUNCTION>
<FUNCTION>
<NAME>mxf_product_version_is_valid</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFProductVersion *version
</FUNCTION>
<FUNCTION>
<NAME>mxf_product_version_write</NAME>
<RETURNS>void  </RETURNS>
const MXFProductVersion *version, guint8 *data
</FUNCTION>
<FUNCTION>
<NAME>mxf_fraction_parse</NAME>
<RETURNS>gboolean  </RETURNS>
MXFFraction *fraction, const guint8 *data, guint size
</FUNCTION>
<FUNCTION>
<NAME>mxf_fraction_to_double</NAME>
<RETURNS>gdouble  </RETURNS>
const MXFFraction *fraction
</FUNCTION>
<FUNCTION>
<NAME>mxf_timestamp_parse</NAME>
<RETURNS>gboolean  </RETURNS>
MXFTimestamp * timestamp, const guint8 * data, guint size
</FUNCTION>
<FUNCTION>
<NAME>mxf_timestamp_is_unknown</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFTimestamp *a
</FUNCTION>
<FUNCTION>
<NAME>mxf_timestamp_compare</NAME>
<RETURNS>gint  </RETURNS>
const MXFTimestamp *a, const MXFTimestamp *b
</FUNCTION>
<FUNCTION>
<NAME>mxf_timestamp_to_string</NAME>
<RETURNS>gchar  *</RETURNS>
const MXFTimestamp *t, gchar str[32]
</FUNCTION>
<FUNCTION>
<NAME>mxf_timestamp_set_now</NAME>
<RETURNS>void  </RETURNS>
MXFTimestamp *timestamp
</FUNCTION>
<FUNCTION>
<NAME>mxf_timestamp_write</NAME>
<RETURNS>void  </RETURNS>
const MXFTimestamp *timestamp, guint8 *data
</FUNCTION>
<FUNCTION>
<NAME>mxf_op_set_atom</NAME>
<RETURNS>void  </RETURNS>
MXFUL *ul, gboolean single_sourceclip, gboolean single_essence_track
</FUNCTION>
<FUNCTION>
<NAME>mxf_op_set_generalized</NAME>
<RETURNS>void  </RETURNS>
MXFUL *ul, MXFOperationalPattern pattern, gboolean internal_essence, gboolean streamable, gboolean single_track
</FUNCTION>
<FUNCTION>
<NAME>mxf_fill_to_buffer</NAME>
<RETURNS>GstBuffer  * </RETURNS>
guint size
</FUNCTION>
<FUNCTION>
<NAME>mxf_partition_pack_parse</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul, MXFPartitionPack *pack, const guint8 *data, guint size
</FUNCTION>
<FUNCTION>
<NAME>mxf_partition_pack_reset</NAME>
<RETURNS>void  </RETURNS>
MXFPartitionPack *pack
</FUNCTION>
<FUNCTION>
<NAME>mxf_partition_pack_to_buffer</NAME>
<RETURNS>GstBuffer  * </RETURNS>
const MXFPartitionPack *pack
</FUNCTION>
<FUNCTION>
<NAME>mxf_primer_pack_parse</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul, MXFPrimerPack *pack, const guint8 *data, guint size
</FUNCTION>
<FUNCTION>
<NAME>mxf_primer_pack_reset</NAME>
<RETURNS>void  </RETURNS>
MXFPrimerPack *pack
</FUNCTION>
<FUNCTION>
<NAME>mxf_primer_pack_add_mapping</NAME>
<RETURNS>guint16  </RETURNS>
MXFPrimerPack *primer, guint16 local_tag, const MXFUL *ul
</FUNCTION>
<FUNCTION>
<NAME>mxf_primer_pack_to_buffer</NAME>
<RETURNS>GstBuffer  * </RETURNS>
const MXFPrimerPack *pack
</FUNCTION>
<FUNCTION>
<NAME>mxf_random_index_pack_parse</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul, const guint8 *data, guint size, GArray **array
</FUNCTION>
<FUNCTION>
<NAME>mxf_random_index_pack_to_buffer</NAME>
<RETURNS>GstBuffer  * </RETURNS>
const GArray *array
</FUNCTION>
<FUNCTION>
<NAME>mxf_index_table_segment_parse</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFUL *ul, MXFIndexTableSegment *segment, const guint8 *data, guint size
</FUNCTION>
<FUNCTION>
<NAME>mxf_index_table_segment_reset</NAME>
<RETURNS>void  </RETURNS>
MXFIndexTableSegment *segment
</FUNCTION>
<FUNCTION>
<NAME>mxf_index_table_segment_to_buffer</NAME>
<RETURNS>GstBuffer  * </RETURNS>
const MXFIndexTableSegment *segment
</FUNCTION>
<FUNCTION>
<NAME>mxf_local_tag_parse</NAME>
<RETURNS>gboolean  </RETURNS>
const guint8 * data, guint size, guint16 * tag, guint16 * tag_size, const guint8 ** tag_data
</FUNCTION>
<FUNCTION>
<NAME>mxf_local_tag_free</NAME>
<RETURNS>void  </RETURNS>
MXFLocalTag *tag
</FUNCTION>
<FUNCTION>
<NAME>mxf_local_tag_add_to_hash_table</NAME>
<RETURNS>gboolean  </RETURNS>
const MXFPrimerPack *primer, guint16 tag, const guint8 *tag_data, guint16 tag_size, GHashTable **hash_table
</FUNCTION>
<FUNCTION>
<NAME>mxf_local_tag_insert</NAME>
<RETURNS>gboolean  </RETURNS>
MXFLocalTag *tag, GHashTable **hash_table
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SIMPLE_VIDEO_MARK</NAME>
#define GST_TYPE_SIMPLE_VIDEO_MARK   (gst_video_mark_get_type())
</MACRO>
<MACRO>
<NAME>GST_SIMPLE_VIDEO_MARK</NAME>
#define GST_SIMPLE_VIDEO_MARK(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SIMPLE_VIDEO_MARK,GstSimpleVideoMark))
</MACRO>
<MACRO>
<NAME>GST_SIMPLE_VIDEO_MARK_CLASS</NAME>
#define GST_SIMPLE_VIDEO_MARK_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SIMPLE_VIDEO_MARK,GstSimpleVideoMarkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SIMPLE_VIDEO_MARK</NAME>
#define GST_IS_SIMPLE_VIDEO_MARK(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SIMPLE_VIDEO_MARK))
</MACRO>
<MACRO>
<NAME>GST_IS_SIMPLE_VIDEO_MARK_CLASS</NAME>
#define GST_IS_SIMPLE_VIDEO_MARK_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SIMPLE_VIDEO_MARK))
</MACRO>
<STRUCT>
<NAME>GstSimpleVideoMark</NAME>
struct _GstSimpleVideoMark
{
  GstVideoFilter base_simplevideomark;

  /* properties */
  gint pattern_width;
  gint pattern_height;
  gint pattern_count;
  gint pattern_data_count;
  guint64 pattern_data;
  gboolean enabled;
  gint left_offset;
  gint bottom_offset;
};
</STRUCT>
<STRUCT>
<NAME>GstSimpleVideoMarkClass</NAME>
struct _GstSimpleVideoMarkClass
{
  GstVideoFilterClass base_simplevideomark_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_mark_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SIMPLE_VIDEO_MARK_DETECT</NAME>
#define GST_TYPE_SIMPLE_VIDEO_MARK_DETECT   (gst_video_detect_get_type())
</MACRO>
<MACRO>
<NAME>GST_SIMPLE_VIDEO_MARK_DETECT</NAME>
#define GST_SIMPLE_VIDEO_MARK_DETECT(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SIMPLE_VIDEO_MARK_DETECT,GstSimpleVideoMarkDetect))
</MACRO>
<MACRO>
<NAME>GST_SIMPLE_VIDEO_MARK_DETECT_CLASS</NAME>
#define GST_SIMPLE_VIDEO_MARK_DETECT_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SIMPLE_VIDEO_MARK_DETECT,GstSimpleVideoMarkDetectClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SIMPLE_VIDEO_MARK_DETECT</NAME>
#define GST_IS_SIMPLE_VIDEO_MARK_DETECT(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SIMPLE_VIDEO_MARK_DETECT))
</MACRO>
<MACRO>
<NAME>GST_IS_SIMPLE_VIDEO_MARK_DETECT_CLASS</NAME>
#define GST_IS_SIMPLE_VIDEO_MARK_DETECT_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SIMPLE_VIDEO_MARK_DETECT))
</MACRO>
<STRUCT>
<NAME>GstSimpleVideoMarkDetect</NAME>
struct _GstSimpleVideoMarkDetect
{
  GstVideoFilter base_simplevideomarkdetect;

  gboolean message;
  gint pattern_width;
  gint pattern_height;
  gint pattern_count;
  gint pattern_data_count;
  gdouble pattern_center;
  gdouble pattern_sensitivity;
  gint left_offset;
  gint bottom_offset;

  gboolean in_pattern;
};
</STRUCT>
<STRUCT>
<NAME>GstSimpleVideoMarkDetectClass</NAME>
struct _GstSimpleVideoMarkDetectClass
{
  GstVideoFilterClass base_simplevideomarkdetect_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_detect_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DIGITAL_ZOOM</NAME>
#define GST_TYPE_DIGITAL_ZOOM \
  (gst_digital_zoom_get_type())
</MACRO>
<MACRO>
<NAME>GST_DIGITAL_ZOOM</NAME>
#define GST_DIGITAL_ZOOM(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DIGITAL_ZOOM,GstDigitalZoom))
</MACRO>
<MACRO>
<NAME>GST_DIGITAL_ZOOM_CLASS</NAME>
#define GST_DIGITAL_ZOOM_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DIGITAL_ZOOM,GstDigitalZoomClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DIGITAL_ZOOM</NAME>
#define GST_IS_DIGITAL_ZOOM(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DIGITAL_ZOOM))
</MACRO>
<MACRO>
<NAME>GST_IS_DIGITAL_ZOOM_CLASS</NAME>
#define GST_IS_DIGITAL_ZOOM_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DIGITAL_ZOOM))
</MACRO>
<MACRO>
<NAME>GST_DIGITAL_ZOOM_CAST</NAME>
#define GST_DIGITAL_ZOOM_CAST(d) ((GstDigitalZoom *)(d))
</MACRO>
<FUNCTION>
<NAME>gst_digital_zoom_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstDigitalZoom</NAME>
struct _GstDigitalZoom
{
  GstBin parent;

  GstPad *srcpad;
  GstPad *sinkpad;

  gboolean elements_created;
  GstElement *videocrop;
  GstElement *videoscale;
  GstElement *capsfilter;

  GstPad *capsfilter_sinkpad;

  gfloat zoom;
};
</STRUCT>
<STRUCT>
<NAME>GstDigitalZoomClass</NAME>
struct _GstDigitalZoomClass
{
  GstBinClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_camerabin_try_add_element</NAME>
<RETURNS>gboolean  </RETURNS>
GstBin * bin, const gchar * srcpad, GstElement * new_elem, const gchar * dstpad
</FUNCTION>
<FUNCTION>
<NAME>gst_camerabin_add_element</NAME>
<RETURNS>gboolean  </RETURNS>
GstBin * bin, GstElement * new_elem
</FUNCTION>
<FUNCTION>
<NAME>gst_camerabin_add_element_full</NAME>
<RETURNS>gboolean  </RETURNS>
GstBin * bin, const gchar * srcpad, GstElement * new_elem, const gchar * dstpad
</FUNCTION>
<FUNCTION>
<NAME>gst_camerabin_create_and_add_element</NAME>
<RETURNS>GstElement  *</RETURNS>
GstBin * bin, const gchar * elem_name, const gchar * instance_name
</FUNCTION>
<FUNCTION>
<NAME>gst_camerabin_setup_default_element</NAME>
<RETURNS>GstElement  * </RETURNS>
GstBin * bin, GstElement *user_elem, const gchar *auto_elem_name, const gchar *default_elem_name, const gchar * instance_elem_name
</FUNCTION>
<FUNCTION>
<NAME>gst_camerabin_remove_elements_from_bin</NAME>
<RETURNS>void  </RETURNS>
GstBin * bin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WRAPPER_CAMERA_BIN_SRC</NAME>
#define GST_TYPE_WRAPPER_CAMERA_BIN_SRC \
  (gst_wrapper_camera_bin_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_WRAPPER_CAMERA_BIN_SRC</NAME>
#define GST_WRAPPER_CAMERA_BIN_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WRAPPER_CAMERA_BIN_SRC,GstWrapperCameraBinSrc))
</MACRO>
<MACRO>
<NAME>GST_WRAPPER_CAMERA_BIN_SRC_CLASS</NAME>
#define GST_WRAPPER_CAMERA_BIN_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WRAPPER_CAMERA_BIN_SRC,GstWrapperCameraBinSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WRAPPER_CAMERA_BIN_SRC</NAME>
#define GST_IS_WRAPPER_CAMERA_BIN_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WRAPPER_CAMERA_BIN_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_WRAPPER_CAMERA_BIN_SRC_CLASS</NAME>
#define GST_IS_WRAPPER_CAMERA_BIN_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WRAPPER_CAMERA_BIN_SRC))
</MACRO>
<FUNCTION>
<NAME>gst_wrapper_camera_bin_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstVideoRecordingStatus</NAME>
enum GstVideoRecordingStatus {
  GST_VIDEO_RECORDING_STATUS_DONE,
  GST_VIDEO_RECORDING_STATUS_STARTING,
  GST_VIDEO_RECORDING_STATUS_RUNNING,
  GST_VIDEO_RECORDING_STATUS_FINISHING
};
</ENUM>
<STRUCT>
<NAME>GstWrapperCameraBinSrc</NAME>
struct _GstWrapperCameraBinSrc
{
  GstBaseCameraSrc parent;

  GstCameraBinMode mode;

  GstPad *srcfilter_pad;
  GstPad *vfsrc;
  GstPad *imgsrc;
  GstPad *vidsrc;

  /* video recording controls */
  gint video_rec_status;

  /* image capture controls */
  gint image_capture_count;

  /* source elements */
  GstElement *src_vid_src;
  GstElement *video_filter;
  GstElement *src_filter;
  GstElement *digitalzoom;

  /* Pad from our last element that is linked
   * with the output pads */
  GstPad *src_pad;

  GstPad *video_tee_vf_pad;
  GstPad *video_tee_sink;

  gboolean elements_created;

  gulong src_event_probe_id;
  gulong src_max_zoom_signal_id;
  gulong image_capture_probe;
  gulong video_capture_probe;

  /* Application configurable elements */
  GstElement *app_vid_src;
  GstElement *app_vid_filter;

  /* Caps that videosrc supports */
  GstCaps *allowed_caps;

  /* Optional crop for frames. Used to crop frames e.g.
     due to wrong aspect ratio. Done before the crop related to zooming. */
  GstElement *src_crop;

  /* Caps applied to capsfilters when in view finder mode */
  GstCaps *view_finder_caps;

  /* Caps applied to capsfilters when taking still image */
  GstCaps *image_capture_caps;
  gboolean image_renegotiate;
  gboolean video_renegotiate;
};
</STRUCT>
<STRUCT>
<NAME>GstWrapperCameraBinSrcClass</NAME>
struct _GstWrapperCameraBinSrcClass
{
  GstBaseCameraSrcClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wrapper_camera_bin_src_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VIEWFINDER_BIN</NAME>
#define GST_TYPE_VIEWFINDER_BIN   (gst_viewfinder_bin_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIEWFINDER_BIN</NAME>
#define GST_VIEWFINDER_BIN(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIEWFINDER_BIN,GstViewfinderBin))
</MACRO>
<MACRO>
<NAME>GST_VIEWFINDER_BIN_CAST</NAME>
#define GST_VIEWFINDER_BIN_CAST(obj)   ((GstViewfinderBin *) obj)
</MACRO>
<MACRO>
<NAME>GST_VIEWFINDER_BIN_CLASS</NAME>
#define GST_VIEWFINDER_BIN_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIEWFINDER_BIN,GstViewfinderBinClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIEWFINDER_BIN</NAME>
#define GST_IS_VIEWFINDER_BIN(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIEWFINDER_BIN))
</MACRO>
<MACRO>
<NAME>GST_IS_VIEWFINDER_BIN_CLASS</NAME>
#define GST_IS_VIEWFINDER_BIN_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIEWFINDER_BIN))
</MACRO>
<STRUCT>
<NAME>GstViewfinderBin</NAME>
struct _GstViewfinderBin
{
  GstBin bin;

  GstPad *ghostpad;

  GstElement *video_sink;
  GstElement *user_video_sink;

  gboolean elements_created;

  gboolean disable_converters;
};
</STRUCT>
<STRUCT>
<NAME>GstViewfinderBinClass</NAME>
struct _GstViewfinderBinClass
{
  GstBinClass bin_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_viewfinder_bin_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_viewfinder_bin_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>VAD_SILENCE</NAME>
#define VAD_SILENCE  0
</MACRO>
<MACRO>
<NAME>VAD_VOICE</NAME>
#define VAD_VOICE    1
</MACRO>
<TYPEDEF>
<NAME>VADFilter</NAME>
typedef struct _vad_s VADFilter;
</TYPEDEF>
<FUNCTION>
<NAME>vad_update</NAME>
<RETURNS>gint  </RETURNS>
VADFilter *p, gint16 *data, gint len
</FUNCTION>
<FUNCTION>
<NAME>vad_set_hysteresis</NAME>
<RETURNS>void  </RETURNS>
VADFilter *p, guint64 hysteresis
</FUNCTION>
<FUNCTION>
<NAME>vad_get_hysteresis</NAME>
<RETURNS>guint64  </RETURNS>
VADFilter *p
</FUNCTION>
<FUNCTION>
<NAME>vad_new</NAME>
<RETURNS>VADFilter * </RETURNS>
guint64 hysteresis
</FUNCTION>
<FUNCTION>
<NAME>vad_reset</NAME>
<RETURNS>void  </RETURNS>
VADFilter *p
</FUNCTION>
<FUNCTION>
<NAME>vad_destroy</NAME>
<RETURNS>void  </RETURNS>
VADFilter *p
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_REMOVE_SILENCE</NAME>
#define GST_TYPE_REMOVE_SILENCE \
  (gst_remove_silence_get_type())
</MACRO>
<MACRO>
<NAME>GST_REMOVE_SILENCE</NAME>
#define GST_REMOVE_SILENCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_REMOVE_SILENCE,GstRemoveSilence))
</MACRO>
<MACRO>
<NAME>GST_REMOVE_SILENCE_CLASS</NAME>
#define GST_REMOVE_SILENCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_REMOVE_SILENCE,GstRemoveSilenceClass))
</MACRO>
<MACRO>
<NAME>GST_IS_REMOVESILENCE</NAME>
#define GST_IS_REMOVESILENCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_REMOVE_SILENCE))
</MACRO>
<MACRO>
<NAME>GST_IS_REMOVESILENCE_CLASS</NAME>
#define GST_IS_REMOVESILENCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_REMOVE_SILENCE))
</MACRO>
<STRUCT>
<NAME>GstRemoveSilence</NAME>
typedef struct _GstRemoveSilence {
  GstBaseTransform parent;
  VADFilter* vad;
  gboolean remove;
} GstRemoveSilence;
</STRUCT>
<STRUCT>
<NAME>GstRemoveSilenceClass</NAME>
typedef struct _GstRemoveSilenceClass {
  GstBaseTransformClass parent_class;
} GstRemoveSilenceClass;
</STRUCT>
<FUNCTION>
<NAME>gst_remove_silence_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_Y4M_DEC</NAME>
#define GST_TYPE_Y4M_DEC   (gst_y4m_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_Y4M_DEC</NAME>
#define GST_Y4M_DEC(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_Y4M_DEC,GstY4mDec))
</MACRO>
<MACRO>
<NAME>GST_Y4M_DEC_CLASS</NAME>
#define GST_Y4M_DEC_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_Y4M_DEC,GstY4mDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_Y4M_DEC</NAME>
#define GST_IS_Y4M_DEC(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_Y4M_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_Y4M_DEC_CLASS</NAME>
#define GST_IS_Y4M_DEC_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_Y4M_DEC))
</MACRO>
<STRUCT>
<NAME>GstY4mDec</NAME>
struct _GstY4mDec
{
  GstElement base_y4mdec;

  GstPad *sinkpad;
  GstPad *srcpad;
  GstAdapter *adapter;

  /* state */
  gboolean have_header;
  int frame_index;
  int header_size;

  gboolean have_new_segment;
  GstSegment segment;

  GstVideoInfo info;
  GstVideoInfo out_info;
  gboolean video_meta;
  GstBufferPool *pool;
};
</STRUCT>
<STRUCT>
<NAME>GstY4mDecClass</NAME>
struct _GstY4mDecClass
{
  GstElementClass base_y4mdec_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_y4m_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FREEVERB</NAME>
#define GST_TYPE_FREEVERB            (gst_freeverb_get_type())
</MACRO>
<MACRO>
<NAME>GST_FREEVERB</NAME>
#define GST_FREEVERB(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FREEVERB,GstFreeverb))
</MACRO>
<MACRO>
<NAME>GST_IS_FREEVERB</NAME>
#define GST_IS_FREEVERB(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FREEVERB))
</MACRO>
<MACRO>
<NAME>GST_FREEVERB_CLASS</NAME>
#define GST_FREEVERB_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_FREEVERB,GstFreeverbClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FREEVERB_CLASS</NAME>
#define GST_IS_FREEVERB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_FREEVERB))
</MACRO>
<MACRO>
<NAME>GST_FREEVERB_GET_CLASS</NAME>
#define GST_FREEVERB_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_FREEVERB,GstFreeverbClass))
</MACRO>
<USER_FUNCTION>
<NAME>GstFreeverbProcessFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstFreeverb*, guint8*, guint8*, guint
</USER_FUNCTION>
<STRUCT>
<NAME>GstFreeverb</NAME>
struct _GstFreeverb {
  GstBaseTransform element;
  
  /* < private > */
  gfloat room_size;
  gfloat damping;
  gfloat pan_width;
  gfloat level;

  GstFreeverbProcessFunc process;
  GstAudioInfo info;

  gboolean drained;
  
  GstFreeverbPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstFreeverbClass</NAME>
struct _GstFreeverbClass {
  GstBaseTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_freeverb_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstFreeverbPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_AVWAIT</NAME>
#define GST_TYPE_AVWAIT                    (gst_avwait_get_type())
</MACRO>
<MACRO>
<NAME>GST_AVWAIT</NAME>
#define GST_AVWAIT(obj)                    (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AVWAIT,GstAvWait))
</MACRO>
<MACRO>
<NAME>GST_IS_AVWAIT</NAME>
#define GST_IS_AVWAIT(obj)                 (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AVWAIT))
</MACRO>
<MACRO>
<NAME>GST_AVWAIT_CLASS</NAME>
#define GST_AVWAIT_CLASS(klass)            (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_AVWAIT,GstAvWaitClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AVWAIT_CLASS</NAME>
#define GST_IS_AVWAIT_CLASS(klass)         (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_AVWAIT))
</MACRO>
<MACRO>
<NAME>GST_AVWAIT_GET_CLASS</NAME>
#define GST_AVWAIT_GET_CLASS(obj)          (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_AVWAIT,GstAvWaitClass))
</MACRO>
<MACRO>
<NAME>GST_TYPE_AVWAIT_MODE</NAME>
#define GST_TYPE_AVWAIT_MODE (gst_avwait_mode_get_type ())
</MACRO>
<ENUM>
<NAME>GstAvWaitMode</NAME>
typedef enum
{
  MODE_TIMECODE,
  MODE_RUNNING_TIME,
  MODE_VIDEO_FIRST
} GstAvWaitMode;
</ENUM>
<STRUCT>
<NAME>GstAvWait</NAME>
struct _GstAvWait
{
  GstElement parent;

  GstVideoTimeCode *tc;
  gboolean from_string;
  GstClockTime target_running_time;
  GstAvWaitMode mode;

  GstPad *asrcpad, *asinkpad, *vsrcpad, *vsinkpad;

  GstAudioInfo ainfo;
  GstVideoInfo vinfo;

  GstSegment asegment, vsegment;

  GstClockTime running_time_to_wait_for;

  gboolean video_eos_flag;
  gboolean audio_flush_flag;
  gboolean shutdown_flag;

  GCond cond;
  GMutex mutex;
};
</STRUCT>
<STRUCT>
<NAME>GstAvWaitClass</NAME>
struct _GstAvWaitClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_avwait_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TIME_CODE_STAMPER</NAME>
#define GST_TYPE_TIME_CODE_STAMPER            (gst_timecodestamper_get_type())
</MACRO>
<MACRO>
<NAME>GST_TIME_CODE_STAMPER</NAME>
#define GST_TIME_CODE_STAMPER(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TIME_CODE_STAMPER,GstTimeCodeStamper))
</MACRO>
<MACRO>
<NAME>GST_TIME_CODE_STAMPER_CLASS</NAME>
#define GST_TIME_CODE_STAMPER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_TIME_CODE_STAMPER,GstTimeCodeStamperClass))
</MACRO>
<MACRO>
<NAME>GST_TIME_CODE_STAMPER_GET_CLASS</NAME>
#define GST_TIME_CODE_STAMPER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj), GST_TYPE_TIME_CODE_STAMPER,GstTimeCodeStamperClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TIME_CODE_STAMPER</NAME>
#define GST_IS_TIME_CODE_STAMPER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TIME_CODE_STAMPER))
</MACRO>
<MACRO>
<NAME>GST_IS_TIME_CODE_STAMPER_CLASS</NAME>
#define GST_IS_TIME_CODE_STAMPER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_TIME_CODE_STAMPER))
</MACRO>
<STRUCT>
<NAME>GstTimeCodeStamper</NAME>
struct _GstTimeCodeStamper
{
  GstBaseTransform videofilter;

  /* < private > */
  gboolean override_existing;
  gboolean drop_frame;
  GstVideoTimeCode *current_tc;
  GstVideoTimeCode *first_tc;
  GstVideoInfo vinfo;
  gboolean post_messages;
  gboolean first_tc_now;
};
</STRUCT>
<STRUCT>
<NAME>GstTimeCodeStamperClass</NAME>
struct _GstTimeCodeStamperClass
{
  GstBaseTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_timecodestamper_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_IRTSP_PARSE</NAME>
#define GST_TYPE_IRTSP_PARSE \
  (gst_irtsp_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_IRTSP_PARSE</NAME>
#define GST_IRTSP_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_IRTSP_PARSE, GstIRTSPParse))
</MACRO>
<MACRO>
<NAME>GST_IRTSP_PARSE_CLASS</NAME>
#define GST_IRTSP_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_IRTSP_PARSE, GstIRTSPParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_IRTSP_PARSE</NAME>
#define GST_IS_IRTSP_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_IRTSP_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_IRTSP_PARSE_CLASS</NAME>
#define GST_IS_IRTSP_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_IRTSP_PARSE))
</MACRO>
<STRUCT>
<NAME>GstIRTSPParse</NAME>
struct _GstIRTSPParse {
  GstBaseParse baseparse;

  guint8 channel_id;
  /*< private >*/
};
</STRUCT>
<STRUCT>
<NAME>GstIRTSPParseClass</NAME>
struct _GstIRTSPParseClass {
  GstBaseParseClass baseparse_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_irtsp_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GDP_PAY</NAME>
#define GST_TYPE_GDP_PAY \
  (gst_gdp_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_GDP_PAY</NAME>
#define GST_GDP_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GDP_PAY,GstGDPPay))
</MACRO>
<MACRO>
<NAME>GST_GDP_PAY_CLASS</NAME>
#define GST_GDP_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GDP_PAY,GstGDPPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GDP_PAY</NAME>
#define GST_IS_GDP_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GDP_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_GDP_PAY_CLASS</NAME>
#define GST_IS_GDP_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GDP_PAY))
</MACRO>
<STRUCT>
<NAME>GstGDPPay</NAME>
struct _GstGDPPay
{
  GstElement element;

  GstPad *sinkpad;
  GstPad *srcpad;

  GstCaps *caps; /* incoming caps */

  gboolean  have_streamstartid;
  gboolean  have_caps;
  gboolean  have_segment;

  gboolean reset_streamheader;

  gboolean sent_streamheader; /* TRUE after the first streamheaders are sent */
  GList *queue; /* list of queued buffers before streamheaders are sent */
  guint64 offset;

  gboolean crc_header;
  gboolean crc_payload;
  GstDPHeaderFlag header_flag;
};
</STRUCT>
<STRUCT>
<NAME>GstGDPPayClass</NAME>
struct _GstGDPPayClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gdp_pay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_gdp_pay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GDP_DEPAY</NAME>
#define GST_TYPE_GDP_DEPAY \
  (gst_gdp_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_GDP_DEPAY</NAME>
#define GST_GDP_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GDP_DEPAY,GstGDPDepay))
</MACRO>
<MACRO>
<NAME>GST_GDP_DEPAY_CLASS</NAME>
#define GST_GDP_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GDP_DEPAY,GstGDPDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GDP_DEPAY</NAME>
#define GST_IS_GDP_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GDP_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_GDP_DEPAY_CLASS</NAME>
#define GST_IS_GDP_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GDP_DEPAY))
</MACRO>
<ENUM>
<NAME>GstGDPDepayState</NAME>
typedef enum {
  GST_GDP_DEPAY_STATE_HEADER = 0,
  GST_GDP_DEPAY_STATE_PAYLOAD,
  GST_GDP_DEPAY_STATE_BUFFER,
  GST_GDP_DEPAY_STATE_CAPS,
  GST_GDP_DEPAY_STATE_EVENT,
} GstGDPDepayState;
</ENUM>
<STRUCT>
<NAME>GstGDPDepay</NAME>
struct _GstGDPDepay
{
  GstElement element;
  GstPad *sinkpad;
  GstPad *srcpad;

  GstAdapter *adapter;
  GstGDPDepayState state;
  GstCaps *caps;

  guint8 *header;
  guint32 payload_length;
  GstDPPayloadType payload_type;

  gint64 ts_offset;

  GstAllocator *allocator;
  GstAllocationParams allocation_params;
};
</STRUCT>
<STRUCT>
<NAME>GstGDPDepayClass</NAME>
struct _GstGDPDepayClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gdp_depay_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_gdp_depay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_DP_HEADER_LENGTH</NAME>
#define GST_DP_HEADER_LENGTH 62
</MACRO>
<ENUM>
<NAME>GstDPHeaderFlag</NAME>
typedef enum {
  GST_DP_HEADER_FLAG_NONE        = 0,
  GST_DP_HEADER_FLAG_CRC_HEADER  = (1 << 0),
  GST_DP_HEADER_FLAG_CRC_PAYLOAD = (1 << 1),
  GST_DP_HEADER_FLAG_CRC         = (1 << 1) | (1 << 0),
} GstDPHeaderFlag;
</ENUM>
<ENUM>
<NAME>GstDPPayloadType</NAME>
typedef enum {
  GST_DP_PAYLOAD_NONE            = 0,
  GST_DP_PAYLOAD_BUFFER,
  GST_DP_PAYLOAD_CAPS,
  GST_DP_PAYLOAD_EVENT_NONE      = 64,
} GstDPPayloadType;
</ENUM>
<FUNCTION>
<NAME>gst_dp_init</NAME>
<RETURNS>void             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dp_header_payload_length</NAME>
<RETURNS>guint32          </RETURNS>
const guint8 * header
</FUNCTION>
<FUNCTION>
<NAME>gst_dp_header_payload_type</NAME>
<RETURNS>GstDPPayloadType </RETURNS>
const guint8 * header
</FUNCTION>
<FUNCTION>
<NAME>gst_dp_buffer_from_header</NAME>
<RETURNS>GstBuffer  *     </RETURNS>
guint header_length, const guint8 * header, GstAllocator * allocator, GstAllocationParams * allocation_params
</FUNCTION>
<FUNCTION>
<NAME>gst_dp_caps_from_packet</NAME>
<RETURNS>GstCaps  *       </RETURNS>
guint header_length, const guint8 * header, const guint8 * payload
</FUNCTION>
<FUNCTION>
<NAME>gst_dp_event_from_packet</NAME>
<RETURNS>GstEvent  *      </RETURNS>
guint header_length, const guint8 * header, const guint8 * payload
</FUNCTION>
<FUNCTION>
<NAME>gst_dp_payload_buffer</NAME>
<RETURNS>GstBuffer  *     </RETURNS>
GstBuffer      * buffer, GstDPHeaderFlag  flags
</FUNCTION>
<FUNCTION>
<NAME>gst_dp_payload_caps</NAME>
<RETURNS>GstBuffer  *     </RETURNS>
const GstCaps  * caps, GstDPHeaderFlag  flags
</FUNCTION>
<FUNCTION>
<NAME>gst_dp_payload_event</NAME>
<RETURNS>GstBuffer  *     </RETURNS>
const GstEvent * event, GstDPHeaderFlag  flags
</FUNCTION>
<FUNCTION>
<NAME>gst_dp_validate_header</NAME>
<RETURNS>gboolean         </RETURNS>
guint header_length, const guint8 * header
</FUNCTION>
<FUNCTION>
<NAME>gst_dp_validate_payload</NAME>
<RETURNS>gboolean         </RETURNS>
guint header_length, const guint8 * header, const guint8 * payload
</FUNCTION>
<FUNCTION>
<NAME>gst_dp_validate_packet</NAME>
<RETURNS>gboolean         </RETURNS>
guint header_length, const guint8 * header, const guint8 * payload
</FUNCTION>
<MACRO>
<NAME>GST_DP_HEADER_MAJOR_VERSION</NAME>
#define GST_DP_HEADER_MAJOR_VERSION(x)	((x)[0])
</MACRO>
<MACRO>
<NAME>GST_DP_HEADER_MINOR_VERSION</NAME>
#define GST_DP_HEADER_MINOR_VERSION(x)  ((x)[1])
</MACRO>
<MACRO>
<NAME>GST_DP_HEADER_FLAGS</NAME>
#define GST_DP_HEADER_FLAGS(x)          ((x)[2])
</MACRO>
<MACRO>
<NAME>GST_DP_HEADER_PAYLOAD_TYPE</NAME>
#define GST_DP_HEADER_PAYLOAD_TYPE(x)   GST_READ_UINT16_BE (x + 4)
</MACRO>
<MACRO>
<NAME>GST_DP_HEADER_PAYLOAD_LENGTH</NAME>
#define GST_DP_HEADER_PAYLOAD_LENGTH(x) GST_READ_UINT32_BE (x + 6)
</MACRO>
<MACRO>
<NAME>GST_DP_HEADER_TIMESTAMP</NAME>
#define GST_DP_HEADER_TIMESTAMP(x)      GST_READ_UINT64_BE (x + 10)
</MACRO>
<MACRO>
<NAME>GST_DP_HEADER_DURATION</NAME>
#define GST_DP_HEADER_DURATION(x)       GST_READ_UINT64_BE (x + 18)
</MACRO>
<MACRO>
<NAME>GST_DP_HEADER_OFFSET</NAME>
#define GST_DP_HEADER_OFFSET(x)         GST_READ_UINT64_BE (x + 26)
</MACRO>
<MACRO>
<NAME>GST_DP_HEADER_OFFSET_END</NAME>
#define GST_DP_HEADER_OFFSET_END(x)     GST_READ_UINT64_BE (x + 34)
</MACRO>
<MACRO>
<NAME>GST_DP_HEADER_BUFFER_FLAGS</NAME>
#define GST_DP_HEADER_BUFFER_FLAGS(x)   GST_READ_UINT16_BE (x + 42)
</MACRO>
<MACRO>
<NAME>GST_DP_HEADER_DTS</NAME>
#define GST_DP_HEADER_DTS(x)            GST_READ_UINT64_BE (x + 44)
</MACRO>
<MACRO>
<NAME>GST_DP_HEADER_CRC_HEADER</NAME>
#define GST_DP_HEADER_CRC_HEADER(x)     GST_READ_UINT16_BE (x + 58)
</MACRO>
<MACRO>
<NAME>GST_DP_HEADER_CRC_PAYLOAD</NAME>
#define GST_DP_HEADER_CRC_PAYLOAD(x)    GST_READ_UINT16_BE (x + 60)
</MACRO>
<FUNCTION>
<NAME>gst_dp_dump_byte_array</NAME>
<RETURNS>void  </RETURNS>
guint8 *array, guint length
</FUNCTION>
<STRUCT>
<NAME>DVBSubtitlePicture</NAME>
typedef struct DVBSubtitlePicture {
	guint8 *data;
	guint32 *palette;
	guint8 palette_bits_count;
	int rowstride;
} DVBSubtitlePicture;
</STRUCT>
<STRUCT>
<NAME>DVBSubtitleRect</NAME>
typedef struct DVBSubtitleRect {
	int x;
	int y;
	int w;
	int h;

	DVBSubtitlePicture pict;
} DVBSubtitleRect;
</STRUCT>
<STRUCT>
<NAME>DVBSubtitleWindow</NAME>
typedef struct DVBSubtitleWindow {
    gint version;
    gint window_flag;

    gint display_width;
    gint display_height;

    gint window_x;
    gint window_y;
    gint window_width;
    gint window_height;
} DVBSubtitleWindow;
</STRUCT>
<STRUCT>
<NAME>DVBSubtitles</NAME>
typedef struct DVBSubtitles {
	guint64 pts;
	guint8 page_time_out;
	guint num_rects;
	DVBSubtitleRect *rects;
	DVBSubtitleWindow display_def;
} DVBSubtitles;
</STRUCT>
<STRUCT>
<NAME>DvbSubCallbacks</NAME>
typedef struct {
	void     (*new_data) (DvbSub *dvb_sub, DVBSubtitles * subs, gpointer user_data);
	/*< private >*/
	gpointer _dvb_sub_reserved[3];
} DvbSubCallbacks;
</STRUCT>
<FUNCTION>
<NAME>dvb_sub_new</NAME>
<RETURNS>DvbSub   *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>dvb_sub_free</NAME>
<RETURNS>void      </RETURNS>
DvbSub * sub
</FUNCTION>
<FUNCTION>
<NAME>dvb_sub_feed_with_pts</NAME>
<RETURNS>gint      </RETURNS>
DvbSub *dvb_sub, guint64 pts, guint8 *data, gint len
</FUNCTION>
<FUNCTION>
<NAME>dvb_sub_set_callbacks</NAME>
<RETURNS>void      </RETURNS>
DvbSub *dvb_sub, DvbSubCallbacks *callbacks, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>dvb_subtitles_free</NAME>
<RETURNS>void      </RETURNS>
DVBSubtitles *sub
</FUNCTION>
<STRUCT>
<NAME>DvbSub</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_DVBSUB_OVERLAY</NAME>
#define GST_TYPE_DVBSUB_OVERLAY (gst_dvbsub_overlay_get_type())
</MACRO>
<MACRO>
<NAME>GST_DVBSUB_OVERLAY</NAME>
#define GST_DVBSUB_OVERLAY(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DVBSUB_OVERLAY,GstDVBSubOverlay))
</MACRO>
<MACRO>
<NAME>GST_DVBSUB_OVERLAY_CLASS</NAME>
#define GST_DVBSUB_OVERLAY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DVBSUB_OVERLAY,GstDVBSubOverlayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DVBSUB_OVERLAY</NAME>
#define GST_IS_DVBSUB_OVERLAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DVBSUB_OVERLAY))
</MACRO>
<MACRO>
<NAME>GST_IS_DVBSUB_OVERLAY_CLASS</NAME>
#define GST_IS_DVBSUB_OVERLAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DVBSUB_OVERLAY))
</MACRO>
<STRUCT>
<NAME>GstDVBSubOverlay</NAME>
struct _GstDVBSubOverlay
{
  GstElement element;

  GstPad *video_sinkpad, *text_sinkpad, *srcpad;

  /* properties */
  gboolean enable;
  gint max_page_timeout;
  gboolean force_end;

  /* <private> */
  GstSegment video_segment;
  GstSegment subtitle_segment;

  GstVideoInfo info;

  DVBSubtitles *current_subtitle; /* The currently active set of subtitle regions, if any */
  GstVideoOverlayComposition *current_comp;
  GQueue *pending_subtitles; /* A queue of raw subtitle region sets with
			      * metadata that are waiting their running time */

  GMutex dvbsub_mutex; /* protects the queue and the DvbSub instance */
  DvbSub *dvb_sub;

  /* subtitle data submitted to dvb_sub but no sub received yet */
  gboolean pending_sub;
  /* last text pts */
  GstClockTime last_text_pts;

  gboolean attach_compo_to_buffer;
};
</STRUCT>
<STRUCT>
<NAME>GstDVBSubOverlayClass</NAME>
struct _GstDVBSubOverlayClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dvbsub_overlay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEG4VIDEO_PARSE</NAME>
#define GST_TYPE_MPEG4VIDEO_PARSE            (gst_mpeg4vparse_get_type())
</MACRO>
<MACRO>
<NAME>GST_MPEG4VIDEO_PARSE</NAME>
#define GST_MPEG4VIDEO_PARSE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),\
                                GST_TYPE_MPEG4VIDEO_PARSE, GstMpeg4VParse))
</MACRO>
<MACRO>
<NAME>GST_MPEG4VIDEO_PARSE_CLASS</NAME>
#define GST_MPEG4VIDEO_PARSE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),\
                                GST_TYPE_MPEG4VIDEO_PARSE, GstMpeg4VParseClass))
</MACRO>
<MACRO>
<NAME>GST_MPEG4VIDEO_PARSE_GET_CLASS</NAME>
#define GST_MPEG4VIDEO_PARSE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),\
                                GST_TYPE_MPEG4VIDEO_PARSE, GstMpeg4VParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MPEG4VIDEO_PARSE</NAME>
#define GST_IS_MPEG4VIDEO_PARSE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),\
                                GST_TYPE_MPEG4VIDEO_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_MPEG4VIDEO_PARSE_CLASS</NAME>
#define GST_IS_MPEG4VIDEO_PARSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),\
                                GST_TYPE_MPEG4VIDEO_PARSE))
</MACRO>
<STRUCT>
<NAME>GstMpeg4VParse</NAME>
struct _GstMpeg4VParse {
  GstBaseParse element;

  GstClockTime last_report;

  /* parse state */
  gint last_sc;
  gint vop_offset;
  gboolean vo_found;
  gboolean config_found;
  gboolean update_caps;
  gboolean sent_codec_tag;

  GstMpeg4VisualObject vo;
  gint vo_offset;

  gboolean discont;

  GstBuffer *config;
  GstMpeg4VideoObjectLayer vol;
  gboolean vol_offset;
  const gchar *profile;
  const gchar *level;

  /* properties */
  gboolean drop;
  guint interval;
  GstClockTime pending_key_unit_ts;
  GstEvent *force_key_unit_event;
};
</STRUCT>
<STRUCT>
<NAME>GstMpeg4VParseClass</NAME>
struct _GstMpeg4VParseClass {
  GstBaseParseClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpeg4vparse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VC1_PARSE</NAME>
#define GST_TYPE_VC1_PARSE \
  (gst_vc1_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_VC1_PARSE</NAME>
#define GST_VC1_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VC1_PARSE,GstVC1Parse))
</MACRO>
<MACRO>
<NAME>GST_VC1_PARSE_CLASS</NAME>
#define GST_VC1_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VC1_PARSE,GstVC1ParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VC1_PARSE</NAME>
#define GST_IS_VC1_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VC1_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_VC1_PARSE_CLASS</NAME>
#define GST_IS_VC1_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VC1_PARSE))
</MACRO>
<ENUM>
<NAME>VC1HeaderFormat</NAME>
typedef enum {
  VC1_HEADER_FORMAT_NONE = 0,
  VC1_HEADER_FORMAT_ASF,
  VC1_HEADER_FORMAT_SEQUENCE_LAYER
} VC1HeaderFormat;
</ENUM>
<ENUM>
<NAME>VC1StreamFormat</NAME>
typedef enum {
  VC1_STREAM_FORMAT_BDU = 0,
  VC1_STREAM_FORMAT_BDU_FRAME,
  VC1_STREAM_FORMAT_SEQUENCE_LAYER_BDU,
  VC1_STREAM_FORMAT_SEQUENCE_LAYER_BDU_FRAME,
  VC1_STREAM_FORMAT_SEQUENCE_LAYER_RAW_FRAME,
  VC1_STREAM_FORMAT_SEQUENCE_LAYER_FRAME_LAYER,
  VC1_STREAM_FORMAT_ASF,
  VC1_STREAM_FORMAT_FRAME_LAYER
} VC1StreamFormat;
</ENUM>
<ENUM>
<NAME>GstVC1ParseFormat</NAME>
typedef enum {
  GST_VC1_PARSE_FORMAT_WMV3 = 0,
  GST_VC1_PARSE_FORMAT_WVC1
} GstVC1ParseFormat;
</ENUM>
<STRUCT>
<NAME>GstVC1Parse</NAME>
struct _GstVC1Parse
{
  GstBaseParse baseparse;

  /* Caps */
  GstVC1Profile profile;
  GstVC1Level level;
  GstVC1ParseFormat format;
  gint width, height;

  gint fps_n, fps_d;
  gboolean fps_from_caps;
  GstClockTime frame_duration;
  gint par_n, par_d;
  gboolean par_from_caps;

  /* TRUE if we should negotiate with downstream */
  gboolean renegotiate;
  /* TRUE if the srcpads should be updated */
  gboolean update_caps;

  gboolean sent_codec_tag;

  VC1HeaderFormat input_header_format;
  VC1HeaderFormat output_header_format;
  VC1StreamFormat input_stream_format;
  VC1StreamFormat output_stream_format;
  gboolean detecting_stream_format;

  GstVC1SeqHdr seq_hdr;
  GstBuffer *seq_hdr_buffer;
  GstBuffer *entrypoint_buffer;

  GstVC1SeqLayer seq_layer;
  GstBuffer *seq_layer_buffer;

  /* Metadata about the currently parsed frame, only
   * valid if the GstBaseParseFrame has the
   * GST_BASE_PARSE_FRAME_FLAG_PARSING flag */
  GstVC1StartCode startcode;

  /* TRUE if we have already sent the sequence-layer,
   * use for stream-format conversion */
  gboolean seq_layer_sent;

  /* TRUE if we have already sent the frame-layer first frame,
   * use for stream-format conversion */
  gboolean frame_layer_first_frame_sent;
};
</STRUCT>
<STRUCT>
<NAME>GstVC1ParseClass</NAME>
struct _GstVC1ParseClass
{
  GstBaseParseClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vc1_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DIRAC_PARSE</NAME>
#define GST_TYPE_DIRAC_PARSE   (gst_dirac_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_DIRAC_PARSE</NAME>
#define GST_DIRAC_PARSE(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DIRAC_PARSE,GstDiracParse))
</MACRO>
<MACRO>
<NAME>GST_DIRAC_PARSE_CLASS</NAME>
#define GST_DIRAC_PARSE_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DIRAC_PARSE,GstDiracParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DIRAC_PARSE</NAME>
#define GST_IS_DIRAC_PARSE(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DIRAC_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_DIRAC_PARSE_CLASS</NAME>
#define GST_IS_DIRAC_PARSE_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DIRAC_PARSE))
</MACRO>
<STRUCT>
<NAME>GstDiracParse</NAME>
struct _GstDiracParse
{
  GstBaseParse base_diracparse;

  DiracSequenceHeader sequence_header;

  guint32 frame_number;

  gboolean sent_codec_tag;
};
</STRUCT>
<STRUCT>
<NAME>GstDiracParseClass</NAME>
struct _GstDiracParseClass
{
  GstBaseParseClass base_diracparse_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dirac_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_H265_PARSE</NAME>
#define GST_TYPE_H265_PARSE \
  (gst_h265_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_H265_PARSE</NAME>
#define GST_H265_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_H265_PARSE,GstH265Parse))
</MACRO>
<MACRO>
<NAME>GST_H265_PARSE_CLASS</NAME>
#define GST_H265_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_H265_PARSE,GstH265ParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_H265_PARSE</NAME>
#define GST_IS_H265_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_H265_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_H265_PARSE_CLASS</NAME>
#define GST_IS_H265_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_H265_PARSE))
</MACRO>
<FUNCTION>
<NAME>gst_h265_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstH265Parse</NAME>
struct _GstH265Parse
{
  GstBaseParse baseparse;

  /* stream */
  gint width, height;
  gint fps_num, fps_den;
  gint upstream_par_n, upstream_par_d;
  gint parsed_par_n, parsed_par_d;
  /* current codec_data in output caps, if any */
  GstBuffer *codec_data;
  /* input codec_data, if any */
  GstBuffer *codec_data_in;
  guint nal_length_size;
  gboolean packetized;
  gboolean split_packetized;
  gboolean transform;

  /* state */
  GstH265Parser *nalparser;
  guint align;
  guint format;
  gint current_off;

  GstClockTime last_report;
  gboolean push_codec;
  gboolean have_vps;
  gboolean have_sps;
  gboolean have_pps;

  /* collected SPS and PPS NALUs */
  GstBuffer *vps_nals[GST_H265_MAX_VPS_COUNT];
  GstBuffer *sps_nals[GST_H265_MAX_SPS_COUNT];
  GstBuffer *pps_nals[GST_H265_MAX_PPS_COUNT];

  /* frame parsing */
  gint idr_pos, sei_pos;
  gboolean update_caps;
  GstAdapter *frame_out;
  gboolean keyframe;
  gboolean header;
  /* AU state */
  gboolean picture_start;

  /* props */
  guint interval;

  gboolean sent_codec_tag;

  GstClockTime pending_key_unit_ts;
  GstEvent *force_key_unit_event;
};
</STRUCT>
<STRUCT>
<NAME>GstH265ParseClass</NAME>
struct _GstH265ParseClass
{
  GstBaseParseClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_H263_PARSE</NAME>
#define GST_TYPE_H263_PARSE \
  (gst_h263_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_H263_PARSE</NAME>
#define GST_H263_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_H263_PARSE,GstH263Parse))
</MACRO>
<MACRO>
<NAME>GST_H263_PARSE_CLASS</NAME>
#define GST_H263_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_H263_PARSE,GstH263ParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_H263_PARSE</NAME>
#define GST_IS_H263_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_H263_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_H263_PARSE_CLASS</NAME>
#define GST_IS_H263_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_H263_PARSE))
</MACRO>
<FUNCTION>
<NAME>gst_h263_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstH263Parse</NAME>
struct _GstH263Parse
{
  GstBaseParse baseparse;

  gint profile, level;
  guint bitrate;

  H263ParseState state;
  gboolean sent_codec_tag;
};
</STRUCT>
<STRUCT>
<NAME>GstH263ParseClass</NAME>
struct _GstH263ParseClass
{
  GstBaseParseClass parent_class;
};
</STRUCT>
<ENUM>
<NAME>H263ParseState</NAME>
typedef enum
{
  PARSING = 0,
  GOT_HEADER,
  PASSTHROUGH
} H263ParseState;
</ENUM>
<ENUM>
<NAME>H263OptionalFeatures</NAME>
typedef enum
{
  /* Optional Unrestricted Motion Vector (UMV) mode (see Annex D) */
  H263_OPTION_UMV_MODE = 1 << 0,
  /* Optional Syntax-based Arithmetic Coding (SAC) mode (see Annex E) */
  H263_OPTION_SAC_MODE = 1 << 1,
  /* Optional Advanced Prediction mode (AP) (see Annex F) */
  H263_OPTION_AP_MODE = 1 << 2,
  /* Optional PB-frames mode (see Annex G) */
  H263_OPTION_PB_MODE = 1 << 3,
  /* Optional Advanced INTRA Coding (AIC) mode (see Annex I) */
  H263_OPTION_AIC_MODE = 1 << 4,
  /* Optional Deblocking Filter (DF) mode (see Annex J) */
  H263_OPTION_DF_MODE = 1 << 5,
  /* Optional Slice Structured (SS) mode (see Annex K) */
  H263_OPTION_SS_MODE = 1 << 6,
  /* Optional Reference Picture Selection (RPS) mode (see Annex N) */
  H263_OPTION_RPS_MODE = 1 << 7,
  /* Optional Independent Segment Decoding (ISD) mode (see Annex R) */
  H263_OPTION_ISD_MODE = 1 << 8,
  /* Optional Alternative INTER VLC (AIV) mode (see Annex S) */
  H263_OPTION_AIV_MODE = 1 << 9,
  /* Optional Modified Quantization (MQ) mode (see Annex T) */
  H263_OPTION_MQ_MODE = 1 << 10,
  /* Optional Reference Picture Resampling (RPR) mode (see Annex P) */
  H263_OPTION_RPR_MODE = 1 << 11,
  /* Optional Reduced-Resolution Update (RRU) mode (see Annex Q) */
  H263_OPTION_RRU_MODE = 1 << 12,
  /* Optional Enhanced Reference Picture Selection (ERPS) mode (see Annex U) */
  H263_OPTION_ERPS_MODE = 1 << 13,
  /* Optional Data Partitioned Slices (DPS) mode (see Annex V) */
  H263_OPTION_DPS_MODE = 1 << 14
} H263OptionalFeatures;
</ENUM>
<ENUM>
<NAME>H263PictureType</NAME>
typedef enum
{
  PICTURE_I = 0,                /* I-picture (INTRA) Baseline */
  PICTURE_P,                    /* P-picture (INTER) Baseline */
  PICTURE_IMPROVED_PB,          /* Improved PB-frame (Annex M) */
  PICTURE_B,                    /* B-picture (Annex O) */
  PICTURE_EI,                   /* EI-picture (Annex O) */
  PICTURE_EP,                   /* EP-picture (Annex O) */
  PICTURE_RESERVED1,
  PICTURE_RESERVED2,
  PICTURE_PB                    /* PB-frame (See Annex G) */
} H263PictureType;
</ENUM>
<ENUM>
<NAME>H263PictureFormat</NAME>
typedef enum
{
  PICTURE_FMT_FORBIDDEN_0 = 0,
  PICTURE_FMT_SUB_QCIF,
  PICTURE_FMT_QCIF,
  PICTURE_FMT_CIF,
  PICTURE_FMT_4CIF,
  PICTURE_FMT_16CIF,
  PICTURE_FMT_RESERVED1,
  PICTURE_FMT_EXTENDEDPTYPE
} H263PictureFormat;
</ENUM>
<ENUM>
<NAME>H263UUI</NAME>
typedef enum
{
  UUI_ABSENT = 0,
  UUI_IS_1,
  UUI_IS_01,
} H263UUI;
</ENUM>
<STRUCT>
<NAME>H263Params</NAME>
struct _H263Params
{
  guint32 temporal_ref;

  H263OptionalFeatures features;

  gboolean splitscreen;
  gboolean documentcamera;
  gboolean fullpicturefreezerelease;
  gboolean custompcfpresent;
  H263UUI uui;
  guint8 sss;

  H263PictureFormat format;

  H263PictureType type;

  guint32 width;
  guint32 height;
  guint8 parnum, pardenom;
  gint32 pcfnum, pcfdenom;
};
</STRUCT>
<FUNCTION>
<NAME>gst_h263_parse_is_delta_unit</NAME>
<RETURNS>gboolean       </RETURNS>
const H263Params * params
</FUNCTION>
<FUNCTION>
<NAME>gst_h263_parse_get_params</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
H263Params       * params_p, GstBuffer        * buffer, gboolean           fast, H263ParseState   * state
</FUNCTION>
<FUNCTION>
<NAME>gst_h263_parse_get_framerate</NAME>
<RETURNS>void           </RETURNS>
const H263Params * params, gint             * num, gint             * denom
</FUNCTION>
<FUNCTION>
<NAME>gst_h263_parse_get_par</NAME>
<RETURNS>void           </RETURNS>
const H263Params * params, gint             * num, gint             * denom
</FUNCTION>
<FUNCTION>
<NAME>gst_h263_parse_get_profile</NAME>
<RETURNS>gint           </RETURNS>
const H263Params * params
</FUNCTION>
<FUNCTION>
<NAME>gst_h263_parse_get_level</NAME>
<RETURNS>gint           </RETURNS>
const H263Params * params, gint               profile, guint              bitrate, gint               fps_num, gint               fps_denom
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_JPEG2000_PARSE</NAME>
#define GST_TYPE_JPEG2000_PARSE \
  (gst_jpeg2000_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_JPEG2000_PARSE</NAME>
#define GST_JPEG2000_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_JPEG2000_PARSE,GstJPEG2000Parse))
</MACRO>
<MACRO>
<NAME>GST_JPEG2000_PARSE_CLASS</NAME>
#define GST_JPEG2000_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_JPEG2000_PARSE,GstJPEG2000ParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_JPEG2000_PARSE</NAME>
#define GST_IS_JPEG2000_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_JPEG2000_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_JPEG2000_PARSE_CLASS</NAME>
#define GST_IS_JPEG2000_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_JPEG2000_PARSE))
</MACRO>
<FUNCTION>
<NAME>gst_jpeg2000_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_JPEG2000_PARSE_MAX_SUPPORTED_COMPONENTS</NAME>
#define GST_JPEG2000_PARSE_MAX_SUPPORTED_COMPONENTS 4
</MACRO>
<ENUM>
<NAME>GstJPEG2000ParseFormats</NAME>
typedef enum
{
  GST_JPEG2000_PARSE_NO_CODEC,
  GST_JPEG2000_PARSE_JPC,       /* jpeg 2000 code stream */
  GST_JPEG2000_PARSE_J2C,       /* jpeg 2000 contiguous code stream box plus code stream */
  GST_JPEG2000_PARSE_JP2,       /* jpeg 2000 part I file format */

} GstJPEG2000ParseFormats;
</ENUM>
<STRUCT>
<NAME>GstJPEG2000Parse</NAME>
struct _GstJPEG2000Parse
{
  GstBaseParse baseparse;


  guint width;
  guint height;

  GstJPEG2000Sampling sampling;
  GstJPEG2000Colorspace colorspace;
  GstJPEG2000ParseFormats codec_format;
};
</STRUCT>
<STRUCT>
<NAME>GstJPEG2000ParseClass</NAME>
struct _GstJPEG2000ParseClass
{
  GstBaseParseClass parent_class;


};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_H264_PARSE</NAME>
#define GST_TYPE_H264_PARSE \
  (gst_h264_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_H264_PARSE</NAME>
#define GST_H264_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_H264_PARSE,GstH264Parse))
</MACRO>
<MACRO>
<NAME>GST_H264_PARSE_CLASS</NAME>
#define GST_H264_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_H264_PARSE,GstH264ParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_H264_PARSE</NAME>
#define GST_IS_H264_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_H264_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_H264_PARSE_CLASS</NAME>
#define GST_IS_H264_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_H264_PARSE))
</MACRO>
<FUNCTION>
<NAME>gst_h264_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstH264Parse</NAME>
struct _GstH264Parse
{
  GstBaseParse baseparse;

  /* stream */
  gint width, height;
  gint fps_num, fps_den;
  gint upstream_par_n, upstream_par_d;
  gint parsed_par_n, parsed_par_d;
  /* current codec_data in output caps, if any */
  GstBuffer *codec_data;
  /* input codec_data, if any */
  GstBuffer *codec_data_in;
  guint nal_length_size;
  gboolean packetized;
  gboolean split_packetized;
  gboolean transform;

  /* state */
  GstH264NalParser *nalparser;
  guint state;
  guint in_align;
  guint align;
  guint format;
  gint current_off;
  /* True if input format and alignment match negotiated output */
  gboolean can_passthrough;

  GstClockTime last_report;
  gboolean push_codec;
  /* The following variables have a meaning in context of "have
   * SPS/PPS to push downstream", e.g. to update caps */
  gboolean have_sps;
  gboolean have_pps;

  gboolean sent_codec_tag;

  /* collected SPS and PPS NALUs */
  GstBuffer *sps_nals[GST_H264_MAX_SPS_COUNT];
  GstBuffer *pps_nals[GST_H264_MAX_PPS_COUNT];

  /* Infos we need to keep track of */
  guint32 sei_cpb_removal_delay;
  guint8 sei_pic_struct;
  guint8 sei_pic_struct_pres_flag;
  guint field_pic_flag;

  /* cached timestamps */
  /* (trying to) track upstream dts and interpolate */
  GstClockTime dts;
  /* dts at start of last buffering period */
  GstClockTime ts_trn_nb;
  gboolean do_ts;

  gboolean discont;

  /* frame parsing */
  /*guint last_nal_pos;*/
  /*guint next_sc_pos;*/
  gint idr_pos, sei_pos;
  gboolean update_caps;
  GstAdapter *frame_out;
  gboolean keyframe;
  gboolean header;
  gboolean frame_start;
  /* AU state */
  gboolean picture_start;

  /* props */
  gint interval;

  GstClockTime pending_key_unit_ts;
  GstEvent *force_key_unit_event;

  /* Stereo / multiview info */
  GstVideoMultiviewMode multiview_mode;
  GstVideoMultiviewFlags multiview_flags;
  gboolean first_in_bundle;

  /* For insertion of AU Delimiter */
  gboolean aud_needed;
  gboolean aud_insert;
};
</STRUCT>
<STRUCT>
<NAME>GstH264ParseClass</NAME>
struct _GstH264ParseClass
{
  GstBaseParseClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>H264Params</NAME>
</STRUCT>
<ENUM>
<NAME>SchroParseCode</NAME>
typedef enum _SchroParseCode {
  SCHRO_PARSE_CODE_SEQUENCE_HEADER = 0x00,
  SCHRO_PARSE_CODE_END_OF_SEQUENCE = 0x10,
  SCHRO_PARSE_CODE_AUXILIARY_DATA = 0x20,
  SCHRO_PARSE_CODE_PADDING = 0x30,

  SCHRO_PARSE_CODE_INTRA_REF = 0x0c,
  SCHRO_PARSE_CODE_INTRA_NON_REF = 0x08,
  SCHRO_PARSE_CODE_INTRA_REF_NOARITH = 0x4c,
  SCHRO_PARSE_CODE_INTRA_NON_REF_NOARITH = 0x48,

  SCHRO_PARSE_CODE_INTER_REF_1 = 0x0d,
  SCHRO_PARSE_CODE_INTER_REF_1_NOARITH = 0x4d,
  SCHRO_PARSE_CODE_INTER_REF_2 = 0x0e,
  SCHRO_PARSE_CODE_INTER_REF_2_NOARITH = 0x4e,

  SCHRO_PARSE_CODE_INTER_NON_REF_1 = 0x09,
  SCHRO_PARSE_CODE_INTER_NON_REF_1_NOARITH = 0x49,
  SCHRO_PARSE_CODE_INTER_NON_REF_2 = 0x0a,
  SCHRO_PARSE_CODE_INTER_NON_REF_2_NOARITH = 0x4a,

  SCHRO_PARSE_CODE_LD_INTRA_REF = 0xcc,
  SCHRO_PARSE_CODE_LD_INTRA_NON_REF = 0xc8
} SchroParseCode;
</ENUM>
<MACRO>
<NAME>SCHRO_PARSE_CODE_PICTURE</NAME>
#define SCHRO_PARSE_CODE_PICTURE(is_ref,n_refs,is_lowdelay,is_noarith) \
  (8 | ((is_ref)<<2) | (n_refs) | ((is_lowdelay)<<7) | ((is_noarith)<<6))
</MACRO>
<MACRO>
<NAME>SCHRO_PARSE_CODE_IS_SEQ_HEADER</NAME>
#define SCHRO_PARSE_CODE_IS_SEQ_HEADER(x) ((x) == SCHRO_PARSE_CODE_SEQUENCE_HEADER)
</MACRO>
<MACRO>
<NAME>SCHRO_PARSE_CODE_IS_END_OF_SEQUENCE</NAME>
#define SCHRO_PARSE_CODE_IS_END_OF_SEQUENCE(x) ((x) == SCHRO_PARSE_CODE_END_OF_SEQUENCE)
</MACRO>
<MACRO>
<NAME>SCHRO_PARSE_CODE_IS_AUXILIARY_DATA</NAME>
#define SCHRO_PARSE_CODE_IS_AUXILIARY_DATA(x) ((x) == SCHRO_PARSE_CODE_AUXILIARY_DATA)
</MACRO>
<MACRO>
<NAME>SCHRO_PARSE_CODE_IS_PADDING</NAME>
#define SCHRO_PARSE_CODE_IS_PADDING(x) ((x) == SCHRO_PARSE_CODE_PADDING)
</MACRO>
<MACRO>
<NAME>SCHRO_PARSE_CODE_IS_PICTURE</NAME>
#define SCHRO_PARSE_CODE_IS_PICTURE(x) ((x) & 0x8)
</MACRO>
<MACRO>
<NAME>SCHRO_PARSE_CODE_IS_LOW_DELAY</NAME>
#define SCHRO_PARSE_CODE_IS_LOW_DELAY(x) (((x) & 0x88) == 0x88)
</MACRO>
<MACRO>
<NAME>SCHRO_PARSE_CODE_IS_CORE_SYNTAX</NAME>
#define SCHRO_PARSE_CODE_IS_CORE_SYNTAX(x) (((x) & 0x88) == 0x08)
</MACRO>
<MACRO>
<NAME>SCHRO_PARSE_CODE_USING_AC</NAME>
#define SCHRO_PARSE_CODE_USING_AC(x) (((x) & 0x48) == 0x08)
</MACRO>
<MACRO>
<NAME>SCHRO_PARSE_CODE_IS_REFERENCE</NAME>
#define SCHRO_PARSE_CODE_IS_REFERENCE(x) (((x) & 0xc) == 0x0c)
</MACRO>
<MACRO>
<NAME>SCHRO_PARSE_CODE_IS_NON_REFERENCE</NAME>
#define SCHRO_PARSE_CODE_IS_NON_REFERENCE(x) (((x) & 0xc) == 0x08)
</MACRO>
<MACRO>
<NAME>SCHRO_PARSE_CODE_NUM_REFS</NAME>
#define SCHRO_PARSE_CODE_NUM_REFS(x) ((x) & 0x3)
</MACRO>
<MACRO>
<NAME>SCHRO_PARSE_CODE_IS_INTRA</NAME>
#define SCHRO_PARSE_CODE_IS_INTRA(x) (SCHRO_PARSE_CODE_IS_PICTURE(x) && SCHRO_PARSE_CODE_NUM_REFS(x) == 0)
</MACRO>
<MACRO>
<NAME>SCHRO_PARSE_CODE_IS_INTER</NAME>
#define SCHRO_PARSE_CODE_IS_INTER(x) (SCHRO_PARSE_CODE_IS_PICTURE(x) && SCHRO_PARSE_CODE_NUM_REFS(x) > 0)
</MACRO>
<MACRO>
<NAME>SCHRO_PARSE_HEADER_SIZE</NAME>
#define SCHRO_PARSE_HEADER_SIZE (4+1+4+4)
</MACRO>
<ENUM>
<NAME>SchroVideoFormatEnum</NAME>
typedef enum _SchroVideoFormatEnum {
  SCHRO_VIDEO_FORMAT_CUSTOM = 0,
  SCHRO_VIDEO_FORMAT_QSIF,
  SCHRO_VIDEO_FORMAT_QCIF,
  SCHRO_VIDEO_FORMAT_SIF,
  SCHRO_VIDEO_FORMAT_CIF,
  SCHRO_VIDEO_FORMAT_4SIF,
  SCHRO_VIDEO_FORMAT_4CIF,
  SCHRO_VIDEO_FORMAT_SD480I_60,
  SCHRO_VIDEO_FORMAT_SD576I_50,
  SCHRO_VIDEO_FORMAT_HD720P_60,
  SCHRO_VIDEO_FORMAT_HD720P_50,
  SCHRO_VIDEO_FORMAT_HD1080I_60,
  SCHRO_VIDEO_FORMAT_HD1080I_50,
  SCHRO_VIDEO_FORMAT_HD1080P_60,
  SCHRO_VIDEO_FORMAT_HD1080P_50,
  SCHRO_VIDEO_FORMAT_DC2K_24,
  SCHRO_VIDEO_FORMAT_DC4K_24
} SchroVideoFormatEnum;
</ENUM>
<ENUM>
<NAME>SchroChromaFormat</NAME>
typedef enum _SchroChromaFormat {
  SCHRO_CHROMA_444 = 0,
  SCHRO_CHROMA_422,
  SCHRO_CHROMA_420
} SchroChromaFormat;
</ENUM>
<MACRO>
<NAME>SCHRO_CHROMA_FORMAT_H_SHIFT</NAME>
#define SCHRO_CHROMA_FORMAT_H_SHIFT(format) (((format) == SCHRO_CHROMA_444)?0:1)
</MACRO>
<MACRO>
<NAME>SCHRO_CHROMA_FORMAT_V_SHIFT</NAME>
#define SCHRO_CHROMA_FORMAT_V_SHIFT(format) (((format) == SCHRO_CHROMA_420)?1:0)
</MACRO>
<ENUM>
<NAME>SchroSignalRange</NAME>
typedef enum _SchroSignalRange {
  SCHRO_SIGNAL_RANGE_CUSTOM = 0,
  SCHRO_SIGNAL_RANGE_8BIT_FULL = 1,
  SCHRO_SIGNAL_RANGE_8BIT_VIDEO = 2,
  SCHRO_SIGNAL_RANGE_10BIT_VIDEO = 3,
  SCHRO_SIGNAL_RANGE_12BIT_VIDEO = 4
} SchroSignalRange;
</ENUM>
<ENUM>
<NAME>SchroColourSpec</NAME>
typedef enum _SchroColourSpec {
  SCHRO_COLOUR_SPEC_CUSTOM = 0,
  SCHRO_COLOUR_SPEC_SDTV_525 = 1,
  SCHRO_COLOUR_SPEC_SDTV_625 = 2,
  SCHRO_COLOUR_SPEC_HDTV = 3,
  SCHRO_COLOUR_SPEC_CINEMA = 4
} SchroColourSpec;
</ENUM>
<ENUM>
<NAME>SchroColourPrimaries</NAME>
typedef enum _SchroColourPrimaries {
  SCHRO_COLOUR_PRIMARY_HDTV = 0,
  SCHRO_COLOUR_PRIMARY_SDTV_525 = 1,
  SCHRO_COLOUR_PRIMARY_SDTV_625 = 2,
  SCHRO_COLOUR_PRIMARY_CINEMA = 3
} SchroColourPrimaries;
</ENUM>
<ENUM>
<NAME>SchroColourMatrix</NAME>
typedef enum _SchroColourMatrix {
  SCHRO_COLOUR_MATRIX_HDTV = 0,
  SCHRO_COLOUR_MATRIX_SDTV = 1,
  SCHRO_COLOUR_MATRIX_REVERSIBLE = 2
}SchroColourMatrix;
</ENUM>
<ENUM>
<NAME>SchroTransferFunction</NAME>
typedef enum _SchroTransferFunction {
  SCHRO_TRANSFER_CHAR_TV_GAMMA = 0,
  SCHRO_TRANSFER_CHAR_EXTENDED_GAMUT = 1,
  SCHRO_TRANSFER_CHAR_LINEAR = 2,
  SCHRO_TRANSFER_CHAR_DCI_GAMMA = 3
} SchroTransferFunction;
</ENUM>
<STRUCT>
<NAME>DiracSequenceHeader</NAME>
struct _DiracSequenceHeader {
  int major_version;
  int minor_version;
  int profile;
  int level;

  int index;
  int width;
  int height;
  int chroma_format;
  
  int interlaced;
  int top_field_first;
  
  int frame_rate_numerator;
  int frame_rate_denominator;
  int aspect_ratio_numerator;
  int aspect_ratio_denominator;
    
  int clean_width;
  int clean_height;
  int left_offset;
  int top_offset;
    
  int luma_offset;
  int luma_excursion;
  int chroma_offset;
  int chroma_excursion;
    
  int colour_primaries;
  int colour_matrix;
  int transfer_function;

  int interlaced_coding;

  int unused0;
  int unused1;
  int unused2;
};  
</STRUCT>
<FUNCTION>
<NAME>dirac_sequence_header_parse</NAME>
<RETURNS>int  </RETURNS>
DiracSequenceHeader *header, unsigned char *data, int length
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MPEGVIDEO_PARSE</NAME>
#define GST_TYPE_MPEGVIDEO_PARSE            (gst_mpegv_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_MPEGVIDEO_PARSE</NAME>
#define GST_MPEGVIDEO_PARSE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),\
                                GST_TYPE_MPEGVIDEO_PARSE, GstMpegvParse))
</MACRO>
<MACRO>
<NAME>GST_MPEGVIDEO_PARSE_CLASS</NAME>
#define GST_MPEGVIDEO_PARSE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),\
                                GST_TYPE_MPEGVIDEO_PARSE, GstMpegvParseClass))
</MACRO>
<MACRO>
<NAME>GST_MPEGVIDEO_PARSE_GET_CLASS</NAME>
#define GST_MPEGVIDEO_PARSE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),\
                                GST_TYPE_MPEGVIDEO_PARSE, GstMpegvParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MPEGVIDEO_PARSE</NAME>
#define GST_IS_MPEGVIDEO_PARSE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),\
                                GST_TYPE_MPEGVIDEO_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_MPEGVIDEO_PARSE_CLASS</NAME>
#define GST_IS_MPEGVIDEO_PARSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),\
                                GST_TYPE_MPEGVIDEO_PARSE))
</MACRO>
<STRUCT>
<NAME>GstMpegvParse</NAME>
struct _GstMpegvParse {
  GstBaseParse element;

  /* parse state */
  gint ext_offsets[10];
  gint ext_count;
  gint last_sc;
  gint seq_offset;
  gint seq_size;
  gint pic_offset;
  guint slice_count;
  guint slice_offset;
  gboolean update_caps;
  gboolean send_codec_tag;
  gboolean send_mpeg_meta;

  GstBuffer *config;
  guint8 profile;
  guint config_flags;
  GstMpegVideoSequenceHdr sequencehdr;
  GstMpegVideoSequenceExt sequenceext;
  GstMpegVideoSequenceDisplayExt sequencedispext;
  GstMpegVideoPictureHdr pichdr;
  GstMpegVideoPictureExt picext;
  GstMpegVideoQuantMatrixExt quantmatrext;

  gboolean seqhdr_updated;
  gboolean seqext_updated;
  gboolean seqdispext_updated;
  gboolean picext_updated;
  gboolean quantmatrext_updated;

  /* properties */
  gboolean drop;
  gboolean gop_split;

  int fps_num;
  int fps_den;
  int frame_repeat_count;
};
</STRUCT>
<STRUCT>
<NAME>GstMpegvParseClass</NAME>
struct _GstMpegvParseClass {
  GstBaseParseClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpegv_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PNG_PARSE</NAME>
#define GST_TYPE_PNG_PARSE \
  (gst_png_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_PNG_PARSE</NAME>
#define GST_PNG_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_PNG_PARSE,GstPngParse))
</MACRO>
<MACRO>
<NAME>GST_PNG_PARSE_CLASS</NAME>
#define GST_PNG_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_PNG_PARSE,GstPngParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PNG_PARSE</NAME>
#define GST_IS_PNG_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_PNG_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_PNG_PARSE_CLASS</NAME>
#define GST_IS_PNG_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_PNG_PARSE))
</MACRO>
<FUNCTION>
<NAME>gst_png_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstPngParse</NAME>
struct _GstPngParse
{
  GstBaseParse baseparse;

  guint width;
  guint height;
  
  gboolean sent_codec_tag;
};
</STRUCT>
<STRUCT>
<NAME>GstPngParseClass</NAME>
struct _GstPngParseClass
{
  GstBaseParseClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_AUTO_VIDEO_CONVERT</NAME>
#define GST_TYPE_AUTO_VIDEO_CONVERT 	        	(gst_auto_video_convert_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUTO_VIDEO_CONVERT</NAME>
#define GST_AUTO_VIDEO_CONVERT(obj)	            (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_AUTO_VIDEO_CONVERT,GstAutoVideoConvert))
</MACRO>
<MACRO>
<NAME>GST_AUTO_VIDEO_CONVERT_CLASS</NAME>
#define GST_AUTO_VIDEO_CONVERT_CLASS(klass)       (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_AUTO_VIDEO_CONVERT,GstAutoVideoConvertClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUTO_VIDEO_CONVERT</NAME>
#define GST_IS_AUTO_VIDEO_CONVERT(obj)            (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_AUTO_VIDEO_CONVERT))
</MACRO>
<MACRO>
<NAME>GST_IS_AUTO_VIDEO_CONVERT_CLASS</NAME>
#define GST_IS_AUTO_VIDEO_CONVERT_CLASS(klass)     (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_AUTO_VIDEO_CONVERT))
</MACRO>
<STRUCT>
<NAME>GstAutoVideoConvert</NAME>
struct _GstAutoVideoConvert
{
  /*< private > */
  GstBin bin;                   /* we extend GstBin */

  GstElement *autoconvert;
  GstPad *sinkpad;
  GstPad *srcpad;
};
</STRUCT>
<STRUCT>
<NAME>GstAutoVideoConvertClass</NAME>
struct _GstAutoVideoConvertClass
{
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_auto_video_convert_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SBC_ENC</NAME>
#define GST_TYPE_SBC_ENC \
	(gst_sbc_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_SBC_ENC</NAME>
#define GST_SBC_ENC(obj) \
	(G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SBC_ENC,GstSbcEnc))
</MACRO>
<MACRO>
<NAME>GST_SBC_ENC_CLASS</NAME>
#define GST_SBC_ENC_CLASS(klass) \
	(G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SBC_ENC,GstSbcEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SBC_ENC</NAME>
#define GST_IS_SBC_ENC(obj) \
	(G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SBC_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_SBC_ENC_CLASS</NAME>
#define GST_IS_SBC_ENC_CLASS(obj) \
	(G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SBC_ENC))
</MACRO>
<STRUCT>
<NAME>GstSbcEnc</NAME>
struct _GstSbcEnc {
	GstAudioEncoder audio_encoder;

    /*< private >*/
    gint rate;
    gint channels;
    gint blocks;
    gint subbands;
    gint bitpool;

    sbc_t sbc;
};
</STRUCT>
<STRUCT>
<NAME>GstSbcEncClass</NAME>
struct _GstSbcEncClass {
    GstAudioEncoderClass audio_encoder_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_sbc_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SBC_DEC</NAME>
#define GST_TYPE_SBC_DEC \
    (gst_sbc_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_SBC_DEC</NAME>
#define GST_SBC_DEC(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SBC_DEC,GstSbcDec))
</MACRO>
<MACRO>
<NAME>GST_SBC_DEC_CLASS</NAME>
#define GST_SBC_DEC_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SBC_DEC,GstSbcDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SBC_DEC</NAME>
#define GST_IS_SBC_DEC(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SBC_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_SBC_DEC_CLASS</NAME>
#define GST_IS_SBC_DEC_CLASS(obj) \
    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SBC_DEC))
</MACRO>
<STRUCT>
<NAME>GstSbcDec</NAME>
struct _GstSbcDec {
    GstAudioDecoder audio_decoder;

    /*< private >*/
    sbc_t           sbc;

    gsize           frame_len;
    gsize           samples_per_frame; /* for all channels */
};
</STRUCT>
<STRUCT>
<NAME>GstSbcDecClass</NAME>
struct _GstSbcDecClass {
    GstAudioDecoderClass audio_decoder_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_sbc_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_STEREOSPLIT</NAME>
#define GST_TYPE_GL_STEREOSPLIT            (gst_gl_stereosplit_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_STEREOSPLIT</NAME>
#define GST_GL_STEREOSPLIT(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_STEREOSPLIT,GstGLStereoSplit))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_STEREOSPLIT</NAME>
#define GST_IS_GL_STEREOSPLIT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_STEREOSPLIT))
</MACRO>
<MACRO>
<NAME>GST_GL_STEREOSPLIT_CLASS</NAME>
#define GST_GL_STEREOSPLIT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_STEREOSPLIT,GstGLStereoSplitClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_STEREOSPLIT_CLASS</NAME>
#define GST_IS_GL_STEREOSPLIT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_STEREOSPLIT))
</MACRO>
<MACRO>
<NAME>GST_GL_STEREOSPLIT_GET_CLASS</NAME>
#define GST_GL_STEREOSPLIT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_STEREOSPLIT,GstGLStereoSplitClass))
</MACRO>
<STRUCT>
<NAME>GstGLStereoSplit</NAME>
struct _GstGLStereoSplit
{
  GstElement parent;

  GstPad *sink_pad;
  GstPad *left_pad;
  GstPad *right_pad;

  GstGLDisplay      *display;
  GstGLContext      *context;
  GstGLContext      *other_context;

  GstGLViewConvert    *viewconvert;
};
</STRUCT>
<STRUCT>
<NAME>GstGLStereoSplitClass</NAME>
struct _GstGLStereoSplitClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_stereosplit_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_VIDEO_FLIP</NAME>
#define GST_TYPE_GL_VIDEO_FLIP            (gst_gl_video_flip_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_VIDEO_FLIP</NAME>
#define GST_GL_VIDEO_FLIP(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_VIDEO_FLIP,GstGLVideoFlip))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_VIDEO_FLIP</NAME>
#define GST_IS_GL_VIDEO_FLIP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_VIDEO_FLIP))
</MACRO>
<MACRO>
<NAME>GST_GL_VIDEO_FLIP_CLASS</NAME>
#define GST_GL_VIDEO_FLIP_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_VIDEO_FLIP,GstGLVideoFlipClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_VIDEO_FLIP_CLASS</NAME>
#define GST_IS_GL_VIDEO_FLIP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_VIDEO_FLIP))
</MACRO>
<MACRO>
<NAME>GST_GL_VIDEO_FLIP_GET_CLASS</NAME>
#define GST_GL_VIDEO_FLIP_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_VIDEO_FLIP,GstGLVideoFlipClass))
</MACRO>
<ENUM>
<NAME>GstGLVideoFlipMethod</NAME>
typedef enum {
  GST_GL_VIDEO_FLIP_METHOD_IDENTITY,
  GST_GL_VIDEO_FLIP_METHOD_90R,
  GST_GL_VIDEO_FLIP_METHOD_180,
  GST_GL_VIDEO_FLIP_METHOD_90L,
  GST_GL_VIDEO_FLIP_METHOD_FLIP_HORIZ,
  GST_GL_VIDEO_FLIP_METHOD_FLIP_VERT,
  GST_GL_VIDEO_FLIP_METHOD_FLIP_UL_LR,
  GST_GL_VIDEO_FLIP_METHOD_FLIP_UR_LL,
  GST_GL_VIDEO_FLIP_METHOD_AUTO,
} GstGLVideoFlipMethod;
</ENUM>
<STRUCT>
<NAME>GstGLVideoFlip</NAME>
struct _GstGLVideoFlip
{
  GstBin        bin;

  GstPad       *srcpad;
  GstPad       *sinkpad;

  GstElement   *input_capsfilter;
  GstElement   *transformation;
  GstElement   *output_capsfilter;

  gulong        sink_probe;
  gulong        src_probe;

  GstCaps      *input_caps;

  /* properties */
  GstVideoOrientationMethod method;
  GstVideoOrientationMethod tag_method;
  GstVideoOrientationMethod active_method;

  gfloat aspect;
};
</STRUCT>
<STRUCT>
<NAME>GstGLVideoFlipClass</NAME>
struct _GstGLVideoFlipClass
{
  GstBinClass filter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_video_flip_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_DIFFERENCEMATTE</NAME>
#define GST_TYPE_GL_DIFFERENCEMATTE            (gst_gl_differencematte_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_DIFFERENCEMATTE</NAME>
#define GST_GL_DIFFERENCEMATTE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_GL_DIFFERENCEMATTE,GstGLDifferenceMatte))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DIFFERENCEMATTE</NAME>
#define GST_IS_GL_DIFFERENCEMATTE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_GL_DIFFERENCEMATTE))
</MACRO>
<MACRO>
<NAME>GST_GL_DIFFERENCEMATTE_CLASS</NAME>
#define GST_GL_DIFFERENCEMATTE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) , GST_TYPE_GL_DIFFERENCEMATTE,GstGLDifferenceMatteClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DIFFERENCEMATTE_CLASS</NAME>
#define GST_IS_GL_DIFFERENCEMATTE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) , GST_TYPE_GL_DIFFERENCEMATTE))
</MACRO>
<MACRO>
<NAME>GST_GL_DIFFERENCEMATTE_GET_CLASS</NAME>
#define GST_GL_DIFFERENCEMATTE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) , GST_TYPE_GL_DIFFERENCEMATTE,GstGLDifferenceMatteClass))
</MACRO>
<STRUCT>
<NAME>GstGLDifferenceMatte</NAME>
struct _GstGLDifferenceMatte
{
  GstGLFilter filter;

  GstGLShader *identity_shader;
  GstGLShader *shader[4];

  gchar *location;
  gboolean bg_has_changed;

  guchar *pixbuf;
  gint pbuf_width, pbuf_height;
  GstGLMemory *savedbgtexture;
  GstGLMemory *newbgtexture;
  GstGLMemory *midtexture[4];
  GstGLMemory *intexture;
  float kernel[7];
};
</STRUCT>
<STRUCT>
<NAME>GstGLDifferenceMatteClass</NAME>
struct _GstGLDifferenceMatteClass
{
  GstGLFilterClass filter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_differencematte_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_TRANSFORMATION</NAME>
#define GST_TYPE_GL_TRANSFORMATION            (gst_gl_transformation_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_TRANSFORMATION</NAME>
#define GST_GL_TRANSFORMATION(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_TRANSFORMATION,GstGLTransformation))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_TRANSFORMATION</NAME>
#define GST_IS_GL_TRANSFORMATION(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_TRANSFORMATION))
</MACRO>
<MACRO>
<NAME>GST_GL_TRANSFORMATION_CLASS</NAME>
#define GST_GL_TRANSFORMATION_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_TRANSFORMATION,GstGLTransformationClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_TRANSFORMATION_CLASS</NAME>
#define GST_IS_GL_TRANSFORMATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_TRANSFORMATION))
</MACRO>
<MACRO>
<NAME>GST_GL_TRANSFORMATION_GET_CLASS</NAME>
#define GST_GL_TRANSFORMATION_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_TRANSFORMATION,GstGLTransformationClass))
</MACRO>
<STRUCT>
<NAME>GstGLTransformation</NAME>
struct _GstGLTransformation
{
    GstGLFilter filter;

    GstGLShader *shader;
    GLuint       vao;
    GLuint       vbo_indices;
    GLuint       vertex_buffer;
    GLint        attr_position;
    GLint        attr_texture;

    GstGLMemory *in_tex;
    GstGLMemory *out_tex;

    gfloat xrotation;
    gfloat yrotation;
    gfloat zrotation;

    gfloat xscale;
    gfloat yscale;

    gfloat xtranslation;
    gfloat ytranslation;
    gfloat ztranslation;

    gfloat xpivot;
    gfloat ypivot;
    gfloat zpivot;

    /* perspective */
    gfloat fov;
    gfloat aspect;
    gfloat znear;
    gfloat zfar;
    gboolean ortho;

    graphene_matrix_t model_matrix;
    graphene_matrix_t view_matrix;
    graphene_matrix_t projection_matrix;
    graphene_matrix_t inv_model_matrix;
    graphene_matrix_t inv_view_matrix;
    graphene_matrix_t inv_projection_matrix;
    graphene_matrix_t mvp_matrix;

    graphene_vec3_t camera_position;

    gboolean downstream_supports_affine_meta;
    gboolean caps_change;
};
</STRUCT>
<STRUCT>
<NAME>GstGLTransformationClass</NAME>
struct _GstGLTransformationClass
{
    GstGLFilterClass filter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_transformation_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_FILTER_CUBE</NAME>
#define GST_TYPE_GL_FILTER_CUBE            (gst_gl_filter_cube_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER_CUBE</NAME>
#define GST_GL_FILTER_CUBE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_FILTER_CUBE,GstGLFilterCube))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_FILTER_CUBE</NAME>
#define GST_IS_GL_FILTER_CUBE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_FILTER_CUBE))
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER_CUBE_CLASS</NAME>
#define GST_GL_FILTER_CUBE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_FILTER_CUBE,GstGLFilterCubeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_FILTER_CUBE_CLASS</NAME>
#define GST_IS_GL_FILTER_CUBE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_FILTER_CUBE))
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER_CUBE_GET_CLASS</NAME>
#define GST_GL_FILTER_CUBE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_FILTER_CUBE,GstGLFilterCubeClass))
</MACRO>
<STRUCT>
<NAME>GstGLFilterCube</NAME>
struct _GstGLFilterCube
{
    GstGLFilter filter;

    GstGLShader *shader;
    GstGLMemory *in_tex;

    /* background color */
    gfloat red;
    gfloat green;
    gfloat blue;

    /* perspective */
    gdouble fovy;
    gdouble aspect;
    gdouble znear;
    gdouble zfar;

    GLuint             vao;
    GLuint             vbo_indices;
    GLuint             vertex_buffer;
    GLint              attr_position;
    GLint              attr_texture;
};
</STRUCT>
<STRUCT>
<NAME>GstGLFilterCubeClass</NAME>
struct _GstGLFilterCubeClass
{
    GstGLFilterClass filter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_filter_cube_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CA_OPENGL_LAYER_SINK</NAME>
#define GST_TYPE_CA_OPENGL_LAYER_SINK \
    (gst_ca_opengl_layer_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_CA_OPENGL_LAYER_SINK</NAME>
#define GST_CA_OPENGL_LAYER_SINK(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CA_OPENGL_LAYER_SINK,GstCAOpenGLLayerSink))
</MACRO>
<MACRO>
<NAME>GST_CA_OPENGL_LAYER_SINK_CLASS</NAME>
#define GST_CA_OPENGL_LAYER_SINK_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CA_OPENGL_LAYER_SINK,GstCAOpenGLLayerSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CA_OPENGL_LAYER_SINK</NAME>
#define GST_IS_CA_OPENGL_LAYER_SINK(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CA_OPENGL_LAYER_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_CA_OPENGL_LAYER_SINK_CLASS</NAME>
#define GST_IS_CA_OPENGL_LAYER_SINK_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CA_OPENGL_LAYER_SINK))
</MACRO>
<STRUCT>
<NAME>GstCAOpenGLLayerSink</NAME>
struct _GstCAOpenGLLayerSink
{
    GstVideoSink video_sink;

    /* caps */
    GstVideoInfo info;
    GstCaps *gl_caps;

    /* gl state */
    GstGLDisplay *display;
    GstGLContext *other_context;
    GstGLContext *context;

    guint      next_tex;
    GstBuffer *next_buffer;
    GstBuffer *next_sync;

    gpointer layer;

    gboolean keep_aspect_ratio;

    /* avoid replacing the stored_buffer while drawing */
    GMutex drawing_lock;
    GstBuffer *stored_buffer;
    GstBuffer *stored_sync;
    GLuint redisplay_texture;

    gboolean caps_change;
    guint window_width;
    guint window_height;

    /* gl state */
    GstGLShader *redisplay_shader;
    GLuint vao;
    GLuint vertex_buffer;
    GLuint vbo_indices;
    GLint  attr_position;
    GLint  attr_texture;
};
</STRUCT>
<STRUCT>
<NAME>GstCAOpenGLLayerSinkClass</NAME>
struct _GstCAOpenGLLayerSinkClass
{
    GstVideoSinkClass video_sink_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ca_opengl_layer_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_ca_opengl_layer_sink_bin_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_src_bin_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_SRC_BIN</NAME>
#define GST_TYPE_GL_SRC_BIN \
    (gst_gl_src_bin_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_SRC_BIN</NAME>
#define GST_GL_SRC_BIN(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_SRC_BIN,GstGLSrcBin))
</MACRO>
<MACRO>
<NAME>GST_GL_SRC_BIN_CLASS</NAME>
#define GST_GL_SRC_BIN_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_SRC_BIN,GstGLSrcBinClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_SRC_BIN</NAME>
#define GST_IS_GL_SRC_BIN(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_SRC_BIN))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_SRC_BIN_CLASS</NAME>
#define GST_IS_GL_SRC_BIN_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_SRC_BIN))
</MACRO>
<MACRO>
<NAME>GST_GL_SRC_BIN_GET_CLASS</NAME>
#define GST_GL_SRC_BIN_GET_CLASS(obj) \
    (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_SRC_BIN,GstGLSrcBinClass))
</MACRO>
<STRUCT>
<NAME>GstGLSrcBin</NAME>
struct _GstGLSrcBin
{
  GstBin parent;

  GstPad *srcpad;

  GstElement *src;
  GstElement *convert;
  GstElement *download;
};
</STRUCT>
<STRUCT>
<NAME>GstGLSrcBinClass</NAME>
struct _GstGLSrcBinClass
{
  GstBinClass parent_class;

  GstElement * (*create_element) (void);
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_src_bin_finish_init</NAME>
<RETURNS>void  </RETURNS>
GstGLSrcBin * self
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_src_bin_finish_init_with_element</NAME>
<RETURNS>void  </RETURNS>
GstGLSrcBin * self, GstElement * element
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_filter_bin_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_FILTER_BIN</NAME>
#define GST_TYPE_GL_FILTER_BIN            (gst_gl_filter_bin_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER_BIN</NAME>
#define GST_GL_FILTER_BIN(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_FILTER_BIN,GstGLFilterBin))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_FILTER_BIN</NAME>
#define GST_IS_GL_FILTER_BIN(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_FILTER_BIN))
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER_BIN_CLASS</NAME>
#define GST_GL_FILTER_BIN_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_FILTER_BIN,GstGLFilterBinClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_FILTER_BIN_CLASS</NAME>
#define GST_IS_GL_FILTER_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_FILTER_BIN))
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER_BIN_GET_CLASS</NAME>
#define GST_GL_FILTER_BIN_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_FILTER_BIN,GstGLFilterBinClass))
</MACRO>
<STRUCT>
<NAME>GstGLFilterBin</NAME>
struct _GstGLFilterBin
{
  GstBin   parent;

  GstPad *srcpad;
  GstPad *sinkpad;

  GstElement *upload;
  GstElement *in_convert;
  GstElement *filter;
  GstElement *out_convert;
  GstElement *download;
};
</STRUCT>
<STRUCT>
<NAME>GstGLFilterBinClass</NAME>
struct _GstGLFilterBinClass
{
  GstBinClass parent_class;

  GstElement * (*create_element) (void);
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_filter_bin_finish_init</NAME>
<RETURNS>void  </RETURNS>
GstGLFilterBin * self
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_filter_bin_finish_init_with_element</NAME>
<RETURNS>void  </RETURNS>
GstGLFilterBin * self, GstElement * element
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_upload_element_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_UPLOAD_ELEMENT</NAME>
#define GST_TYPE_GL_UPLOAD_ELEMENT (gst_gl_upload_element_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_UPLOAD_ELEMENT</NAME>
#define GST_GL_UPLOAD_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_UPLOAD_ELEMENT,GstGLUploadElement))
</MACRO>
<MACRO>
<NAME>GST_GL_UPLOAD_ELEMENT_CLASS</NAME>
#define GST_GL_UPLOAD_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_UPLOAD_ELEMENT,GstGLUploadElementClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_UPLOAD_ELEMENT</NAME>
#define GST_IS_GL_UPLOAD_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_UPLOAD_ELEMENT))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_UPLOAD_ELEMENT_CLASS</NAME>
#define GST_IS_GL_UPLOAD_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_UPLOAD_ELEMENT))
</MACRO>
<MACRO>
<NAME>GST_GL_UPLOAD_ELEMENT_CAST</NAME>
#define GST_GL_UPLOAD_ELEMENT_CAST(obj) ((GstGLUploadElement*)(obj))
</MACRO>
<STRUCT>
<NAME>GstGLUploadElement</NAME>
struct _GstGLUploadElement
{
  /* <private> */
  GstGLBaseFilter     parent;

  GstGLUpload *upload;
  GstCaps *in_caps;
  GstCaps *out_caps;
};
</STRUCT>
<STRUCT>
<NAME>GstGLUploadElementClass</NAME>
struct _GstGLUploadElementClass
{
  GstGLBaseFilterClass object_class;
};
</STRUCT>
<STRUCT>
<NAME>GstGLUploadElementPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GL_MOSAIC</NAME>
#define GST_TYPE_GL_MOSAIC            (gst_gl_mosaic_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_MOSAIC</NAME>
#define GST_GL_MOSAIC(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_MOSAIC,GstGLMosaic))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_MOSAIC</NAME>
#define GST_IS_GL_MOSAIC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_MOSAIC))
</MACRO>
<MACRO>
<NAME>GST_GL_MOSAIC_CLASS</NAME>
#define GST_GL_MOSAIC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_MOSAIC,GstGLMosaicClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_MOSAIC_CLASS</NAME>
#define GST_IS_GL_MOSAIC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_MOSAIC))
</MACRO>
<MACRO>
<NAME>GST_GL_MOSAIC_GET_CLASS</NAME>
#define GST_GL_MOSAIC_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_MOSAIC,GstGLMosaicClass))
</MACRO>
<STRUCT>
<NAME>GstGLMosaic</NAME>
struct _GstGLMosaic
{
    GstGLMixer mixer;

    GstGLShader *shader;
    GstGLMemory *out_tex;
};
</STRUCT>
<STRUCT>
<NAME>GstGLMosaicClass</NAME>
struct _GstGLMosaicClass
{
    GstGLMixerClass mixer_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_mosaic_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_OVERLAY</NAME>
#define GST_TYPE_GL_OVERLAY            (gst_gl_overlay_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_OVERLAY</NAME>
#define GST_GL_OVERLAY(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_GL_OVERLAY,GstGLOverlay))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_OVERLAY</NAME>
#define GST_IS_GL_OVERLAY(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_GL_OVERLAY))
</MACRO>
<MACRO>
<NAME>GST_GL_OVERLAY_CLASS</NAME>
#define GST_GL_OVERLAY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) , GST_TYPE_GL_OVERLAY,GstGLOverlayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_OVERLAY_CLASS</NAME>
#define GST_IS_GL_OVERLAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) , GST_TYPE_GL_OVERLAY))
</MACRO>
<MACRO>
<NAME>GST_GL_OVERLAY_GET_CLASS</NAME>
#define GST_GL_OVERLAY_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) , GST_TYPE_GL_OVERLAY,GstGLOverlayClass))
</MACRO>
<STRUCT>
<NAME>GstGLOverlay</NAME>
struct _GstGLOverlay
{
  GstGLFilter  filter;

  /* properties */
  gchar        *location;
  gint          offset_x;
  gint          offset_y;

  gdouble       relative_x;
  gdouble       relative_y;

  gint          overlay_width;
  gint          overlay_height;

  gdouble       alpha;

  /* <private> */
  GstGLShader  *shader;
  GstGLMemory  *image_memory;

  gboolean      location_has_changed;
  gint          window_width, window_height;
  gint          image_width, image_height;

  gboolean      geometry_change;

  GLuint        vao;
  GLuint        overlay_vao;
  GLuint        vbo;
  GLuint        overlay_vbo;
  GLuint        vbo_indices;
  GLuint        attr_position;
  GLuint        attr_texture;
};
</STRUCT>
<STRUCT>
<NAME>GstGLOverlayClass</NAME>
struct _GstGLOverlayClass
{
  GstGLFilterClass filter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_overlay_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstGLTestSrcPattern</NAME>
typedef enum {
    GST_GL_TEST_SRC_SMPTE,
    GST_GL_TEST_SRC_SNOW,
    GST_GL_TEST_SRC_BLACK,
    GST_GL_TEST_SRC_WHITE,
    GST_GL_TEST_SRC_RED,
    GST_GL_TEST_SRC_GREEN,
    GST_GL_TEST_SRC_BLUE,
    GST_GL_TEST_SRC_CHECKERS1,
    GST_GL_TEST_SRC_CHECKERS2,
    GST_GL_TEST_SRC_CHECKERS4,
    GST_GL_TEST_SRC_CHECKERS8,
    GST_GL_TEST_SRC_CIRCULAR,
    GST_GL_TEST_SRC_BLINK,
    GST_GL_TEST_SRC_MANDELBROT
} GstGLTestSrcPattern;
</ENUM>
<STRUCT>
<NAME>BaseSrcImpl</NAME>
struct BaseSrcImpl {
  GstGLTestSrc *src;
  GstGLContext *context;
  GstVideoInfo v_info;
};
</STRUCT>
<STRUCT>
<NAME>SrcFuncs</NAME>
struct SrcFuncs
{
  GstGLTestSrcPattern pattern;
  gpointer (*new) (GstGLTestSrc * src);
  gboolean (*init) (gpointer impl, GstGLContext * context, GstVideoInfo * v_info);
  gboolean (*fill_bound_fbo) (gpointer impl);
  void (*free) (gpointer impl);
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_test_src_get_src_funcs_for_pattern</NAME>
<RETURNS>const struct SrcFuncs  * </RETURNS>
GstGLTestSrcPattern pattern
</FUNCTION>
<STRUCT>
<NAME>GstGLTestSrc</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GL_VIDEO_MIXER</NAME>
#define GST_TYPE_GL_VIDEO_MIXER            (gst_gl_video_mixer_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_VIDEO_MIXER</NAME>
#define GST_GL_VIDEO_MIXER(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_VIDEO_MIXER,GstGLVideoMixer))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_VIDEO_MIXER</NAME>
#define GST_IS_GL_VIDEO_MIXER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_VIDEO_MIXER))
</MACRO>
<MACRO>
<NAME>GST_GL_VIDEO_MIXER_CLASS</NAME>
#define GST_GL_VIDEO_MIXER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_VIDEO_MIXER,GstGLVideoMixerClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_VIDEO_MIXER_CLASS</NAME>
#define GST_IS_GL_VIDEO_MIXER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_VIDEO_MIXER))
</MACRO>
<MACRO>
<NAME>GST_GL_VIDEO_MIXER_GET_CLASS</NAME>
#define GST_GL_VIDEO_MIXER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_VIDEO_MIXER,GstGLVideoMixerClass))
</MACRO>
<ENUM>
<NAME>GstGLVideoMixerBackground</NAME>
typedef enum
{
  GST_GL_VIDEO_MIXER_BACKGROUND_CHECKER,
  GST_GL_VIDEO_MIXER_BACKGROUND_BLACK,
  GST_GL_VIDEO_MIXER_BACKGROUND_WHITE,
  GST_GL_VIDEO_MIXER_BACKGROUND_TRANSPARENT,
}
GstGLVideoMixerBackground;
</ENUM>
<ENUM>
<NAME>GstGLVideoMixerBlendEquation</NAME>
typedef enum
{
  GST_GL_VIDEO_MIXER_BLEND_EQUATION_ADD,
  GST_GL_VIDEO_MIXER_BLEND_EQUATION_SUBTRACT,
  GST_GL_VIDEO_MIXER_BLEND_EQUATION_REVERSE_SUBTRACT,
}
GstGLVideoMixerBlendEquation;
</ENUM>
<ENUM>
<NAME>GstGLVideoMixerBlendFunction</NAME>
typedef enum
{
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_ZERO,
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_ONE,
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_SRC_COLOR,
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_ONE_MINUS_SRC_COLOR,
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_DST_COLOR,
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_ONE_MINUS_DST_COLOR,
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_SRC_ALPHA,
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_ONE_MINUS_SRC_ALPHA,
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_DST_ALPHA,
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_ONE_MINUS_DST_ALPHA,
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_CONSTANT_COLOR,
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_ONE_MINUS_CONSTANT_COLOR,
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_CONSTANT_ALPHA,
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_ONE_MINUS_CONSTANT_ALPHA,
  GST_GL_VIDEO_MIXER_BLEND_FUNCTION_SRC_ALPHA_SATURATE,
}
GstGLVideoMixerBlendFunction;
</ENUM>
<STRUCT>
<NAME>GstGLVideoMixer</NAME>
struct _GstGLVideoMixer
{
    GstGLMixer mixer;

    GstGLVideoMixerBackground background;

    GstGLShader *shader;
    GstGLShader *checker;

    GLuint vao;
    GLuint vbo_indices;
    GLuint checker_vbo;
    GstGLMemory *out_tex;
};
</STRUCT>
<STRUCT>
<NAME>GstGLVideoMixerClass</NAME>
struct _GstGLVideoMixerClass
{
    GstGLMixerClass mixer_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_video_mixer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_video_mixer_bin_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_FILTER_GLASS</NAME>
#define GST_TYPE_GL_FILTER_GLASS            (gst_gl_filter_glass_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER_GLASS</NAME>
#define GST_GL_FILTER_GLASS(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_FILTER_GLASS,GstGLFilterGlass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_FILTER_GLASS</NAME>
#define GST_IS_GL_FILTER_GLASS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_FILTER_GLASS))
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER_GLASS_CLASS</NAME>
#define GST_GL_FILTER_GLASS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_FILTER_GLASS,GstGLFilterGlassClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_FILTER_GLASS_CLASS</NAME>
#define GST_IS_GL_FILTER_GLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_FILTER_GLASS))
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER_GLASS_GET_CLASS</NAME>
#define GST_GL_FILTER_GLASS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_FILTER_GLASS,GstGLFilterGlassClass))
</MACRO>
<STRUCT>
<NAME>GstGLFilterGlass</NAME>
struct _GstGLFilterGlass
{
  GstGLFilter filter;
  GstGLShader *passthrough_shader;
  GstGLShader *shader;
  gint64 timestamp;
  GstGLMemory *in_tex;
  GstGLMemory *out_tex;
};
</STRUCT>
<STRUCT>
<NAME>GstGLFilterGlassClass</NAME>
struct _GstGLFilterGlassClass
{
  GstGLFilterClass filter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_filter_glass_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_sink_bin_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_SINK_BIN</NAME>
#define GST_TYPE_GL_SINK_BIN \
    (gst_gl_sink_bin_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_SINK_BIN</NAME>
#define GST_GL_SINK_BIN(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_SINK_BIN,GstGLSinkBin))
</MACRO>
<MACRO>
<NAME>GST_GL_SINK_BIN_CLASS</NAME>
#define GST_GL_SINK_BIN_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_SINK_BIN,GstGLSinkBinClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_SINK_BIN</NAME>
#define GST_IS_GL_SINK_BIN(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_SINK_BIN))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_SINK_BIN_CLASS</NAME>
#define GST_IS_GL_SINK_BIN_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_SINK_BIN))
</MACRO>
<MACRO>
<NAME>GST_GL_SINK_BIN_GET_CLASS</NAME>
#define GST_GL_SINK_BIN_GET_CLASS(obj) \
    (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_SINK_BIN,GstGLSinkBinClass))
</MACRO>
<STRUCT>
<NAME>GstGLSinkBin</NAME>
struct _GstGLSinkBin
{
  GstBin parent;

  GstPad *sinkpad;

  GstElement *upload;
  GstElement *convert;
  GstElement *balance;
  GstElement *sink;
};
</STRUCT>
<STRUCT>
<NAME>GstGLSinkBinClass</NAME>
struct _GstGLSinkBinClass
{
  GstBinClass parent_class;

  GstElement * (*create_element) (void);
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_sink_bin_finish_init</NAME>
<RETURNS>void  </RETURNS>
GstGLSinkBin * self
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_sink_bin_finish_init_with_element</NAME>
<RETURNS>void  </RETURNS>
GstGLSinkBin * self, GstElement * element
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_FILTER_APP</NAME>
#define GST_TYPE_GL_FILTER_APP            (gst_gl_filter_app_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER_APP</NAME>
#define GST_GL_FILTER_APP(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_FILTER_APP,GstGLFilterApp))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_FILTER_APP</NAME>
#define GST_IS_GL_FILTER_APP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_FILTER_APP))
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER_APP_CLASS</NAME>
#define GST_GL_FILTER_APP_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_FILTER_APP,GstGLFilterAppClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_FILTER_APP_CLASS</NAME>
#define GST_IS_GL_FILTER_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_FILTER_APP))
</MACRO>
<MACRO>
<NAME>GST_GL_FILTER_APP_GET_CLASS</NAME>
#define GST_GL_FILTER_APP_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_FILTER_APP,GstGLFilterAppClass))
</MACRO>
<STRUCT>
<NAME>GstGLFilterApp</NAME>
struct _GstGLFilterApp
{
    GstGLFilter filter;
};
</STRUCT>
<STRUCT>
<NAME>GstGLFilterAppClass</NAME>
struct _GstGLFilterAppClass
{
    GstGLFilterClass filter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_filter_app_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_FILTERSHADER</NAME>
#define GST_TYPE_GL_FILTERSHADER            (gst_gl_filtershader_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_FILTERSHADER</NAME>
#define GST_GL_FILTERSHADER(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_FILTERSHADER,GstGLFilterShader))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_FILTERSHADER</NAME>
#define GST_IS_GL_FILTERSHADER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_FILTERSHADER))
</MACRO>
<MACRO>
<NAME>GST_GL_FILTERSHADER_CLASS</NAME>
#define GST_GL_FILTERSHADER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_FILTERSHADER,GstGLFilterShaderClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_FILTERSHADER_CLASS</NAME>
#define GST_IS_GL_FILTERSHADER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_FILTERSHADER))
</MACRO>
<MACRO>
<NAME>GST_GL_FILTERSHADER_GET_CLASS</NAME>
#define GST_GL_FILTERSHADER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_FILTERSHADER,GstGLFilterShaderClass))
</MACRO>
<STRUCT>
<NAME>GstGLFilterShader</NAME>
struct _GstGLFilterShader
{
  GstGLFilter filter;

  /* properties */
  GstGLShader *shader;
  gchar *vertex;
  gchar *fragment;
  gboolean update_shader; /* update the shader on the next draw */
  GstStructure *uniforms;

  gboolean new_source;
  gboolean new_uniforms;
  gdouble time;

  gint attr_position_loc;
  gint attr_texture_loc;
};
</STRUCT>
<STRUCT>
<NAME>GstGLFilterShaderClass</NAME>
struct _GstGLFilterShaderClass
{
  GstGLFilterClass filter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_filtershader_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_VIEW_CONVERT_ELEMENT</NAME>
#define GST_TYPE_GL_VIEW_CONVERT_ELEMENT            (gst_gl_view_convert_element_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_VIEW_CONVERT_ELEMENT</NAME>
#define GST_GL_VIEW_CONVERT_ELEMENT(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_VIEW_CONVERT_ELEMENT,GstGLViewConvertElement))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_VIEW_CONVERT_ELEMENT</NAME>
#define GST_IS_GL_VIEW_CONVERT_ELEMENT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_VIEW_CONVERT_ELEMENT))
</MACRO>
<MACRO>
<NAME>GST_GL_VIEW_CONVERT_ELEMENT_CLASS</NAME>
#define GST_GL_VIEW_CONVERT_ELEMENT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_VIEW_CONVERT_ELEMENT,GstGLViewConvertElementClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_VIEW_CONVERT_ELEMENT_CLASS</NAME>
#define GST_IS_GL_VIEW_CONVERT_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_VIEW_CONVERT_ELEMENT))
</MACRO>
<MACRO>
<NAME>GST_GL_VIEW_CONVERT_ELEMENT_GET_CLASS</NAME>
#define GST_GL_VIEW_CONVERT_ELEMENT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_VIEW_CONVERT_ELEMENT,GstGLViewConvertElementClass))
</MACRO>
<STRUCT>
<NAME>GstGLViewConvertElement</NAME>
struct _GstGLViewConvertElement
{
  GstGLFilter filter;

  GstGLViewConvert *viewconvert;
};
</STRUCT>
<STRUCT>
<NAME>GstGLViewConvertElementClass</NAME>
struct _GstGLViewConvertElementClass
{
  GstGLFilterClass filter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_view_convert_element_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_DEINTERLACE</NAME>
#define GST_TYPE_GL_DEINTERLACE            (gst_gl_deinterlace_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_DEINTERLACE</NAME>
#define GST_GL_DEINTERLACE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_DEINTERLACE,GstGLDeinterlace))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DEINTERLACE</NAME>
#define GST_IS_GL_DEINTERLACE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_DEINTERLACE))
</MACRO>
<MACRO>
<NAME>GST_GL_DEINTERLACE_CLASS</NAME>
#define GST_GL_DEINTERLACE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_DEINTERLACE,GstGLDeinterlaceClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DEINTERLACE_CLASS</NAME>
#define GST_IS_GL_DEINTERLACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_DEINTERLACE))
</MACRO>
<MACRO>
<NAME>GST_GL_DEINTERLACE_GET_CLASS</NAME>
#define GST_GL_DEINTERLACE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_DEINTERLACE,GstGLDeinterlaceClass))
</MACRO>
<MACRO>
<NAME>USING_OPENGL</NAME>
#define USING_OPENGL(context) (gst_gl_context_check_gl_version (context, GST_GL_API_OPENGL, 1, 0))
</MACRO>
<STRUCT>
<NAME>GstGLDeinterlace</NAME>
struct _GstGLDeinterlace
{
  GstGLFilter               filter;

  GstGLFilterRenderFunc     deinterlacefunc; 
  GHashTable               *shaderstable;
  GstBuffer                *prev_buffer;
  GstGLMemory *             prev_tex;

  gint	                    current_method;
};
</STRUCT>
<STRUCT>
<NAME>GstGLDeinterlaceClass</NAME>
struct _GstGLDeinterlaceClass
{
  GstGLFilterClass filter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_deinterlace_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_BASE_MIXER_PAD</NAME>
#define GST_TYPE_GL_BASE_MIXER_PAD (gst_gl_base_mixer_pad_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_BASE_MIXER_PAD</NAME>
#define GST_GL_BASE_MIXER_PAD(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_BASE_MIXER_PAD, GstGLBaseMixerPad))
</MACRO>
<MACRO>
<NAME>GST_GL_BASE_MIXER_PAD_CLASS</NAME>
#define GST_GL_BASE_MIXER_PAD_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_BASE_MIXER_PAD, GstGLBaseMixerPadClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_BASE_MIXER_PAD</NAME>
#define GST_IS_GL_BASE_MIXER_PAD(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_BASE_MIXER_PAD))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_BASE_MIXER_PAD_CLASS</NAME>
#define GST_IS_GL_BASE_MIXER_PAD_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_BASE_MIXER_PAD))
</MACRO>
<MACRO>
<NAME>GST_GL_BASE_MIXER_PAD_GET_CLASS</NAME>
#define GST_GL_BASE_MIXER_PAD_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_GL_BASE_MIXER_PAD,GstGLBaseMixerPadClass))
</MACRO>
<STRUCT>
<NAME>GstGLBaseMixerPad</NAME>
struct _GstGLBaseMixerPad
{
  GstVideoAggregatorPad parent;                /* subclass the pad */

  gboolean negotiated;
};
</STRUCT>
<STRUCT>
<NAME>GstGLBaseMixerPadClass</NAME>
struct _GstGLBaseMixerPadClass
{
  GstVideoAggregatorPadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_base_mixer_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_BASE_MIXER</NAME>
#define GST_TYPE_GL_BASE_MIXER (gst_gl_base_mixer_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_BASE_MIXER</NAME>
#define GST_GL_BASE_MIXER(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_BASE_MIXER, GstGLBaseMixer))
</MACRO>
<MACRO>
<NAME>GST_GL_BASE_MIXER_CLASS</NAME>
#define GST_GL_BASE_MIXER_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_BASE_MIXER, GstGLBaseMixerClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_BASE_MIXER</NAME>
#define GST_IS_GL_BASE_MIXER(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_BASE_MIXER))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_BASE_MIXER_CLASS</NAME>
#define GST_IS_GL_BASE_MIXER_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_BASE_MIXER))
</MACRO>
<MACRO>
<NAME>GST_GL_BASE_MIXER_GET_CLASS</NAME>
#define GST_GL_BASE_MIXER_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_GL_BASE_MIXER,GstGLBaseMixerClass))
</MACRO>
<STRUCT>
<NAME>GstGLBaseMixer</NAME>
struct _GstGLBaseMixer
{
  GstVideoAggregator     vaggregator;

  GstGLDisplay          *display;
  GstGLContext          *context;

  gpointer _padding[GST_PADDING];

  GstGLBaseMixerPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstGLBaseMixerClass</NAME>
struct _GstGLBaseMixerClass
{
  GstVideoAggregatorClass parent_class;
  GstGLAPI supported_gl_api;

  gboolean (*propose_allocation) (GstGLBaseMixer * mix, GstGLBaseMixerPad * pad, GstQuery * decide_query, GstQuery *query);
  gboolean (*decide_allocation) (GstGLBaseMixer * mix, GstQuery * decide_query);

  gpointer _padding[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_base_mixer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_base_mixer_get_buffer_pool</NAME>
<RETURNS>GstBufferPool  *</RETURNS>
GstGLBaseMixer * mix
</FUNCTION>
<STRUCT>
<NAME>GstGLBaseMixerPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GL_TEST_SRC</NAME>
#define GST_TYPE_GL_TEST_SRC \
    (gst_gl_test_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_TEST_SRC</NAME>
#define GST_GL_TEST_SRC(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_TEST_SRC,GstGLTestSrc))
</MACRO>
<MACRO>
<NAME>GST_GL_TEST_SRC_CLASS</NAME>
#define GST_GL_TEST_SRC_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_TEST_SRC,GstGLTestSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_TEST_SRC</NAME>
#define GST_IS_GL_TEST_SRC(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_TEST_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_TEST_SRC_CLASS</NAME>
#define GST_IS_GL_TEST_SRC_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_TEST_SRC))
</MACRO>
<STRUCT>
<NAME>GstGLTestSrc</NAME>
struct _GstGLTestSrc {
    GstPushSrc element;

    /*< private >*/

    /* type of output */
    GstGLTestSrcPattern set_pattern;
    GstGLTestSrcPattern active_pattern;

    /* video state */
    GstVideoInfo out_info;

    GstGLFramebuffer *fbo;
    GstGLMemory *out_tex;

    GstGLShader *shader;

    GstBufferPool *pool;

    GstGLDisplay *display;
    GstGLContext *context, *other_context;
    gint64 timestamp_offset;              /* base offset */
    GstClockTime running_time;            /* total running time */
    gint64 n_frames;                      /* total frames sent */
    gboolean negotiated;

    gboolean gl_result;
    const struct SrcFuncs *src_funcs;
    gpointer src_impl;

    GstCaps *out_caps;
};
</STRUCT>
<STRUCT>
<NAME>GstGLTestSrcClass</NAME>
struct _GstGLTestSrcClass {
    GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_test_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_download_element_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_DOWNLOAD_ELEMENT</NAME>
#define GST_TYPE_GL_DOWNLOAD_ELEMENT (gst_gl_download_element_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_DOWNLOAD_ELEMENT</NAME>
#define GST_GL_DOWNLOAD_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_DOWNLOAD_ELEMENT,GstGLDownloadElement))
</MACRO>
<MACRO>
<NAME>GST_GL_DOWNLOAD_ELEMENT_CLASS</NAME>
#define GST_GL_DOWNLOAD_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_DISPLAY,GstGLDownloadElementClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DOWNLOAD_ELEMENT</NAME>
#define GST_IS_GL_DOWNLOAD_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_DOWNLOAD_ELEMENT))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_DOWNLOAD_ELEMENT_CLASS</NAME>
#define GST_IS_GL_DOWNLOAD_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_DOWNLOAD_ELEMENT))
</MACRO>
<MACRO>
<NAME>GST_GL_DOWNLOAD_ELEMENT_CAST</NAME>
#define GST_GL_DOWNLOAD_ELEMENT_CAST(obj) ((GstGLDownloadElement*)(obj))
</MACRO>
<STRUCT>
<NAME>GstGLDownloadElement</NAME>
struct _GstGLDownloadElement
{
  /* <private> */
  GstGLBaseFilter  parent;
};
</STRUCT>
<STRUCT>
<NAME>GstGLDownloadElementClass</NAME>
struct _GstGLDownloadElementClass
{
  /* <private> */
  GstGLBaseFilterClass object_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GL_EFFECTS</NAME>
#define GST_TYPE_GL_EFFECTS            (gst_gl_effects_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_EFFECTS</NAME>
#define GST_GL_EFFECTS(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_GL_EFFECTS,GstGLEffects))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_EFFECTS</NAME>
#define GST_IS_GL_EFFECTS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_GL_EFFECTS))
</MACRO>
<MACRO>
<NAME>GST_GL_EFFECTS_CLASS</NAME>
#define GST_GL_EFFECTS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) , GST_TYPE_GL_EFFECTS,GstGLEffectsClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_EFFECTS_CLASS</NAME>
#define GST_IS_GL_EFFECTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) , GST_TYPE_GL_EFFECTS))
</MACRO>
<MACRO>
<NAME>GST_GL_EFFECTS_GET_CLASS</NAME>
#define GST_GL_EFFECTS_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) , GST_TYPE_GL_EFFECTS,GstGLEffectsClass))
</MACRO>
<MACRO>
<NAME>USING_OPENGL</NAME>
#define USING_OPENGL(context) (gst_gl_context_check_gl_version (context, GST_GL_API_OPENGL, 1, 0))
</MACRO>
<MACRO>
<NAME>USING_OPENGL3</NAME>
#define USING_OPENGL3(context) (gst_gl_context_check_gl_version (context, GST_GL_API_OPENGL3, 3, 1))
</MACRO>
<MACRO>
<NAME>USING_GLES</NAME>
#define USING_GLES(context) (gst_gl_context_check_gl_version (context, GST_GL_API_GLES, 1, 0))
</MACRO>
<MACRO>
<NAME>USING_GLES2</NAME>
#define USING_GLES2(context) (gst_gl_context_check_gl_version (context, GST_GL_API_GLES2, 2, 0))
</MACRO>
<MACRO>
<NAME>USING_GLES3</NAME>
#define USING_GLES3(context) (gst_gl_context_check_gl_version (context, GST_GL_API_GLES2, 3, 0))
</MACRO>
<STRUCT>
<NAME>GstGLEffectsFilterDescriptor</NAME>
typedef struct {
  gint effect;
  guint supported_properties;
  const gchar *filter_name;
  const gchar *filter_longname;
} GstGLEffectsFilterDescriptor;
</STRUCT>
<USER_FUNCTION>
<NAME>GstGLEffectProcessFunc</NAME>
<RETURNS>void </RETURNS>
GstGLEffects *effects
</USER_FUNCTION>
<MACRO>
<NAME>NEEDED_TEXTURES</NAME>
#define NEEDED_TEXTURES 5
</MACRO>
<STRUCT>
<NAME>GstGLEffects</NAME>
struct _GstGLEffects
{
  GstGLFilter filter;

  GstGLEffectProcessFunc effect;
  gint current_effect;

  GstGLMemory *intexture;
  GstGLMemory *midtexture[NEEDED_TEXTURES];
  GstGLMemory *outtexture;

  GLuint curve[GST_GL_EFFECTS_N_CURVES];

  GHashTable *shaderstable;

  gboolean horizontal_swap; /* switch left to right */
  gboolean invert; /* colours */
};
</STRUCT>
<STRUCT>
<NAME>GstGLEffectsClass</NAME>
struct _GstGLEffectsClass
{
  GstGLFilterClass filter_class;
  const GstGLEffectsFilterDescriptor *filter_descriptor;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_effects_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_register_filters</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *, GstRank
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_get_fragment_shader</NAME>
<RETURNS>GstGLShader * </RETURNS>
GstGLEffects *effects, const gchar * shader_name, const gchar * shader_source_gles2
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_identity</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_mirror</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_squeeze</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_stretch</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_tunnel</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_fisheye</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_twirl</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_bulge</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_square</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_heat</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_sepia</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_xpro</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_xray</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_luma_xpro</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_sin</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_glow</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_sobel</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_blur</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_laplacian</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GLIMAGE_SINK</NAME>
#define GST_TYPE_GLIMAGE_SINK \
    (gst_glimage_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_GLIMAGE_SINK</NAME>
#define GST_GLIMAGE_SINK(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GLIMAGE_SINK,GstGLImageSink))
</MACRO>
<MACRO>
<NAME>GST_GLIMAGE_SINK_CLASS</NAME>
#define GST_GLIMAGE_SINK_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GLIMAGE_SINK,GstGLImageSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GLIMAGE_SINK</NAME>
#define GST_IS_GLIMAGE_SINK(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GLIMAGE_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_GLIMAGE_SINK_CLASS</NAME>
#define GST_IS_GLIMAGE_SINK_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GLIMAGE_SINK))
</MACRO>
<ENUM>
<NAME>GstGLRotateMethod</NAME>
typedef enum
{
  GST_GL_ROTATE_METHOD_IDENTITY,
  GST_GL_ROTATE_METHOD_90R,
  GST_GL_ROTATE_METHOD_180,
  GST_GL_ROTATE_METHOD_90L,
  GST_GL_ROTATE_METHOD_FLIP_HORIZ,
  GST_GL_ROTATE_METHOD_FLIP_VERT,
  GST_GL_ROTATE_METHOD_FLIP_UL_LR,
  GST_GL_ROTATE_METHOD_FLIP_UR_LL,
  GST_GL_ROTATE_METHOD_AUTO,
}GstGLRotateMethod;
</ENUM>
<STRUCT>
<NAME>GstGLImageSink</NAME>
struct _GstGLImageSink
{
    GstVideoSink video_sink;

    guintptr window_id;
    guintptr new_window_id;
    gulong mouse_sig_id;
    gulong key_sig_id;

    /* GstVideoOverlay::set_render_rectangle() cache */
    gint x;
    gint y;
    gint width;
    gint height;

    /* Input info before 3d stereo output conversion, if any */
    GstVideoInfo in_info;
    GstCaps *in_caps;

    /* format/caps we actually hand off to the app */
    GstVideoInfo out_info;
    GstCaps *out_caps;
    GstGLTextureTarget texture_target;

    GstGLDisplay *display;
    GstGLContext *context;
    GstGLContext *other_context;
    gboolean handle_events;
    gboolean ignore_alpha;

    GstGLViewConvert *convert_views;

    /* Original input RGBA buffer, ready for display,
     * or possible reconversion through the views filter */
    GstBuffer *input_buffer;
    /* Secondary view buffer - when operating in frame-by-frame mode */
    GstBuffer *input_buffer2;

    guint      next_tex;
    GstBuffer *next_buffer;
    GstBuffer *next_buffer2; /* frame-by-frame 2nd view */
    GstBuffer *next_sync;
    GstGLSyncMeta *next_sync_meta;

    volatile gint to_quit;
    gboolean keep_aspect_ratio;
    gint par_n, par_d;

    /* avoid replacing the stored_buffer while drawing */
    GMutex drawing_lock;
    GstBuffer *stored_buffer[2];
    GstBuffer *stored_sync;
    GstGLSyncMeta *stored_sync_meta;
    GLuint redisplay_texture;

    /* protected with drawing_lock */
    gboolean window_resized;
    guint window_width;
    guint window_height;

    GstVideoRectangle display_rect;

    GstGLShader *redisplay_shader;
    GLuint vao;
    GLuint vbo_indices;
    GLuint vertex_buffer;
    GLint  attr_position;
    GLint  attr_texture;

    GstVideoMultiviewMode mview_output_mode;
    GstVideoMultiviewFlags mview_output_flags;
    gboolean output_mode_changed;
    GstGLStereoDownmix mview_downmix_mode;

    GstGLOverlayCompositor *overlay_compositor;

    /* current video flip method */
    GstGLRotateMethod current_rotate_method;
    GstGLRotateMethod rotate_method;
    const gfloat *transform_matrix;
};
</STRUCT>
<STRUCT>
<NAME>GstGLImageSinkClass</NAME>
struct _GstGLImageSinkClass
{
    GstVideoSinkClass video_sink_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_glimage_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_image_sink_bin_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_gen_shader</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLContext * context, const gchar * shader_vertex_source, const gchar * shader_fragment_source, GstGLShader ** shader
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_multiply_matrix4</NAME>
<RETURNS>void  </RETURNS>
const gfloat * a, const gfloat * b, gfloat * result
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_get_affine_transformation_meta_as_ndc_ext</NAME>
<RETURNS>void  </RETURNS>
GstVideoAffineTransformationMeta * meta, gfloat * matrix
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_COLORSCALE</NAME>
#define GST_TYPE_GL_COLORSCALE            (gst_gl_colorscale_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_COLORSCALE</NAME>
#define GST_GL_COLORSCALE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_COLORSCALE,GstGLColorscale))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_COLORSCALE</NAME>
#define GST_IS_GL_COLORSCALE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_COLORSCALE))
</MACRO>
<MACRO>
<NAME>GST_GL_COLORSCALE_CLASS</NAME>
#define GST_GL_COLORSCALE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_GL_COLORSCALE,GstGLColorscaleClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_COLORSCALE_CLASS</NAME>
#define GST_IS_GL_COLORSCALE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_GL_COLORSCALE))
</MACRO>
<MACRO>
<NAME>GST_GL_COLORSCALE_GET_CLASS</NAME>
#define GST_GL_COLORSCALE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_GL_COLORSCALE,GstGLColorscaleClass))
</MACRO>
<STRUCT>
<NAME>GstGLColorscale</NAME>
struct _GstGLColorscale
{
    GstGLFilter filter;

    GstGLShader *shader;
};
</STRUCT>
<STRUCT>
<NAME>GstGLColorscaleClass</NAME>
struct _GstGLColorscaleClass
{
    GstGLFilterClass filter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_colorscale_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_color_convert_element_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_COLOR_CONVERT_ELEMENT</NAME>
#define GST_TYPE_GL_COLOR_CONVERT_ELEMENT (gst_gl_color_convert_element_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_COLOR_CONVERT_ELEMENT</NAME>
#define GST_GL_COLOR_CONVERT_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_COLOR_CONVERT_ELEMENT,GstGLColorConvertElement))
</MACRO>
<MACRO>
<NAME>GST_GL_COLOR_CONVERT_ELEMENT_CLASS</NAME>
#define GST_GL_COLOR_CONVERT_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_DISPLAY,GstGLColorConvertElementClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_COLOR_CONVERT_ELEMENT</NAME>
#define GST_IS_GL_COLOR_CONVERT_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_COLOR_CONVERT_ELEMENT))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_COLOR_CONVERT_ELEMENT_CLASS</NAME>
#define GST_IS_GL_COLOR_CONVERT_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_COLOR_CONVERT_ELEMENT))
</MACRO>
<MACRO>
<NAME>GST_GL_COLOR_CONVERT_ELEMENT_CAST</NAME>
#define GST_GL_COLOR_CONVERT_ELEMENT_CAST(obj) ((GstGLColorConvertElement*)(obj))
</MACRO>
<STRUCT>
<NAME>GstGLColorConvertElement</NAME>
struct _GstGLColorConvertElement
{
  GstGLBaseFilter        parent;

  GstGLColorConvert *convert;
  GstCaps *in_caps;
  GstCaps *out_caps;
};
</STRUCT>
<STRUCT>
<NAME>GstGLColorConvertElementClass</NAME>
struct _GstGLColorConvertElementClass
{
  GstGLBaseFilterClass object_class;
};
</STRUCT>
<STRUCT>
<NAME>GstGLColorConvertElementPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GL_COLOR_BALANCE</NAME>
#define GST_TYPE_GL_COLOR_BALANCE \
  (gst_gl_color_balance_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_COLOR_BALANCE</NAME>
#define GST_GL_COLOR_BALANCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_COLOR_BALANCE,GstGLColorBalance))
</MACRO>
<MACRO>
<NAME>GST_GL_COLOR_BALANCE_CLASS</NAME>
#define GST_GL_COLOR_BALANCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_COLOR_BALANCE,GstGLColorBalanceClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_COLOR_BALANCE</NAME>
#define GST_IS_GL_COLOR_BALANCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_COLOR_BALANCE))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_COLOR_BALANCE_CLASS</NAME>
#define GST_IS_GL_COLOR_BALANCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_COLOR_BALANCE))
</MACRO>
<STRUCT>
<NAME>GstGLColorBalance</NAME>
struct _GstGLColorBalance {
  GstGLFilter videofilter;

  /* < private > */
  GstGLShader *shader;

  /* channels for interface */
  GList *channels;

  /* properties */
  gdouble contrast;
  gdouble brightness;
  gdouble hue;
  gdouble saturation;
};
</STRUCT>
<STRUCT>
<NAME>GstGLColorBalanceClass</NAME>
struct _GstGLColorBalanceClass {
  GstGLFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_color_balance_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_mixer_bin_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_MIXER_BIN</NAME>
#define GST_TYPE_GL_MIXER_BIN (gst_gl_mixer_bin_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_MIXER_BIN</NAME>
#define GST_GL_MIXER_BIN(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_MIXER_BIN, GstGLMixerBin))
</MACRO>
<MACRO>
<NAME>GST_GL_MIXER_BIN_CLASS</NAME>
#define GST_GL_MIXER_BIN_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_MIXER_BIN, GstGLMixerBinClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_MIXER_BIN</NAME>
#define GST_IS_GL_MIXER_BIN(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_MIXER_BIN))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_MIXER_BIN_CLASS</NAME>
#define GST_IS_GL_MIXER_BIN_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_MIXER_BIN))
</MACRO>
<MACRO>
<NAME>GST_GL_MIXER_BIN_GET_CLASS</NAME>
#define GST_GL_MIXER_BIN_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_GL_MIXER_BIN,GstGLMixerBinClass))
</MACRO>
<STRUCT>
<NAME>GstGLMixerBin</NAME>
struct _GstGLMixerBin
{
  GstBin parent;

  GstElement *mixer;
  GstElement *out_convert;
  GstElement *download;
  GstPad *srcpad;

  GstGLMixerBinPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstGLMixerBinClass</NAME>
struct _GstGLMixerBinClass
{
  GstBinClass parent_class;

  GstElement * (*create_element) (void);
  GstGhostPad * (*create_input_pad) (GstGLMixerBin * self, GstPad * mixer_pad);
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_mixer_bin_finish_init</NAME>
<RETURNS>void  </RETURNS>
GstGLMixerBin * self
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_mixer_bin_finish_init_with_element</NAME>
<RETURNS>void  </RETURNS>
GstGLMixerBin * self, GstElement * element
</FUNCTION>
<STRUCT>
<NAME>GstGLMixerBinPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GL_MIXER_PAD</NAME>
#define GST_TYPE_GL_MIXER_PAD (gst_gl_mixer_pad_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_MIXER_PAD</NAME>
#define GST_GL_MIXER_PAD(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_MIXER_PAD, GstGLMixerPad))
</MACRO>
<MACRO>
<NAME>GST_GL_MIXER_PAD_CLASS</NAME>
#define GST_GL_MIXER_PAD_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_MIXER_PAD, GstGLMixerPadClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_MIXER_PAD</NAME>
#define GST_IS_GL_MIXER_PAD(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_MIXER_PAD))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_MIXER_PAD_CLASS</NAME>
#define GST_IS_GL_MIXER_PAD_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_MIXER_PAD))
</MACRO>
<MACRO>
<NAME>GST_GL_MIXER_PAD_GET_CLASS</NAME>
#define GST_GL_MIXER_PAD_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_GL_MIXER_PAD,GstGLMixerPadClass))
</MACRO>
<STRUCT>
<NAME>GstGLMixerPad</NAME>
struct _GstGLMixerPad
{
  GstGLBaseMixerPad parent;

  guint current_texture;
};
</STRUCT>
<STRUCT>
<NAME>GstGLMixerPadClass</NAME>
struct _GstGLMixerPadClass
{
  GstGLBaseMixerPadClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_mixer_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GL_MIXER</NAME>
#define GST_TYPE_GL_MIXER (gst_gl_mixer_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_MIXER</NAME>
#define GST_GL_MIXER(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_MIXER, GstGLMixer))
</MACRO>
<MACRO>
<NAME>GST_GL_MIXER_CLASS</NAME>
#define GST_GL_MIXER_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_MIXER, GstGLMixerClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_MIXER</NAME>
#define GST_IS_GL_MIXER(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_MIXER))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_MIXER_CLASS</NAME>
#define GST_IS_GL_MIXER_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_MIXER))
</MACRO>
<MACRO>
<NAME>GST_GL_MIXER_GET_CLASS</NAME>
#define GST_GL_MIXER_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_GL_MIXER,GstGLMixerClass))
</MACRO>
<USER_FUNCTION>
<NAME>GstGLMixerSetCaps</NAME>
<RETURNS>gboolean </RETURNS>
GstGLMixer* mixer,
  GstCaps* outcaps
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstGLMixerReset</NAME>
<RETURNS>void </RETURNS>
GstGLMixer *mixer
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstGLMixerProcessFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstGLMixer *mix, GstBuffer *outbuf
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstGLMixerProcessTextures</NAME>
<RETURNS>gboolean </RETURNS>
GstGLMixer *mix, GstGLMemory *out_tex
</USER_FUNCTION>
<STRUCT>
<NAME>GstGLMixer</NAME>
struct _GstGLMixer
{
  GstGLBaseMixer vaggregator;

  GstGLFramebuffer *fbo;

  GstCaps *out_caps;

  GstGLMixerPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstGLMixerClass</NAME>
struct _GstGLMixerClass
{
  GstGLBaseMixerClass parent_class;

  GstGLMixerSetCaps set_caps;
  GstGLMixerReset reset;
  GstGLMixerProcessFunc process_buffers;
  GstGLMixerProcessTextures process_textures;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_mixer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_mixer_process_textures</NAME>
<RETURNS>gboolean  </RETURNS>
GstGLMixer * mix, GstBuffer * outbuf
</FUNCTION>
<STRUCT>
<NAME>GstGLMixerPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GL_STEREO_MIX</NAME>
#define GST_TYPE_GL_STEREO_MIX (gst_gl_stereo_mix_get_type())
</MACRO>
<MACRO>
<NAME>GST_GL_STEREO_MIX</NAME>
#define GST_GL_STEREO_MIX(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GL_STEREO_MIX, GstGLStereoMix))
</MACRO>
<MACRO>
<NAME>GST_GL_STEREO_MIX_CLASS</NAME>
#define GST_GL_STEREO_MIX_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GL_STEREO_MIX, GstGLStereoMixClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_STEREO_MIX</NAME>
#define GST_IS_GL_STEREO_MIX(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GL_STEREO_MIX))
</MACRO>
<MACRO>
<NAME>GST_IS_GL_STEREO_MIX_CLASS</NAME>
#define GST_IS_GL_STEREO_MIX_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GL_STEREO_MIX))
</MACRO>
<MACRO>
<NAME>GST_GL_STEREO_MIX_GET_CLASS</NAME>
#define GST_GL_STEREO_MIX_GET_CLASS(obj) \
        (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_GL_STEREO_MIX,GstGLStereoMixClass))
</MACRO>
<STRUCT>
<NAME>GstGLStereoMixPad</NAME>
struct _GstGLStereoMixPad
{
  GstGLMixerPad mixer_pad;

  gboolean mapped;
  GstBuffer *current_buffer;
};
</STRUCT>
<STRUCT>
<NAME>GstGLStereoMixPadClass</NAME>
struct _GstGLStereoMixPadClass
{
  GstGLMixerPadClass mixer_pad_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GL_STEREO_MIX_PAD</NAME>
#define GST_TYPE_GL_STEREO_MIX_PAD (gst_gl_stereo_mix_pad_get_type ())
</MACRO>
<FUNCTION>
<NAME>gst_gl_stereo_mix_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstGLStereoMix</NAME>
struct _GstGLStereoMix
{
  GstGLMixer mixer;

  GLuint out_tex_id;

  GstGLViewConvert *viewconvert;
  GstGLStereoDownmix downmix_mode;

  GstVideoInfo mix_info;

  GPtrArray *input_frames;
  GstBuffer *primary_out;
  GstBuffer *auxilliary_out;
};
</STRUCT>
<STRUCT>
<NAME>GstGLStereoMixClass</NAME>
struct _GstGLStereoMixClass
{
    GstGLMixerClass mixer_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gl_stereo_mix_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_effects_luma_to_curve</NAME>
<RETURNS>void  </RETURNS>
GstGLEffects *effects, const GstGLEffectsCurve *curve, gint curve_index, GstGLMemory *in_tex, GstGLMemory *out_tex
</FUNCTION>
<VARIABLE>
<NAME>mirror_fragment_source_gles2</NAME>
extern const gchar *mirror_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>squeeze_fragment_source_gles2</NAME>
extern const gchar *squeeze_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>stretch_fragment_source_gles2</NAME>
extern const gchar *stretch_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>fisheye_fragment_source_gles2</NAME>
extern const gchar *fisheye_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>twirl_fragment_source_gles2</NAME>
extern const gchar *twirl_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>bulge_fragment_source_gles2</NAME>
extern const gchar *bulge_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>tunnel_fragment_source_gles2</NAME>
extern const gchar *tunnel_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>square_fragment_source_gles2</NAME>
extern const gchar *square_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>luma_threshold_fragment_source_gles2</NAME>
extern const gchar *luma_threshold_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>hconv7_fragment_source_gles2</NAME>
extern const gchar *hconv7_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>vconv7_fragment_source_gles2</NAME>
extern const gchar *vconv7_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>sum_fragment_source_gles2</NAME>
extern const gchar *sum_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>luma_to_curve_fragment_source_gles2</NAME>
extern const gchar *luma_to_curve_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>rgb_to_curve_fragment_source_gles2</NAME>
extern const gchar *rgb_to_curve_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>sin_fragment_source_gles2</NAME>
extern const gchar *sin_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>desaturate_fragment_source_gles2</NAME>
extern const gchar *desaturate_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>sep_sobel_hconv3_fragment_source_gles2</NAME>
extern const gchar *sep_sobel_hconv3_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>sep_sobel_vconv3_fragment_source_gles2</NAME>
extern const gchar *sep_sobel_vconv3_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>sep_sobel_length_fragment_source_gles2</NAME>
extern const gchar *sep_sobel_length_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>multiply_fragment_source_gles2</NAME>
extern const gchar *multiply_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>conv9_fragment_source_gles2</NAME>
extern const gchar *conv9_fragment_source_gles2;
</VARIABLE>
<VARIABLE>
<NAME>interpolate_fragment_source</NAME>
extern const gchar *interpolate_fragment_source;
</VARIABLE>
<VARIABLE>
<NAME>texture_interp_fragment_source</NAME>
extern const gchar *texture_interp_fragment_source;
</VARIABLE>
<VARIABLE>
<NAME>difference_fragment_source</NAME>
extern const gchar *difference_fragment_source;
</VARIABLE>
<FUNCTION>
<NAME>fill_gaussian_kernel</NAME>
<RETURNS>void  </RETURNS>
float *kernel, int size, float sigma
</FUNCTION>
<STRUCT>
<NAME>GstGLEffectsCurve</NAME>
struct _GstGLEffectsCurve {
  guint 	 width;
  guint 	 height;
  guint 	 bytes_per_pixel; /* 3:RGB */ 
  guint8	 pixel_data[256 * 1 * 3 + 1];
};
</STRUCT>
<VARIABLE>
<NAME>xpro_curve</NAME>
extern const GstGLEffectsCurve xpro_curve;
</VARIABLE>
<VARIABLE>
<NAME>luma_xpro_curve</NAME>
extern const GstGLEffectsCurve luma_xpro_curve;
</VARIABLE>
<VARIABLE>
<NAME>heat_curve</NAME>
extern const GstGLEffectsCurve heat_curve;
</VARIABLE>
<VARIABLE>
<NAME>sepia_curve</NAME>
extern const GstGLEffectsCurve sepia_curve;
</VARIABLE>
<VARIABLE>
<NAME>xray_curve</NAME>
extern const GstGLEffectsCurve xray_curve;
</VARIABLE>
<STRUCT>
<NAME>GstGLEffectsCurve</NAME>
</STRUCT>
<ENUM>
<NAME>GstIsoffParserResult</NAME>
typedef enum {
  GST_ISOFF_PARSER_OK,
  GST_ISOFF_PARSER_DONE,
  GST_ISOFF_PARSER_UNEXPECTED,
  GST_ISOFF_PARSER_ERROR
} GstIsoffParserResult;
</ENUM>
<FUNCTION>
<NAME>gst_isoff_parse_box_header</NAME>
<RETURNS>gboolean  </RETURNS>
GstByteReader * reader, guint32 * type, guint8 extended_type[16], guint * header_size, guint64 * size
</FUNCTION>
<MACRO>
<NAME>GST_ISOFF_FOURCC_UUID</NAME>
#define GST_ISOFF_FOURCC_UUID GST_MAKE_FOURCC('u','u','i','d')
</MACRO>
<MACRO>
<NAME>GST_ISOFF_FOURCC_MOOF</NAME>
#define GST_ISOFF_FOURCC_MOOF GST_MAKE_FOURCC('m','o','o','f')
</MACRO>
<MACRO>
<NAME>GST_ISOFF_FOURCC_MFHD</NAME>
#define GST_ISOFF_FOURCC_MFHD GST_MAKE_FOURCC('m','f','h','d')
</MACRO>
<MACRO>
<NAME>GST_ISOFF_FOURCC_TFHD</NAME>
#define GST_ISOFF_FOURCC_TFHD GST_MAKE_FOURCC('t','f','h','d')
</MACRO>
<MACRO>
<NAME>GST_ISOFF_FOURCC_TRUN</NAME>
#define GST_ISOFF_FOURCC_TRUN GST_MAKE_FOURCC('t','r','u','n')
</MACRO>
<MACRO>
<NAME>GST_ISOFF_FOURCC_TRAF</NAME>
#define GST_ISOFF_FOURCC_TRAF GST_MAKE_FOURCC('t','r','a','f')
</MACRO>
<MACRO>
<NAME>GST_ISOFF_FOURCC_MDAT</NAME>
#define GST_ISOFF_FOURCC_MDAT GST_MAKE_FOURCC('m','d','a','t')
</MACRO>
<MACRO>
<NAME>GST_ISOFF_FOURCC_SIDX</NAME>
#define GST_ISOFF_FOURCC_SIDX GST_MAKE_FOURCC('s','i','d','x')
</MACRO>
<MACRO>
<NAME>GST_ISOFF_SAMPLE_FLAGS_IS_LEADING</NAME>
#define GST_ISOFF_SAMPLE_FLAGS_IS_LEADING(flags)                   (((flags) >> 26) & 0x03)
</MACRO>
<MACRO>
<NAME>GST_ISOFF_SAMPLE_FLAGS_SAMPLE_DEPENDS_ON</NAME>
#define GST_ISOFF_SAMPLE_FLAGS_SAMPLE_DEPENDS_ON(flags)            (((flags) >> 24) & 0x03)
</MACRO>
<MACRO>
<NAME>GST_ISOFF_SAMPLE_FLAGS_SAMPLE_IS_DEPENDED_ON</NAME>
#define GST_ISOFF_SAMPLE_FLAGS_SAMPLE_IS_DEPENDED_ON(flags)        (((flags) >> 22) & 0x03)
</MACRO>
<MACRO>
<NAME>GST_ISOFF_SAMPLE_FLAGS_SAMPLE_HAS_REDUNDANCY</NAME>
#define GST_ISOFF_SAMPLE_FLAGS_SAMPLE_HAS_REDUNDANCY(flags)        (((flags) >> 20) & 0x03)
</MACRO>
<MACRO>
<NAME>GST_ISOFF_SAMPLE_FLAGS_SAMPLE_PADDING_VALUE</NAME>
#define GST_ISOFF_SAMPLE_FLAGS_SAMPLE_PADDING_VALUE(flags)         (((flags) >> 17) & 0x07)
</MACRO>
<MACRO>
<NAME>GST_ISOFF_SAMPLE_FLAGS_SAMPLE_IS_NON_SYNC_SAMPLE</NAME>
#define GST_ISOFF_SAMPLE_FLAGS_SAMPLE_IS_NON_SYNC_SAMPLE(flags)    (((flags) >> 16) & 0x01)
</MACRO>
<MACRO>
<NAME>GST_ISOFF_SAMPLE_FLAGS_SAMPLE_DEGRADATION_PRIORITY</NAME>
#define GST_ISOFF_SAMPLE_FLAGS_SAMPLE_DEGRADATION_PRIORITY(flags)  (((flags) >>  0) & 0x0f)
</MACRO>
<ENUM>
<NAME>GstTfhdFlags</NAME>
typedef enum
{
  GST_TFHD_FLAGS_BASE_DATA_OFFSET_PRESENT         = 0x000001,
  GST_TFHD_FLAGS_SAMPLE_DESCRIPTION_INDEX_PRESENT = 0x000002,
  GST_TFHD_FLAGS_DEFAULT_SAMPLE_DURATION_PRESENT  = 0x000008,
  GST_TFHD_FLAGS_DEFAULT_SAMPLE_SIZE_PRESENT      = 0x000010,
  GST_TFHD_FLAGS_DEFAULT_SAMPLE_FLAGS_PRESENT     = 0x000020,
  GST_TFHD_FLAGS_DURATION_IS_EMPTY                = 0x010000,
  GST_TFHD_FLAGS_DEFAULT_BASE_IS_MOOF             = 0x020000
} GstTfhdFlags;
</ENUM>
<ENUM>
<NAME>GstTrunFlags</NAME>
typedef enum
{
  GST_TRUN_FLAGS_DATA_OFFSET_PRESENT                     = 0x000001,
  GST_TRUN_FLAGS_FIRST_SAMPLE_FLAGS_PRESENT              = 0x000004,
  GST_TRUN_FLAGS_SAMPLE_DURATION_PRESENT                 = 0x000100,
  GST_TRUN_FLAGS_SAMPLE_SIZE_PRESENT                     = 0x000200,
  GST_TRUN_FLAGS_SAMPLE_FLAGS_PRESENT                    = 0x000400,
  GST_TRUN_FLAGS_SAMPLE_COMPOSITION_TIME_OFFSETS_PRESENT = 0x000800
} GstTrunFlags;
</ENUM>
<FUNCTION>
<NAME>gst_isoff_moof_box_parse</NAME>
<RETURNS>GstMoofBox  * </RETURNS>
GstByteReader *reader
</FUNCTION>
<FUNCTION>
<NAME>gst_isoff_moof_box_free</NAME>
<RETURNS>void  </RETURNS>
GstMoofBox *moof
</FUNCTION>
<ENUM>
<NAME>GstSidxParserStatus</NAME>
typedef enum _GstSidxParserStatus
{
  GST_ISOFF_SIDX_PARSER_INIT,
  GST_ISOFF_SIDX_PARSER_HEADER,
  GST_ISOFF_SIDX_PARSER_DATA,
  GST_ISOFF_SIDX_PARSER_FINISHED
} GstSidxParserStatus;
</ENUM>
<FUNCTION>
<NAME>gst_isoff_sidx_parser_init</NAME>
<RETURNS>void  </RETURNS>
GstSidxParser * parser
</FUNCTION>
<FUNCTION>
<NAME>gst_isoff_sidx_parser_clear</NAME>
<RETURNS>void  </RETURNS>
GstSidxParser * parser
</FUNCTION>
<FUNCTION>
<NAME>gst_isoff_sidx_parser_parse</NAME>
<RETURNS>GstIsoffParserResult  </RETURNS>
GstSidxParser * parser, GstByteReader * reader, guint * consumed
</FUNCTION>
<FUNCTION>
<NAME>gst_isoff_sidx_parser_add_buffer</NAME>
<RETURNS>GstIsoffParserResult  </RETURNS>
GstSidxParser * parser, GstBuffer * buf, guint * consumed
</FUNCTION>
<MACRO>
<NAME>GST_MPD_CLIENT_LOCK</NAME>
#define GST_MPD_CLIENT_LOCK(c) g_mutex_lock (&c->lock);
</MACRO>
<MACRO>
<NAME>GST_MPD_CLIENT_UNLOCK</NAME>
#define GST_MPD_CLIENT_UNLOCK(c) g_mutex_unlock (&c->lock);
</MACRO>
<MACRO>
<NAME>GST_MPD_DURATION_NONE</NAME>
#define GST_MPD_DURATION_NONE ((guint64)-1)
</MACRO>
<ENUM>
<NAME>GstStreamMimeType</NAME>
typedef enum
{
  GST_STREAM_UNKNOWN,
  GST_STREAM_VIDEO,           /* video stream (the main one) */
  GST_STREAM_AUDIO,           /* audio stream (optional) */
  GST_STREAM_APPLICATION      /* application stream (optional): for timed text/subtitles */
} GstStreamMimeType;
</ENUM>
<ENUM>
<NAME>GstMPDFileType</NAME>
typedef enum
{
  GST_MPD_FILE_TYPE_STATIC,
  GST_MPD_FILE_TYPE_DYNAMIC
} GstMPDFileType;
</ENUM>
<ENUM>
<NAME>GstSAPType</NAME>
typedef enum
{
  GST_SAP_TYPE_0 = 0,
  GST_SAP_TYPE_1,
  GST_SAP_TYPE_2,
  GST_SAP_TYPE_3,
  GST_SAP_TYPE_4,
  GST_SAP_TYPE_5,
  GST_SAP_TYPE_6
} GstSAPType;
</ENUM>
<ENUM>
<NAME>GstXLinkActuate</NAME>
typedef enum
{
  GST_XLINK_ACTUATE_ON_REQUEST,
  GST_XLINK_ACTUATE_ON_LOAD
} GstXLinkActuate;
</ENUM>
<ENUM>
<NAME>GstMPDUTCTimingType</NAME>
typedef enum
{
  GST_MPD_UTCTIMING_TYPE_UNKNOWN     = 0x00,
  GST_MPD_UTCTIMING_TYPE_NTP         = 0x01,
  GST_MPD_UTCTIMING_TYPE_SNTP        = 0x02,
  GST_MPD_UTCTIMING_TYPE_HTTP_HEAD   = 0x04,
  GST_MPD_UTCTIMING_TYPE_HTTP_XSDATE = 0x08,
  GST_MPD_UTCTIMING_TYPE_HTTP_ISO    = 0x10,
  GST_MPD_UTCTIMING_TYPE_HTTP_NTP    = 0x20,
  GST_MPD_UTCTIMING_TYPE_DIRECT      = 0x40
} GstMPDUTCTimingType;
</ENUM>
<STRUCT>
<NAME>GstBaseURL</NAME>
struct _GstBaseURL
{
  gchar *baseURL;
  gchar *serviceLocation;
  gchar *byteRange;
};
</STRUCT>
<STRUCT>
<NAME>GstRange</NAME>
struct _GstRange
{
  guint64 first_byte_pos;
  guint64 last_byte_pos;
};
</STRUCT>
<STRUCT>
<NAME>GstRatio</NAME>
struct _GstRatio
{
  guint num;
  guint den;
};
</STRUCT>
<STRUCT>
<NAME>GstFrameRate</NAME>
struct _GstFrameRate
{
  guint num;
  guint den;
};
</STRUCT>
<STRUCT>
<NAME>GstConditionalUintType</NAME>
struct _GstConditionalUintType
{
  gboolean flag;
  guint value;
};
</STRUCT>
<STRUCT>
<NAME>GstSNode</NAME>
struct _GstSNode
{
  guint64 t;
  guint64 d;
  gint r;
};
</STRUCT>
<STRUCT>
<NAME>GstSegmentTimelineNode</NAME>
struct _GstSegmentTimelineNode
{
  /* list of S nodes */
  GQueue S;
};
</STRUCT>
<STRUCT>
<NAME>GstURLType</NAME>
struct _GstURLType
{
  gchar *sourceURL;
  GstRange *range;
};
</STRUCT>
<STRUCT>
<NAME>GstSegmentBaseType</NAME>
struct _GstSegmentBaseType
{
  guint timescale;
  guint64 presentationTimeOffset;
  GstRange *indexRange;
  gboolean indexRangeExact;
  /* Initialization node */
  GstURLType *Initialization;
  /* RepresentationIndex node */
  GstURLType *RepresentationIndex;
};
</STRUCT>
<STRUCT>
<NAME>GstMultSegmentBaseType</NAME>
struct _GstMultSegmentBaseType
{
  guint duration;                  /* in seconds */
  guint startNumber;
  /* SegmentBaseType extension */
  GstSegmentBaseType *SegBaseType;
  /* SegmentTimeline node */
  GstSegmentTimelineNode *SegmentTimeline;
  /* BitstreamSwitching node */
  GstURLType *BitstreamSwitching;
};
</STRUCT>
<STRUCT>
<NAME>GstSegmentListNode</NAME>
struct _GstSegmentListNode
{
  /* extension */
  GstMultSegmentBaseType *MultSegBaseType;
  /* list of SegmentURL nodes */
  GList *SegmentURL;

  gchar *xlink_href;
  GstXLinkActuate actuate;
};
</STRUCT>
<STRUCT>
<NAME>GstSegmentTemplateNode</NAME>
struct _GstSegmentTemplateNode
{
  /* extension */
  GstMultSegmentBaseType *MultSegBaseType;
  gchar *media;
  gchar *index;
  gchar *initialization;
  gchar *bitstreamSwitching;
};
</STRUCT>
<STRUCT>
<NAME>GstSegmentURLNode</NAME>
struct _GstSegmentURLNode
{
  gchar *media;
  GstRange *mediaRange;
  gchar *index;
  GstRange *indexRange;
};
</STRUCT>
<STRUCT>
<NAME>GstRepresentationBaseType</NAME>
struct _GstRepresentationBaseType
{
  gchar *profiles;
  guint width;
  guint height;
  GstRatio *sar;
  GstFrameRate *minFrameRate;
  GstFrameRate *maxFrameRate;
  GstFrameRate *frameRate;
  gchar *audioSamplingRate;
  gchar *mimeType;
  gchar *segmentProfiles;
  gchar *codecs;
  gdouble maximumSAPPeriod;
  GstSAPType startWithSAP;
  gdouble maxPlayoutRate;
  gboolean codingDependency;
  gchar *scanType;
  /* list of FramePacking DescriptorType nodes */
  GList *FramePacking;
  /* list of AudioChannelConfiguration DescriptorType nodes */
  GList *AudioChannelConfiguration;
  /* list of ContentProtection DescriptorType nodes */
  GList *ContentProtection;
};
</STRUCT>
<STRUCT>
<NAME>GstSubRepresentationNode</NAME>
struct _GstSubRepresentationNode
{
  /* RepresentationBase extension */
  GstRepresentationBaseType *RepresentationBase;
  guint level;
  guint *dependencyLevel;            /* UIntVectorType */
  guint size;                        /* size of "dependencyLevel" array */
  guint bandwidth;
  gchar **contentComponent;          /* StringVectorType */
};
</STRUCT>
<STRUCT>
<NAME>GstRepresentationNode</NAME>
struct _GstRepresentationNode
{
  gchar *id;
  guint bandwidth;
  guint qualityRanking;
  gchar **dependencyId;              /* StringVectorType */
  gchar **mediaStreamStructureId;    /* StringVectorType */
  /* RepresentationBase extension */
  GstRepresentationBaseType *RepresentationBase;
  /* list of BaseURL nodes */
  GList *BaseURLs;
  /* list of SubRepresentation nodes */
  GList *SubRepresentations;
  /* SegmentBase node */
  GstSegmentBaseType *SegmentBase;
  /* SegmentTemplate node */
  GstSegmentTemplateNode *SegmentTemplate;
  /* SegmentList node */
  GstSegmentListNode *SegmentList;
};
</STRUCT>
<STRUCT>
<NAME>GstDescriptorType</NAME>
struct _GstDescriptorType
{
  gchar *schemeIdUri;
  gchar *value;
};
</STRUCT>
<STRUCT>
<NAME>GstContentComponentNode</NAME>
struct _GstContentComponentNode
{
  guint id;
  gchar *lang;                      /* LangVectorType RFC 5646 */
  gchar *contentType;
  GstRatio *par;
  /* list of Accessibility DescriptorType nodes */
  GList *Accessibility;
  /* list of Role DescriptorType nodes */
  GList *Role;
  /* list of Rating DescriptorType nodes */
  GList *Rating;
  /* list of Viewpoint DescriptorType nodes */
  GList *Viewpoint;
};
</STRUCT>
<STRUCT>
<NAME>GstAdaptationSetNode</NAME>
struct _GstAdaptationSetNode
{
  guint id;
  guint group;
  gchar *lang;                      /* LangVectorType RFC 5646 */
  gchar *contentType;
  GstRatio *par;
  guint minBandwidth;
  guint maxBandwidth;
  guint minWidth;
  guint maxWidth;
  guint minHeight;
  guint maxHeight;
  GstConditionalUintType *segmentAlignment;
  GstConditionalUintType *subsegmentAlignment;
  GstSAPType subsegmentStartsWithSAP;
  gboolean bitstreamSwitching;
  /* list of Accessibility DescriptorType nodes */
  GList *Accessibility;
  /* list of Role DescriptorType nodes */
  GList *Role;
  /* list of Rating DescriptorType nodes */
  GList *Rating;
  /* list of Viewpoint DescriptorType nodes */
  GList *Viewpoint;
  /* RepresentationBase extension */
  GstRepresentationBaseType *RepresentationBase;
  /* SegmentBase node */
  GstSegmentBaseType *SegmentBase;
  /* SegmentList node */
  GstSegmentListNode *SegmentList;
  /* SegmentTemplate node */
  GstSegmentTemplateNode *SegmentTemplate;
  /* list of BaseURL nodes */
  GList *BaseURLs;
  /* list of Representation nodes */
  GList *Representations;
  /* list of ContentComponent nodes */
  GList *ContentComponents;

  gchar *xlink_href;
  GstXLinkActuate actuate;
};
</STRUCT>
<STRUCT>
<NAME>GstSubsetNode</NAME>
struct _GstSubsetNode
{
  guint *contains;                   /* UIntVectorType */
  guint size;                        /* size of the "contains" array */
};
</STRUCT>
<STRUCT>
<NAME>GstPeriodNode</NAME>
struct _GstPeriodNode
{
  gchar *id;
  guint64 start;                     /* [ms] */
  guint64 duration;                  /* [ms] */
  gboolean bitstreamSwitching;
  /* SegmentBase node */
  GstSegmentBaseType *SegmentBase;
  /* SegmentList node */
  GstSegmentListNode *SegmentList;
  /* SegmentTemplate node */
  GstSegmentTemplateNode *SegmentTemplate;
  /* list of Adaptation Set nodes */
  GList *AdaptationSets;
  /* list of Representation nodes */
  GList *Subsets;
  /* list of BaseURL nodes */
  GList *BaseURLs;

  gchar *xlink_href;
  GstXLinkActuate actuate;
};
</STRUCT>
<STRUCT>
<NAME>GstProgramInformationNode</NAME>
struct _GstProgramInformationNode
{
  gchar *lang;                      /* LangVectorType RFC 5646 */
  gchar *moreInformationURL;
  /* children nodes */
  gchar *Title;
  gchar *Source;
  gchar *Copyright;
};
</STRUCT>
<STRUCT>
<NAME>GstMetricsRangeNode</NAME>
struct _GstMetricsRangeNode
{
  guint64 starttime;                 /* [ms] */
  guint64 duration;                  /* [ms] */
};
</STRUCT>
<STRUCT>
<NAME>GstMetricsNode</NAME>
struct _GstMetricsNode
{
  gchar *metrics;
  /* list of Metrics Range nodes */
  GList *MetricsRanges;
  /* list of Reporting nodes */
  GList *Reportings;
};
</STRUCT>
<STRUCT>
<NAME>GstUTCTimingNode</NAME>
struct _GstUTCTimingNode {
  GstMPDUTCTimingType method;
  /* NULL terminated array of strings */
  gchar **urls;
};
</STRUCT>
<STRUCT>
<NAME>GstMPDNode</NAME>
struct _GstMPDNode
{
  gchar *default_namespace;
  gchar *namespace_xsi;
  gchar *namespace_ext;
  gchar *schemaLocation;
  gchar *id;
  gchar *profiles;
  GstMPDFileType type;
  GstDateTime *availabilityStartTime;
  GstDateTime *availabilityEndTime;
  guint64 mediaPresentationDuration;  /* [ms] */
  guint64 minimumUpdatePeriod;        /* [ms] */
  guint64 minBufferTime;              /* [ms] */
  guint64 timeShiftBufferDepth;       /* [ms] */
  guint64 suggestedPresentationDelay; /* [ms] */
  guint64 maxSegmentDuration;         /* [ms] */
  guint64 maxSubsegmentDuration;      /* [ms] */
  /* list of BaseURL nodes */
  GList *BaseURLs;
  /* list of Location nodes */
  GList *Locations;
  /* List of ProgramInformation nodes */
  GList *ProgramInfo;
  /* list of Periods nodes */
  GList *Periods;
  /* list of Metrics nodes */
  GList *Metrics;
  /* list of GstUTCTimingNode nodes */
  GList *UTCTiming;
};
</STRUCT>
<STRUCT>
<NAME>GstStreamPeriod</NAME>
struct _GstStreamPeriod
{
  GstPeriodNode *period;                      /* Stream period */
  guint number;                               /* Period number */
  GstClockTime start;                         /* Period start time */
  GstClockTime duration;                      /* Period duration */
};
</STRUCT>
<STRUCT>
<NAME>GstMediaSegment</NAME>
struct _GstMediaSegment
{
  GstSegmentURLNode *SegmentURL;              /* this is NULL when using a SegmentTemplate */
  guint number;                               /* segment number */
  gint repeat;                                /* number of extra repetitions (0 = played only once) */
  guint64 scale_start;                        /* start time in timescale units */
  guint64 scale_duration;                     /* duration in timescale units */
  GstClockTime start;                         /* segment start time */
  GstClockTime duration;                      /* segment duration */
};
</STRUCT>
<STRUCT>
<NAME>GstMediaFragmentInfo</NAME>
struct _GstMediaFragmentInfo
{
  gchar *uri;
  gint64 range_start;
  gint64 range_end;

  gchar *index_uri;
  gint64 index_range_start;
  gint64 index_range_end;

  gboolean discontinuity;
  GstClockTime timestamp;
  GstClockTime duration;
};
</STRUCT>
<STRUCT>
<NAME>GstActiveStream</NAME>
struct _GstActiveStream
{
  GstStreamMimeType mimeType;                 /* video/audio/application */

  guint baseURL_idx;                          /* index of the baseURL used for last request */
  gchar *baseURL;                             /* active baseURL used for last request */
  gchar *queryURL;                            /* active queryURL used for last request */
  guint max_bandwidth;                        /* max bandwidth allowed for this mimeType */

  GstAdaptationSetNode *cur_adapt_set;        /* active adaptation set */
  gint representation_idx;                    /* index of current representation */
  GstRepresentationNode *cur_representation;  /* active representation */
  GstSegmentBaseType *cur_segment_base;       /* active segment base */
  GstSegmentListNode *cur_segment_list;       /* active segment list */
  GstSegmentTemplateNode *cur_seg_template;   /* active segment template */
  gint segment_index;                         /* index of next sequence chunk */
  guint segment_repeat_index;                 /* index of the repeat count of a segment */
  GPtrArray *segments;                        /* array of GstMediaSegment */
  GstClockTime presentationTimeOffset;        /* presentation time offset of the current segment */
};
</STRUCT>
<STRUCT>
<NAME>GstMpdClient</NAME>
struct _GstMpdClient
{
  GstMPDNode *mpd_node;                       /* active MPD manifest file */

  GList *periods;                             /* list of GstStreamPeriod */
  guint period_idx;                           /* index of current Period */

  GList *active_streams;                      /* list of GstActiveStream */

  guint update_failed_count;
  gchar *mpd_uri;                             /* manifest file URI */
  gchar *mpd_base_uri;                        /* base URI for resolving relative URIs.
                                               * this will be different for redirects */

  /* profiles */
  gboolean profile_isoff_ondemand;

  GstUriDownloader * downloader;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpd_client_new</NAME>
<RETURNS>GstMpdClient  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_active_streams_free</NAME>
<RETURNS>void  </RETURNS>
GstMpdClient * client
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_free</NAME>
<RETURNS>void  </RETURNS>
GstMpdClient * client
</FUNCTION>
<FUNCTION>
<NAME>gst_media_fragment_info_clear</NAME>
<RETURNS>void  </RETURNS>
GstMediaFragmentInfo * fragment
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_set_uri_downloader</NAME>
<RETURNS>void  </RETURNS>
GstMpdClient * client, GstUriDownloader * download
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_parse</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient *client, const gchar *data, gint size
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_setup_media_presentation</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient *client, GstClockTime time, gint period_index, const gchar *period_id
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_setup_streaming</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient * client, GstAdaptationSetNode * adapt_set
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_setup_representation</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient *client, GstActiveStream *stream, GstRepresentationNode *representation
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_next_fragment_duration</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstMpdClient * client, GstActiveStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_media_presentation_duration</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstMpdClient *client
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_maximum_segment_duration</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstMpdClient * client
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_last_fragment_timestamp_end</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient * client, guint stream_idx, GstClockTime * ts
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_next_fragment_timestamp</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient * client, guint stream_idx, GstClockTime * ts
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_next_fragment</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient *client, guint indexStream, GstMediaFragmentInfo * fragment
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_next_header</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient *client, gchar **uri, guint stream_idx, gint64 * range_start, gint64 * range_end
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_next_header_index</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient *client, gchar **uri, guint stream_idx, gint64 * range_start, gint64 * range_end
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_is_live</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient * client
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_stream_seek</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient * client, GstActiveStream * stream, gboolean forward, GstSeekFlags flags, GstClockTime ts, GstClockTime * final_ts
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_seek_to_time</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient * client, GDateTime * time
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_parser_get_stream_presentation_offset</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstMpdClient *client, guint stream_idx
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_utc_timing_sources</NAME>
<RETURNS>gchar ** </RETURNS>
GstMpdClient *client, guint methods, GstMPDUTCTimingType *selected_method
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_parser_get_period_start_time</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstMpdClient *client
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_period_index_at_time</NAME>
<RETURNS>guint  </RETURNS>
GstMpdClient * client, GstDateTime * time
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_set_period_index</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient *client, guint period_idx
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_set_period_id</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient *client, const gchar * period_id
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_period_index</NAME>
<RETURNS>guint  </RETURNS>
GstMpdClient *client
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_period_id</NAME>
<RETURNS>const gchar  *</RETURNS>
GstMpdClient *client
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_has_next_period</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient *client
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_has_previous_period</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient * client
</FUNCTION>
<FUNCTION>
<NAME>gst_mpdparser_get_rep_idx_with_max_bandwidth</NAME>
<RETURNS>gint  </RETURNS>
GList *Representations, gint max_bandwidth, gint max_video_width, gint max_video_height, gint max_video_framerate_n, gint max_video_framerate_d
</FUNCTION>
<FUNCTION>
<NAME>gst_mpdparser_get_rep_idx_with_min_bandwidth</NAME>
<RETURNS>gint  </RETURNS>
GList * Representations
</FUNCTION>
<FUNCTION>
<NAME>gst_mpdparser_get_baseURL</NAME>
<RETURNS>const gchar  *</RETURNS>
GstMpdClient *client, guint indexStream
</FUNCTION>
<FUNCTION>
<NAME>gst_mpdparser_get_nb_active_stream</NAME>
<RETURNS>guint  </RETURNS>
GstMpdClient *client
</FUNCTION>
<FUNCTION>
<NAME>gst_mpdparser_get_active_stream_by_index</NAME>
<RETURNS>GstActiveStream  *</RETURNS>
GstMpdClient *client, guint stream_idx
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_active_stream_contains_subtitles</NAME>
<RETURNS>gboolean  </RETURNS>
GstActiveStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mpdparser_get_nb_adaptationSet</NAME>
<RETURNS>guint  </RETURNS>
GstMpdClient *client
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_adaptation_sets</NAME>
<RETURNS>GList  * </RETURNS>
GstMpdClient * client
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_has_next_segment</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient * client, GstActiveStream * stream, gboolean forward
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_advance_segment</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstMpdClient * client, GstActiveStream * stream, gboolean forward
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_seek_to_first_segment</NAME>
<RETURNS>void  </RETURNS>
GstMpdClient * client
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_next_segment_availability_start_time</NAME>
<RETURNS>GstDateTime  *</RETURNS>
GstMpdClient * client, GstActiveStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_stream_caps</NAME>
<RETURNS>GstCaps  * </RETURNS>
GstActiveStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_bitstream_switching_flag</NAME>
<RETURNS>gboolean  </RETURNS>
GstActiveStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_video_stream_width</NAME>
<RETURNS>guint  </RETURNS>
GstActiveStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_video_stream_height</NAME>
<RETURNS>guint  </RETURNS>
GstActiveStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_video_stream_framerate</NAME>
<RETURNS>gboolean  </RETURNS>
GstActiveStream * stream, gint * fps_num, gint * fps_den
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_audio_stream_rate</NAME>
<RETURNS>guint  </RETURNS>
GstActiveStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_get_audio_stream_num_channels</NAME>
<RETURNS>guint  </RETURNS>
GstActiveStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mpdparser_get_list_and_nb_of_audio_language</NAME>
<RETURNS>guint  </RETURNS>
GstMpdClient *client, GList **lang
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_calculate_time_difference</NAME>
<RETURNS>gint64  </RETURNS>
const GstDateTime * t1, const GstDateTime * t2
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_add_time_difference</NAME>
<RETURNS>GstDateTime  *</RETURNS>
GstDateTime * t1, gint64 usecs
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_parse_default_presentation_delay</NAME>
<RETURNS>gint64  </RETURNS>
GstMpdClient * client, const gchar * default_presentation_delay
</FUNCTION>
<FUNCTION>
<NAME>gst_mpd_client_has_isoff_ondemand_profile</NAME>
<RETURNS>gboolean  </RETURNS>
GstMpdClient *client
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DASH_DEMUX</NAME>
#define GST_TYPE_DASH_DEMUX \
        (gst_dash_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_DASH_DEMUX</NAME>
#define GST_DASH_DEMUX(obj) \
        (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DASH_DEMUX,GstDashDemux))
</MACRO>
<MACRO>
<NAME>GST_DASH_DEMUX_CLASS</NAME>
#define GST_DASH_DEMUX_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DASH_DEMUX,GstDashDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DASH_DEMUX</NAME>
#define GST_IS_DASH_DEMUX(obj) \
        (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DASH_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_DASH_DEMUX_CLASS</NAME>
#define GST_IS_DASH_DEMUX_CLASS(klass) \
        (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DASH_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_DASH_DEMUX_CAST</NAME>
#define GST_DASH_DEMUX_CAST(obj) \
	((GstDashDemux *)obj)
</MACRO>
<STRUCT>
<NAME>GstDashDemuxStream</NAME>
struct _GstDashDemuxStream
{
  GstAdaptiveDemuxStream parent;

  gint index;
  GstActiveStream *active_stream;

  GstMediaFragmentInfo current_fragment;

  /* index parsing */
  GstSidxParser sidx_parser;
  GstClockTime sidx_position;
  gint64 sidx_base_offset;
  gboolean allow_sidx;
  GstClockTime pending_seek_ts;

  GstAdapter *adapter;
  /* current offset of the first byte in the adapter / last byte we pushed or
   * dropped*/
  guint64 current_offset;
  /* index = 1, header = 2, data = 3 */
  guint current_index_header_or_data;

  /* ISOBMFF box parsing */
  gboolean is_isobmff;
  struct {
    /* index = 1, header = 2, data = 3 */
    guint32 current_fourcc;
    guint64 current_start_offset;
    guint64 current_size;
  } isobmff_parser;

  GstMoofBox *moof;
  guint64 moof_offset, moof_size;
  GArray *moof_sync_samples;
  guint current_sync_sample;

  guint64 moof_average_size, first_sync_sample_average_size;
  gboolean first_sync_sample_after_moof, first_sync_sample_always_after_moof;
};
</STRUCT>
<STRUCT>
<NAME>GstDashDemux</NAME>
struct _GstDashDemux
{
  GstAdaptiveDemux parent;

  GSList *next_periods;

  GstMpdClient *client;         /* MPD client */
  GMutex client_lock;

  GstDashDemuxClockDrift *clock_drift;

  gboolean end_of_period;
  gboolean end_of_manifest;

  /* Properties */
  GstClockTime max_buffering_time;      /* Maximum buffering time accumulated during playback */
  guint64 max_bitrate;          /* max of bitrate supported by target decoder         */
  gint max_video_width, max_video_height;
  gint max_video_framerate_n, max_video_framerate_d;
  gchar* default_presentation_delay; /* presentation time delay if MPD@suggestedPresentationDelay is not present */

  gint n_audio_streams;
  gint n_video_streams;
  gint n_subtitle_streams;

  gboolean trickmode_no_audio;
  gboolean allow_trickmode_key_units;
};
</STRUCT>
<STRUCT>
<NAME>GstDashDemuxClass</NAME>
struct _GstDashDemuxClass
{
  GstAdaptiveDemuxClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dash_demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstDashDemuxClockDrift</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_FDKAACENC</NAME>
#define GST_TYPE_FDKAACENC \
  (gst_fdkaacenc_get_type())
</MACRO>
<MACRO>
<NAME>GST_FDKAACENC</NAME>
#define GST_FDKAACENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_FDKAACENC, GstFdkAacEnc))
</MACRO>
<MACRO>
<NAME>GST_FDKAACENC_CLASS</NAME>
#define GST_FDKAACENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_FDKAACENC, GstFdkAacEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FDKAACENC</NAME>
#define GST_IS_FDKAACENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_FDKAACENC))
</MACRO>
<MACRO>
<NAME>GST_IS_FDKAACENC_CLASS</NAME>
#define GST_IS_FDKAACENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_FDKAACENC))
</MACRO>
<STRUCT>
<NAME>GstFdkAacEnc</NAME>
struct _GstFdkAacEnc {
  GstAudioEncoder element;

  HANDLE_AACENCODER enc;
  gint bitrate;

  guint outbuf_size, samples_per_frame;
  gboolean need_reorder;
  const GstAudioChannelPosition *aac_positions;
};
</STRUCT>
<STRUCT>
<NAME>GstFdkAacEncClass</NAME>
struct _GstFdkAacEncClass {
  GstAudioEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_fdkaacenc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FDKAACDEC</NAME>
#define GST_TYPE_FDKAACDEC \
  (gst_fdkaacdec_get_type())
</MACRO>
<MACRO>
<NAME>GST_FDKAACDEC</NAME>
#define GST_FDKAACDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_FDKAACDEC, GstFdkAacDec))
</MACRO>
<MACRO>
<NAME>GST_FDKAACDEC_CLASS</NAME>
#define GST_FDKAACDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_FDKAACDEC, GstFdkAacDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FDKAACDEC</NAME>
#define GST_IS_FDKAACDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_FDKAACDEC))
</MACRO>
<MACRO>
<NAME>GST_IS_FDKAACDEC_CLASS</NAME>
#define GST_IS_FDKAACDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_FDKAACDEC))
</MACRO>
<STRUCT>
<NAME>GstFdkAacDec</NAME>
struct _GstFdkAacDec {
  GstAudioDecoder element;

  HANDLE_AACDECODER dec;
  gint16 *decode_buffer;
  gint decode_buffer_size;
};
</STRUCT>
<STRUCT>
<NAME>GstFdkAacDecClass</NAME>
struct _GstFdkAacDecClass {
  GstAudioDecoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_fdkaacdec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TONE_GENERATE_SRC</NAME>
#define GST_TYPE_TONE_GENERATE_SRC \
  (gst_tone_generate_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_TONE_GENERATE_SRC</NAME>
#define GST_TONE_GENERATE_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TONE_GENERATE_SRC,GstToneGenerateSrc))
</MACRO>
<MACRO>
<NAME>GST_TONE_GENERATE_SRC_CLASS</NAME>
#define GST_TONE_GENERATE_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TONE_GENERATE_SRC,GstToneGenerateSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TONE_GENERATE_SRC</NAME>
#define GST_IS_TONE_GENERATE_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TONE_GENERATE_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_TONE_GENERATE_SRC_CLASS</NAME>
#define GST_IS_TONE_GENERATE_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TONE_GENERATE_SRC))
</MACRO>
<STRUCT>
<NAME>GstToneGenerateSrc</NAME>
struct _GstToneGenerateSrc {
  GstPushSrc parent;

  /* parameters */
  gint volume;      /* The level of the first frequency, in dBm0 */
  gint volume2;     /* The level of the second frequency, in dBm0, or the percentage modulation depth for an AM modulated tone. */
  gint freq;        /* The first frequency, in Hz */
  gint freq2;       /* 0 for no second frequency, a positive number for the second frequency, in Hz, or a negative number for an AM modulation frequency, in Hz */
  gint on_time;         /* On time for the first presence of tone signal. */
  gint off_time;        /* Off time between first and second presence of tone signal. */
  gint on_time2;        /* On time for the second presence of tone signal. */
  gint off_time2;       /* Off time after the second presence of tone signal. */
  gboolean repeat;         /* 0/1 if the tone repeates itself or not. */

  /* audio parameters */
  gint samples_per_buffer;

  /*< private >*/
  GstClockTime next_time;               /* next timestamp */
  gint64 next_sample;                   /* next sample to send */

  /* SpanDSP */
  tone_gen_state_t *tone_state;
  tone_gen_descriptor_t *tone_desc;
  gboolean properties_changed;
};
</STRUCT>
<STRUCT>
<NAME>GstToneGenerateSrcClass</NAME>
struct _GstToneGenerateSrcClass {
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_tone_generate_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_tone_generate_src_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_BS2B</NAME>
#define GST_TYPE_BS2B \
  (gst_bs2b_get_type())
</MACRO>
<MACRO>
<NAME>GST_BS2B</NAME>
#define GST_BS2B(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BS2B,GstBs2b))
</MACRO>
<MACRO>
<NAME>GST_BS2B_CLASS</NAME>
#define GST_BS2B_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BS2B,GstBs2bClass))
</MACRO>
<MACRO>
<NAME>GST_IS_BS2B</NAME>
#define GST_IS_BS2B(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BS2B))
</MACRO>
<MACRO>
<NAME>GST_IS_BS2B_CLASS</NAME>
#define GST_IS_BS2B_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BS2B))
</MACRO>
<STRUCT>
<NAME>GstBs2b</NAME>
struct _GstBs2b
{
  GstAudioFilter element;

  /*< private > */
  GMutex bs2b_lock;
  t_bs2bdp bs2bdp;
  void (*func) ();
  guint bytes_per_sample;
};
</STRUCT>
<STRUCT>
<NAME>GstBs2bClass</NAME>
struct _GstBs2bClass
{
  GstAudioFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_bs2b_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GRABCUT</NAME>
#define GST_TYPE_GRABCUT \
  (gst_grabcut_get_type())
</MACRO>
<MACRO>
<NAME>GST_GRABCUT</NAME>
#define GST_GRABCUT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GRABCUT,GstGrabcut))
</MACRO>
<MACRO>
<NAME>GST_GRABCUT_CLASS</NAME>
#define GST_GRABCUT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GRABCUT,GstGrabcutClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GRABCUT</NAME>
#define GST_IS_GRABCUT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GRABCUT))
</MACRO>
<MACRO>
<NAME>GST_IS_GRABCUT_CLASS</NAME>
#define GST_IS_GRABCUT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GRABCUT))
</MACRO>
<STRUCT>
<NAME>grabcut_params</NAME>
struct grabcut_params
{
  void *bgdModel;
  void *fgdModel;
  void *image;
  void *mask;
};
</STRUCT>
<STRUCT>
<NAME>GstGrabcut</NAME>
struct _GstGrabcut
{
  GstOpencvVideoFilter parent;
  gint width, height;
  gboolean test_mode;
  gdouble scale;                // grow multiplier to apply to input bbox

  IplImage *cvRGBin;
  IplImage *cvA;
  IplImage *cvB;
  IplImage *cvC;
  IplImage *cvD;


  CvMat *grabcut_mask;          // mask created by graphcut
  struct grabcut_params GC;
  CvRect facepos;
};
</STRUCT>
<STRUCT>
<NAME>GstGrabcutClass</NAME>
struct _GstGrabcutClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_grabcut_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_grabcut_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_HANDDETECT</NAME>
#define GST_TYPE_HANDDETECT \
  (gst_handdetect_get_type())
</MACRO>
<MACRO>
<NAME>GST_HANDDETECT</NAME>
#define GST_HANDDETECT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_HANDDETECT,GstHanddetect))
</MACRO>
<MACRO>
<NAME>GST_HANDDETECT_CLASS</NAME>
#define GST_HANDDETECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_HANDDETECT,GstHanddetectClass))
</MACRO>
<MACRO>
<NAME>GST_IS_HANDDETECT</NAME>
#define GST_IS_HANDDETECT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_HANDDETECT))
</MACRO>
<MACRO>
<NAME>GST_IS_HANDDETECT_CLASS</NAME>
#define GST_IS_HANDDETECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_HANDDETECT))
</MACRO>
<STRUCT>
<NAME>GstHanddetect</NAME>
struct _GstHanddetect
{
  GstOpencvVideoFilter element;

  gboolean display;
  gchar *profile_fist;
  gchar *profile_palm;
  /* region of interest */
  gint roi_x;
  gint roi_y;
  gint roi_width;
  gint roi_height;

  /* opencv
   * cvGray - image to gray colour
   */
  IplImage *cvGray;
  cv::CascadeClassifier *cvCascade_fist;
  cv::CascadeClassifier *cvCascade_palm;
  cv::Rect *prev_r;
  cv::Rect *best_r;
};
</STRUCT>
<STRUCT>
<NAME>GstHanddetectClass</NAME>
struct _GstHanddetectClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_handdetect_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_handdetect_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CV_DILATE_ERODE</NAME>
#define GST_TYPE_CV_DILATE_ERODE \
  (gst_cv_dilate_erode_get_type())
</MACRO>
<MACRO>
<NAME>GST_CV_DILATE_ERODE</NAME>
#define GST_CV_DILATE_ERODE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CV_DILATE_ERODE,GstCvDilateErode))
</MACRO>
<MACRO>
<NAME>GST_CV_DILATE_ERODE_CLASS</NAME>
#define GST_CV_DILATE_ERODE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CV_DILATE_ERODE,GstCvDilateErodeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CV_DILATE_ERODE</NAME>
#define GST_IS_CV_DILATE_ERODE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CV_DILATE_ERODE))
</MACRO>
<MACRO>
<NAME>GST_IS_CV_DILATE_ERODE_CLASS</NAME>
#define GST_IS_CV_DILATE_ERODE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CV_DILATE_ERODE))
</MACRO>
<STRUCT>
<NAME>GstCvDilateErode</NAME>
struct _GstCvDilateErode
{
  GstOpencvVideoFilter element;

  gint iterations;
};
</STRUCT>
<STRUCT>
<NAME>GstCvDilateErodeClass</NAME>
struct _GstCvDilateErodeClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_cv_dilate_erode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SEGMENTATION</NAME>
#define GST_TYPE_SEGMENTATION \
  (gst_segmentation_get_type())
</MACRO>
<MACRO>
<NAME>GST_SEGMENTATION</NAME>
#define GST_SEGMENTATION(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SEGMENTATION,GstSegmentation))
</MACRO>
<MACRO>
<NAME>GST_SEGMENTATION_CLASS</NAME>
#define GST_SEGMENTATION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SEGMENTATION,GstSegmentationClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SEGMENTATION</NAME>
#define GST_IS_SEGMENTATION(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SEGMENTATION))
</MACRO>
<MACRO>
<NAME>GST_IS_SEGMENTATION_CLASS</NAME>
#define GST_IS_SEGMENTATION_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SEGMENTATION))
</MACRO>
<MACRO>
<NAME>CHANNELS</NAME>
#define CHANNELS 3
</MACRO>
<STRUCT>
<NAME>GstSegmentation</NAME>
struct _GstSegmentation
{
  GstOpencvVideoFilter element;
  gint method;

  gboolean test_mode;
  gint width, height;

  IplImage *cvRGB;
  IplImage *cvYUV;

  IplImage *cvFG;               /*  used for the alpha BW 1ch image composition */
  IplImage *ch1, *ch2, *ch3;
  int framecount;

  /* for codebook approach */
  codeBook *TcodeBook;
  int learning_interval;
  CvMemStorage *mem_storage;
  CvSeq *contours;

  /* for MOG methods */
#if (CV_MAJOR_VERSION >= 3)
  cv::Ptr<cv::BackgroundSubtractor> mog;                   /* cv::BackgroundSubtractorMOG */
  cv::Ptr<cv::BackgroundSubtractorMOG2> mog2;                   /* cv::BackgroundSubtractorMOG2 */
#else
  void *mog;                    /* cv::BackgroundSubtractorMOG */
  void *mog2;                   /* cv::BackgroundSubtractorMOG2 */
#endif
  void *img_input_as_cvMat;     /* cv::Mat */
  void *img_fg_as_cvMat;        /* cv::Mat */
  double learning_rate;
};
</STRUCT>
<STRUCT>
<NAME>GstSegmentationClass</NAME>
struct _GstSegmentationClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_segmentation_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_segmentation_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>MC_HEADER</NAME>
#define MC_HEADER 64
</MACRO>
<MACRO>
<NAME>MC_TYPE</NAME>
#define MC_TYPE 1
</MACRO>
<MACRO>
<NAME>MC_VERSION</NAME>
#define MC_VERSION 1
</MACRO>
<MACRO>
<NAME>MC_VERSIONTEXT</NAME>
#define MC_VERSIONTEXT "MotionCells-1"
</MACRO>
<MACRO>
<NAME>MSGLEN</NAME>
#define MSGLEN 6
</MACRO>
<MACRO>
<NAME>BUSMSGLEN</NAME>
#define BUSMSGLEN 20
</MACRO>
<STRUCT>
<NAME>MotionCellHeader</NAME>
struct MotionCellHeader{
	gint32 headersize;
	gint32 type;
	gint32 version;
	gint32 itemsize;
	gint32 gridx;
	gint32 gridy;
	gint64 starttime;
	char name[MC_HEADER - 32];
};
</STRUCT>
<STRUCT>
<NAME>MotionCellData</NAME>
struct MotionCellData{
	gint32 timestamp;
	char *data;
};
</STRUCT>
<STRUCT>
<NAME>motionmaskcoordrect</NAME>
typedef struct {
	int upper_left_x;
	int upper_left_y;
	int lower_right_x;
	int lower_right_y;
} motionmaskcoordrect;
</STRUCT>
<STRUCT>
<NAME>cellscolor</NAME>
typedef struct {
	int R_channel_value;
	int G_channel_value;
	int B_channel_value;
} cellscolor;
</STRUCT>
<STRUCT>
<NAME>motioncellidx</NAME>
typedef struct {
	int lineidx;
	int columnidx;
} motioncellidx;
</STRUCT>
<STRUCT>
<NAME>Cell</NAME>
struct Cell
{
  double MotionArea;
  double CellArea;
  double MotionPercent;
  bool hasMotion;
};
</STRUCT>
<STRUCT>
<NAME>MotionCellsIdx</NAME>
struct MotionCellsIdx
{
  CvRect motioncell;
  //Points for the edges of the rectangle.
  CvPoint cell_pt1;
  CvPoint cell_pt2;
  int lineidx;
  int colidx;
};
</STRUCT>
<STRUCT>
<NAME>OverlayRegions</NAME>
struct OverlayRegions
{
  CvPoint upperleft;
  CvPoint lowerright;
};
</STRUCT>
<FUNCTION>
<NAME>performDetectionMotionCells</NAME>
<RETURNS>int  </RETURNS>
IplImage * p_frame, double p_sensitivity, double p_framerate, int p_gridx, int p_gridy, gint64 timestamp_millisec, bool p_isVisble, bool p_useAlpha, int motionmaskcoord_count, motionmaskcoordrect * motionmaskcoords, int motionmaskcells_count, motioncellidx * motionmaskcellsidx, cellscolor motioncellscolor, int motioncells_count, motioncellidx * motioncellsidx, gint64 starttime, char *datafile, bool p_changed_datafile, int p_thickness
</FUNCTION>
<FUNCTION>
<NAME>setPrevFrame</NAME>
<RETURNS>void  </RETURNS>
IplImage * p_prevframe) { m_pprevFrame = cvCloneImage (p_prevframe
</FUNCTION>
<FUNCTION>
<NAME>getMotionCellsIdx</NAME>
<RETURNS>char  *</RETURNS>
) { return m_motioncellsidxcstr; } int getMotionCellsIdxCount () { return m_motioncells_idx_count; } bool getChangedDataFile () { return m_changed_datafile; } char *getDatafileInitFailed () { return m_initdatafilefailed; } char *getDatafileSaveFailed () { return m_savedatafilefailed; } int getInitErrorCode () { return m_initerrorcode; } int getSaveErrorCode () { return m_saveerrorcode; } void freeDataFile () { if (mc_savefile) { fclose (mc_savefile
</FUNCTION>
<FUNCTION>
<NAME>calculateMotionPercentInCell</NAME>
<RETURNS>double  </RETURNS>
int p_row, int p_col, double *p_cellarea, double *p_motionarea
</FUNCTION>
<FUNCTION>
<NAME>performMotionMaskCoords</NAME>
<RETURNS>void  </RETURNS>
motionmaskcoordrect * p_motionmaskcoords, int p_motionmaskcoords_count
</FUNCTION>
<FUNCTION>
<NAME>performMotionMask</NAME>
<RETURNS>void  </RETURNS>
motioncellidx * p_motionmaskcellsidx, int p_motionmaskcells_count
</FUNCTION>
<FUNCTION>
<NAME>calculateMotionPercentInMotionCells</NAME>
<RETURNS>void  </RETURNS>
motioncellidx * p_motionmaskcellsidx, int p_motionmaskcells_count = 0
</FUNCTION>
<FUNCTION>
<NAME>saveMotionCells</NAME>
<RETURNS>int  </RETURNS>
gint64 timestamp_millisec
</FUNCTION>
<FUNCTION>
<NAME>initDataFile</NAME>
<RETURNS>int  </RETURNS>
char *p_datafile, gint64 starttime
</FUNCTION>
<FUNCTION>
<NAME>blendImages</NAME>
<RETURNS>void  </RETURNS>
IplImage * p_actFrame, IplImage * p_cellsFrame, float p_alpha, float p_beta
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DEWARP</NAME>
#define GST_TYPE_DEWARP \
  (gst_dewarp_get_type())
</MACRO>
<MACRO>
<NAME>GST_DEWARP</NAME>
#define GST_DEWARP(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DEWARP,GstDewarp))
</MACRO>
<MACRO>
<NAME>GST_DEWARP_CLASS</NAME>
#define GST_DEWARP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DEWARP,GstDewarpClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DEWARP</NAME>
#define GST_IS_DEWARP(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DEWARP))
</MACRO>
<MACRO>
<NAME>GST_IS_DEWARP_CLASS</NAME>
#define GST_IS_DEWARP_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DEWARP))
</MACRO>
<ENUM>
<NAME>GstDewarpDisplayMode</NAME>
enum GstDewarpDisplayMode {
  GST_DEWARP_DISPLAY_PANORAMA = 0,
  GST_DEWARP_DISPLAY_DOUBLE_PANORAMA = 1,
  GST_DEWARP_DISPLAY_QUAD_VIEW = 2
};
</ENUM>
<ENUM>
<NAME>GstDewarpInterpolationMode</NAME>
enum GstDewarpInterpolationMode {
  GST_DEWARP_INTER_NEAREST = 0,
  GST_DEWARP_INTER_LINEAR = 1,
  GST_DEWARP_INTER_CUBIC = 2,
  GST_DEWARP_INTER_LANCZOS4 = 3
};
</ENUM>
<STRUCT>
<NAME>GstDewarp</NAME>
struct _GstDewarp
{
  GstOpencvVideoFilter element;
  cv::Mat *map_x;
  cv::Mat *map_y;
  gdouble x_center;
  gdouble y_center;
  gdouble inner_radius;
  gdouble outer_radius;
  gdouble remap_correction_x;
  gdouble remap_correction_y;
  gboolean need_map_update;
  gint pad_sink_width;
  gint pad_sink_height;
  gint in_width;
  gint in_height;
  gint out_width;
  gint out_height;
  gint display_mode;
  gint interpolation_mode;
};
</STRUCT>
<STRUCT>
<NAME>GstDewarpClass</NAME>
struct _GstDewarpClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dewarp_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dewarp_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MOTIONCELLS</NAME>
#define GST_TYPE_MOTIONCELLS \
  (gst_motion_cells_get_type())
</MACRO>
<MACRO>
<NAME>gst_motion_cells</NAME>
#define gst_motion_cells(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MOTIONCELLS,GstMotioncells))
</MACRO>
<MACRO>
<NAME>gst_motion_cells_CLASS</NAME>
#define gst_motion_cells_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MOTIONCELLS,GstMotioncellsClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MOTIONCELLS</NAME>
#define GST_IS_MOTIONCELLS(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MOTIONCELLS))
</MACRO>
<MACRO>
<NAME>GST_IS_MOTIONCELLS_CLASS</NAME>
#define GST_IS_MOTIONCELLS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MOTIONCELLS))
</MACRO>
<STRUCT>
<NAME>GstMotioncells</NAME>
struct _GstMotioncells
{
  GstOpencvVideoFilter element;
  GstState state;
  gboolean display, calculate_motion, firstgridx, firstgridy, changed_gridx,
      changed_gridy, changed_startime;
  gboolean previous_motion, changed_datafile, postallmotion, usealpha,
      firstdatafile, firstframe;
  gboolean sent_init_error_msg, sent_save_error_msg;
  gchar *prev_datafile, *cur_datafile, *basename_datafile, *datafile_extension;
  gint prevgridx, gridx, prevgridy, gridy, id;
  gdouble sensitivity, threshold;
  motionmaskcoordrect *motionmaskcoords;
  cellscolor *motioncellscolor;
  motioncellidx *motioncellsidx, *motionmaskcellsidx;
  int motionmaskcoord_count, motioncells_count, motionmaskcells_count;
  int thickness;
  guint gap, datafileidx, postnomotion, minimum_motion_frames;
  guint64 motion_begin_timestamp, last_motion_timestamp, motion_timestamp,
      last_nomotion_notified, prev_buff_timestamp, cur_buff_timestamp;
  gint64 diff_timestamp, starttime;
  guint64 consecutive_motion;
  gint width, height;
  //time stuff
  GTimeVal tv;
  double framerate;
};
</STRUCT>
<STRUCT>
<NAME>GstMotioncellsClass</NAME>
struct _GstMotioncellsClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_motion_cells_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_motion_cells_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DISPARITY</NAME>
#define GST_TYPE_DISPARITY \
  (gst_disparity_get_type())
</MACRO>
<MACRO>
<NAME>GST_DISPARITY</NAME>
#define GST_DISPARITY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DISPARITY,GstDisparity))
</MACRO>
<MACRO>
<NAME>GST_DISPARITY_CLASS</NAME>
#define GST_DISPARITY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DISPARITY,GstDisparityClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DISPARITY</NAME>
#define GST_IS_DISPARITY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DISPARITY))
</MACRO>
<MACRO>
<NAME>GST_IS_DISPARITY_CLASS</NAME>
#define GST_IS_DISPARITY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DISPARITY))
</MACRO>
<STRUCT>
<NAME>GstDisparity</NAME>
struct _GstDisparity
{
  GstElement element;

  GstPad *sinkpad_left, *sinkpad_right, *srcpad;
  GstCaps *caps;

  gint method;
  gboolean display;

  int width;
  int height;
  int actualChannels;

  GstBuffer *buffer_left;
  GMutex lock;
  GCond cond;
  gboolean flushing;

  CvSize imgSize;
  IplImage *cvRGB_right;
  IplImage *cvRGB_left;
  IplImage *cvGray_right;
  IplImage *cvGray_left;
  IplImage *cvGray_depth_map1;  /*IPL_DEPTH_16S */
  IplImage *cvGray_depth_map2;  /*IPL_DEPTH_8U */
  IplImage *cvGray_depth_map1_2;        /*IPL_DEPTH_16S */

  void *img_right_as_cvMat_gray;        /* cv::Mat */
  void *img_left_as_cvMat_gray; /* cv::Mat */
  void *depth_map_as_cvMat;     /* cv::Mat */
#if (CV_MAJOR_VERSION >= 3)
  cv::Ptr<cv::StereoBM> sbm;                    /* cv::StereoBM */
  cv::Ptr<cv::StereoSGBM> sgbm;                /* cv::StereoSGBM */
#else
 void *sbm;                    /* cv::StereoBM */
 void *sgbm;                   /* cv::StereoSGBM */
#endif
};
</STRUCT>
<STRUCT>
<NAME>GstDisparityClass</NAME>
struct _GstDisparityClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_disparity_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_disparity_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * disparity
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RETINEX</NAME>
#define GST_TYPE_RETINEX \
  (gst_retinex_get_type())
</MACRO>
<MACRO>
<NAME>GST_RETINEX</NAME>
#define GST_RETINEX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RETINEX,GstRetinex))
</MACRO>
<MACRO>
<NAME>GST_RETINEX_CLASS</NAME>
#define GST_RETINEX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RETINEX,GstRetinexClass))
</MACRO>
<MACRO>
<NAME>GST_IS_RETINEX</NAME>
#define GST_IS_RETINEX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RETINEX))
</MACRO>
<MACRO>
<NAME>GST_IS_RETINEX_CLASS</NAME>
#define GST_IS_RETINEX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RETINEX))
</MACRO>
<STRUCT>
<NAME>GstRetinex</NAME>
struct _GstRetinex
{
  GstOpencvVideoFilter parent;
  gint method;
  gint scales, current_scales;

  double *weights;
  double *sigmas;

  IplImage *cvA;
  IplImage *cvB;
  IplImage *cvC;
  IplImage *cvD;
};
</STRUCT>
<STRUCT>
<NAME>GstRetinexClass</NAME>
struct _GstRetinexClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_retinex_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_retinex_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SKIN_DETECT</NAME>
#define GST_TYPE_SKIN_DETECT \
  (gst_skin_detect_get_type())
</MACRO>
<MACRO>
<NAME>GST_SKIN_DETECT</NAME>
#define GST_SKIN_DETECT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SKIN_DETECT,GstSkinDetect))
</MACRO>
<MACRO>
<NAME>GST_SKIN_DETECT_CLASS</NAME>
#define GST_SKIN_DETECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SKIN_DETECT,GstSkinDetectClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SKIN_DETECT</NAME>
#define GST_IS_SKIN_DETECT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SKIN_DETECT))
</MACRO>
<MACRO>
<NAME>GST_IS_SKIN_DETECT_CLASS</NAME>
#define GST_IS_SKIN_DETECT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SKIN_DETECT))
</MACRO>
<STRUCT>
<NAME>GstSkinDetect</NAME>
struct _GstSkinDetect
{
  GstOpencvVideoFilter element;

  gboolean postprocess;
  gint method;
  gint width, height;

  IplImage *cvChA, *cvRGB, *cvSkin;
  IplImage *cvHSV, *cvH, *cvH2, *cvS, *cvV, *cvSkinPixels1;
  IplImage *cvR, *cvG, *cvB, *cvAll, *cvR2, *cvRp, *cvGp, *cvRp2, *cvGp2,
      *cvdraft, *cvSkinPixels2;
};
</STRUCT>
<STRUCT>
<NAME>GstSkinDetectClass</NAME>
struct _GstSkinDetectClass
{
  GstOpencvVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_skin_detect_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_skin_detect_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<STRUCT>
<NAME>instanceOfMC</NAME>
struct instanceOfMC
{
  int id;
  MotionCells *mc;
};
</STRUCT>
<FUNCTION>
<NAME>searchIdx</NAME>
<RETURNS>int  </RETURNS>
int p_id
</FUNCTION>
<FUNCTION>
<NAME>motion_cells_init</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>perform_detection_motion_cells</NAME>
<RETURNS>int  </RETURNS>
IplImage * p_image, double p_sensitivity, double p_framerate, int p_gridx, int p_gridy, long int p_timestamp_millisec, bool p_isVisible, bool p_useAlpha, int motionmaskcoord_count, motionmaskcoordrect * motionmaskcoords, int motionmaskcells_count, motioncellidx * motionmaskcellsidx, cellscolor motioncellscolor, int motioncells_count, motioncellidx * motioncellsidx, gint64 starttime, char *datafile, bool p_changed_datafile, int p_thickness, int p_id
</FUNCTION>
<FUNCTION>
<NAME>setPrevFrame</NAME>
<RETURNS>void  </RETURNS>
IplImage * p_prevFrame, int p_id
</FUNCTION>
<FUNCTION>
<NAME>motion_cells_free</NAME>
<RETURNS>void  </RETURNS>
int p_id
</FUNCTION>
<FUNCTION>
<NAME>motion_cells_free_resources</NAME>
<RETURNS>void  </RETURNS>
int p_id
</FUNCTION>
<FUNCTION>
<NAME>getMotionCellsIdx</NAME>
<RETURNS>char  *</RETURNS>
int p_id
</FUNCTION>
<FUNCTION>
<NAME>getMotionCellsIdxCnt</NAME>
<RETURNS>int  </RETURNS>
int p_id
</FUNCTION>
<FUNCTION>
<NAME>getChangedDataFile</NAME>
<RETURNS>bool  </RETURNS>
int p_id
</FUNCTION>
<FUNCTION>
<NAME>getInitDataFileFailed</NAME>
<RETURNS>char  *</RETURNS>
int p_id
</FUNCTION>
<FUNCTION>
<NAME>getSaveDataFileFailed</NAME>
<RETURNS>char  *</RETURNS>
int p_id
</FUNCTION>
<FUNCTION>
<NAME>getInitErrorCode</NAME>
<RETURNS>int  </RETURNS>
int p_id
</FUNCTION>
<FUNCTION>
<NAME>getSaveErrorCode</NAME>
<RETURNS>int  </RETURNS>
int p_id
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OPENAL_SINK</NAME>
#define GST_TYPE_OPENAL_SINK \
    (gst_openal_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPENAL_SINK</NAME>
#define GST_OPENAL_SINK(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OPENAL_SINK,GstOpenALSink))
</MACRO>
<MACRO>
<NAME>GST_OPENAL_SINK_CLASS</NAME>
#define GST_OPENAL_SINK_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OPENAL_SINK,GstOpenALSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENAL_SINK</NAME>
#define GST_IS_OPENAL_SINK(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OPENAL_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENAL_SINK_CLASS</NAME>
#define GST_IS_OPENAL_SINK_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OPENAL_SINK))
</MACRO>
<MACRO>
<NAME>GST_OPENAL_SINK_CAST</NAME>
#define GST_OPENAL_SINK_CAST(obj) \
    ((GstOpenALSink*)obj)
</MACRO>
<MACRO>
<NAME>GST_ALC_ERROR</NAME>
#define GST_ALC_ERROR(Device)  ("ALC error: %s", alcGetString((Device), alcGetError((Device))))
</MACRO>
<MACRO>
<NAME>GST_OPENAL_SINK_GET_LOCK</NAME>
#define GST_OPENAL_SINK_GET_LOCK(obj) (&GST_OPENAL_SINK_CAST(obj)->openal_lock)
</MACRO>
<MACRO>
<NAME>GST_OPENAL_SINK_LOCK</NAME>
#define GST_OPENAL_SINK_LOCK(obj)     (g_mutex_lock(GST_OPENAL_SINK_GET_LOCK(obj)))
</MACRO>
<MACRO>
<NAME>GST_OPENAL_SINK_UNLOCK</NAME>
#define GST_OPENAL_SINK_UNLOCK(obj)   (g_mutex_unlock(GST_OPENAL_SINK_GET_LOCK(obj)))
</MACRO>
<STRUCT>
<NAME>GstOpenALSink</NAME>
struct _GstOpenALSink
{
  GstAudioSink sink;

  gchar *device_name;

  ALCdevice *default_device;
  /* When set, device is not owned */
  ALCdevice *user_device;

  ALCcontext *default_context;
  /* When set, device or context is not owned */
  ALCcontext *user_context;

  ALuint default_source;
  /* When set, source is not owned */
  ALuint user_source;

  ALuint buffer_idx;
  ALuint buffer_count;
  ALuint *buffers;
  ALuint buffer_length;

  ALenum format;
  ALuint rate;
  ALuint channels;
  ALuint bytes_per_sample;

  ALboolean write_reset;

  GstCaps *probed_caps;

  GMutex openal_lock;
};
</STRUCT>
<STRUCT>
<NAME>GstOpenALSinkClass</NAME>
struct _GstOpenALSinkClass
{
  GstAudioSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_openal_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OPENAL_SRC</NAME>
#define GST_TYPE_OPENAL_SRC \
    (gst_openal_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPENAL_SRC</NAME>
#define GST_OPENAL_SRC(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_OPENAL_SRC, GstOpenalSrc))
</MACRO>
<MACRO>
<NAME>GST_OPENAL_SRC_CLASS</NAME>
#define GST_OPENAL_SRC_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_OPENAL_SRC, GstOpenalSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENAL_SRC</NAME>
#define GST_IS_OPENAL_SRC(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_OPENAL_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENAL_SRC_CLASS</NAME>
#define GST_IS_OPENAL_SRC_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_OPENAL_SRC))
</MACRO>
<MACRO>
<NAME>GST_ALC_ERROR</NAME>
#define GST_ALC_ERROR(Device)  ("ALC error: %s", alcGetString((Device), alcGetError((Device))))
</MACRO>
<STRUCT>
<NAME>GstOpenalSrc</NAME>
struct _GstOpenalSrc
{
  GstAudioSrc element;
  GstPad *srcpad;
  gboolean silent;

  /* readable name of device */
  gchar *default_device_name;
  /* name of device to open, default is a NULL pointer to get default device */
  gchar *default_device;
  /* OpenAL device handle */
  ALCdevice *device;

  guint64 buffer_length;

  ALenum format;
  ALuint rate;
  ALuint bytes_per_sample;

  GstCaps *probed_caps;
};
</STRUCT>
<STRUCT>
<NAME>GstOpenalSrcClass</NAME>
struct _GstOpenalSrcClass
{
  GstAudioSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_openal_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_GST_BASE_WIDGET</NAME>
#define GTK_GST_BASE_WIDGET(w)         ((GtkGstBaseWidget *)(w))
</MACRO>
<MACRO>
<NAME>GTK_GST_BASE_WIDGET_CLASS</NAME>
#define GTK_GST_BASE_WIDGET_CLASS(k)   ((GtkGstBaseWidgetClass *)(k))
</MACRO>
<MACRO>
<NAME>GTK_GST_BASE_WIDGET_LOCK</NAME>
#define GTK_GST_BASE_WIDGET_LOCK(w)    g_mutex_lock(&((GtkGstBaseWidget*)(w))->lock)
</MACRO>
<MACRO>
<NAME>GTK_GST_BASE_WIDGET_UNLOCK</NAME>
#define GTK_GST_BASE_WIDGET_UNLOCK(w)  g_mutex_unlock(&((GtkGstBaseWidget*)(w))->lock)
</MACRO>
<STRUCT>
<NAME>GtkGstBaseWidget</NAME>
struct _GtkGstBaseWidget
{
  union {
    GtkDrawingArea drawing_area;
#if GTK_CHECK_VERSION(3, 15, 0)
    GtkGLArea gl_area;
#endif
  } parent;

  /* properties */
  gboolean force_aspect_ratio;
  gint par_n, par_d;
  gboolean ignore_alpha;

  gint display_width;
  gint display_height;

  gboolean negotiated;
  GstBuffer *pending_buffer;
  GstBuffer *buffer;
  GstVideoInfo v_info;

  /* resize */
  gboolean pending_resize;
  GstVideoInfo pending_v_info;
  guint display_ratio_num;
  guint display_ratio_den;

  /*< private >*/
  GMutex lock;
  GWeakRef element;

  /* Pending draw idles callback */
  guint draw_id;
};
</STRUCT>
<STRUCT>
<NAME>GtkGstBaseWidgetClass</NAME>
struct _GtkGstBaseWidgetClass
{
  union {
    GtkDrawingAreaClass drawing_area_class;
#if GTK_CHECK_VERSION(3, 15, 0)
    GtkGLAreaClass gl_area_class;
#endif
  } parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_gst_base_widget_class_init</NAME>
<RETURNS>void             </RETURNS>
GtkGstBaseWidgetClass * klass
</FUNCTION>
<FUNCTION>
<NAME>gtk_gst_base_widget_init</NAME>
<RETURNS>void             </RETURNS>
GtkGstBaseWidget * widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_gst_base_widget_finalize</NAME>
<RETURNS>void             </RETURNS>
GObject * object
</FUNCTION>
<FUNCTION>
<NAME>gtk_gst_base_widget_set_format</NAME>
<RETURNS>gboolean         </RETURNS>
GtkGstBaseWidget * widget, GstVideoInfo * v_info
</FUNCTION>
<FUNCTION>
<NAME>gtk_gst_base_widget_set_buffer</NAME>
<RETURNS>void             </RETURNS>
GtkGstBaseWidget * widget, GstBuffer * buffer
</FUNCTION>
<FUNCTION>
<NAME>gtk_gst_base_widget_set_element</NAME>
<RETURNS>void             </RETURNS>
GtkGstBaseWidget * widget, GstElement * element
</FUNCTION>
<FUNCTION>
<NAME>gtk_gst_widget_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_GST_WIDGET</NAME>
#define GTK_TYPE_GST_WIDGET (gtk_gst_widget_get_type())
</MACRO>
<MACRO>
<NAME>GTK_GST_WIDGET</NAME>
#define GTK_GST_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GTK_TYPE_GST_WIDGET,GtkGstWidget))
</MACRO>
<MACRO>
<NAME>GTK_GST_WIDGET_CLASS</NAME>
#define GTK_GST_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GTK_TYPE_GST_WIDGET,GtkGstWidgetClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_GST_WIDGET</NAME>
#define GTK_IS_GST_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GTK_TYPE_GST_WIDGET))
</MACRO>
<MACRO>
<NAME>GST_IS_GST_WIDGET_CLASS</NAME>
#define GST_IS_GST_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GTK_TYPE_GST_WIDGET))
</MACRO>
<MACRO>
<NAME>GTK_GST_WIDGET_CAST</NAME>
#define GTK_GST_WIDGET_CAST(obj) ((GtkGstWidget*)(obj))
</MACRO>
<STRUCT>
<NAME>GtkGstWidget</NAME>
struct _GtkGstWidget
{
  /* <private> */
  GtkGstBaseWidget base;
};
</STRUCT>
<STRUCT>
<NAME>GtkGstWidgetClass</NAME>
struct _GtkGstWidgetClass
{
  /* <private> */
  GtkGstBaseWidgetClass base_class;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_gst_widget_new</NAME>
<RETURNS>GtkWidget  *     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_gst_gl_widget_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GTK_TYPE_GST_GL_WIDGET</NAME>
#define GTK_TYPE_GST_GL_WIDGET (gtk_gst_gl_widget_get_type())
</MACRO>
<MACRO>
<NAME>GTK_GST_GL_WIDGET</NAME>
#define GTK_GST_GL_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GTK_TYPE_GST_GL_WIDGET,GtkGstGLWidget))
</MACRO>
<MACRO>
<NAME>GTK_GST_GL_WIDGET_CLASS</NAME>
#define GTK_GST_GL_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GTK_TYPE_GST_GL_WIDGET,GtkGstGLWidgetClass))
</MACRO>
<MACRO>
<NAME>GTK_IS_GST_GL_WIDGET</NAME>
#define GTK_IS_GST_GL_WIDGET(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GTK_TYPE_GST_GL_WIDGET))
</MACRO>
<MACRO>
<NAME>GTK_IS_GST_GL_WIDGET_CLASS</NAME>
#define GTK_IS_GST_GL_WIDGET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GTK_TYPE_GST_GL_WIDGET))
</MACRO>
<MACRO>
<NAME>GTK_GST_GL_WIDGET_CAST</NAME>
#define GTK_GST_GL_WIDGET_CAST(obj) ((GtkGstGLWidget*)(obj))
</MACRO>
<STRUCT>
<NAME>GtkGstGLWidget</NAME>
struct _GtkGstGLWidget
{
  /* <private> */
  GtkGstBaseWidget base;

  GtkGstGLWidgetPrivate   *priv;
};
</STRUCT>
<STRUCT>
<NAME>GtkGstGLWidgetClass</NAME>
struct _GtkGstGLWidgetClass
{
  /* <private> */
  GtkGstBaseWidgetClass base_class;
};
</STRUCT>
<FUNCTION>
<NAME>gtk_gst_gl_widget_new</NAME>
<RETURNS>GtkWidget  *     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gtk_gst_gl_widget_init_winsys</NAME>
<RETURNS>gboolean         </RETURNS>
GtkGstGLWidget * widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_gst_gl_widget_get_display</NAME>
<RETURNS>GstGLDisplay  *  </RETURNS>
GtkGstGLWidget * widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_gst_gl_widget_get_context</NAME>
<RETURNS>GstGLContext  *  </RETURNS>
GtkGstGLWidget * widget
</FUNCTION>
<FUNCTION>
<NAME>gtk_gst_gl_widget_get_gtk_context</NAME>
<RETURNS>GstGLContext  *  </RETURNS>
GtkGstGLWidget * widget
</FUNCTION>
<STRUCT>
<NAME>GtkGstGLWidgetPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GTK_GL_SINK</NAME>
#define GST_TYPE_GTK_GL_SINK            (gst_gtk_gl_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_GTK_GL_SINK</NAME>
#define GST_GTK_GL_SINK(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GTK_GL_SINK,GstGtkGLSink))
</MACRO>
<MACRO>
<NAME>GST_GTK_GL_SINK_CLASS</NAME>
#define GST_GTK_GL_SINK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GTK_GL_SINK,GstGtkGLSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GTK_GL_SINK</NAME>
#define GST_IS_GTK_GL_SINK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GTK_GL_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_GTK_GL_SINK_CLASS</NAME>
#define GST_IS_GTK_GL_SINK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GTK_GL_SINK))
</MACRO>
<MACRO>
<NAME>GST_GTK_GL_SINK_CAST</NAME>
#define GST_GTK_GL_SINK_CAST(obj)       ((GstGtkGLSink*)(obj))
</MACRO>
<FUNCTION>
<NAME>gst_gtk_gl_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstGtkGLSink</NAME>
struct _GstGtkGLSink
{
  /* <private> */
  GstGtkBaseSink        parent;

  GstGLDisplay         *display;
  GstGLContext         *context;
  GstGLContext         *gtk_context;

  GstGLUpload          *upload;
  GstBuffer            *uploaded_buffer;

  /* read/write with object lock */
  gint                  display_width;
  gint                  display_height;
};
</STRUCT>
<STRUCT>
<NAME>GstGtkGLSinkClass</NAME>
struct _GstGtkGLSinkClass
{
  /* <private> */
  GstGtkBaseSinkClass object_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GTK_SINK</NAME>
#define GST_TYPE_GTK_SINK            (gst_gtk_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_GTK_SINK</NAME>
#define GST_GTK_SINK(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GTK_SINK,GstGtkSink))
</MACRO>
<MACRO>
<NAME>GST_GTK_SINK_CLASS</NAME>
#define GST_GTK_SINK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GTK_SINK,GstGtkSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GTK_SINK</NAME>
#define GST_IS_GTK_SINK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GTK_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_GTK_SINK_CLASS</NAME>
#define GST_IS_GTK_SINK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GTK_SINK))
</MACRO>
<MACRO>
<NAME>GST_GTK_SINK_CAST</NAME>
#define GST_GTK_SINK_CAST(obj)       ((GstGtkSink*)(obj))
</MACRO>
<FUNCTION>
<NAME>gst_gtk_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstGtkSink</NAME>
struct _GstGtkSink
{
  /* <private> */
  GstGtkBaseSink       parent;
};
</STRUCT>
<STRUCT>
<NAME>GstGtkSinkClass</NAME>
struct _GstGtkSinkClass
{
  /* <private> */
  GstGtkBaseSinkClass object_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gtk_invoke_on_main</NAME>
<RETURNS>gpointer  </RETURNS>
GThreadFunc func, gpointer data
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GTK_BASE_SINK</NAME>
#define GST_TYPE_GTK_BASE_SINK            (gst_gtk_base_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_GTK_BASE_SINK</NAME>
#define GST_GTK_BASE_SINK(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GTK_BASE_SINK,GstGtkBaseSink))
</MACRO>
<MACRO>
<NAME>GST_GTK_BASE_SINK_CLASS</NAME>
#define GST_GTK_BASE_SINK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GTK_BASE_SINK,GstGtkBaseSinkClass))
</MACRO>
<MACRO>
<NAME>GST_GTK_BASE_SINK_GET_CLASS</NAME>
#define GST_GTK_BASE_SINK_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_GTK_BASE_SINK, GstGtkBaseSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GTK_BASE_SINK</NAME>
#define GST_IS_GTK_BASE_SINK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GTK_BASE_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_GTK_BASE_SINK_CLASS</NAME>
#define GST_IS_GTK_BASE_SINK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GTK_BASE_SINK))
</MACRO>
<MACRO>
<NAME>GST_GTK_BASE_SINK_CAST</NAME>
#define GST_GTK_BASE_SINK_CAST(obj)       ((GstGtkBaseSink*)(obj))
</MACRO>
<FUNCTION>
<NAME>gst_gtk_base_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstGtkBaseSink</NAME>
struct _GstGtkBaseSink
{
  /* <private> */
  GstVideoSink         parent;

  GstVideoInfo         v_info;

  GtkGstBaseWidget     *widget;

  /* properties */
  gboolean             force_aspect_ratio;
  GBinding             *bind_aspect_ratio;

  gint                  par_n;
  gint                  par_d;
  GBinding             *bind_pixel_aspect_ratio;

  gboolean              ignore_alpha;
  GBinding             *bind_ignore_alpha;

  GtkWidget            *window;
  gulong               widget_destroy_id;
  gulong               window_destroy_id;
};
</STRUCT>
<STRUCT>
<NAME>GstGtkBaseSinkClass</NAME>
struct _GstGtkBaseSinkClass
{
  GstVideoSinkClass object_class;

  /* metadata */
  const gchar *window_title;

  /* virtuals */
  GtkWidget* (*create_widget) (void);
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_INPUT_SELECTOR</NAME>
#define GST_TYPE_INPUT_SELECTOR \
  (gst_input_selector_get_type())
</MACRO>
<MACRO>
<NAME>GST_INPUT_SELECTOR</NAME>
#define GST_INPUT_SELECTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_INPUT_SELECTOR, RsnInputSelector))
</MACRO>
<MACRO>
<NAME>GST_INPUT_SELECTOR_CLASS</NAME>
#define GST_INPUT_SELECTOR_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_INPUT_SELECTOR, RsnInputSelectorClass))
</MACRO>
<MACRO>
<NAME>GST_IS_INPUT_SELECTOR</NAME>
#define GST_IS_INPUT_SELECTOR(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_INPUT_SELECTOR))
</MACRO>
<MACRO>
<NAME>GST_IS_INPUT_SELECTOR_CLASS</NAME>
#define GST_IS_INPUT_SELECTOR_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_INPUT_SELECTOR))
</MACRO>
<MACRO>
<NAME>GST_INPUT_SELECTOR_GET_LOCK</NAME>
#define GST_INPUT_SELECTOR_GET_LOCK(sel) (&((RsnInputSelector*)(sel))->lock)
</MACRO>
<MACRO>
<NAME>GST_INPUT_SELECTOR_GET_COND</NAME>
#define GST_INPUT_SELECTOR_GET_COND(sel) (&((RsnInputSelector*)(sel))->cond)
</MACRO>
<MACRO>
<NAME>GST_INPUT_SELECTOR_LOCK</NAME>
#define GST_INPUT_SELECTOR_LOCK(sel) (g_mutex_lock (GST_INPUT_SELECTOR_GET_LOCK(sel)))
</MACRO>
<MACRO>
<NAME>GST_INPUT_SELECTOR_UNLOCK</NAME>
#define GST_INPUT_SELECTOR_UNLOCK(sel) (g_mutex_unlock (GST_INPUT_SELECTOR_GET_LOCK(sel)))
</MACRO>
<MACRO>
<NAME>GST_INPUT_SELECTOR_WAIT</NAME>
#define GST_INPUT_SELECTOR_WAIT(sel) (g_cond_wait (GST_INPUT_SELECTOR_GET_COND(sel), \
			GST_INPUT_SELECTOR_GET_LOCK(sel)))
</MACRO>
<MACRO>
<NAME>GST_INPUT_SELECTOR_BROADCAST</NAME>
#define GST_INPUT_SELECTOR_BROADCAST(sel) (g_cond_broadcast (GST_INPUT_SELECTOR_GET_COND(sel)))
</MACRO>
<ENUM>
<NAME>RsnInputSelectorSyncMode</NAME>
typedef enum {
  GST_INPUT_SELECTOR_SYNC_MODE_ACTIVE_SEGMENT,
  GST_INPUT_SELECTOR_SYNC_MODE_CLOCK
} RsnInputSelectorSyncMode;
</ENUM>
<STRUCT>
<NAME>RsnInputSelector</NAME>
struct _RsnInputSelector {
  GstElement element;

  GstPad *srcpad;

  GstPad *active_sinkpad;
  guint n_pads;
  guint padcount;
  gboolean sync_streams;
  RsnInputSelectorSyncMode sync_mode;
  gboolean cache_buffers;

  GMutex lock;
  GCond cond;
  gboolean blocked;
  gboolean flushing;
};
</STRUCT>
<STRUCT>
<NAME>RsnInputSelectorClass</NAME>
struct _RsnInputSelectorClass {
  GstElementClass parent_class;

  gint64 (*block)	(RsnInputSelector *self);
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_FLUPS_DEMUX</NAME>
#define GST_TYPE_FLUPS_DEMUX		(gst_flups_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_FLUPS_DEMUX</NAME>
#define GST_FLUPS_DEMUX(obj)		(G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FLUPS_DEMUX,GstFluPSDemux))
</MACRO>
<MACRO>
<NAME>GST_FLUPS_DEMUX_CLASS</NAME>
#define GST_FLUPS_DEMUX_CLASS(klass)	(G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FLUPS_DEMUX,GstFluPSDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_FLUPS_DEMUX_GET_CLASS</NAME>
#define GST_FLUPS_DEMUX_GET_CLASS(klass) (G_TYPE_INSTANCE_GET_CLASS((klass),GST_TYPE_FLUPS_DEMUX,GstFluPSDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FLUPS_DEMUX</NAME>
#define GST_IS_FLUPS_DEMUX(obj)		(G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FLUPS_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_FLUPS_DEMUX_CLASS</NAME>
#define GST_IS_FLUPS_DEMUX_CLASS(obj)	(G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FLUPS_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_FLUPS_DEMUX_MAX_STREAMS</NAME>
#define GST_FLUPS_DEMUX_MAX_STREAMS	256
</MACRO>
<MACRO>
<NAME>GST_FLUPS_DEMUX_MAX_PSM</NAME>
#define GST_FLUPS_DEMUX_MAX_PSM		256
</MACRO>
<MACRO>
<NAME>MAX_DVD_AUDIO_STREAMS</NAME>
#define MAX_DVD_AUDIO_STREAMS 8
</MACRO>
<MACRO>
<NAME>MAX_DVD_SUBPICTURE_STREAMS</NAME>
#define MAX_DVD_SUBPICTURE_STREAMS 32
</MACRO>
<ENUM>
<NAME>GstFluPSDemuxState</NAME>
typedef enum
{
  STATE_FLUPS_DEMUX_NEED_SYNC,
  STATE_FLUPS_DEMUX_SYNCED,
  STATE_FLUPS_DEMUX_NEED_MORE_DATA,
} GstFluPSDemuxState;
</ENUM>
<STRUCT>
<NAME>GstFluPSStream</NAME>
struct _GstFluPSStream
{
  GstPad *pad;

  gint id;
  gint type;

  GstClockTime segment_thresh;
  GstClockTime last_ts;
  GstFlowReturn last_flow;

  gboolean discont;
  gboolean notlinked;
  gboolean need_segment;

  GstTagList *pending_tags;
};
</STRUCT>
<STRUCT>
<NAME>GstFluPSDemux</NAME>
struct _GstFluPSDemux
{
  GstElement parent;

  GstPad *sinkpad;
  gboolean random_access;       /* If we operate in pull mode */
  gboolean in_still;

  gboolean have_group_id;
  guint group_id;

  GstAdapter *adapter;
  GstAdapter *rev_adapter;
  guint64 adapter_offset;
  guint32 last_sync_code;
  GstPESFilter filter;

  gint64 mux_rate;
  guint64 first_scr;
  guint64 first_dts;
  guint64 base_time;
  guint64 current_scr;
  guint64 next_scr;
  guint64 bytes_since_scr;
  gint64 scr_adjust;
  guint64 scr_rate_n;
  guint64 scr_rate_d;
  guint64 first_scr_offset;
  guint64 cur_scr_offset;

  gint16 psm[GST_FLUPS_DEMUX_MAX_PSM];

  GstSegment sink_segment;
  GstSegment src_segment;

  /* stream output */
  GstFluPSStream *current_stream;
  guint64 next_pts;
  guint64 next_dts;
  GstFluPSStream **streams;
  GstFluPSStream **streams_found;
  gint found_count;
  gboolean need_no_more_pads;

  /* Indicates an MPEG-2 stream */
  gboolean is_mpeg2_pack;

  /* DVD-specific stream handling */
  gboolean disable_stream_creation;
  gint audio_stream_map[MAX_DVD_AUDIO_STREAMS];
};
</STRUCT>
<STRUCT>
<NAME>GstFluPSDemuxClass</NAME>
struct _GstFluPSDemuxClass
{
  GstElementClass parent_class;

  GstPadTemplate *sink_template;
  GstPadTemplate *video_template;
  GstPadTemplate *audio_template;
  GstPadTemplate *subpicture_template;
  GstPadTemplate *private_template;
};
</STRUCT>
<FUNCTION>
<NAME>gst_flups_demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_flups_demux_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *plugin
</FUNCTION>
<MACRO>
<NAME>RESIN_TYPE_DVDBIN</NAME>
#define RESIN_TYPE_DVDBIN \
  (rsn_dvdbin_get_type())
</MACRO>
<MACRO>
<NAME>RESINDVDBIN</NAME>
#define RESINDVDBIN(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),RESIN_TYPE_DVDBIN,RsnDvdBin))
</MACRO>
<MACRO>
<NAME>RESINDVDBIN_CLASS</NAME>
#define RESINDVDBIN_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),RESIN_TYPE_DVDBIN,RsnDvdBinClass))
</MACRO>
<MACRO>
<NAME>IS_RESINDVDBIN</NAME>
#define IS_RESINDVDBIN(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),RESIN_TYPE_DVDBIN))
</MACRO>
<MACRO>
<NAME>IS_RESINDVDBIN_CLASS</NAME>
#define IS_RESINDVDBIN_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),RESIN_TYPE_DVDBIN))
</MACRO>
<MACRO>
<NAME>DVD_ELEM_SOURCE</NAME>
#define DVD_ELEM_SOURCE         0
</MACRO>
<MACRO>
<NAME>DVD_ELEM_DEMUX</NAME>
#define DVD_ELEM_DEMUX          1
</MACRO>
<MACRO>
<NAME>DVD_ELEM_MQUEUE</NAME>
#define DVD_ELEM_MQUEUE         2
</MACRO>
<MACRO>
<NAME>DVD_ELEM_SPUQ</NAME>
#define DVD_ELEM_SPUQ           3
</MACRO>
<MACRO>
<NAME>DVD_ELEM_VIDPARSE</NAME>
#define DVD_ELEM_VIDPARSE       4
</MACRO>
<MACRO>
<NAME>DVD_ELEM_VIDDEC</NAME>
#define DVD_ELEM_VIDDEC         5
</MACRO>
<MACRO>
<NAME>DVD_ELEM_PARSET</NAME>
#define DVD_ELEM_PARSET         6
</MACRO>
<MACRO>
<NAME>DVD_ELEM_AUDPARSE</NAME>
#define DVD_ELEM_AUDPARSE       7 
</MACRO>
<MACRO>
<NAME>DVD_ELEM_AUDDEC</NAME>
#define DVD_ELEM_AUDDEC         8
</MACRO>
<MACRO>
<NAME>DVD_ELEM_VIDQ</NAME>
#define DVD_ELEM_VIDQ           9
</MACRO>
<MACRO>
<NAME>DVD_ELEM_SPU_SELECT</NAME>
#define DVD_ELEM_SPU_SELECT     10
</MACRO>
<MACRO>
<NAME>DVD_ELEM_AUD_SELECT</NAME>
#define DVD_ELEM_AUD_SELECT     11
</MACRO>
<MACRO>
<NAME>DVD_ELEM_LAST</NAME>
#define DVD_ELEM_LAST           12
</MACRO>
<STRUCT>
<NAME>RsnDvdBin</NAME>
struct _RsnDvdBin
{
  GstBin element;

  /* Protects pieces list and properties */
  GMutex dvd_lock;
  GMutex preroll_lock;

  gchar *device;
  gchar *last_uri;
  GstElement *pieces[DVD_ELEM_LAST];

  GstPad *video_pad;
  GstPad *audio_pad;
  GstPad *subpicture_pad;

  gboolean video_added;
  gboolean audio_added;
  gboolean audio_broken;
  gboolean subpicture_added;

  gboolean did_no_more_pads;

  GList *mq_req_pads;
};
</STRUCT>
<STRUCT>
<NAME>RsnDvdBinClass</NAME>
struct _RsnDvdBinClass 
{
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>rsn_dvdbin_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>RSN_TYPE_RSNPARSETTER</NAME>
#define RSN_TYPE_RSNPARSETTER \
  (rsn_parsetter_get_type())
</MACRO>
<MACRO>
<NAME>RSN_PARSETTER</NAME>
#define RSN_PARSETTER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),RSN_TYPE_RSNPARSETTER,RsnParSetter))
</MACRO>
<MACRO>
<NAME>RSN_PARSETTER_CLASS</NAME>
#define RSN_PARSETTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),RSN_TYPE_RSNPARSETTER,RsnParSetterClass))
</MACRO>
<MACRO>
<NAME>RSN_IS_PARSETTER</NAME>
#define RSN_IS_PARSETTER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),RSN_TYPE_RSNPARSETTER))
</MACRO>
<MACRO>
<NAME>RSN_IS_PARSETTER_CLASS</NAME>
#define RSN_IS_PARSETTER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),RSN_TYPE_RSNPARSETTER))
</MACRO>
<STRUCT>
<NAME>RsnParSetter</NAME>
struct _RsnParSetter
{
  GstElement element;

  GstPad *sinkpad, *srcpad;

  gboolean override_outcaps;
  GstCaps *outcaps;

  gboolean is_widescreen;

  GstCaps *in_caps_last;
  gboolean in_caps_was_ok;
  GstCaps *in_caps_converted;
};
</STRUCT>
<STRUCT>
<NAME>RsnParSetterClass</NAME>
struct _RsnParSetterClass 
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>rsn_parsetter_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>ID_PS_END_CODE</NAME>
#define ID_PS_END_CODE                          0x000001B9
</MACRO>
<MACRO>
<NAME>ID_PS_PACK_START_CODE</NAME>
#define ID_PS_PACK_START_CODE                   0x000001BA
</MACRO>
<MACRO>
<NAME>ID_PS_SYSTEM_HEADER_START_CODE</NAME>
#define ID_PS_SYSTEM_HEADER_START_CODE          0x000001BB
</MACRO>
<MACRO>
<NAME>ID_PS_PROGRAM_STREAM_MAP</NAME>
#define ID_PS_PROGRAM_STREAM_MAP                0x000001BC
</MACRO>
<MACRO>
<NAME>ID_PRIVATE_STREAM_1</NAME>
#define ID_PRIVATE_STREAM_1                     0x000001BD
</MACRO>
<MACRO>
<NAME>ID_PADDING_STREAM</NAME>
#define ID_PADDING_STREAM                       0x000001BE
</MACRO>
<MACRO>
<NAME>ID_PRIVATE_STREAM_2</NAME>
#define ID_PRIVATE_STREAM_2                     0x000001BF
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_MPEG12_AUDIO_STREAM_0</NAME>
#define ID_ISO_IEC_MPEG12_AUDIO_STREAM_0        0x000001C0
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_MPEG12_AUDIO_STREAM_32</NAME>
#define ID_ISO_IEC_MPEG12_AUDIO_STREAM_32       0x000001DF
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_MPEG12_VIDEO_STREAM_0</NAME>
#define ID_ISO_IEC_MPEG12_VIDEO_STREAM_0        0x000001E0
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_MPEG12_VIDEO_STREAM_16</NAME>
#define ID_ISO_IEC_MPEG12_VIDEO_STREAM_16       0x000001EF
</MACRO>
<MACRO>
<NAME>ID_ECM_STREAM</NAME>
#define ID_ECM_STREAM                           0x000001F0
</MACRO>
<MACRO>
<NAME>ID_EMM_STREAM</NAME>
#define ID_EMM_STREAM                           0x000001F1
</MACRO>
<MACRO>
<NAME>ID_DSMCC_STREAM</NAME>
#define ID_DSMCC_STREAM                         0x000001F2
</MACRO>
<MACRO>
<NAME>ID_ISO_IEC_13522_STREAM</NAME>
#define ID_ISO_IEC_13522_STREAM                 0x000001F3
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_A_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_A_STREAM          0x000001F4
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_B_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_B_STREAM          0x000001F5
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_C_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_C_STREAM          0x000001F6
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_D_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_D_STREAM          0x000001F7
</MACRO>
<MACRO>
<NAME>ID_ITU_TREC_H222_TYPE_E_STREAM</NAME>
#define ID_ITU_TREC_H222_TYPE_E_STREAM          0x000001F8
</MACRO>
<MACRO>
<NAME>ID_ANCILLARY_STREAM</NAME>
#define ID_ANCILLARY_STREAM                     0x000001F9
</MACRO>
<MACRO>
<NAME>ID_RESERVED_STREAM_1</NAME>
#define ID_RESERVED_STREAM_1                    0x000001FA
</MACRO>
<MACRO>
<NAME>ID_RESERVED_STREAM_2</NAME>
#define ID_RESERVED_STREAM_2                    0x000001FB
</MACRO>
<MACRO>
<NAME>ID_EXTENDED_METADATA</NAME>
#define ID_EXTENDED_METADATA                    0x000001FC
</MACRO>
<MACRO>
<NAME>ID_EXTENDED_STREAM_ID</NAME>
#define ID_EXTENDED_STREAM_ID                   0x000001FD
</MACRO>
<MACRO>
<NAME>ID_RESERVED_STREAM_3</NAME>
#define ID_RESERVED_STREAM_3                    0x000001FE
</MACRO>
<MACRO>
<NAME>ID_PROGRAM_STREAM_DIRECTORY</NAME>
#define ID_PROGRAM_STREAM_DIRECTORY             0x000001FF
</MACRO>
<MACRO>
<NAME>PACKET_VIDEO_START_CODE</NAME>
#define PACKET_VIDEO_START_CODE                 0x000001E0
</MACRO>
<MACRO>
<NAME>PACKET_AUDIO_START_CODE</NAME>
#define PACKET_AUDIO_START_CODE                 0x000001C0
</MACRO>
<MACRO>
<NAME>PICTURE_START_CODE</NAME>
#define PICTURE_START_CODE                      0x00000100
</MACRO>
<MACRO>
<NAME>USER_DATA_START_CODE</NAME>
#define USER_DATA_START_CODE                    0x000001B2
</MACRO>
<MACRO>
<NAME>SEQUENCE_HEADER_CODE</NAME>
#define SEQUENCE_HEADER_CODE                    0x000001B3
</MACRO>
<MACRO>
<NAME>SEQUENCE_ERROR_CODE</NAME>
#define SEQUENCE_ERROR_CODE                     0x000001B4
</MACRO>
<MACRO>
<NAME>EXTENSION_START_CODE</NAME>
#define EXTENSION_START_CODE                    0x000001B5
</MACRO>
<MACRO>
<NAME>SEQUENCE_END_CODE</NAME>
#define SEQUENCE_END_CODE                       0x000001B7
</MACRO>
<MACRO>
<NAME>GROUP_START_CODE</NAME>
#define GROUP_START_CODE                        0x000001B8
</MACRO>
<MACRO>
<NAME>AC3_SYNC_WORD</NAME>
#define AC3_SYNC_WORD                           0x0b770000
</MACRO>
<MACRO>
<NAME>MPEG_TS_SYNC_BYTE</NAME>
#define MPEG_TS_SYNC_BYTE                       0x00000047
</MACRO>
<MACRO>
<NAME>PID_PROGRAM_ASSOCIATION_TABLE</NAME>
#define PID_PROGRAM_ASSOCIATION_TABLE          0x0000
</MACRO>
<MACRO>
<NAME>PID_CONDITIONAL_ACCESS_TABLE</NAME>
#define PID_CONDITIONAL_ACCESS_TABLE           0x0001
</MACRO>
<MACRO>
<NAME>PID_RESERVED_FIRST</NAME>
#define PID_RESERVED_FIRST                     0x0002
</MACRO>
<MACRO>
<NAME>PID_RESERVED_LAST</NAME>
#define PID_RESERVED_LAST                      0x0010
</MACRO>
<MACRO>
<NAME>PID_NULL_PACKET</NAME>
#define PID_NULL_PACKET                        0x1FFF
</MACRO>
<MACRO>
<NAME>PID_TYPE_UNKNOWN</NAME>
#define PID_TYPE_UNKNOWN                        0
</MACRO>
<MACRO>
<NAME>PID_TYPE_RESERVED</NAME>
#define PID_TYPE_RESERVED                       1
</MACRO>
<MACRO>
<NAME>PID_TYPE_PROGRAM_ASSOCIATION</NAME>
#define PID_TYPE_PROGRAM_ASSOCIATION            2
</MACRO>
<MACRO>
<NAME>PID_TYPE_CONDITIONAL_ACCESS</NAME>
#define PID_TYPE_CONDITIONAL_ACCESS             3
</MACRO>
<MACRO>
<NAME>PID_TYPE_PROGRAM_MAP</NAME>
#define PID_TYPE_PROGRAM_MAP                    4
</MACRO>
<MACRO>
<NAME>PID_TYPE_ELEMENTARY</NAME>
#define PID_TYPE_ELEMENTARY                     5
</MACRO>
<MACRO>
<NAME>PID_TYPE_NULL_PACKET</NAME>
#define PID_TYPE_NULL_PACKET                    6
</MACRO>
<MACRO>
<NAME>PID_TYPE_PRIVATE_SECTION</NAME>
#define PID_TYPE_PRIVATE_SECTION                7
</MACRO>
<MACRO>
<NAME>ST_RESERVED</NAME>
#define ST_RESERVED                     0x00
</MACRO>
<MACRO>
<NAME>ST_VIDEO_MPEG1</NAME>
#define ST_VIDEO_MPEG1                  0x01
</MACRO>
<MACRO>
<NAME>ST_VIDEO_MPEG2</NAME>
#define ST_VIDEO_MPEG2                  0x02
</MACRO>
<MACRO>
<NAME>ST_AUDIO_MPEG1</NAME>
#define ST_AUDIO_MPEG1                  0x03
</MACRO>
<MACRO>
<NAME>ST_AUDIO_MPEG2</NAME>
#define ST_AUDIO_MPEG2                  0x04
</MACRO>
<MACRO>
<NAME>ST_PRIVATE_SECTIONS</NAME>
#define ST_PRIVATE_SECTIONS             0x05
</MACRO>
<MACRO>
<NAME>ST_PRIVATE_DATA</NAME>
#define ST_PRIVATE_DATA                 0x06
</MACRO>
<MACRO>
<NAME>ST_MHEG</NAME>
#define ST_MHEG                         0x07
</MACRO>
<MACRO>
<NAME>ST_DSMCC</NAME>
#define ST_DSMCC                        0x08
</MACRO>
<MACRO>
<NAME>ST_H222_1</NAME>
#define ST_H222_1                       0x09
</MACRO>
<MACRO>
<NAME>ST_AUDIO_AAC_ADTS</NAME>
#define ST_AUDIO_AAC_ADTS               0x0f
</MACRO>
<MACRO>
<NAME>ST_AUDIO_AAC_LOAS</NAME>
#define ST_AUDIO_AAC_LOAS               0x11
</MACRO>
<MACRO>
<NAME>ST_VIDEO_MPEG4</NAME>
#define ST_VIDEO_MPEG4                  0x10
</MACRO>
<MACRO>
<NAME>ST_VIDEO_H264</NAME>
#define ST_VIDEO_H264                   0x1b
</MACRO>
<MACRO>
<NAME>ST_VIDEO_DIRAC</NAME>
#define ST_VIDEO_DIRAC                  0xd1
</MACRO>
<MACRO>
<NAME>ST_PS_AUDIO_AC3</NAME>
#define ST_PS_AUDIO_AC3                 0x81
</MACRO>
<MACRO>
<NAME>ST_PS_AUDIO_DTS</NAME>
#define ST_PS_AUDIO_DTS                 0x8a
</MACRO>
<MACRO>
<NAME>ST_PS_AUDIO_LPCM</NAME>
#define ST_PS_AUDIO_LPCM                0x8b
</MACRO>
<MACRO>
<NAME>ST_PS_DVD_SUBPICTURE</NAME>
#define ST_PS_DVD_SUBPICTURE            0xff
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_LPCM</NAME>
#define ST_BD_AUDIO_LPCM                0x80
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_AC3</NAME>
#define ST_BD_AUDIO_AC3                 0x81
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_DTS</NAME>
#define ST_BD_AUDIO_DTS                 0x82
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_AC3_TRUE_HD</NAME>
#define ST_BD_AUDIO_AC3_TRUE_HD         0x83
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_AC3_PLUS</NAME>
#define ST_BD_AUDIO_AC3_PLUS            0x84
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_DTS_HD</NAME>
#define ST_BD_AUDIO_DTS_HD              0x85
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_DTS_HD_MASTER_AUDIO</NAME>
#define ST_BD_AUDIO_DTS_HD_MASTER_AUDIO 0x86
</MACRO>
<MACRO>
<NAME>ST_BD_AUDIO_EAC3</NAME>
#define ST_BD_AUDIO_EAC3                0x87
</MACRO>
<MACRO>
<NAME>ST_BD_PGS_SUBPICTURE</NAME>
#define ST_BD_PGS_SUBPICTURE            0x90
</MACRO>
<MACRO>
<NAME>ST_BD_IGS</NAME>
#define ST_BD_IGS                       0x91
</MACRO>
<MACRO>
<NAME>ST_BD_SUBTITLE</NAME>
#define ST_BD_SUBTITLE                  0x92
</MACRO>
<MACRO>
<NAME>ST_BD_SECONDARY_AC3_PLUS</NAME>
#define ST_BD_SECONDARY_AC3_PLUS        0xa1
</MACRO>
<MACRO>
<NAME>ST_BD_SECONDARY_DTS_HD</NAME>
#define ST_BD_SECONDARY_DTS_HD          0xa2
</MACRO>
<MACRO>
<NAME>ST_PRIVATE_EA</NAME>
#define ST_PRIVATE_EA                   0xea
</MACRO>
<MACRO>
<NAME>ST_HDV_AUX_A</NAME>
#define ST_HDV_AUX_A                    0xa0
</MACRO>
<MACRO>
<NAME>ST_HDV_AUX_V</NAME>
#define ST_HDV_AUX_V                    0xa1
</MACRO>
<MACRO>
<NAME>ST_PS_TIMECODE</NAME>
#define ST_PS_TIMECODE                  0xd2
</MACRO>
<MACRO>
<NAME>ST_GST_AUDIO_RAWA52</NAME>
#define ST_GST_AUDIO_RAWA52             0x181
</MACRO>
<MACRO>
<NAME>ST_GST_VIDEO_MPEG1_OR_2</NAME>
#define ST_GST_VIDEO_MPEG1_OR_2         0x102
</MACRO>
<MACRO>
<NAME>CLOCK_BASE</NAME>
#define CLOCK_BASE 9LL
</MACRO>
<MACRO>
<NAME>CLOCK_FREQ</NAME>
#define CLOCK_FREQ (CLOCK_BASE * 10000)
</MACRO>
<MACRO>
<NAME>MPEGTIME_TO_GSTTIME</NAME>
#define MPEGTIME_TO_GSTTIME(time) (gst_util_uint64_scale ((time), \
            GST_MSECOND/10, CLOCK_BASE))
</MACRO>
<MACRO>
<NAME>GSTTIME_TO_MPEGTIME</NAME>
#define GSTTIME_TO_MPEGTIME(time) (gst_util_uint64_scale ((time), \
            CLOCK_BASE, GST_MSECOND/10))
</MACRO>
<MACRO>
<NAME>MPEG_MUX_RATE_MULT</NAME>
#define MPEG_MUX_RATE_MULT      50
</MACRO>
<MACRO>
<NAME>READ_TS</NAME>
#define READ_TS(data, target, lost_sync_label)          \
    if ((*data & 0x01) != 0x01) goto lost_sync_label;   \
    target  = ((guint64) (*data++ & 0x0E)) << 29;       \
    target |= ((guint64) (*data++       )) << 22;       \
    if ((*data & 0x01) != 0x01) goto lost_sync_label;   \
    target |= ((guint64) (*data++ & 0xFE)) << 14;       \
    target |= ((guint64) (*data++       )) << 7;        \
    if ((*data & 0x01) != 0x01) goto lost_sync_label;   \
    target |= ((guint64) (*data++ & 0xFE)) >> 1;
</MACRO>
<MACRO>
<NAME>GST_FLOW_NEED_MORE_DATA</NAME>
#define GST_FLOW_NEED_MORE_DATA   GST_FLOW_CUSTOM_SUCCESS
</MACRO>
<MACRO>
<NAME>GST_FLOW_LOST_SYNC</NAME>
#define GST_FLOW_LOST_SYNC        GST_FLOW_CUSTOM_SUCCESS_1
</MACRO>
<MACRO>
<NAME>RSN_TYPE_DEC</NAME>
#define RSN_TYPE_DEC               (rsn_dec_get_type())
</MACRO>
<MACRO>
<NAME>RSN_DEC</NAME>
#define RSN_DEC(obj)               (G_TYPE_CHECK_INSTANCE_CAST((obj),RSN_TYPE_DEC,RsnDec))
</MACRO>
<MACRO>
<NAME>RSN_DEC_CLASS</NAME>
#define RSN_DEC_CLASS(klass)       (G_TYPE_CHECK_CLASS_CAST((klass),RSN_TYPE_DEC,RsnDecClass))
</MACRO>
<MACRO>
<NAME>RSN_IS_DEC</NAME>
#define RSN_IS_DEC(obj)            (G_TYPE_CHECK_INSTANCE_TYPE((obj),RSN_TYPE_DEC))
</MACRO>
<MACRO>
<NAME>RSN_IS_DEC_CLASS</NAME>
#define RSN_IS_DEC_CLASS(klass)    (G_TYPE_CHECK_CLASS_TYPE((klass),RSN_TYPE_DEC))
</MACRO>
<MACRO>
<NAME>RSN_DEC_GET_CLASS</NAME>
#define RSN_DEC_GET_CLASS(obj)     (G_TYPE_INSTANCE_GET_CLASS ((obj), RSN_TYPE_DEC, RsnDecClass))
</MACRO>
<MACRO>
<NAME>RSN_TYPE_AUDIODEC</NAME>
#define RSN_TYPE_AUDIODEC               (rsn_audiodec_get_type())
</MACRO>
<MACRO>
<NAME>RSN_AUDIODEC</NAME>
#define RSN_AUDIODEC(obj)               (G_TYPE_CHECK_INSTANCE_CAST((obj),RSN_TYPE_AUDIODEC,RsnAudioDec))
</MACRO>
<MACRO>
<NAME>RSN_AUDIODEC_CLASS</NAME>
#define RSN_AUDIODEC_CLASS(klass)       (G_TYPE_CHECK_CLASS_CAST((klass),RSN_TYPE_AUDIODEC,RsnAudioDecClass))
</MACRO>
<MACRO>
<NAME>RSN_IS_AUDIODEC</NAME>
#define RSN_IS_AUDIODEC(obj)            (G_TYPE_CHECK_INSTANCE_TYPE((obj),RSN_TYPE_AUDIODEC))
</MACRO>
<MACRO>
<NAME>RSN_IS_AUDIODEC_CLASS</NAME>
#define RSN_IS_AUDIODEC_CLASS(klass)    (G_TYPE_CHECK_CLASS_TYPE((klass),RSN_TYPE_AUDIODEC))
</MACRO>
<MACRO>
<NAME>RSN_TYPE_VIDEODEC</NAME>
#define RSN_TYPE_VIDEODEC               (rsn_videodec_get_type())
</MACRO>
<MACRO>
<NAME>RSN_VIDEODEC</NAME>
#define RSN_VIDEODEC(obj)               (G_TYPE_CHECK_INSTANCE_CAST((obj),RSN_TYPE_VIDEODEC,RsnVideoDec))
</MACRO>
<MACRO>
<NAME>RSN_VIDEODEC_CLASS</NAME>
#define RSN_VIDEODEC_CLASS(klass)       (G_TYPE_CHECK_CLASS_CAST((klass),RSN_TYPE_VIDEODEC,RsnVideoDecClass))
</MACRO>
<MACRO>
<NAME>RSN_IS_VIDEODEC</NAME>
#define RSN_IS_VIDEODEC(obj)            (G_TYPE_CHECK_INSTANCE_TYPE((obj),RSN_TYPE_VIDEODEC))
</MACRO>
<MACRO>
<NAME>RSN_IS_VIDEODEC_CLASS</NAME>
#define RSN_IS_VIDEODEC_CLASS(klass)    (G_TYPE_CHECK_CLASS_TYPE((klass),RSN_TYPE_VIDEODEC))
</MACRO>
<FUNCTION>
<NAME>rsn_dec_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rsn_audiodec_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rsn_videodec_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>RsnAudioDec</NAME>
typedef struct _RsnDec             RsnAudioDec;
</TYPEDEF>
<TYPEDEF>
<NAME>RsnAudioDecClass</NAME>
typedef struct _RsnDecClass        RsnAudioDecClass;
</TYPEDEF>
<TYPEDEF>
<NAME>RsnVideoDec</NAME>
typedef struct _RsnDec             RsnVideoDec;
</TYPEDEF>
<TYPEDEF>
<NAME>RsnVideoDecClass</NAME>
typedef struct _RsnDecClass        RsnVideoDecClass;
</TYPEDEF>
<STRUCT>
<NAME>RsnDec</NAME>
struct _RsnDec {
  GstBin element;

  /* Our sink and source pads */
  GstGhostPad *sinkpad;
  GstGhostPad *srcpad;

  GstPadEventFunction sink_event_func;

  GstElement *current_decoder;
};
</STRUCT>
<STRUCT>
<NAME>RsnDecClass</NAME>
struct _RsnDecClass {
  GstBinClass parent_class;

  const GList * (*get_decoder_factories) (RsnDecClass *klass);
};
</STRUCT>
<MACRO>
<NAME>DESC_VIDEO_STREAM</NAME>
#define DESC_VIDEO_STREAM			2
</MACRO>
<MACRO>
<NAME>DESC_AUDIO_STREAM</NAME>
#define DESC_AUDIO_STREAM			3
</MACRO>
<MACRO>
<NAME>DESC_HIERARCHY</NAME>
#define DESC_HIERARCHY				4
</MACRO>
<MACRO>
<NAME>DESC_REGISTRATION</NAME>
#define DESC_REGISTRATION			5
</MACRO>
<MACRO>
<NAME>DESC_DATA_STREAM_ALIGNMENT</NAME>
#define DESC_DATA_STREAM_ALIGNMENT		6
</MACRO>
<MACRO>
<NAME>DESC_TARGET_BACKGROUND_GRID</NAME>
#define DESC_TARGET_BACKGROUND_GRID		7
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_WINDOW</NAME>
#define DESC_VIDEO_WINDOW			8
</MACRO>
<MACRO>
<NAME>DESC_CA</NAME>
#define DESC_CA					9
</MACRO>
<MACRO>
<NAME>DESC_ISO_639_LANGUAGE</NAME>
#define DESC_ISO_639_LANGUAGE			10
</MACRO>
<MACRO>
<NAME>DESC_SYSTEM_CLOCK</NAME>
#define DESC_SYSTEM_CLOCK			11
</MACRO>
<MACRO>
<NAME>DESC_MULTIPLEX_BUFFER_UTILISATION</NAME>
#define DESC_MULTIPLEX_BUFFER_UTILISATION	12
</MACRO>
<MACRO>
<NAME>DESC_COPYRIGHT</NAME>
#define DESC_COPYRIGHT				13
</MACRO>
<MACRO>
<NAME>DESC_MAXIMUM_BITRATE</NAME>
#define DESC_MAXIMUM_BITRATE			14
</MACRO>
<MACRO>
<NAME>DESC_PRIVATE_DATA_INDICATOR</NAME>
#define DESC_PRIVATE_DATA_INDICATOR		15
</MACRO>
<MACRO>
<NAME>DESC_SMOOTHING_BUFFER</NAME>
#define DESC_SMOOTHING_BUFFER			16
</MACRO>
<MACRO>
<NAME>DESC_STD</NAME>
#define DESC_STD				17
</MACRO>
<MACRO>
<NAME>DESC_IBP</NAME>
#define DESC_IBP				18
</MACRO>
<MACRO>
<NAME>DESC_DIRAC_TC_PRIVATE</NAME>
#define DESC_DIRAC_TC_PRIVATE			0xAC
</MACRO>
<MACRO>
<NAME>DESC_DVB_NETWORK_NAME</NAME>
#define DESC_DVB_NETWORK_NAME   0x40
</MACRO>
<MACRO>
<NAME>DESC_DVB_SERVICE_LIST</NAME>
#define DESC_DVB_SERVICE_LIST   0x41
</MACRO>
<MACRO>
<NAME>DESC_DVB_STUFFING</NAME>
#define DESC_DVB_STUFFING       0x42
</MACRO>
<MACRO>
<NAME>DESC_DVB_SATELLITE_DELIVERY_SYSTEM</NAME>
#define DESC_DVB_SATELLITE_DELIVERY_SYSTEM    0x43
</MACRO>
<MACRO>
<NAME>DESC_DVB_CABLE_DELIVERY_SYSTEM</NAME>
#define DESC_DVB_CABLE_DELIVERY_SYSTEM    0x44
</MACRO>
<MACRO>
<NAME>DESC_DVB_VBI_DATA</NAME>
#define DESC_DVB_VBI_DATA       0x45
</MACRO>
<MACRO>
<NAME>DESC_DVB_VBI_TELETEXT</NAME>
#define DESC_DVB_VBI_TELETEXT   0x46
</MACRO>
<MACRO>
<NAME>DESC_DVB_BOUQUET_NAME</NAME>
#define DESC_DVB_BOUQUET_NAME   0x47
</MACRO>
<MACRO>
<NAME>DESC_DVB_SERVICE</NAME>
#define DESC_DVB_SERVICE        0x48
</MACRO>
<MACRO>
<NAME>DESC_DVB_COUNTRY_AVAILABILITY</NAME>
#define DESC_DVB_COUNTRY_AVAILABILITY   0x49
</MACRO>
<MACRO>
<NAME>DESC_DVB_LINKAGE</NAME>
#define DESC_DVB_LINKAGE        0x4A
</MACRO>
<MACRO>
<NAME>DESC_DVB_NVOD_REFERENCE</NAME>
#define DESC_DVB_NVOD_REFERENCE 0x4B
</MACRO>
<MACRO>
<NAME>DESC_DVB_TIME_SHIFTED_SERVICE</NAME>
#define DESC_DVB_TIME_SHIFTED_SERVICE   0x4C
</MACRO>
<MACRO>
<NAME>DESC_DVB_SHORT_EVENT</NAME>
#define DESC_DVB_SHORT_EVENT    0x4D
</MACRO>
<MACRO>
<NAME>DESC_DVB_EXTENDED_EVENT</NAME>
#define DESC_DVB_EXTENDED_EVENT 0x4E
</MACRO>
<MACRO>
<NAME>DESC_DVB_TIME_SHIFTED_EVENT</NAME>
#define DESC_DVB_TIME_SHIFTED_EVENT   0x4F
</MACRO>
<MACRO>
<NAME>DESC_DVB_COMPONENT</NAME>
#define DESC_DVB_COMPONENT      0x50
</MACRO>
<MACRO>
<NAME>DESC_DVB_MOSAIC</NAME>
#define DESC_DVB_MOSAIC         0x51
</MACRO>
<MACRO>
<NAME>DESC_DVB_STREAM_IDENTIFIER</NAME>
#define DESC_DVB_STREAM_IDENTIFIER    0x52
</MACRO>
<MACRO>
<NAME>DESC_DVB_CA_IDENTIFIER</NAME>
#define DESC_DVB_CA_IDENTIFIER  0x53
</MACRO>
<MACRO>
<NAME>DESC_DVB_CONTENT</NAME>
#define DESC_DVB_CONTENT        0x54
</MACRO>
<MACRO>
<NAME>DESC_DVB_PARENTAL_RATING</NAME>
#define DESC_DVB_PARENTAL_RATING    0x55
</MACRO>
<MACRO>
<NAME>DESC_DVB_TELETEXT</NAME>
#define DESC_DVB_TELETEXT       0x56
</MACRO>
<MACRO>
<NAME>DESC_DVB_TELEPHONE</NAME>
#define DESC_DVB_TELEPHONE      0x57
</MACRO>
<MACRO>
<NAME>DESC_DVB_LOCAL_TIME_OFFSET</NAME>
#define DESC_DVB_LOCAL_TIME_OFFSET  0x58
</MACRO>
<MACRO>
<NAME>DESC_DVB_SUBTITLING</NAME>
#define DESC_DVB_SUBTITLING     0x59
</MACRO>
<MACRO>
<NAME>DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM</NAME>
#define DESC_DVB_TERRESTRIAL_DELIVERY_SYSTEM  0x5A
</MACRO>
<MACRO>
<NAME>DESC_DVB_MULTILINGUAL_NETWORK_NAME</NAME>
#define DESC_DVB_MULTILINGUAL_NETWORK_NAME    0x5B
</MACRO>
<MACRO>
<NAME>DESC_DVB_MULTILINGUAL_BOUQUET_NAME</NAME>
#define DESC_DVB_MULTILINGUAL_BOUQUET_NAME    0x5C
</MACRO>
<MACRO>
<NAME>DESC_DVB_MULTILINGUAL_SERVICE_NAME</NAME>
#define DESC_DVB_MULTILINGUAL_SERVICE_NAME    0x5D
</MACRO>
<MACRO>
<NAME>DESC_DVB_MULTILINGUAL_COMPONENT</NAME>
#define DESC_DVB_MULTILINGUAL_COMPONENT   0x5E
</MACRO>
<MACRO>
<NAME>DESC_DVB_PRIVATE_DATA</NAME>
#define DESC_DVB_PRIVATE_DATA   0x5F
</MACRO>
<MACRO>
<NAME>DESC_DVB_SERVICE_MOVE</NAME>
#define DESC_DVB_SERVICE_MOVE   0x60
</MACRO>
<MACRO>
<NAME>DESC_DVB_SHORT_SMOOTHING_BUFFER</NAME>
#define DESC_DVB_SHORT_SMOOTHING_BUFFER   0x61
</MACRO>
<MACRO>
<NAME>DESC_DVB_FREQUENCY_LIST</NAME>
#define DESC_DVB_FREQUENCY_LIST 0x62
</MACRO>
<MACRO>
<NAME>DESC_DVB_PARTIAL_TRANSPORT_STREAM</NAME>
#define DESC_DVB_PARTIAL_TRANSPORT_STREAM   0x63
</MACRO>
<MACRO>
<NAME>DESC_DVB_DATA_BROADCAST</NAME>
#define DESC_DVB_DATA_BROADCAST 0x64
</MACRO>
<MACRO>
<NAME>DESC_DVB_SCRAMBLING</NAME>
#define DESC_DVB_SCRAMBLING     0x65
</MACRO>
<MACRO>
<NAME>DESC_DVB_DATA_BROADCAST_ID</NAME>
#define DESC_DVB_DATA_BROADCAST_ID    0x66
</MACRO>
<MACRO>
<NAME>DESC_DVB_TRANSPORT_STREAM</NAME>
#define DESC_DVB_TRANSPORT_STREAM   0x67
</MACRO>
<MACRO>
<NAME>DESC_DVB_DSNG</NAME>
#define DESC_DVB_DSNG           0x68
</MACRO>
<MACRO>
<NAME>DESC_DVB_PDC</NAME>
#define DESC_DVB_PDC            0x69
</MACRO>
<MACRO>
<NAME>DESC_DVB_AC3</NAME>
#define DESC_DVB_AC3            0x6A
</MACRO>
<MACRO>
<NAME>DESC_DVB_ANCILLARY_DATA</NAME>
#define DESC_DVB_ANCILLARY_DATA 0x6B
</MACRO>
<MACRO>
<NAME>DESC_DVB_CELL_LIST</NAME>
#define DESC_DVB_CELL_LIST          0x6C
</MACRO>
<MACRO>
<NAME>DESC_DVB_CELL_FREQUENCY_LINK</NAME>
#define DESC_DVB_CELL_FREQUENCY_LINK    0x6D
</MACRO>
<MACRO>
<NAME>DESC_DVB_ANNOUNCEMENT_SUPPORT</NAME>
#define DESC_DVB_ANNOUNCEMENT_SUPPORT   0x6E
</MACRO>
<MACRO>
<NAME>DESC_DVB_APPLICATION_SIGNALLING</NAME>
#define DESC_DVB_APPLICATION_SIGNALLING   0x6F
</MACRO>
<MACRO>
<NAME>DESC_DVB_ADAPTATION_FIELD_DATA</NAME>
#define DESC_DVB_ADAPTATION_FIELD_DATA    0x70
</MACRO>
<MACRO>
<NAME>DESC_DVB_SERVICE_IDENTIFIER</NAME>
#define DESC_DVB_SERVICE_IDENTIFIER   0x71
</MACRO>
<MACRO>
<NAME>DESC_DVB_SERVICE_AVAILABILITY</NAME>
#define DESC_DVB_SERVICE_AVAILABILITY   0x72
</MACRO>
<MACRO>
<NAME>DESC_DVB_DEFAULT_AUTHORITY</NAME>
#define DESC_DVB_DEFAULT_AUTHORITY    0x73
</MACRO>
<MACRO>
<NAME>DESC_DVB_RELATED_CONTENT</NAME>
#define DESC_DVB_RELATED_CONTENT    0x74
</MACRO>
<MACRO>
<NAME>DESC_DVB_TVA_ID</NAME>
#define DESC_DVB_TVA_ID         0x75
</MACRO>
<MACRO>
<NAME>DESC_DVB_CONTENT_IDENTIFIER</NAME>
#define DESC_DVB_CONTENT_IDENTIFIER   0x76
</MACRO>
<MACRO>
<NAME>DESC_DVB_TIMESLICE_FEC_IDENTIFIER</NAME>
#define DESC_DVB_TIMESLICE_FEC_IDENTIFIER   0x77
</MACRO>
<MACRO>
<NAME>DESC_DVB_ECM_REPETITION_RATE</NAME>
#define DESC_DVB_ECM_REPETITION_RATE    0x78
</MACRO>
<MACRO>
<NAME>DESC_DVB_S2_SATELLITE_DELIVERY_SYSTEM</NAME>
#define DESC_DVB_S2_SATELLITE_DELIVERY_SYSTEM   0x79
</MACRO>
<MACRO>
<NAME>DESC_DVB_ENHANCED_AC3</NAME>
#define DESC_DVB_ENHANCED_AC3   0x7A
</MACRO>
<MACRO>
<NAME>DESC_DVB_DTS</NAME>
#define DESC_DVB_DTS            0x7B
</MACRO>
<MACRO>
<NAME>DESC_DVB_AAC</NAME>
#define DESC_DVB_AAC            0x7C
</MACRO>
<MACRO>
<NAME>DESC_DVB_EXTENSION</NAME>
#define DESC_DVB_EXTENSION      0x7F
</MACRO>
<MACRO>
<NAME>DESC_TAG</NAME>
#define DESC_TAG(desc) 		(desc[0])
</MACRO>
<MACRO>
<NAME>DESC_LENGTH</NAME>
#define DESC_LENGTH(desc) 	(desc[1])
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_multiple_framerate_flag</NAME>
#define DESC_VIDEO_STREAM_multiple_framerate_flag(desc) 	(((desc)[2] & 0x80) == 0x80)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_frame_rate_code</NAME>
#define DESC_VIDEO_STREAM_frame_rate_code(desc) 		(((desc)[2] & 0x38) >> 3)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_MPEG_1_only_flag</NAME>
#define DESC_VIDEO_STREAM_MPEG_1_only_flag(desc) 		(((desc)[2] & 0x04) == 0x04)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_constrained_parameter_flag</NAME>
#define DESC_VIDEO_STREAM_constrained_parameter_flag(desc) 	(((desc)[2] & 0x02) == 0x02)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_still_picture_flag</NAME>
#define DESC_VIDEO_STREAM_still_picture_flag(desc) 	 	(((desc)[2] & 0x01) == 0x01)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_profile_and_level_indication</NAME>
#define DESC_VIDEO_STREAM_profile_and_level_indication(desc)	((desc)[3])
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_chroma_format</NAME>
#define DESC_VIDEO_STREAM_chroma_format(desc)			(((desc)[4] & 0xc0) >> 6)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_STREAM_frame_rate_extension_flag</NAME>
#define DESC_VIDEO_STREAM_frame_rate_extension_flag(desc)	(((desc)[4] & 0x20) == 0x20)
</MACRO>
<MACRO>
<NAME>DESC_AUDIO_STREAM_free_format_flag</NAME>
#define DESC_AUDIO_STREAM_free_format_flag(desc) 		(((desc)[2] & 0x80) == 0x80)
</MACRO>
<MACRO>
<NAME>DESC_AUDIO_STREAM_ID</NAME>
#define DESC_AUDIO_STREAM_ID(desc) 				(((desc)[2] & 0x40) == 0x40)
</MACRO>
<MACRO>
<NAME>DESC_AUDIO_STREAM_layer</NAME>
#define DESC_AUDIO_STREAM_layer(desc) 				(((desc)[2] & 0x30) >> 4)
</MACRO>
<MACRO>
<NAME>DESC_AUDIO_STREAM_variable_rate_audio_indicator</NAME>
#define DESC_AUDIO_STREAM_variable_rate_audio_indicator(desc) 	(((desc)[2] & 0x08) == 0x08)
</MACRO>
<MACRO>
<NAME>DESC_HIERARCHY_hierarchy_type</NAME>
#define DESC_HIERARCHY_hierarchy_type(desc)			(((desc)[2] & 0x0f))
</MACRO>
<MACRO>
<NAME>DESC_HIERARCHY_hierarchy_layer_index</NAME>
#define DESC_HIERARCHY_hierarchy_layer_index(desc)		(((desc)[3] & 0x3f))
</MACRO>
<MACRO>
<NAME>DESC_HIERARCHY_hierarchy_embedded_layer_index</NAME>
#define DESC_HIERARCHY_hierarchy_embedded_layer_index(desc)	(((desc)[4] & 0x3f))
</MACRO>
<MACRO>
<NAME>DESC_HIERARCHY_hierarchy_channel</NAME>
#define DESC_HIERARCHY_hierarchy_channel(desc)			(((desc)[5] & 0x3f))
</MACRO>
<MACRO>
<NAME>DESC_REGISTRATION_format_identifier</NAME>
#define DESC_REGISTRATION_format_identifier(desc)		(GST_READ_UINT32_BE ((desc)+2))
</MACRO>
<MACRO>
<NAME>DESC_REGISTRATION_additional_ident_info_len</NAME>
#define DESC_REGISTRATION_additional_ident_info_len(desc)	((desc)[1] - 4)
</MACRO>
<MACRO>
<NAME>DESC_REGISTRATION_additional_ident_info</NAME>
#define DESC_REGISTRATION_additional_ident_info(desc)		(&(desc)[6])
</MACRO>
<MACRO>
<NAME>DESC_DATA_STREAM_ALIGNMENT_alignment_type</NAME>
#define DESC_DATA_STREAM_ALIGNMENT_alignment_type(desc)		((desc)[2])
</MACRO>
<MACRO>
<NAME>DESC_TARGET_BACKGROUND_GRID_horizontal_size</NAME>
#define DESC_TARGET_BACKGROUND_GRID_horizontal_size(desc)	(GST_READ_UINT16_BE ((desc)+2) >> 2)
</MACRO>
<MACRO>
<NAME>DESC_TARGET_BACKGROUND_GRID_vertical_size</NAME>
#define DESC_TARGET_BACKGROUND_GRID_vertical_size(desc)		((GST_READ_UINT32_BE ((desc)+2) & 0x0003fff0) >> 4)
</MACRO>
<MACRO>
<NAME>DESC_TARGET_BACKGROUND_GRID_aspect_ratio_information</NAME>
#define DESC_TARGET_BACKGROUND_GRID_aspect_ratio_information(desc) ((desc)[5] & 0x0f)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_WINDOW_horizontal_offset</NAME>
#define DESC_VIDEO_WINDOW_horizontal_offset(desc)		(GST_READ_UINT16_BE ((desc)+2) >> 2)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_WINDOW_vertical_offset</NAME>
#define DESC_VIDEO_WINDOW_vertical_offset(desc)			((GST_READ_UINT32_BE ((desc)+2) & 0x0003fff0) >> 4)
</MACRO>
<MACRO>
<NAME>DESC_VIDEO_WINDOW_window_priority</NAME>
#define DESC_VIDEO_WINDOW_window_priority(desc)	 		((desc)[5] & 0x0f)
</MACRO>
<MACRO>
<NAME>DESC_CA_system_ID</NAME>
#define DESC_CA_system_ID(desc)					(GST_READ_UINT16_BE ((desc)+2))
</MACRO>
<MACRO>
<NAME>DESC_CA_PID</NAME>
#define DESC_CA_PID(desc)					(GST_READ_UINT16_BE ((desc)+2) & 0x1fff)
</MACRO>
<MACRO>
<NAME>DESC_ISO_639_LANGUAGE_codes_n</NAME>
#define DESC_ISO_639_LANGUAGE_codes_n(desc)			((desc[1]) >> 2)
</MACRO>
<MACRO>
<NAME>DESC_ISO_639_LANGUAGE_language_code_nth</NAME>
#define DESC_ISO_639_LANGUAGE_language_code_nth(desc,i)		(&(desc[2 + (4*i)]))
</MACRO>
<MACRO>
<NAME>DESC_ISO_639_LANGUAGE_audio_type_nth</NAME>
#define DESC_ISO_639_LANGUAGE_audio_type_nth(desc,i)		((desc)[5 + (4*i)])
</MACRO>
<MACRO>
<NAME>DESC_SYSTEM_CLOCK_external_clock_reference_indicator</NAME>
#define DESC_SYSTEM_CLOCK_external_clock_reference_indicator(desc) (((desc)[2] & 0x80) == 0x80)
</MACRO>
<MACRO>
<NAME>DESC_SYSTEM_CLOCK_clock_accuracy_integer</NAME>
#define DESC_SYSTEM_CLOCK_clock_accuracy_integer(desc)		((desc)[2] & 0x3f)
</MACRO>
<MACRO>
<NAME>DESC_SYSTEM_CLOCK_clock_accuracy_exponent</NAME>
#define DESC_SYSTEM_CLOCK_clock_accuracy_exponent(desc)		(((desc)[3] & 0xe0) >> 5)
</MACRO>
<MACRO>
<NAME>DESC_MULTIPLEX_BUFFER_UTILISATION_bound_valid_flag</NAME>
#define DESC_MULTIPLEX_BUFFER_UTILISATION_bound_valid_flag(desc)	(((desc)[2] & 0x80) == 0x80)
</MACRO>
<MACRO>
<NAME>DESC_MULTIPLEX_BUFFER_UTILISATION_LTW_offset_lower_bound</NAME>
#define DESC_MULTIPLEX_BUFFER_UTILISATION_LTW_offset_lower_bound(desc)	(GST_READ_UINT16_BE ((desc)+2) & 0x7fff)
</MACRO>
<MACRO>
<NAME>DESC_MULTIPLEX_BUFFER_UTILISATION_LTW_offset_upper_bound</NAME>
#define DESC_MULTIPLEX_BUFFER_UTILISATION_LTW_offset_upper_bound(desc)	(GST_READ_UINT16_BE ((desc)+4) & 0x7fff)
</MACRO>
<MACRO>
<NAME>DESC_COPYRIGHT_copyright_identifier</NAME>
#define DESC_COPYRIGHT_copyright_identifier(desc)		(GST_READ_UINT32_BE ((desc)+2))
</MACRO>
<MACRO>
<NAME>DESC_COPYRIGHT_additional_copyright_info_len</NAME>
#define DESC_COPYRIGHT_additional_copyright_info_len(desc)	((desc)[1] - 4)
</MACRO>
<MACRO>
<NAME>DESC_COPYRIGHT_additional_copyright_info</NAME>
#define DESC_COPYRIGHT_additional_copyright_info(desc)		(&(desc)[6])
</MACRO>
<MACRO>
<NAME>DESC_MAXIMUM_BITRAT_maximum_bitrate</NAME>
#define DESC_MAXIMUM_BITRAT_maximum_bitrate(desc)		(((((guint32)desc[2]) & 0x3f) << 16) | \
								 GST_READ_UINT16_BE ((desc)+3)) 
</MACRO>
<MACRO>
<NAME>DESC_PRIVATE_DATA_INDICATOR_indicator</NAME>
#define DESC_PRIVATE_DATA_INDICATOR_indicator(desc)		(GST_READ_UINT32_BE(&desc[2]))
</MACRO>
<MACRO>
<NAME>DESC_SMOOTHING_BUFFER_sb_leak_rate</NAME>
#define DESC_SMOOTHING_BUFFER_sb_leak_rate(desc)		(((((guint32)desc[2]) & 0x3f) << 16) | \
                                                                 GST_READ_UINT16_BE ((desc)+3))
</MACRO>
<MACRO>
<NAME>DESC_SMOOTHING_BUFFER_sb_size</NAME>
#define DESC_SMOOTHING_BUFFER_sb_size(desc)			(((((guint32)desc[5]) & 0x3f) << 16) | \
                                                                 GST_READ_UINT16_BE ((desc)+6))
</MACRO>
<MACRO>
<NAME>DESC_STD_leak_valid_flag</NAME>
#define DESC_STD_leak_valid_flag(desc)				(((desc)[2] & 0x01) == 0x01)
</MACRO>
<MACRO>
<NAME>DESC_IBP_closed_gop_flag</NAME>
#define DESC_IBP_closed_gop_flag(desc)				(((desc)[2] & 0x80) == 0x80)
</MACRO>
<MACRO>
<NAME>DESC_IBP_identical_gop_flag</NAME>
#define DESC_IBP_identical_gop_flag(desc)			(((desc)[2] & 0x40) == 0x40)
</MACRO>
<MACRO>
<NAME>DESC_IBP_max_gop_length</NAME>
#define DESC_IBP_max_gop_length(desc)				(GST_READ_UINT16_BE ((desc)+6) & 0x3fff)
</MACRO>
<MACRO>
<NAME>DESC_TIMECODE_video_pid</NAME>
#define DESC_TIMECODE_video_pid(desc)                           (GST_READ_UINT16_BE ((desc) + 2) & 0x1fff)
</MACRO>
<MACRO>
<NAME>DESC_DVB_STREAM_IDENTIFIER_component_tag</NAME>
#define DESC_DVB_STREAM_IDENTIFIER_component_tag(desc)  (desc[2])
</MACRO>
<MACRO>
<NAME>DESC_DVB_NETWORK_NAME_length</NAME>
#define DESC_DVB_NETWORK_NAME_length(desc)  (GST_READ_UINT8((desc)+1))
</MACRO>
<MACRO>
<NAME>DESC_DVB_NETWORK_NAME_text</NAME>
#define DESC_DVB_NETWORK_NAME_text(desc)    (desc+2)
</MACRO>
<STRUCT>
<NAME>GstMPEGDescriptor</NAME>
typedef struct {
  guint    n_desc;
  guint8   data_length;
  guint8  *data;
} GstMPEGDescriptor;
</STRUCT>
<FUNCTION>
<NAME>gst_mpeg_descriptor_parse</NAME>
<RETURNS>GstMPEGDescriptor * 	</RETURNS>
guint8 *data, guint size
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_descriptor_free</NAME>
<RETURNS>void 		 	</RETURNS>
GstMPEGDescriptor *desc
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_descriptor_n_desc</NAME>
<RETURNS>guint  			</RETURNS>
GstMPEGDescriptor *desc
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_descriptor_find</NAME>
<RETURNS>guint8 *			</RETURNS>
GstMPEGDescriptor *desc, gint tag
</FUNCTION>
<FUNCTION>
<NAME>gst_mpeg_descriptor_nth</NAME>
<RETURNS>guint8 *			</RETURNS>
GstMPEGDescriptor *desc, guint i
</FUNCTION>
<MACRO>
<NAME>RESIN_TYPE_DVDSRC</NAME>
#define RESIN_TYPE_DVDSRC (rsn_dvdsrc_get_type())
</MACRO>
<MACRO>
<NAME>RESINDVDSRC</NAME>
#define RESINDVDSRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),RESIN_TYPE_DVDSRC,resinDvdSrc))
</MACRO>
<MACRO>
<NAME>RESINDVDSRC_CLASS</NAME>
#define RESINDVDSRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),RESIN_TYPE_DVDSRC,resinDvdSrcClass))
</MACRO>
<MACRO>
<NAME>IS_RESINDVDSRC</NAME>
#define IS_RESINDVDSRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),RESIN_TYPE_DVDSRC))
</MACRO>
<MACRO>
<NAME>IS_RESINDVDSRC_CLASS</NAME>
#define IS_RESINDVDSRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),RESIN_TYPE_DVDSRC))
</MACRO>
<STRUCT>
<NAME>resinDvdSrc</NAME>
struct _resinDvdSrc
{
  GstBaseSrc parent;

  gboolean	faststart;

  GMutex	dvd_lock;
  GCond		still_cond;
  GMutex	branch_lock;
  gboolean	branching;

  gchar		*device;
  dvdnav_t	*dvdnav;

  gchar     *disc_name;

  /* dvd_reader instance is used to load and cache VTS/VMG ifo info */
  dvd_reader_t  *dvdread;

  /* vmgi_mat_t from the VMG ifo: */
  vmgi_mat_t                vmgm_attr;        /* VMGM domain info             */
  /* Array of cached vtsi_mat_t strctures from each IFO: */
  GArray                   *vts_attrs;

  ifo_handle_t              *vmg_file;
  ifo_handle_t              *vts_file;

  /* Current playback location: VTS 0 = VMG, plus in_menu or not */
  gint		vts_n;
  gboolean	in_menu;
  gint          title_n; /* Title num */
  gint          part_n; /* Part num */
  gint          n_angles; /* number of angles */
  gint          cur_angle; /* current angle */

  gboolean	running;
  gboolean	discont;
  gboolean	first_seek;
  gboolean	flushing_seek;
  gboolean	need_segment;
  gboolean	need_tag_update;
  gboolean	active_highlight;
  gboolean      in_still_state;
  gboolean      in_playing;

  gboolean      was_mouse_over;

  /* Remaining time to wait in a timed still: */
  GstClockTime  still_time_remaining;

  GstBuffer	*alloc_buf;
  GstBuffer	*next_buf;
  /* TRUE if the next_buf is a nav block that needs enqueueing */
  gboolean      next_is_nav_block;
  /* PTS for activating the pending nav block in next_buf */
  GstClockTime  next_nav_ts;
  /* Track accumulated segment position, cleared by flushing */
  GstSegment    src_segment;

  /* Start timestamp of the previous NAV block */
  GstClockTime  cur_start_ts;
  /* End timestamp of the previous NAV block */
  GstClockTime  cur_end_ts;
  /* base ts is cur_start_ts - cell_time for each VOBU */
  GstClockTime  cur_vobu_base_ts;
  /* Position info of the previous NAV block */
  GstClockTime  cur_position;
  /* Duration of the current PGC */
  GstClockTime  pgc_duration;

  gint          active_button;
  dvdnav_highlight_area_t area;

  /* Pending events to output */
  GstEvent	*streams_event;
  GstEvent	*clut_event;
  GstEvent	*spu_select_event;
  GstEvent	*audio_select_event;
  GstEvent	*highlight_event;

  gboolean      angles_changed;
  gboolean      commands_changed;

  /* GList of NAV packets awaiting activation, and the
   * running times to activate them. */
  GSList *pending_nav_blocks;
  GSList *pending_nav_blocks_end;

  GstClockID nav_clock_id;

  gboolean have_pci;
  pci_t cur_pci;

  /* Current state tracking */
  gint8         cur_audio_phys_stream;
  gint8         cur_spu_phys_stream;
  gboolean      cur_spu_forced_only;
  guint32       cur_clut[16];

  guint32       cur_btn_mask;
};
</STRUCT>
<STRUCT>
<NAME>resinDvdSrcClass</NAME>
struct _resinDvdSrcClass 
{
  GstBaseSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>rsn_dvdsrc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<USER_FUNCTION>
<NAME>GstPESFilterData</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstPESFilter * filter, gboolean first, GstBuffer * buffer, 
                         gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPESFilterResync</NAME>
<RETURNS>void </RETURNS>
GstPESFilter * filter, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPESFilterIndex</NAME>
<RETURNS>void </RETURNS>
GstPESFilter * filter, gpointer user_data
</USER_FUNCTION>
<ENUM>
<NAME>GstPESFilterState</NAME>
typedef enum {
  STATE_HEADER_PARSE,
  STATE_DATA_PUSH, 
  STATE_DATA_SKIP 
} GstPESFilterState;
</ENUM>
<STRUCT>
<NAME>GstPESFilter</NAME>
struct _GstPESFilter {
  GstAdapter         * adapter;
  guint64            * adapter_offset;

  GstPESFilterState  state;
  /* Whether to collect entire PES packets before
   * outputting */
  gboolean           gather_pes;
  /* Whether unbounded packets are allowed in this
   * stream */
  gboolean           allow_unbounded;

  gboolean           first;
  GstPESFilterData   data_cb;
  GstPESFilterResync resync_cb;
  gpointer           user_data;

  guint32            start_code;
  guint8             id;
  gboolean           unbounded_packet;
  guint16            length;

  gint64             pts;
  gint64             dts;
};
</STRUCT>
<FUNCTION>
<NAME>gst_pes_filter_init</NAME>
<RETURNS>void  </RETURNS>
GstPESFilter * filter, GstAdapter * adapter, guint64 * adapter_offset
</FUNCTION>
<FUNCTION>
<NAME>gst_pes_filter_uninit</NAME>
<RETURNS>void  </RETURNS>
GstPESFilter * filter
</FUNCTION>
<FUNCTION>
<NAME>gst_pes_filter_set_callbacks</NAME>
<RETURNS>void  </RETURNS>
GstPESFilter * filter, GstPESFilterData data_cb, GstPESFilterResync resync_cb, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_pes_filter_push</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstPESFilter * filter, GstBuffer * buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_pes_filter_process</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstPESFilter * filter
</FUNCTION>
<FUNCTION>
<NAME>gst_pes_filter_flush</NAME>
<RETURNS>void  </RETURNS>
GstPESFilter * filter
</FUNCTION>
<FUNCTION>
<NAME>gst_pes_filter_drain</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstPESFilter * filter
</FUNCTION>
<FUNCTION>
<NAME>gst_opus_header_is_header</NAME>
<RETURNS>gboolean  </RETURNS>
GstBuffer * buf, const char *magic, guint magic_size
</FUNCTION>
<FUNCTION>
<NAME>gst_opus_header_is_id_header</NAME>
<RETURNS>gboolean  </RETURNS>
GstBuffer * buf
</FUNCTION>
<FUNCTION>
<NAME>gst_opus_header_is_comment_header</NAME>
<RETURNS>gboolean  </RETURNS>
GstBuffer * buf
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OPUS_PARSE</NAME>
#define GST_TYPE_OPUS_PARSE \
  (gst_opus_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPUS_PARSE</NAME>
#define GST_OPUS_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OPUS_PARSE,GstOpusParse))
</MACRO>
<MACRO>
<NAME>GST_OPUS_PARSE_CLASS</NAME>
#define GST_OPUS_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OPUS_PARSE,GstOpusParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OPUS_PARSE</NAME>
#define GST_IS_OPUS_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OPUS_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_OPUS_PARSE_CLASS</NAME>
#define GST_IS_OPUS_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OPUS_PARSE))
</MACRO>
<STRUCT>
<NAME>GstOpusParse</NAME>
struct _GstOpusParse {
  GstBaseParse       element;

  gboolean got_headers, header_sent;
  guint64 pre_skip;
  GstClockTime next_ts;
  GstBuffer *id_header;
  GstBuffer *comment_header;
};
</STRUCT>
<STRUCT>
<NAME>GstOpusParseClass</NAME>
struct _GstOpusParseClass {
  GstBaseParseClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_opus_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DTLS_CONNECTION</NAME>
#define GST_TYPE_DTLS_CONNECTION            (gst_dtls_connection_get_type())
</MACRO>
<MACRO>
<NAME>GST_DTLS_CONNECTION</NAME>
#define GST_DTLS_CONNECTION(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_DTLS_CONNECTION, GstDtlsConnection))
</MACRO>
<MACRO>
<NAME>GST_DTLS_CONNECTION_CLASS</NAME>
#define GST_DTLS_CONNECTION_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_DTLS_CONNECTION, GstDtlsConnectionClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_CONNECTION</NAME>
#define GST_IS_DTLS_CONNECTION(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_DTLS_CONNECTION))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_CONNECTION_CLASS</NAME>
#define GST_IS_DTLS_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_DTLS_CONNECTION))
</MACRO>
<MACRO>
<NAME>GST_DTLS_CONNECTION_GET_CLASS</NAME>
#define GST_DTLS_CONNECTION_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj), GST_TYPE_DTLS_CONNECTION, GstDtlsConnectionClass))
</MACRO>
<ENUM>
<NAME>GstDtlsSrtpCipher</NAME>
typedef enum {
    GST_DTLS_SRTP_CIPHER_AES_128_ICM = 1
} GstDtlsSrtpCipher;
</ENUM>
<ENUM>
<NAME>GstDtlsSrtpAuth</NAME>
typedef enum {
    GST_DTLS_SRTP_AUTH_HMAC_SHA1_32 = 1,
    GST_DTLS_SRTP_AUTH_HMAC_SHA1_80 = 2
} GstDtlsSrtpAuth;
</ENUM>
<MACRO>
<NAME>GST_DTLS_SRTP_MASTER_KEY_LENGTH</NAME>
#define GST_DTLS_SRTP_MASTER_KEY_LENGTH 30
</MACRO>
<STRUCT>
<NAME>GstDtlsConnection</NAME>
struct _GstDtlsConnection {
    GObject parent_instance;

    GstDtlsConnectionPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstDtlsConnectionClass</NAME>
struct _GstDtlsConnectionClass {
    GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dtls_connection_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_connection_start</NAME>
<RETURNS>void  </RETURNS>
GstDtlsConnection *, gboolean is_client
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_connection_check_timeout</NAME>
<RETURNS>void  </RETURNS>
GstDtlsConnection *
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_connection_stop</NAME>
<RETURNS>void  </RETURNS>
GstDtlsConnection *
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_connection_close</NAME>
<RETURNS>void  </RETURNS>
GstDtlsConnection *
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_connection_set_send_callback</NAME>
<RETURNS>void  </RETURNS>
GstDtlsConnection *, GClosure *
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_connection_process</NAME>
<RETURNS>gint  </RETURNS>
GstDtlsConnection *, gpointer ptr, gint len
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_connection_send</NAME>
<RETURNS>gint  </RETURNS>
GstDtlsConnection *, gpointer ptr, gint len
</FUNCTION>
<STRUCT>
<NAME>GstDtlsConnectionPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_DTLS_ENC</NAME>
#define GST_TYPE_DTLS_ENC (gst_dtls_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_DTLS_ENC</NAME>
#define GST_DTLS_ENC(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_DTLS_ENC, GstDtlsEnc))
</MACRO>
<MACRO>
<NAME>GST_DTLS_ENC_CLASS</NAME>
#define GST_DTLS_ENC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_DTLS_ENC, GstDtlsEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_ENC</NAME>
#define GST_IS_DTLS_ENC(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_DTLS_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_ENC_CLASS</NAME>
#define GST_IS_DTLS_ENC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_DTLS_ENC))
</MACRO>
<STRUCT>
<NAME>GstDtlsEnc</NAME>
struct _GstDtlsEnc {
    GstElement element;

    GstPad *src;

    GQueue queue;
    GMutex queue_lock;
    GCond queue_cond_add;
    gboolean flushing;

    GstDtlsConnection *connection;
    gchar *connection_id;

    gboolean is_client;

    GstBuffer *encoder_key;
    guint srtp_cipher;
    guint srtp_auth;

    gboolean send_initial_events;
};
</STRUCT>
<STRUCT>
<NAME>GstDtlsEncClass</NAME>
struct _GstDtlsEncClass {
    GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dtls_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_enc_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DTLS_SRTP_BIN</NAME>
#define GST_TYPE_DTLS_SRTP_BIN (gst_dtls_srtp_bin_get_type())
</MACRO>
<MACRO>
<NAME>GST_DTLS_SRTP_BIN</NAME>
#define GST_DTLS_SRTP_BIN(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_DTLS_SRTP_BIN, GstDtlsSrtpBin))
</MACRO>
<MACRO>
<NAME>GST_DTLS_SRTP_BIN_CLASS</NAME>
#define GST_DTLS_SRTP_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_DTLS_SRTP_BIN, GstDtlsSrtpBinClass))
</MACRO>
<MACRO>
<NAME>GST_DTLS_SRTP_BIN_GET_CLASS</NAME>
#define GST_DTLS_SRTP_BIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS((obj), GST_TYPE_DTLS_SRTP_BIN, GstDtlsSrtpBinClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_SRTP_BIN</NAME>
#define GST_IS_DTLS_SRTP_BIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_DTLS_SRTP_BIN))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_SRTP_BIN_CLASS</NAME>
#define GST_IS_DTLS_SRTP_BIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_DTLS_SRTP_BIN))
</MACRO>
<STRUCT>
<NAME>GstDtlsSrtpBin</NAME>
struct _GstDtlsSrtpBin {
    GstBin bin;

    GstElement *dtls_element;

    gboolean key_is_set;
    GstBuffer *key;
    gchar *srtp_cipher;
    gchar *srtp_auth;
    gchar *srtcp_cipher;
    gchar *srtcp_auth;
};
</STRUCT>
<STRUCT>
<NAME>GstDtlsSrtpBinClass</NAME>
struct _GstDtlsSrtpBinClass {
    GstBinClass parent_class;

    void (*remove_dtls_element)(GstDtlsSrtpBin *);
};
</STRUCT>
<FUNCTION>
<NAME>gst_dtls_srtp_bin_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DTLS_CERTIFICATE</NAME>
#define GST_TYPE_DTLS_CERTIFICATE            (gst_dtls_certificate_get_type())
</MACRO>
<MACRO>
<NAME>GST_DTLS_CERTIFICATE</NAME>
#define GST_DTLS_CERTIFICATE(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_DTLS_CERTIFICATE, GstDtlsCertificate))
</MACRO>
<MACRO>
<NAME>GST_DTLS_CERTIFICATE_CLASS</NAME>
#define GST_DTLS_CERTIFICATE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_DTLS_CERTIFICATE, GstDtlsCertificateClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_CERTIFICATE</NAME>
#define GST_IS_DTLS_CERTIFICATE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_DTLS_CERTIFICATE))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_CERTIFICATE_CLASS</NAME>
#define GST_IS_DTLS_CERTIFICATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_DTLS_CERTIFICATE))
</MACRO>
<MACRO>
<NAME>GST_DTLS_CERTIFICATE_GET_CLASS</NAME>
#define GST_DTLS_CERTIFICATE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj), GST_TYPE_DTLS_CERTIFICATE, GstDtlsCertificateClass))
</MACRO>
<TYPEDEF>
<NAME>GstDtlsCertificateInternalCertificate</NAME>
typedef gpointer GstDtlsCertificateInternalCertificate;
</TYPEDEF>
<TYPEDEF>
<NAME>GstDtlsCertificateInternalKey</NAME>
typedef gpointer GstDtlsCertificateInternalKey;
</TYPEDEF>
<STRUCT>
<NAME>GstDtlsCertificate</NAME>
struct _GstDtlsCertificate {
    GObject parent_instance;

    GstDtlsCertificatePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstDtlsCertificateClass</NAME>
struct _GstDtlsCertificateClass {
    GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dtls_certificate_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstDtlsCertificatePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_DTLS_DEC</NAME>
#define GST_TYPE_DTLS_DEC \
    (gst_dtls_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_DTLS_DEC</NAME>
#define GST_DTLS_DEC(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_DTLS_DEC, GstDtlsDec))
</MACRO>
<MACRO>
<NAME>GST_DTLS_DEC_CLASS</NAME>
#define GST_DTLS_DEC_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_DTLS_DEC, GstDtlsDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_DEC</NAME>
#define GST_IS_DTLS_DEC(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_DTLS_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_DEC_CLASS</NAME>
#define GST_IS_DTLS_DEC_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_DTLS_DEC))
</MACRO>
<STRUCT>
<NAME>GstDtlsDec</NAME>
struct _GstDtlsDec {
    GstElement element;

    GstPad *src;
    GstPad *sink;
    GMutex src_mutex;

    GstDtlsAgent *agent;
    GstDtlsConnection *connection;
    GMutex connection_mutex;
    gchar *connection_id;
    gchar *peer_pem;

    GstBuffer *decoder_key;
    guint srtp_cipher;
    guint srtp_auth;
};
</STRUCT>
<STRUCT>
<NAME>GstDtlsDecClass</NAME>
struct _GstDtlsDecClass {
    GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dtls_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_dec_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_dec_fetch_connection</NAME>
<RETURNS>GstDtlsConnection  *</RETURNS>
gchar *id
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DTLS_SRTP_DEC</NAME>
#define GST_TYPE_DTLS_SRTP_DEC (gst_dtls_srtp_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_DTLS_SRTP_DEC</NAME>
#define GST_DTLS_SRTP_DEC(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_DTLS_SRTP_DEC, GstDtlsSrtpDec))
</MACRO>
<MACRO>
<NAME>GST_DTLS_SRTP_DEC_CLASS</NAME>
#define GST_DTLS_SRTP_DEC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_DTLS_SRTP_DEC, GstDtlsSrtpDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_SRTP_DEC</NAME>
#define GST_IS_DTLS_SRTP_DEC(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_DTLS_SRTP_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_SRTP_DEC_CLASS</NAME>
#define GST_IS_DTLS_SRTP_DEC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_DTLS_SRTP_DEC))
</MACRO>
<STRUCT>
<NAME>GstDtlsSrtpDec</NAME>
struct _GstDtlsSrtpDec {
    GstDtlsSrtpBin bin;

    GstElement *dtls_srtp_demux;
    GstElement *srtp_dec;
};
</STRUCT>
<STRUCT>
<NAME>GstDtlsSrtpDecClass</NAME>
struct _GstDtlsSrtpDecClass {
    GstDtlsSrtpBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dtls_srtp_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_srtp_dec_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DTLS_SRTP_DEMUX</NAME>
#define GST_TYPE_DTLS_SRTP_DEMUX \
    (gst_dtls_srtp_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_DTLS_SRTP_DEMUX</NAME>
#define GST_DTLS_SRTP_DEMUX(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_DTLS_SRTP_DEMUX, GstDtlsSrtpDemux))
</MACRO>
<MACRO>
<NAME>GST_DTLS_SRTP_DEMUX_CLASS</NAME>
#define GST_DTLS_SRTP_DEMUX_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_DTLS_SRTP_DEMUX, GstDtlsSrtpDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_SRTP_DEMUX</NAME>
#define GST_IS_DTLS_SRTP_DEMUX(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_DTLS_SRTP_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_SRTP_DEMUX_CLASS</NAME>
#define GST_IS_DTLS_SRTP_DEMUX_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_DTLS_SRTP_DEMUX))
</MACRO>
<STRUCT>
<NAME>GstDtlsSrtpDemux</NAME>
struct _GstDtlsSrtpDemux {
    GstElement element;

    GstPad *rtp_src;
    GstPad *dtls_src;
};
</STRUCT>
<STRUCT>
<NAME>GstDtlsSrtpDemuxClass</NAME>
struct _GstDtlsSrtpDemuxClass {
    GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dtls_srtp_demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_srtp_demux_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DTLS_SRTP_ENC</NAME>
#define GST_TYPE_DTLS_SRTP_ENC (gst_dtls_srtp_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_DTLS_SRTP_ENC</NAME>
#define GST_DTLS_SRTP_ENC(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_DTLS_SRTP_ENC, GstDtlsSrtpEnc))
</MACRO>
<MACRO>
<NAME>GST_DTLS_SRTP_ENC_CLASS</NAME>
#define GST_DTLS_SRTP_ENC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_DTLS_SRTP_ENC, GstDtlsSrtpEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_SRTP_ENC</NAME>
#define GST_IS_DTLS_SRTP_ENC(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_DTLS_SRTP_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_SRTP_ENC_CLASS</NAME>
#define GST_IS_DTLS_SRTP_ENC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_DTLS_SRTP_ENC))
</MACRO>
<STRUCT>
<NAME>GstDtlsSrtpEnc</NAME>
struct _GstDtlsSrtpEnc {
    GstDtlsSrtpBin bin;

    GstElement *srtp_enc;
    GstElement *funnel;
};
</STRUCT>
<STRUCT>
<NAME>GstDtlsSrtpEncClass</NAME>
struct _GstDtlsSrtpEncClass {
    GstDtlsSrtpBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dtls_srtp_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_srtp_enc_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_srtp_enc_get_cipher_value_by_nick</NAME>
<RETURNS>guint  </RETURNS>
const gchar *cipher_nick
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_srtp_enc_get_auth_value_by_nick</NAME>
<RETURNS>guint  </RETURNS>
const gchar *auth_nick
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DTLS_AGENT</NAME>
#define GST_TYPE_DTLS_AGENT            (gst_dtls_agent_get_type())
</MACRO>
<MACRO>
<NAME>GST_DTLS_AGENT</NAME>
#define GST_DTLS_AGENT(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_DTLS_AGENT, GstDtlsAgent))
</MACRO>
<MACRO>
<NAME>GST_DTLS_AGENT_CLASS</NAME>
#define GST_DTLS_AGENT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_DTLS_AGENT, GstDtlsAgentClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_AGENT</NAME>
#define GST_IS_DTLS_AGENT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_DTLS_AGENT))
</MACRO>
<MACRO>
<NAME>GST_IS_DTLS_AGENT_CLASS</NAME>
#define GST_IS_DTLS_AGENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_DTLS_AGENT))
</MACRO>
<MACRO>
<NAME>GST_DTLS_AGENT_GET_CLASS</NAME>
#define GST_DTLS_AGENT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj), GST_TYPE_DTLS_AGENT, GstDtlsAgentClass))
</MACRO>
<TYPEDEF>
<NAME>GstDtlsAgentContext</NAME>
typedef gpointer GstDtlsAgentContext;
</TYPEDEF>
<STRUCT>
<NAME>GstDtlsAgent</NAME>
struct _GstDtlsAgent {
    GObject parent_instance;

    GstDtlsAgentPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstDtlsAgentClass</NAME>
struct _GstDtlsAgentClass {
    GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dtls_agent_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_agent_get_certificate</NAME>
<RETURNS>GstDtlsCertificate  *</RETURNS>
GstDtlsAgent *
</FUNCTION>
<FUNCTION>
<NAME>gst_dtls_agent_get_certificate_pem</NAME>
<RETURNS>gchar  *</RETURNS>
GstDtlsAgent *self
</FUNCTION>
<STRUCT>
<NAME>GstDtlsAgentPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_OPENEXR_DEC</NAME>
#define GST_TYPE_OPENEXR_DEC \
  (gst_openexr_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPENEXR_DEC</NAME>
#define GST_OPENEXR_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OPENEXR_DEC,GstOpenEXRDec))
</MACRO>
<MACRO>
<NAME>GST_OPENEXR_DEC_CLASS</NAME>
#define GST_OPENEXR_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OPENEXR_DEC,GstOpenEXRDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENEXR_DEC</NAME>
#define GST_IS_OPENEXR_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OPENEXR_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENEXR_DEC_CLASS</NAME>
#define GST_IS_OPENEXR_DEC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OPENEXR_DEC))
</MACRO>
<STRUCT>
<NAME>GstOpenEXRDec</NAME>
struct _GstOpenEXRDec
{
  GstVideoDecoder parent;

  /* < private > */
  GstVideoCodecState *input_state;
  GstVideoCodecState *output_state;
};
</STRUCT>
<STRUCT>
<NAME>GstOpenEXRDecClass</NAME>
struct _GstOpenEXRDecClass
{
  GstVideoDecoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_openexr_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ttml_parse</NAME>
<RETURNS>GList  *</RETURNS>
const gchar * file, GstClockTime begin, GstClockTime duration
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TTML_PARSE</NAME>
#define GST_TYPE_TTML_PARSE \
  (gst_ttml_parse_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TTML_PARSE</NAME>
#define GST_TTML_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_TTML_PARSE, GstTtmlParse))
</MACRO>
<MACRO>
<NAME>GST_TTML_PARSE_CLASS</NAME>
#define GST_TTML_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_TTML_PARSE, GstTtmlParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TTML_PARSE</NAME>
#define GST_IS_TTML_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_TTML_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_TTML_PARSE_CLASS</NAME>
#define GST_IS_TTML_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_TTML_PARSE))
</MACRO>
<STRUCT>
<NAME>GstTtmlParse</NAME>
struct _GstTtmlParse {
  GstElement element;

  GstPad *sinkpad, *srcpad;

  /* contains the input in the input encoding */
  GstAdapter *adapter;
  /* contains the UTF-8 decoded input */
  GString *textbuf;

  /* seek */
  guint64 offset;

  /* Segment */
  GstSegment    segment;
  gboolean      need_segment;

  gboolean valid_utf8;
  gchar   *detected_encoding;
  gchar   *encoding;

  gboolean first_buffer;
};
</STRUCT>
<STRUCT>
<NAME>GstTtmlParseClass</NAME>
struct _GstTtmlParseClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ttml_parse_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TTML_RENDER</NAME>
#define GST_TYPE_TTML_RENDER            (gst_ttml_render_get_type())
</MACRO>
<MACRO>
<NAME>GST_TTML_RENDER</NAME>
#define GST_TTML_RENDER(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),\
                                         GST_TYPE_TTML_RENDER, GstTtmlRender))
</MACRO>
<MACRO>
<NAME>GST_TTML_RENDER_CLASS</NAME>
#define GST_TTML_RENDER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),\
                                         GST_TYPE_TTML_RENDER, \
                                         GstTtmlRenderClass))
</MACRO>
<MACRO>
<NAME>GST_TTML_RENDER_GET_CLASS</NAME>
#define GST_TTML_RENDER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),\
                                         GST_TYPE_TTML_RENDER, \
                                         GstTtmlRenderClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TTML_RENDER</NAME>
#define GST_IS_TTML_RENDER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),\
                                         GST_TYPE_TTML_RENDER))
</MACRO>
<MACRO>
<NAME>GST_IS_TTML_RENDER_CLASS</NAME>
#define GST_IS_TTML_RENDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),\
                                         GST_TYPE_TTML_RENDER))
</MACRO>
<STRUCT>
<NAME>GstTtmlRenderRenderedImage</NAME>
struct _GstTtmlRenderRenderedImage {
  GstBuffer *image;
  gint x;
  gint y;
  guint width;
  guint height;
};
</STRUCT>
<STRUCT>
<NAME>GstTtmlRender</NAME>
struct _GstTtmlRender {
    GstElement               element;

    GstPad                  *video_sinkpad;
    GstPad                  *text_sinkpad;
    GstPad                  *srcpad;

    GstSegment               segment;
    GstSegment               text_segment;
    GstBuffer               *text_buffer;
    gboolean                text_linked;
    gboolean                video_flushing;
    gboolean                video_eos;
    gboolean                text_flushing;
    gboolean                text_eos;

    GMutex                   lock;
    GCond                    cond;  /* to signal removal of a queued text
                                     * buffer, arrival of a text buffer,
                                     * a text segment update, or a change
                                     * in status (e.g. shutdown, flushing) */

    GstVideoInfo             info;
    GstVideoFormat           format;
    gint                     width;
    gint                     height;

    gboolean                 want_background;
    gboolean                 wait_text;

    gboolean                 need_render;

    PangoLayout             *layout;
    GList * compositions;
};
</STRUCT>
<STRUCT>
<NAME>GstTtmlRenderClass</NAME>
struct _GstTtmlRenderClass {
    GstElementClass parent_class;

    PangoContext *pango_context;
    GMutex       *pango_lock;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ttml_render_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstSubtitleMeta</NAME>
struct _GstSubtitleMeta {
  GstMeta meta;

  GPtrArray *regions;
};
</STRUCT>
<FUNCTION>
<NAME>gst_subtitle_meta_api_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_SUBTITLE_META_API_TYPE</NAME>
#define GST_SUBTITLE_META_API_TYPE (gst_subtitle_meta_api_get_type())
</MACRO>
<MACRO>
<NAME>gst_buffer_get_subtitle_meta</NAME>
#define gst_buffer_get_subtitle_meta(b) \
    ((GstSubtitleMeta*)gst_buffer_get_meta ((b), GST_SUBTITLE_META_API_TYPE))
</MACRO>
<MACRO>
<NAME>GST_SUBTITLE_META_INFO</NAME>
#define GST_SUBTITLE_META_INFO (gst_subtitle_meta_get_info())
</MACRO>
<FUNCTION>
<NAME>gst_subtitle_meta_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstMeta * meta, gpointer params, GstBuffer * buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_meta_free</NAME>
<RETURNS>void  </RETURNS>
GstMeta * meta, GstBuffer * buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_meta_get_info</NAME>
<RETURNS>const GstMetaInfo  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_add_subtitle_meta</NAME>
<RETURNS>GstSubtitleMeta  * </RETURNS>
GstBuffer * buffer, GPtrArray * regions
</FUNCTION>
<ENUM>
<NAME>GstSubtitleWritingMode</NAME>
typedef enum {
    GST_SUBTITLE_WRITING_MODE_LRTB,
    GST_SUBTITLE_WRITING_MODE_RLTB,
    GST_SUBTITLE_WRITING_MODE_TBRL,
    GST_SUBTITLE_WRITING_MODE_TBLR
} GstSubtitleWritingMode;
</ENUM>
<ENUM>
<NAME>GstSubtitleDisplayAlign</NAME>
typedef enum {
    GST_SUBTITLE_DISPLAY_ALIGN_BEFORE,
    GST_SUBTITLE_DISPLAY_ALIGN_CENTER,
    GST_SUBTITLE_DISPLAY_ALIGN_AFTER
} GstSubtitleDisplayAlign;
</ENUM>
<ENUM>
<NAME>GstSubtitleBackgroundMode</NAME>
typedef enum {
    GST_SUBTITLE_BACKGROUND_MODE_ALWAYS,
    GST_SUBTITLE_BACKGROUND_MODE_WHEN_ACTIVE
} GstSubtitleBackgroundMode;
</ENUM>
<ENUM>
<NAME>GstSubtitleOverflowMode</NAME>
typedef enum {
    GST_SUBTITLE_OVERFLOW_MODE_HIDDEN,
    GST_SUBTITLE_OVERFLOW_MODE_VISIBLE
} GstSubtitleOverflowMode;
</ENUM>
<STRUCT>
<NAME>GstSubtitleColor</NAME>
struct _GstSubtitleColor {
  guint8 r;
  guint8 g;
  guint8 b;
  guint8 a;
};
</STRUCT>
<ENUM>
<NAME>GstSubtitleTextDirection</NAME>
typedef enum {
  GST_SUBTITLE_TEXT_DIRECTION_LTR,
  GST_SUBTITLE_TEXT_DIRECTION_RTL
} GstSubtitleTextDirection;
</ENUM>
<ENUM>
<NAME>GstSubtitleTextAlign</NAME>
typedef enum {
  GST_SUBTITLE_TEXT_ALIGN_START,
  GST_SUBTITLE_TEXT_ALIGN_LEFT,
  GST_SUBTITLE_TEXT_ALIGN_CENTER,
  GST_SUBTITLE_TEXT_ALIGN_RIGHT,
  GST_SUBTITLE_TEXT_ALIGN_END
} GstSubtitleTextAlign;
</ENUM>
<ENUM>
<NAME>GstSubtitleFontStyle</NAME>
typedef enum {
  GST_SUBTITLE_FONT_STYLE_NORMAL,
  GST_SUBTITLE_FONT_STYLE_ITALIC
} GstSubtitleFontStyle;
</ENUM>
<ENUM>
<NAME>GstSubtitleFontWeight</NAME>
typedef enum {
  GST_SUBTITLE_FONT_WEIGHT_NORMAL,
  GST_SUBTITLE_FONT_WEIGHT_BOLD
} GstSubtitleFontWeight;
</ENUM>
<ENUM>
<NAME>GstSubtitleTextDecoration</NAME>
typedef enum {
  GST_SUBTITLE_TEXT_DECORATION_NONE,
  GST_SUBTITLE_TEXT_DECORATION_UNDERLINE
} GstSubtitleTextDecoration;
</ENUM>
<ENUM>
<NAME>GstSubtitleUnicodeBidi</NAME>
typedef enum {
  GST_SUBTITLE_UNICODE_BIDI_NORMAL,
  GST_SUBTITLE_UNICODE_BIDI_EMBED,
  GST_SUBTITLE_UNICODE_BIDI_OVERRIDE
} GstSubtitleUnicodeBidi;
</ENUM>
<ENUM>
<NAME>GstSubtitleWrapping</NAME>
typedef enum {
  GST_SUBTITLE_WRAPPING_ON,
  GST_SUBTITLE_WRAPPING_OFF
} GstSubtitleWrapping;
</ENUM>
<ENUM>
<NAME>GstSubtitleMultiRowAlign</NAME>
typedef enum {
  GST_SUBTITLE_MULTI_ROW_ALIGN_AUTO,
  GST_SUBTITLE_MULTI_ROW_ALIGN_START,
  GST_SUBTITLE_MULTI_ROW_ALIGN_CENTER,
  GST_SUBTITLE_MULTI_ROW_ALIGN_END
} GstSubtitleMultiRowAlign;
</ENUM>
<STRUCT>
<NAME>GstSubtitleStyleSet</NAME>
struct _GstSubtitleStyleSet
{
  GstMiniObject mini_object;

  GstSubtitleTextDirection text_direction;
  gchar *font_family;
  gdouble font_size;
  gdouble line_height;
  GstSubtitleTextAlign text_align;
  GstSubtitleColor color;
  GstSubtitleColor background_color;
  GstSubtitleFontStyle font_style;
  GstSubtitleFontWeight font_weight;
  GstSubtitleTextDecoration text_decoration;
  GstSubtitleUnicodeBidi unicode_bidi;
  GstSubtitleWrapping wrap_option;
  GstSubtitleMultiRowAlign multi_row_align;
  gdouble line_padding;
  gdouble origin_x, origin_y;
  gdouble extent_w, extent_h;
  GstSubtitleDisplayAlign display_align;
  gdouble padding_start, padding_end, padding_before, padding_after;
  GstSubtitleWritingMode writing_mode;
  GstSubtitleBackgroundMode show_background;
  GstSubtitleOverflowMode overflow;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_subtitle_style_set_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_style_set_new</NAME>
<RETURNS>GstSubtitleStyleSet  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_style_set_ref</NAME>
<RETURNS>GstSubtitleStyleSet  *</RETURNS>
GstSubtitleStyleSet * style_set
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_style_set_unref</NAME>
<RETURNS>void </RETURNS>
GstSubtitleStyleSet * style_set
</FUNCTION>
<STRUCT>
<NAME>GstSubtitleElement</NAME>
struct _GstSubtitleElement
{
  GstMiniObject mini_object;

  GstSubtitleStyleSet *style_set;
  guint text_index;
  gboolean suppress_whitespace;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_subtitle_element_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_element_new</NAME>
<RETURNS>GstSubtitleElement  * </RETURNS>
GstSubtitleStyleSet * style_set, guint text_index, gboolean suppress_whitespace
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_element_ref</NAME>
<RETURNS>GstSubtitleElement  *</RETURNS>
GstSubtitleElement * element
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_element_unref</NAME>
<RETURNS>void </RETURNS>
GstSubtitleElement * element
</FUNCTION>
<STRUCT>
<NAME>GstSubtitleBlock</NAME>
struct _GstSubtitleBlock
{
  GstMiniObject mini_object;

  GstSubtitleStyleSet *style_set;

  /*< private >*/
  GPtrArray *elements;
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_subtitle_block_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_block_new</NAME>
<RETURNS>GstSubtitleBlock  * </RETURNS>
GstSubtitleStyleSet * style_set
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_block_add_element</NAME>
<RETURNS>void  </RETURNS>
 GstSubtitleBlock * block, GstSubtitleElement * element
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_block_get_element_count</NAME>
<RETURNS>guint  </RETURNS>
const GstSubtitleBlock * block
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_block_get_element</NAME>
<RETURNS>GstSubtitleElement  * </RETURNS>
 const GstSubtitleBlock * block, guint index
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_block_ref</NAME>
<RETURNS>GstSubtitleBlock  *</RETURNS>
GstSubtitleBlock * block
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_block_unref</NAME>
<RETURNS>void </RETURNS>
GstSubtitleBlock * block
</FUNCTION>
<STRUCT>
<NAME>GstSubtitleRegion</NAME>
struct _GstSubtitleRegion
{
  GstMiniObject mini_object;

  GstSubtitleStyleSet *style_set;

  /*< private >*/
  GPtrArray *blocks;
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_subtitle_region_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_region_new</NAME>
<RETURNS>GstSubtitleRegion  * </RETURNS>
GstSubtitleStyleSet * style_set
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_region_add_block</NAME>
<RETURNS>void  </RETURNS>
 GstSubtitleRegion * region, GstSubtitleBlock * block
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_region_get_block_count</NAME>
<RETURNS>guint  </RETURNS>
const GstSubtitleRegion * region
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_region_get_block</NAME>
<RETURNS>const GstSubtitleBlock  * </RETURNS>
 const GstSubtitleRegion * region, guint index
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_region_ref</NAME>
<RETURNS>GstSubtitleRegion  *</RETURNS>
GstSubtitleRegion * region
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_region_unref</NAME>
<RETURNS>void </RETURNS>
GstSubtitleRegion * region
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OPENJPEG_ENC</NAME>
#define GST_TYPE_OPENJPEG_ENC \
  (gst_openjpeg_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPENJPEG_ENC</NAME>
#define GST_OPENJPEG_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OPENJPEG_ENC,GstOpenJPEGEnc))
</MACRO>
<MACRO>
<NAME>GST_OPENJPEG_ENC_CLASS</NAME>
#define GST_OPENJPEG_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OPENJPEG_ENC,GstOpenJPEGEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENJPEG_ENC</NAME>
#define GST_IS_OPENJPEG_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OPENJPEG_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENJPEG_ENC_CLASS</NAME>
#define GST_IS_OPENJPEG_ENC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OPENJPEG_ENC))
</MACRO>
<STRUCT>
<NAME>GstOpenJPEGEnc</NAME>
struct _GstOpenJPEGEnc
{
  GstVideoEncoder parent;

  /* < private > */
  GstVideoCodecState *input_state;
  GstVideoCodecState *output_state;

  OPJ_CODEC_FORMAT codec_format;
  gboolean is_jp2c;

  void (*fill_image) (opj_image_t * image, GstVideoFrame *frame);

  opj_cparameters_t params;
};
</STRUCT>
<STRUCT>
<NAME>GstOpenJPEGEncClass</NAME>
struct _GstOpenJPEGEncClass
{
  GstVideoEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_openjpeg_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OPENJPEG_DEC</NAME>
#define GST_TYPE_OPENJPEG_DEC \
  (gst_openjpeg_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPENJPEG_DEC</NAME>
#define GST_OPENJPEG_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OPENJPEG_DEC,GstOpenJPEGDec))
</MACRO>
<MACRO>
<NAME>GST_OPENJPEG_DEC_CLASS</NAME>
#define GST_OPENJPEG_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OPENJPEG_DEC,GstOpenJPEGDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENJPEG_DEC</NAME>
#define GST_IS_OPENJPEG_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OPENJPEG_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENJPEG_DEC_CLASS</NAME>
#define GST_IS_OPENJPEG_DEC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OPENJPEG_DEC))
</MACRO>
<STRUCT>
<NAME>GstOpenJPEGDec</NAME>
struct _GstOpenJPEGDec
{
  GstVideoDecoder parent;

  /* < private > */
  GstVideoCodecState *input_state;
  GstVideoCodecState *output_state;

  OPJ_CODEC_FORMAT codec_format;
  gboolean is_jp2c;
  OPJ_COLOR_SPACE color_space;
  GstJPEG2000Sampling sampling;
  gint ncomps;

  void (*fill_frame) (GstVideoFrame *frame, opj_image_t * image);

  opj_dparameters_t params;
};
</STRUCT>
<STRUCT>
<NAME>GstOpenJPEGDecClass</NAME>
struct _GstOpenJPEGDecClass
{
  GstVideoDecoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_openjpeg_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>OPJ_CLRSPC_UNKNOWN</NAME>
#define OPJ_CLRSPC_UNKNOWN CLRSPC_UNKNOWN
</MACRO>
<MACRO>
<NAME>OPJ_CLRSPC_SRGB</NAME>
#define OPJ_CLRSPC_SRGB CLRSPC_SRGB
</MACRO>
<MACRO>
<NAME>OPJ_CLRSPC_GRAY</NAME>
#define OPJ_CLRSPC_GRAY CLRSPC_GRAY
</MACRO>
<MACRO>
<NAME>OPJ_CLRSPC_SYCC</NAME>
#define OPJ_CLRSPC_SYCC CLRSPC_SYCC
</MACRO>
<MACRO>
<NAME>OPJ_CODEC_J2K</NAME>
#define OPJ_CODEC_J2K CODEC_J2K
</MACRO>
<MACRO>
<NAME>OPJ_CODEC_JP2</NAME>
#define OPJ_CODEC_JP2 CODEC_JP2
</MACRO>
<MACRO>
<NAME>OPJ_LRCP</NAME>
#define OPJ_LRCP LRCP
</MACRO>
<MACRO>
<NAME>OPJ_RLCP</NAME>
#define OPJ_RLCP RLCP
</MACRO>
<MACRO>
<NAME>OPJ_RPCL</NAME>
#define OPJ_RPCL RPCL
</MACRO>
<MACRO>
<NAME>OPJ_PCRL</NAME>
#define OPJ_PCRL PCRL
</MACRO>
<MACRO>
<NAME>OPJ_CPRL</NAME>
#define OPJ_CPRL CPRL
</MACRO>
<FUNCTION>
<NAME>gst_musepack_init_reader</NAME>
<RETURNS>void  </RETURNS>
mpc_reader * r, GstMusepackDec * musepackdec
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MUSEPACK_DEC</NAME>
#define GST_TYPE_MUSEPACK_DEC \
  (gst_musepackdec_get_type ())
</MACRO>
<MACRO>
<NAME>GST_MUSEPACK_DEC</NAME>
#define GST_MUSEPACK_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_MUSEPACK_DEC, \
                               GstMusepackDec))
</MACRO>
<MACRO>
<NAME>GST_MUSEPACK_DEC_CLASS</NAME>
#define GST_MUSEPACK_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_MUSEPACK_DEC, \
                            GstMusepackDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MUSEPACK_DEC</NAME>
#define GST_IS_MUSEPACK_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_MUSEPACK_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_MUSEPACK_DEC_CLASS</NAME>
#define GST_IS_MUSEPACK_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_MUSEPACK_DEC))
</MACRO>
<STRUCT>
<NAME>GstMusepackDec</NAME>
typedef struct _GstMusepackDec {
  GstElement    element;

  GstPad       *srcpad;
  GstPad       *sinkpad;
  guint64       offset;

  /* MUSEPACK_DEC object */
#ifdef MPC_IS_OLD_API
  mpc_decoder  *d;
#else
  mpc_demux    *d;
#endif
  mpc_reader   *r;

  gint          bps;     /* bytes per sample */ /* ATOMIC */
  gint          rate;    /* sample rate      */ /* ATOMIC */

  GstSegment    segment; /* configured segment in samples (DEFAULT format) */
} GstMusepackDec;
</STRUCT>
<STRUCT>
<NAME>GstMusepackDecClass</NAME>
typedef struct _GstMusepackDecClass {
  GstElementClass parent_class;
} GstMusepackDecClass;
</STRUCT>
<FUNCTION>
<NAME>gst_musepackdec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OPENH264DEC</NAME>
#define GST_TYPE_OPENH264DEC          (gst_openh264dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPENH264DEC</NAME>
#define GST_OPENH264DEC(obj)          (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OPENH264DEC,GstOpenh264Dec))
</MACRO>
<MACRO>
<NAME>GST_OPENH264DEC_CLASS</NAME>
#define GST_OPENH264DEC_CLASS(klass)  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OPENH264DEC,GstOpenh264DecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENH264DEC</NAME>
#define GST_IS_OPENH264DEC(obj)       (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OPENH264DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENH264DEC_CLASS</NAME>
#define GST_IS_OPENH264DEC_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OPENH264DEC))
</MACRO>
<STRUCT>
<NAME>GstOpenh264Dec</NAME>
struct _GstOpenh264Dec
{
  GstVideoDecoder base_openh264dec;

  /*< private >*/
  ISVCDecoder *decoder;
  GstVideoCodecState *input_state;
  guint width, height;
};
</STRUCT>
<STRUCT>
<NAME>GstOpenh264DecClass</NAME>
struct _GstOpenh264DecClass
{
    GstVideoDecoderClass base_openh264dec_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_openh264dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstOpenh264encDeblockingMode</NAME>
typedef enum _GstOpenh264encDeblockingMode
{
  GST_OPENH264_DEBLOCKING_ON = 0,
  GST_OPENH264_DEBLOCKING_OFF = 1,
  GST_OPENH264_DEBLOCKING_NOT_SLICE_BOUNDARIES = 2
} GstOpenh264encDeblockingMode;
</ENUM>
<ENUM>
<NAME>GstOpenh264EncSliceMode</NAME>
typedef enum
{
  GST_OPENH264_SLICE_MODE_N_SLICES = 1,  /* SM_FIXEDSLCNUM_SLICE */
  GST_OPENH264_SLICE_MODE_AUTO = 5       /* former SM_AUTO_SLICE */
} GstOpenh264EncSliceMode;
</ENUM>
<MACRO>
<NAME>GST_TYPE_OPENH264ENC</NAME>
#define GST_TYPE_OPENH264ENC          (gst_openh264enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPENH264ENC</NAME>
#define GST_OPENH264ENC(obj)          (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OPENH264ENC,GstOpenh264Enc))
</MACRO>
<MACRO>
<NAME>GST_OPENH264ENC_CLASS</NAME>
#define GST_OPENH264ENC_CLASS(klass)  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OPENH264ENC,GstOpenh264EncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENH264ENC</NAME>
#define GST_IS_OPENH264ENC(obj)       (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OPENH264ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENH264ENC_CLASS</NAME>
#define GST_IS_OPENH264ENC_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OPENH264ENC))
</MACRO>
<STRUCT>
<NAME>GstOpenh264Enc</NAME>
struct _GstOpenh264Enc
{
  GstVideoEncoder base_openh264enc;

  /*< private >*/
  ISVCEncoder *encoder;
  EUsageType usage_type;
  guint gop_size;
  RC_MODES rate_control;
  guint max_slice_size;
  guint bitrate;
  guint max_bitrate;
  guint qp_min;
  guint qp_max;
  guint framerate;
  guint multi_thread;
  gboolean enable_denoise;
  gboolean enable_frame_skip;
  GstVideoCodecState *input_state;
  guint64 time_per_frame;
  guint64 frame_count;
  guint64 previous_timestamp;
  GstOpenh264encDeblockingMode deblocking_mode;
  gboolean background_detection;
  gboolean adaptive_quantization;
  gboolean scene_change_detection;
  GstOpenh264EncSliceMode slice_mode;
  guint num_slices;
  ECOMPLEXITY_MODE complexity;
};
</STRUCT>
<STRUCT>
<NAME>GstOpenh264EncClass</NAME>
struct _GstOpenh264EncClass
{
    GstVideoEncoderClass base_openh264enc_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_openh264enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_BZ2DEC</NAME>
#define GST_TYPE_BZ2DEC            (gst_bz2dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_BZ2DEC</NAME>
#define GST_BZ2DEC(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BZ2DEC,GstBz2dec))
</MACRO>
<MACRO>
<NAME>GST_BZ2DEC_CLASS</NAME>
#define GST_BZ2DEC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BZ2DEC,GstBz2decClass))
</MACRO>
<MACRO>
<NAME>GST_IS_BZ2DEC</NAME>
#define GST_IS_BZ2DEC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BZ2DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_BZ2DEC_CLASS</NAME>
#define GST_IS_BZ2DEC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BZ2DEC))
</MACRO>
<FUNCTION>
<NAME>gst_bz2dec_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstBz2dec</NAME>
</STRUCT>
<STRUCT>
<NAME>GstBz2decClass</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_BZ2ENC</NAME>
#define GST_TYPE_BZ2ENC            (gst_bz2enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_BZ2ENC</NAME>
#define GST_BZ2ENC(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BZ2ENC,GstBz2enc))
</MACRO>
<MACRO>
<NAME>GST_BZ2ENC_CLASS</NAME>
#define GST_BZ2ENC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BZ2ENC,GstBz2encClass))
</MACRO>
<MACRO>
<NAME>GST_IS_BZ2ENC</NAME>
#define GST_IS_BZ2ENC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BZ2ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_BZ2ENC_CLASS</NAME>
#define GST_IS_BZ2ENC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BZ2ENC))
</MACRO>
<FUNCTION>
<NAME>gst_bz2enc_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstBz2enc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstBz2encClass</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_WL_WINDOW</NAME>
#define GST_TYPE_WL_WINDOW                  (gst_wl_window_get_type ())
</MACRO>
<MACRO>
<NAME>GST_WL_WINDOW</NAME>
#define GST_WL_WINDOW(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WL_WINDOW, GstWlWindow))
</MACRO>
<MACRO>
<NAME>GST_IS_WL_WINDOW</NAME>
#define GST_IS_WL_WINDOW(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WL_WINDOW))
</MACRO>
<MACRO>
<NAME>GST_WL_WINDOW_CLASS</NAME>
#define GST_WL_WINDOW_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_WL_WINDOW, GstWlWindowClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WL_WINDOW_CLASS</NAME>
#define GST_IS_WL_WINDOW_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_WL_WINDOW))
</MACRO>
<MACRO>
<NAME>GST_WL_WINDOW_GET_CLASS</NAME>
#define GST_WL_WINDOW_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_WL_WINDOW, GstWlWindowClass))
</MACRO>
<STRUCT>
<NAME>GstWlWindow</NAME>
struct _GstWlWindow
{
  GObject parent_instance;

  GMutex *render_lock;

  GstWlDisplay *display;
  struct wl_surface *area_surface;
  struct wl_subsurface *area_subsurface;
  struct wp_viewport *area_viewport;
  struct wl_surface *video_surface;
  struct wl_subsurface *video_subsurface;
  struct wp_viewport *video_viewport;
  struct wl_shell_surface *shell_surface;

  /* the size and position of the area_(sub)surface */
  GstVideoRectangle render_rectangle;

  /* the size and position of the video_subsurface */
  GstVideoRectangle video_rectangle;

  /* the size of the video in the buffers */
  gint video_width, video_height;

  /* this will be set when viewporter is available and black background has
   * already been set on the area_subsurface */
  gboolean no_border_update;

};
</STRUCT>
<STRUCT>
<NAME>GstWlWindowClass</NAME>
struct _GstWlWindowClass
{
  GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wl_window_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_window_new_toplevel</NAME>
<RETURNS>GstWlWindow  *</RETURNS>
GstWlDisplay * display, const GstVideoInfo * info, GMutex * render_lock
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_window_new_in_surface</NAME>
<RETURNS>GstWlWindow  *</RETURNS>
GstWlDisplay * display, struct wl_surface * parent, GMutex * render_lock
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_window_get_display</NAME>
<RETURNS>GstWlDisplay  *</RETURNS>
GstWlWindow * window
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_window_get_wl_surface</NAME>
<RETURNS>struct wl_surface  *</RETURNS>
GstWlWindow * window
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_window_is_toplevel</NAME>
<RETURNS>gboolean  </RETURNS>
GstWlWindow *window
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_window_render</NAME>
<RETURNS>void  </RETURNS>
GstWlWindow * window, GstWlBuffer * buffer, const GstVideoInfo * info
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_window_set_render_rectangle</NAME>
<RETURNS>void  </RETURNS>
GstWlWindow * window, gint x, gint y, gint w, gint h
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WL_SHM_ALLOCATOR</NAME>
#define GST_TYPE_WL_SHM_ALLOCATOR                  (gst_wl_shm_allocator_get_type ())
</MACRO>
<MACRO>
<NAME>GST_WL_SHM_ALLOCATOR</NAME>
#define GST_WL_SHM_ALLOCATOR(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WL_SHM_ALLOCATOR, GstWlShmAllocator))
</MACRO>
<MACRO>
<NAME>GST_IS_WL_SHM_ALLOCATOR</NAME>
#define GST_IS_WL_SHM_ALLOCATOR(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WL_SHM_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_WL_SHM_ALLOCATOR_CLASS</NAME>
#define GST_WL_SHM_ALLOCATOR_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_WL_SHM_ALLOCATOR, GstWlShmAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WL_SHM_ALLOCATOR_CLASS</NAME>
#define GST_IS_WL_SHM_ALLOCATOR_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_WL_SHM_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_WL_SHM_ALLOCATOR_GET_CLASS</NAME>
#define GST_WL_SHM_ALLOCATOR_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_WL_SHM_ALLOCATOR, GstWlShmAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_ALLOCATOR_WL_SHM</NAME>
#define GST_ALLOCATOR_WL_SHM "wl_shm"
</MACRO>
<STRUCT>
<NAME>GstWlShmAllocator</NAME>
struct _GstWlShmAllocator
{
  GstFdAllocator parent_instance;
};
</STRUCT>
<STRUCT>
<NAME>GstWlShmAllocatorClass</NAME>
struct _GstWlShmAllocatorClass
{
  GstFdAllocatorClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wl_shm_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_shm_allocator_register</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_shm_allocator_get</NAME>
<RETURNS>GstAllocator  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_is_wl_shm_memory</NAME>
<RETURNS>gboolean  </RETURNS>
GstMemory * mem
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_shm_memory_construct_wl_buffer</NAME>
<RETURNS>struct wl_buffer  * </RETURNS>
GstMemory * mem, GstWlDisplay * display, const GstVideoInfo * info
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WAYLAND_SINK</NAME>
#define GST_TYPE_WAYLAND_SINK \
	    (gst_wayland_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_WAYLAND_SINK</NAME>
#define GST_WAYLAND_SINK(obj) \
	    (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WAYLAND_SINK,GstWaylandSink))
</MACRO>
<MACRO>
<NAME>GST_WAYLAND_SINK_CLASS</NAME>
#define GST_WAYLAND_SINK_CLASS(klass) \
	    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WAYLAND_SINK,GstWaylandSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WAYLAND_SINK</NAME>
#define GST_IS_WAYLAND_SINK(obj) \
	    (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WAYLAND_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_WAYLAND_SINK_CLASS</NAME>
#define GST_IS_WAYLAND_SINK_CLASS(klass) \
	    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WAYLAND_SINK))
</MACRO>
<MACRO>
<NAME>GST_WAYLAND_SINK_GET_CLASS</NAME>
#define GST_WAYLAND_SINK_GET_CLASS(inst) \
        (G_TYPE_INSTANCE_GET_CLASS ((inst), GST_TYPE_WAYLAND_SINK, GstWaylandSinkClass))
</MACRO>
<STRUCT>
<NAME>GstWaylandSink</NAME>
struct _GstWaylandSink
{
  GstVideoSink parent;

  GMutex display_lock;
  GstWlDisplay *display;
  GstWlWindow *window;
  GstBufferPool *pool;
  gboolean use_dmabuf;

  gboolean video_info_changed;
  GstVideoInfo video_info;

  gchar *display_name;

  gboolean redraw_pending;
  GMutex render_lock;
  GstBuffer *last_buffer;
};
</STRUCT>
<STRUCT>
<NAME>GstWaylandSinkClass</NAME>
struct _GstWaylandSinkClass
{
  GstVideoSinkClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wayland_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_video_format_to_wl_shm_format</NAME>
<RETURNS>enum wl_shm_format  </RETURNS>
GstVideoFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_video_format_to_wl_dmabuf_format</NAME>
<RETURNS>gint  </RETURNS>
GstVideoFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_shm_format_to_video_format</NAME>
<RETURNS>GstVideoFormat  </RETURNS>
enum wl_shm_format wl_format
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_dmabuf_format_to_video_format</NAME>
<RETURNS>GstVideoFormat  </RETURNS>
guint wl_format
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_shm_format_to_string</NAME>
<RETURNS>const gchar  *</RETURNS>
enum wl_shm_format wl_format
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_dmabuf_format_to_string</NAME>
<RETURNS>const gchar  *</RETURNS>
guint wl_format
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WL_BUFFER</NAME>
#define GST_TYPE_WL_BUFFER                  (gst_wl_buffer_get_type ())
</MACRO>
<MACRO>
<NAME>GST_WL_BUFFER</NAME>
#define GST_WL_BUFFER(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WL_BUFFER, GstWlBuffer))
</MACRO>
<MACRO>
<NAME>GST_IS_WL_BUFFER</NAME>
#define GST_IS_WL_BUFFER(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WL_BUFFER))
</MACRO>
<MACRO>
<NAME>GST_WL_BUFFER_CLASS</NAME>
#define GST_WL_BUFFER_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_WL_BUFFER, GstWlBufferClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WL_BUFFER_CLASS</NAME>
#define GST_IS_WL_BUFFER_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_WL_BUFFER))
</MACRO>
<MACRO>
<NAME>GST_WL_BUFFER_GET_CLASS</NAME>
#define GST_WL_BUFFER_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_WL_BUFFER, GstWlBufferClass))
</MACRO>
<STRUCT>
<NAME>GstWlBuffer</NAME>
struct _GstWlBuffer
{
  GObject parent_instance;

  struct wl_buffer * wlbuffer;
  GstBuffer *gstbuffer;

  GstWlDisplay *display;

  gboolean used_by_compositor;
};
</STRUCT>
<STRUCT>
<NAME>GstWlBufferClass</NAME>
struct _GstWlBufferClass
{
  GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wl_buffer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_add_wl_buffer</NAME>
<RETURNS>GstWlBuffer  * </RETURNS>
GstBuffer * gstbuffer, struct wl_buffer * wlbuffer, GstWlDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_get_wl_buffer</NAME>
<RETURNS>GstWlBuffer  * </RETURNS>
GstBuffer * gstbuffer
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_buffer_force_release_and_unref</NAME>
<RETURNS>void  </RETURNS>
GstWlBuffer * self
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_buffer_attach</NAME>
<RETURNS>void  </RETURNS>
GstWlBuffer * self, struct wl_surface *surface
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WL_DISPLAY</NAME>
#define GST_TYPE_WL_DISPLAY                  (gst_wl_display_get_type ())
</MACRO>
<MACRO>
<NAME>GST_WL_DISPLAY</NAME>
#define GST_WL_DISPLAY(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WL_DISPLAY, GstWlDisplay))
</MACRO>
<MACRO>
<NAME>GST_IS_WL_DISPLAY</NAME>
#define GST_IS_WL_DISPLAY(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WL_DISPLAY))
</MACRO>
<MACRO>
<NAME>GST_WL_DISPLAY_CLASS</NAME>
#define GST_WL_DISPLAY_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_WL_DISPLAY, GstWlDisplayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WL_DISPLAY_CLASS</NAME>
#define GST_IS_WL_DISPLAY_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_WL_DISPLAY))
</MACRO>
<MACRO>
<NAME>GST_WL_DISPLAY_GET_CLASS</NAME>
#define GST_WL_DISPLAY_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_WL_DISPLAY, GstWlDisplayClass))
</MACRO>
<STRUCT>
<NAME>GstWlDisplay</NAME>
struct _GstWlDisplay
{
  GObject parent_instance;

  /* public objects */
  struct wl_display *display;
  struct wl_event_queue *queue;

  /* globals */
  struct wl_registry *registry;
  struct wl_compositor *compositor;
  struct wl_subcompositor *subcompositor;
  struct wl_shell *shell;
  struct wl_shm *shm;
  struct wp_viewporter *viewporter;
  struct zwp_linux_dmabuf_v1 *dmabuf;
  GArray *shm_formats;
  GArray *dmabuf_formats;

  /* private */
  gboolean own_display;
  GThread *thread;
  GstPoll *wl_fd_poll;

  GMutex buffers_mutex;
  GHashTable *buffers;
  gboolean shutting_down;
};
</STRUCT>
<STRUCT>
<NAME>GstWlDisplayClass</NAME>
struct _GstWlDisplayClass
{
  GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wl_display_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_display_new</NAME>
<RETURNS>GstWlDisplay  *</RETURNS>
const gchar * name, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_display_new_existing</NAME>
<RETURNS>GstWlDisplay  *</RETURNS>
struct wl_display * display, gboolean take_ownership, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_display_register_buffer</NAME>
<RETURNS>void  </RETURNS>
GstWlDisplay * self, gpointer buf
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_display_unregister_buffer</NAME>
<RETURNS>void  </RETURNS>
GstWlDisplay * self, gpointer buf
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_display_check_format_for_shm</NAME>
<RETURNS>gboolean  </RETURNS>
GstWlDisplay * display, GstVideoFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_wl_display_check_format_for_dmabuf</NAME>
<RETURNS>gboolean  </RETURNS>
GstWlDisplay * display, GstVideoFormat format
</FUNCTION>
<MACRO>
<NAME>GST_CAPS_FEATURE_MEMORY_DMABUF</NAME>
#define GST_CAPS_FEATURE_MEMORY_DMABUF "memory:DMABuf"
</MACRO>
<FUNCTION>
<NAME>gst_wl_linux_dmabuf_construct_wl_buffer</NAME>
<RETURNS>struct wl_buffer  * </RETURNS>
GstBuffer * buf, GstWlDisplay * display, const GstVideoInfo * info
</FUNCTION>
<MACRO>
<NAME>GST_KATE_UINT16_BE</NAME>
#define GST_KATE_UINT16_BE(ptr) ( ( ((guint16)((ptr)[0])) <<8) | ((ptr)[1]) )
</MACRO>
<MACRO>
<NAME>GST_KATE_STM_TO_GST</NAME>
#define GST_KATE_STM_TO_GST(stm) ((GST_MSECOND * 1024 * (stm)) / 90)
</MACRO>
<MACRO>
<NAME>GST_KATE_GST_TO_STM</NAME>
#define GST_KATE_GST_TO_STM(gst) ((int)(((gst) * 90000 ) / 1024))
</MACRO>
<MACRO>
<NAME>GST_KATE_SPU_MIME_TYPE</NAME>
#define GST_KATE_SPU_MIME_TYPE "subpicture/x-dvd"
</MACRO>
<FUNCTION>
<NAME>gst_kate_spu_decode_spu</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstKateEnc * ke, GstBuffer * buf, kate_region * kr, kate_bitmap * kb, kate_palette * kp
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_spu_encode_spu</NAME>
<RETURNS>GstBuffer *</RETURNS>
GstKateDec * kd, const kate_event * ev
</FUNCTION>
<ENUM>
<NAME>GstKateFormat</NAME>
typedef enum {
  GST_KATE_FORMAT_UNDEFINED,
  GST_KATE_FORMAT_SPU,
  GST_KATE_FORMAT_TEXT_UTF8,
  GST_KATE_FORMAT_TEXT_PANGO_MARKUP
} GstKateFormat;
</ENUM>
<USER_FUNCTION>
<NAME>handler</NAME>
<RETURNS>gboolean </RETURNS>
GstPad *, GstObject*, GstEvent *
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_kate_util_set_header_on_caps</NAME>
<RETURNS>GstCaps  *</RETURNS>
GstElement * element, GstCaps * caps, GList * headers
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_util_decode_base_init</NAME>
<RETURNS>void  </RETURNS>
GstKateDecoderBase * decoder, gboolean delay_events
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_util_install_decoder_base_properties</NAME>
<RETURNS>void  </RETURNS>
GObjectClass * gobject_class
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_util_decoder_base_get_property</NAME>
<RETURNS>gboolean  </RETURNS>
GstKateDecoderBase * decoder, GObject * object, guint prop_id, GValue * value, GParamSpec * pspec
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_util_decoder_base_chain_kate_packet</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstKateDecoderBase * decoder, GstElement * element, GstPad * pad, GstBuffer * buffer, GstPad * srcpad, GstPad * tagpad, GstCaps **src_caps, const kate_event ** ev
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_util_decoder_base_set_flushing</NAME>
<RETURNS>void </RETURNS>
GstKateDecoderBase * decoder, gboolean flushing
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_util_decoder_base_segment_event</NAME>
<RETURNS>void </RETURNS>
GstKateDecoderBase * decoder, GstEvent * event
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_util_decoder_base_update_segment</NAME>
<RETURNS>gboolean </RETURNS>
GstKateDecoderBase * decoder, GstElement * element, GstBuffer * buf
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_decoder_base_change_state</NAME>
<RETURNS>GstStateChangeReturn </RETURNS>
GstKateDecoderBase * decoder, GstElement * element, GstElementClass * parent_class, GstStateChange transition
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_decoder_base_convert</NAME>
<RETURNS>gboolean  </RETURNS>
GstKateDecoderBase * decoder, GstElement * element, GstPad * pad, GstFormat src_fmt, gint64 src_val, GstFormat * dest_fmt, gint64 * dest_val
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_decoder_base_sink_query</NAME>
<RETURNS>gboolean  </RETURNS>
GstKateDecoderBase * decoder, GstElement * element, GstPad * pad, GstObject * parent, GstQuery * query
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_util_decoder_base_queue_event</NAME>
<RETURNS>gboolean </RETURNS>
GstKateDecoderBase * decoder, GstEvent * event, gboolean (*handler)(GstPad *, GstObject *, GstEvent *), GstObject * parent, GstPad * pad
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_util_decoder_base_add_tags</NAME>
<RETURNS>void </RETURNS>
GstKateDecoderBase * decoder, GstTagList * tags, gboolean take_ownership_of_tags
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_util_decoder_base_get_tag_event</NAME>
<RETURNS>GstEvent  *</RETURNS>
GstKateDecoderBase * decoder
</FUNCTION>
<FUNCTION>
<NAME>gst_kate_util_get_error_message</NAME>
<RETURNS>const char  *</RETURNS>
int ret
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GME_DEC</NAME>
#define GST_TYPE_GME_DEC \
  (gst_gme_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_GME_DEC</NAME>
#define GST_GME_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GME_DEC,GstGmeDec))
</MACRO>
<MACRO>
<NAME>GST_GME_DEC_CLASS</NAME>
#define GST_GME_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GME_DEC,GstGmeDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GME_DEC</NAME>
#define GST_IS_GME_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GME_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_GME_DEC_CLASS</NAME>
#define GST_IS_GME_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GME_DEC))
</MACRO>
<STRUCT>
<NAME>GstGmeDec</NAME>
struct _GstGmeDec
{
  GstElement  element;

  GstPad     *sinkpad;
  GstPad     *srcpad;

  GstAdapter *adapter;
  Music_Emu  *player;
  gboolean    initialized;
  gboolean    seeking;
  int         seekpoint;

  GstClockTime total_duration;
};
</STRUCT>
<STRUCT>
<NAME>GstGmeDecClass</NAME>
struct _GstGmeDecClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gme_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SRTP_ENC</NAME>
#define GST_TYPE_SRTP_ENC \
  (gst_srtp_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_SRTP_ENC</NAME>
#define GST_SRTP_ENC(obj)                                              \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SRTP_ENC,GstSrtpEnc))
</MACRO>
<MACRO>
<NAME>GST_SRTP_ENC_CLASS</NAME>
#define GST_SRTP_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SRTP_ENC,GstSrtpEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SRTP_ENC</NAME>
#define GST_IS_SRTP_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SRTP_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_SRTP_ENC_CLASS</NAME>
#define GST_IS_SRTP_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SRTP_ENC))
</MACRO>
<STRUCT>
<NAME>GstSrtpEnc</NAME>
struct _GstSrtpEnc
{
  GstElement element;

  gboolean random_key;

  GstBuffer *key;
  guint rtp_cipher;
  guint rtp_auth;
  guint rtcp_cipher;
  guint rtcp_auth;

  srtp_t session;
  gboolean first_session;
  gboolean key_changed;

  guint replay_window_size;
  gboolean allow_repeat_tx;
};
</STRUCT>
<STRUCT>
<NAME>GstSrtpEncClass</NAME>
struct _GstSrtpEncClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_srtp_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_srtp_enc_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<ENUM>
<NAME>GstSrtpCipherType</NAME>
typedef enum
{
  GST_SRTP_CIPHER_NULL,
  GST_SRTP_CIPHER_AES_128_ICM,
  GST_SRTP_CIPHER_AES_256_ICM
} GstSrtpCipherType;
</ENUM>
<ENUM>
<NAME>GstSrtpAuthType</NAME>
typedef enum
{
  GST_SRTP_AUTH_NULL,
  GST_SRTP_AUTH_HMAC_SHA1_32,
  GST_SRTP_AUTH_HMAC_SHA1_80
} GstSrtpAuthType;
</ENUM>
<FUNCTION>
<NAME>gst_srtp_init_event_reporter</NAME>
<RETURNS>void      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_srtp_get_soft_limit_reached</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rtcp_buffer_get_ssrc</NAME>
<RETURNS>gboolean  </RETURNS>
GstBuffer * buf, guint32 * ssrc
</FUNCTION>
<FUNCTION>
<NAME>enum_nick_from_value</NAME>
<RETURNS>const gchar  *</RETURNS>
GType enum_gtype, gint value
</FUNCTION>
<FUNCTION>
<NAME>enum_value_from_nick</NAME>
<RETURNS>gint  </RETURNS>
GType enum_gtype, const gchar *nick
</FUNCTION>
<FUNCTION>
<NAME>set_crypto_policy_cipher_auth</NAME>
<RETURNS>void  </RETURNS>
GstSrtpCipherType cipher, GstSrtpAuthType auth, crypto_policy_t * policy
</FUNCTION>
<FUNCTION>
<NAME>cipher_key_size</NAME>
<RETURNS>guint  </RETURNS>
GstSrtpCipherType cipher
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SRTP_DEC</NAME>
#define GST_TYPE_SRTP_DEC \
  (gst_srtp_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_SRTP_DEC</NAME>
#define GST_SRTP_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SRTP_DEC,GstSrtpDec))
</MACRO>
<MACRO>
<NAME>GST_SRTP_DEC_CLASS</NAME>
#define GST_SRTP_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SRTP_DEC,GstSrtpDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SRTP_DEC</NAME>
#define GST_IS_SRTP_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SRTP_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_SRTP_DEC_CLASS</NAME>
#define GST_IS_SRTP_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SRTP_DEC))
</MACRO>
<STRUCT>
<NAME>GstSrtpDec</NAME>
struct _GstSrtpDec
{
  GstElement element;

  guint replay_window_size;

  GstPad *rtp_sinkpad, *rtp_srcpad;
  GstPad *rtcp_sinkpad, *rtcp_srcpad;

  gboolean ask_update;
  srtp_t session;
  gboolean first_session;
  GHashTable *streams;

  gboolean rtp_has_segment;
  gboolean rtcp_has_segment;

  gboolean roc_changed;
};
</STRUCT>
<STRUCT>
<NAME>GstSrtpDecClass</NAME>
struct _GstSrtpDecClass
{
  GstElementClass parent_class;

  void (*clear_streams) (GstSrtpDec * filter);
  void (*remove_stream) (GstSrtpDec * filter, guint ssrc);
};
</STRUCT>
<FUNCTION>
<NAME>gst_srtp_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_srtp_dec_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<STRUCT>
<NAME>GstSrtpDecSsrcStream</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_WEBP_DEC</NAME>
#define GST_TYPE_WEBP_DEC \
  (gst_webp_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_WEBP_DEC</NAME>
#define GST_WEBP_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WEBP_DEC,GstWebPDec))
</MACRO>
<MACRO>
<NAME>GST_WEBP_DEC_CLASS</NAME>
#define GST_WEBP_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WEBP_DEC,GstWebPDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WEBP_DEC</NAME>
#define GST_IS_WEBP_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WEBP_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_WEBP_DEC_CLASS</NAME>
#define GST_IS_WEBP_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WEBP_DEC))
</MACRO>
<STRUCT>
<NAME>GstWebPDec</NAME>
struct _GstWebPDec {
  GstVideoDecoder decoder;

  GstVideoCodecState *input_state;
  GstVideoCodecState *output_state;

  gboolean saw_header;
  guint frame_size;

  /* properties */
  gboolean bypass_filtering;
  gboolean no_fancy_upsampling;
  gboolean use_threads;

  WEBP_CSP_MODE colorspace;
  WebPDecoderConfig config;
};
</STRUCT>
<STRUCT>
<NAME>GstWebPDecClass</NAME>
struct _GstWebPDecClass {
  GstVideoDecoderClass decoder_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_webp_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_webp_dec_register</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WEBP_ENC</NAME>
#define GST_TYPE_WEBP_ENC \
  (gst_webp_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_WEBP_ENC</NAME>
#define GST_WEBP_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WEBP_ENC,GstWebpEnc))
</MACRO>
<MACRO>
<NAME>GST_WEBP_ENC_CLASS</NAME>
#define GST_WEBP_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WEBP_ENC,GstWebpEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WEBP_ENC</NAME>
#define GST_IS_WEBP_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WEBP_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_WEBP_ENC_CLASS</NAME>
#define GST_IS_WEBP_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WEBP_ENC))
</MACRO>
<STRUCT>
<NAME>GstWebpEnc</NAME>
struct _GstWebpEnc
{
  GstVideoEncoder element;

  GstVideoCodecState *input_state;

  gboolean lossless;
  gfloat quality;
  guint speed;
  gint preset;

  gboolean use_argb;
  GstVideoFormat rgb_format;

  WebPEncCSP webp_color_space;
  struct WebPConfig webp_config;
  struct WebPPicture webp_picture;
  WebPMemoryWriter webp_writer;
};
</STRUCT>
<STRUCT>
<NAME>GstWebpEncClass</NAME>
struct _GstWebpEncClass
{
  GstVideoEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_webp_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_webp_enc_register</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CURL_SSH_SINK</NAME>
#define GST_TYPE_CURL_SSH_SINK \
  (gst_curl_ssh_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_CURL_SSH_SINK</NAME>
#define GST_CURL_SSH_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CURL_SSH_SINK,GstCurlSshSink))
</MACRO>
<MACRO>
<NAME>GST_CURL_SSH_SINK_CLASS</NAME>
#define GST_CURL_SSH_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CURL_SSH_SINK,GstCurlSshSinkClass))
</MACRO>
<MACRO>
<NAME>GST_CURL_SSH_SINK_GET_CLASS</NAME>
#define GST_CURL_SSH_SINK_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_CURL_SSH_SINK,GstCurlSshSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_SSH_SINK</NAME>
#define GST_IS_CURL_SSH_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CURL_SSH_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_SSH_SINK_CLASS</NAME>
#define GST_IS_CURL_SSH_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CURL_SSH_SINK))
</MACRO>
<ENUM>
<NAME>GstCurlSshAuthType</NAME>
typedef enum
{
  /* Keep these in sync with the libcurl definitions. See <curl/curl.h> */
  GST_CURLSSH_AUTH_NONE = CURLSSH_AUTH_NONE,
  GST_CURLSSH_AUTH_PUBLICKEY = CURLSSH_AUTH_PUBLICKEY,
  GST_CURLSSH_AUTH_PASSWORD = CURLSSH_AUTH_PASSWORD
} GstCurlSshAuthType;
</ENUM>
<STRUCT>
<NAME>GstCurlSshSink</NAME>
struct _GstCurlSshSink
{
  GstCurlBaseSink parent;

  /*< private > */
  /* for now, supporting only:
   * GST_CURLSSH_AUTH_PASSWORD (password authentication) and
   * GST_CURLSSH_AUTH_PUBLICKEY (public key authentication) */
  GstCurlSshAuthType ssh_auth_type;

  gchar *ssh_pub_keyfile;       /* filename for the public key:
                                   CURLOPT_SSH_PUBLIC_KEYFILE */
  gchar *ssh_priv_keyfile;      /* filename for the private key:
                                   CURLOPT_SSH_PRIVATE_KEYFILE */
  gchar *ssh_key_passphrase;    /* passphrase for the pvt key:
                                   CURLOPT_KEYPASSWD */

  gchar *ssh_knownhosts;        /* filename of the 'known_hosts' file:
                                   CURLOPT_SSH_KNOWN_HOSTS */
  gboolean ssh_accept_unknownhost;      /* accept or reject unknown public key
                                           from remote host */
  gchar *ssh_host_public_key_md5;   /* MD5-hash of the remote host's public key:
                                       CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 */
};
</STRUCT>
<STRUCT>
<NAME>GstCurlSshSinkClass</NAME>
struct _GstCurlSshSinkClass
{
  GstCurlBaseSinkClass parent_class;

  /* vmethods */
    gboolean (*set_options_unlocked) (GstCurlBaseSink * sink);
};
</STRUCT>
<FUNCTION>
<NAME>gst_curl_ssh_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CURL_SFTP_SINK</NAME>
#define GST_TYPE_CURL_SFTP_SINK \
  (gst_curl_sftp_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_CURL_SFTP_SINK</NAME>
#define GST_CURL_SFTP_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CURL_SFTP_SINK,GstCurlSftpSink))
</MACRO>
<MACRO>
<NAME>GST_CURL_SFTP_SINK_CLASS</NAME>
#define GST_CURL_SFTP_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CURL_SFTP_SINK,GstCurlSftpSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_SFTP_SINK</NAME>
#define GST_IS_CURL_SFTP_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CURL_SFTP_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_CURL_SFTP_SINK_CLASS</NAME>
#define GST_IS_CURL_SFTP_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CURL_SFTP_SINK))
</MACRO>
<STRUCT>
<NAME>GstCurlSftpSink</NAME>
struct _GstCurlSftpSink
{
  GstCurlSshSink parent;

  /*< private > */
  gboolean create_dirs;
};
</STRUCT>
<STRUCT>
<NAME>GstCurlSftpSinkClass</NAME>
struct _GstCurlSftpSinkClass
{
  GstCurlSshSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_curl_sftp_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_qt_get_gl_display</NAME>
<RETURNS>GstGLDisplay  * </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>gst_qt_get_gl_wrapcontext</NAME>
<RETURNS>gboolean        </RETURNS>
GstGLDisplay * display, GstGLContext **wrap_glcontext, GstGLContext **context
</FUNCTION>
<FUNCTION>
<NAME>setDAR</NAME>
<RETURNS>void  </RETURNS>
gint, gint
</FUNCTION>
<FUNCTION>
<NAME>getDAR</NAME>
<RETURNS>void  </RETURNS>
gint *, gint *
</FUNCTION>
<FUNCTION>
<NAME>setForceAspectRatio</NAME>
<RETURNS>void  </RETURNS>
bool
</FUNCTION>
<FUNCTION>
<NAME>getForceAspectRatio</NAME>
<RETURNS>bool  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>handleWindowChanged</NAME>
<RETURNS>void  </RETURNS>
QQuickWindow * win
</FUNCTION>
<FUNCTION>
<NAME>onSceneGraphInitialized</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>onSceneGraphInvalidated</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>updatePaintNode</NAME>
<RETURNS>QSGNode  * </RETURNS>
QSGNode * oldNode, UpdatePaintNodeData * updatePaintNodeData
</FUNCTION>
<FUNCTION>
<NAME>setViewportSize</NAME>
<RETURNS>void  </RETURNS>
const QSize &size
</FUNCTION>
<FUNCTION>
<NAME>shareContext</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>qt_item_set_buffer</NAME>
<RETURNS>void             </RETURNS>
QtGLVideoItem * widget, GstBuffer * buffer
</FUNCTION>
<FUNCTION>
<NAME>qt_item_set_caps</NAME>
<RETURNS>gboolean         </RETURNS>
QtGLVideoItem * widget, GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>qt_item_init_winsys</NAME>
<RETURNS>gboolean         </RETURNS>
QtGLVideoItem * widget
</FUNCTION>
<FUNCTION>
<NAME>qt_item_get_qt_context</NAME>
<RETURNS>GstGLContext  *  </RETURNS>
QtGLVideoItem * qt_item
</FUNCTION>
<FUNCTION>
<NAME>qt_item_get_context</NAME>
<RETURNS>GstGLContext  *  </RETURNS>
QtGLVideoItem * qt_item
</FUNCTION>
<FUNCTION>
<NAME>qt_item_get_display</NAME>
<RETURNS>GstGLDisplay  *  </RETURNS>
QtGLVideoItem * qt_item
</FUNCTION>
<STRUCT>
<NAME>QtGLVideoItemPrivate</NAME>
</STRUCT>
<FUNCTION>
<NAME>setCaps</NAME>
<RETURNS>void  </RETURNS>
GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>setBuffer</NAME>
<RETURNS>gboolean  </RETURNS>
GstBuffer * buffer
</FUNCTION>
<FUNCTION>
<NAME>bind</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<MACRO>
<NAME>GLsync</NAME>
#define GLsync gst_qt_GLsync
</MACRO>
<FUNCTION>
<NAME>gst_qt_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_QT_SRC</NAME>
#define GST_TYPE_QT_SRC            (gst_qt_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_QT_SRC</NAME>
#define GST_QT_SRC(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_QT_SRC,GstQtSrc))
</MACRO>
<MACRO>
<NAME>GST_QT_SRC_CLASS</NAME>
#define GST_QT_SRC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_QT_SRC,GstQtSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_QT_SRC</NAME>
#define GST_IS_QT_SRC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_QT_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_QT_SRC_CLASS</NAME>
#define GST_IS_QT_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_QT_SRC))
</MACRO>
<MACRO>
<NAME>GST_QT_SRC_CAST</NAME>
#define GST_QT_SRC_CAST(obj)       ((GstQtSrc*)(obj))
</MACRO>
<STRUCT>
<NAME>GstQtSrc</NAME>
struct _GstQtSrc
{
  /* <private> */
  GstPushSrc            parent;

  QQuickWindow          *qwindow;
  QtGLWindow            *window;

  GstVideoInfo          v_info;

  GstGLDisplay         *display;
  GstGLContext         *context;
  GstGLContext         *qt_context;

  gboolean              default_fbo;
  gboolean              downstream_supports_affine_meta;
  gboolean              pending_image_orientation;
};
</STRUCT>
<STRUCT>
<NAME>GstQtSrcClass</NAME>
struct _GstQtSrcClass
{
  /* <private> */
  GstPushSrcClass object_class;
};
</STRUCT>
<FUNCTION>
<NAME>getGeometry</NAME>
<RETURNS>bool  </RETURNS>
int * width, int * height
</FUNCTION>
<FUNCTION>
<NAME>beforeRendering</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>afterRendering</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>onSceneGraphInitialized</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>onSceneGraphInvalidated</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>aboutToQuit</NAME>
<RETURNS>void  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>qt_window_set_buffer</NAME>
<RETURNS>gboolean         </RETURNS>
QtGLWindow * qt_window, GstBuffer * buffer
</FUNCTION>
<FUNCTION>
<NAME>qt_window_set_caps</NAME>
<RETURNS>gboolean         </RETURNS>
QtGLWindow * qt_window, GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>qt_window_get_qt_context</NAME>
<RETURNS>GstGLContext  *  </RETURNS>
QtGLWindow * qt_window
</FUNCTION>
<FUNCTION>
<NAME>qt_window_get_display</NAME>
<RETURNS>GstGLDisplay  *  </RETURNS>
QtGLWindow * qt_window
</FUNCTION>
<FUNCTION>
<NAME>qt_window_is_scenegraph_initialized</NAME>
<RETURNS>gboolean         </RETURNS>
QtGLWindow * qt_window
</FUNCTION>
<FUNCTION>
<NAME>qt_window_use_default_fbo</NAME>
<RETURNS>void             </RETURNS>
QtGLWindow * qt_window, gboolean useDefaultFbo
</FUNCTION>
<STRUCT>
<NAME>QtGLWindowPrivate</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_qt_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_QT_SINK</NAME>
#define GST_TYPE_QT_SINK            (gst_qt_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_QT_SINK</NAME>
#define GST_QT_SINK(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_QT_SINK,GstQtSink))
</MACRO>
<MACRO>
<NAME>GST_QT_SINK_CLASS</NAME>
#define GST_QT_SINK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_QT_SINK,GstQtSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_QT_SINK</NAME>
#define GST_IS_QT_SINK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_QT_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_QT_SINK_CLASS</NAME>
#define GST_IS_QT_SINK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_QT_SINK))
</MACRO>
<MACRO>
<NAME>GST_QT_SINK_CAST</NAME>
#define GST_QT_SINK_CAST(obj)       ((GstQtSink*)(obj))
</MACRO>
<STRUCT>
<NAME>GstQtSink</NAME>
struct _GstQtSink
{
  /* <private> */
  GstVideoSink          parent;

  QtGLVideoItem        *widget;

  GstVideoInfo          v_info;
  GstBufferPool        *pool;

  GstGLDisplay         *display;
  GstGLContext         *context;
  GstGLContext         *qt_context;

  GstQtSinkPrivate  *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstQtSinkClass</NAME>
struct _GstQtSinkClass
{
  /* <private> */
  GstVideoSinkClass object_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_qt_sink_new</NAME>
<RETURNS>GstQtSink  *    </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstQtSinkPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_OFA</NAME>
#define GST_TYPE_OFA \
  (gst_ofa_get_type())
</MACRO>
<MACRO>
<NAME>GST_OFA</NAME>
#define GST_OFA(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OFA,GstOFA))
</MACRO>
<MACRO>
<NAME>GST_OFA_CLASS</NAME>
#define GST_OFA_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OFA,GstOFAClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OFA</NAME>
#define GST_IS_OFA(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OFA))
</MACRO>
<MACRO>
<NAME>GST_IS_OFA_CLASS</NAME>
#define GST_IS_OFA_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OFA))
</MACRO>
<MACRO>
<NAME>GST_TAG_OFA_FINGERPRINT</NAME>
#define GST_TAG_OFA_FINGERPRINT "ofa-fingerprint"
</MACRO>
<STRUCT>
<NAME>GstOFA</NAME>
struct _GstOFA
{
  GstAudioFilter audiofilter;

  /*< private > */

  GstAdapter *adapter;
  char *fingerprint;
  gboolean record;
};
</STRUCT>
<STRUCT>
<NAME>GstOFAClass</NAME>
struct _GstOFAClass
{
  GstAudioFilterClass audiofilter_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ofa_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_LIBDE265_DEC</NAME>
#define GST_TYPE_LIBDE265_DEC \
    (gst_libde265_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_LIBDE265_DEC</NAME>
#define GST_LIBDE265_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_LIBDE265_DEC,GstLibde265Dec))
</MACRO>
<MACRO>
<NAME>GST_LIBDE265_DEC_CLASS</NAME>
#define GST_LIBDE265_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_LIBDE265_DEC,GstLibde265DecClass))
</MACRO>
<ENUM>
<NAME>GstLibde265DecFormat</NAME>
typedef enum
{
  GST_TYPE_LIBDE265_FORMAT_PACKETIZED,
  GST_TYPE_LIBDE265_FORMAT_BYTESTREAM
} GstLibde265DecFormat;
</ENUM>
<FUNCTION>
<NAME>gst_libde265_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_libde265_dec_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CHROMAPRINT</NAME>
#define GST_TYPE_CHROMAPRINT \
  (gst_chromaprint_get_type())
</MACRO>
<MACRO>
<NAME>GST_CHROMAPRINT</NAME>
#define GST_CHROMAPRINT(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CHROMAPRINT,GstChromaprint))
</MACRO>
<MACRO>
<NAME>GST_CHROMAPRINT_CLASS</NAME>
#define GST_CHROMAPRINT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CHROMAPRINT,GstChromaprintClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CHROMAPRINT</NAME>
#define GST_IS_CHROMAPRINT(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CHROMAPRINT))
</MACRO>
<MACRO>
<NAME>GST_IS_CHROMAPRINT_CLASS</NAME>
#define GST_IS_CHROMAPRINT_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CHROMAPRINT))
</MACRO>
<MACRO>
<NAME>GST_TAG_CHROMAPRINT_FINGERPRINT</NAME>
#define GST_TAG_CHROMAPRINT_FINGERPRINT "chromaprint-fingerprint"
</MACRO>
<STRUCT>
<NAME>GstChromaprint</NAME>
struct _GstChromaprint
{
  GstAudioFilter element;

  /*< private >*/
  ChromaprintContext * context;
  char               * fingerprint;
  gboolean             record;
  guint64              nsamples;
  guint                duration;
  guint                max_duration;
};
</STRUCT>
<STRUCT>
<NAME>GstChromaprintClass</NAME>
struct _GstChromaprintClass
{
  GstAudioFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_chromaprint_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DAALA_ENC</NAME>
#define GST_TYPE_DAALA_ENC \
  (gst_daala_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_DAALA_ENC</NAME>
#define GST_DAALA_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DAALA_ENC,GstDaalaEnc))
</MACRO>
<MACRO>
<NAME>GST_DAALA_ENC_CLASS</NAME>
#define GST_DAALA_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DAALA_ENC,GstDaalaEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DAALA_ENC</NAME>
#define GST_IS_DAALA_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DAALA_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_DAALA_ENC_CLASS</NAME>
#define GST_IS_DAALA_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DAALA_ENC))
</MACRO>
<STRUCT>
<NAME>GstDaalaEnc</NAME>
struct _GstDaalaEnc
{
  GstVideoEncoder element;

  ogg_stream_state vo;

  daala_enc_ctx *encoder;
  daala_info info;
  daala_comment comment;
  gboolean initialised;

  guint packetno;
  guint64 bytes_out;
  guint64 granulepos_offset;
  guint64 timestamp_offset;
  guint64 pfn_offset;

  int quant;
  int keyframe_rate;
  gboolean quant_changed;
  gboolean keyframe_rate_changed;

  GstVideoCodecState *input_state;
};
</STRUCT>
<STRUCT>
<NAME>GstDaalaEncClass</NAME>
struct _GstDaalaEncClass
{
  GstVideoEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_daala_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_daala_enc_register</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DAALA_DEC</NAME>
#define GST_TYPE_DAALA_DEC \
  (gst_daala_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_DAALA_DEC</NAME>
#define GST_DAALA_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DAALA_DEC,GstDaalaDec))
</MACRO>
<MACRO>
<NAME>GST_DAALA_DEC_CLASS</NAME>
#define GST_DAALA_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DAALA_DEC,GstDaalaDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DAALA_DEC</NAME>
#define GST_IS_DAALA_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DAALA_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_DAALA_DEC_CLASS</NAME>
#define GST_IS_DAALA_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DAALA_DEC))
</MACRO>
<STRUCT>
<NAME>GstDaalaDec</NAME>
struct _GstDaalaDec
{
  GstVideoDecoder element;

  /* daala decoder state */
  daala_dec_ctx *decoder;
  daala_setup_info *setup;
  daala_info info;
  daala_comment comment;

  gboolean have_header;

  gboolean need_keyframe;
  GstVideoCodecState *input_state;
  GstVideoCodecState *output_state;
};
</STRUCT>
<STRUCT>
<NAME>GstDaalaDecClass</NAME>
struct _GstDaalaDecClass
{
  GstVideoDecoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_daala_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_daala_dec_register</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MMS</NAME>
#define GST_TYPE_MMS \
  (gst_mms_get_type())
</MACRO>
<MACRO>
<NAME>GST_MMS</NAME>
#define GST_MMS(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MMS,GstMMS))
</MACRO>
<MACRO>
<NAME>GST_MMS_CLASS</NAME>
#define GST_MMS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MMS,GstMMSClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MMS</NAME>
#define GST_IS_MMS(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MMS))
</MACRO>
<MACRO>
<NAME>GST_IS_MMS_CLASS</NAME>
#define GST_IS_MMS_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MMS))
</MACRO>
<STRUCT>
<NAME>GstMMS</NAME>
struct _GstMMS
{
  GstPushSrc parent;

  gchar  *uri_name;
  gchar  *current_connection_uri_name;
  guint64  connection_speed;
  
  mmsx_t *connection;
};
</STRUCT>
<STRUCT>
<NAME>GstMMSClass</NAME>
struct _GstMMSClass 
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mms_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>spc_tag_clear</NAME>
<RETURNS>void  </RETURNS>
spc_tag_info* info
</FUNCTION>
<FUNCTION>
<NAME>spc_tag_get_info</NAME>
<RETURNS>void  </RETURNS>
guchar* data, guint length, spc_tag_info* info
</FUNCTION>
<FUNCTION>
<NAME>spc_tag_free</NAME>
<RETURNS>void  </RETURNS>
spc_tag_info* info
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SPC_DEC</NAME>
#define GST_TYPE_SPC_DEC \
  (gst_spc_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_SPC_DEC</NAME>
#define GST_SPC_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SPC_DEC,GstSpcDec))
</MACRO>
<MACRO>
<NAME>GST_SPC_DEC_CLASS</NAME>
#define GST_SPC_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SPC_DEC,GstSpcDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SPC_DEC</NAME>
#define GST_IS_SPC_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SPC_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_SPC_DEC_CLASS</NAME>
#define GST_IS_SPC_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SPC_DEC))
</MACRO>
<STRUCT>
<NAME>GstSpcDec</NAME>
struct _GstSpcDec
{
  GstElement  element;

  GstPad     *sinkpad;
  GstPad     *srcpad;

  GstBuffer  *buf;
  gboolean    initialized;
  gboolean    seeking;
  guint32     seekpoint;
  
  spc_tag_info tag_info;
  
  guint32 byte_pos;
};
</STRUCT>
<STRUCT>
<NAME>GstSpcDecClass</NAME>
struct _GstSpcDecClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_spc_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SF_DEC</NAME>
#define GST_TYPE_SF_DEC \
  (gst_sf_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_SF_DEC</NAME>
#define GST_SF_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SF_DEC,GstSFDec))
</MACRO>
<MACRO>
<NAME>GST_SF_DEC_CLASS</NAME>
#define GST_SF_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SF_DEC,GstSFDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SF_DEC</NAME>
#define GST_IS_SF_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SF_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_SF_DEC_CLASS</NAME>
#define GST_IS_SF_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SF_DEC))
</MACRO>
<USER_FUNCTION>
<NAME>GstSFReader</NAME>
<RETURNS>sf_count_t </RETURNS>
SNDFILE *f, void *data, sf_count_t nframes
</USER_FUNCTION>
<STRUCT>
<NAME>GstSFDec</NAME>
struct _GstSFDec {
  GstElement parent;

  GstPad *sinkpad;
  GstPad *srcpad;
  
  guint64 pos;      /* in bytes */
  guint64 duration; /* in frames */
  
  gboolean seekable;

  SNDFILE *file;
  sf_count_t offset;
  GstSFReader reader;
  gint bytes_per_frame;

  gint channels;
  gint rate;
};
</STRUCT>
<STRUCT>
<NAME>GstSFDecClass</NAME>
struct _GstSFDecClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_sf_create_audio_template_caps</NAME>
<RETURNS>GstCaps  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SF_MAJOR_TYPES</NAME>
#define GST_TYPE_SF_MAJOR_TYPES (gst_sf_major_types_get_type())
</MACRO>
<MACRO>
<NAME>GST_TYPE_SF_MINOR_TYPES</NAME>
#define GST_TYPE_SF_MINOR_TYPES (gst_sf_minor_types_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_sf_major_types_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_sf_minor_types_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_sf_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstLV2Group</NAME>
struct _GstLV2Group
{
  gchar *uri; /**< RDF resource (URI or blank node) */
  guint pad; /**< Gst pad index */
  gchar *symbol; /**< Gst pad name / LV2 group symbol */
  GArray *ports; /**< Array of GstLV2Port */
  /* FIXME: not set as of now */
  gboolean has_roles; /**< TRUE iff all ports have a known role */
};
</STRUCT>
<ENUM>
<NAME>GstLV2PortType</NAME>
typedef enum {
  GST_LV2_PORT_AUDIO = 0,
  GST_LV2_PORT_CONTROL,
  GST_LV2_PORT_CV
} GstLV2PortType;
</ENUM>
<STRUCT>
<NAME>GstLV2Port</NAME>
struct _GstLV2Port
{
  gint index; /**< LV2 port index (on LV2 plugin) */
  GstLV2PortType type; /**< Port type */
  /**< Gst pad index (iff not part of a group), only for audio ports */
  gint pad;
  /* FIXME: not set as of now */
  LilvNode *role; /**< Channel position / port role */
  GstAudioChannelPosition position; /**< Channel position */
};
</STRUCT>
<STRUCT>
<NAME>GstLV2</NAME>
struct _GstLV2
{
  GstLV2Class *klass;

  LilvInstance *instance;
  GHashTable *presets;

  gboolean activated;
  unsigned long rate;

  struct
  {
    struct
    {
      gfloat *in;
      gfloat *out;
    } control;
  } ports;
};
</STRUCT>
<STRUCT>
<NAME>GstLV2Class</NAME>
struct _GstLV2Class
{
  guint properties;

  const LilvPlugin *plugin;
  GHashTable *sym_to_name;

  gint num_control_in, num_control_out;
  gint num_cv_in, num_cv_out;

  GstLV2Group in_group; /**< Array of GstLV2Group */
  GstLV2Group out_group; /**< Array of GstLV2Group */
  GArray *control_in_ports; /**< Array of GstLV2Port */
  GArray *control_out_ports; /**< Array of GstLV2Port */
};
</STRUCT>
<FUNCTION>
<NAME>gst_lv2_check_required_features</NAME>
<RETURNS>gboolean  </RETURNS>
const LilvPlugin * lv2plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_host_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_get_preset_names</NAME>
<RETURNS>gchar  **</RETURNS>
GstLV2 * lv2, GstObject * obj
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_load_preset</NAME>
<RETURNS>gboolean  </RETURNS>
GstLV2 * lv2, GstObject * obj, const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_save_preset</NAME>
<RETURNS>gboolean  </RETURNS>
GstLV2 * lv2, GstObject * obj, const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_delete_preset</NAME>
<RETURNS>gboolean  </RETURNS>
GstLV2 * lv2, GstObject * obj, const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_init</NAME>
<RETURNS>void  </RETURNS>
GstLV2 * lv2, GstLV2Class * lv2_class
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_finalize</NAME>
<RETURNS>void  </RETURNS>
GstLV2 * lv2
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_setup</NAME>
<RETURNS>gboolean  </RETURNS>
GstLV2 * lv2, unsigned long rate
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_cleanup</NAME>
<RETURNS>gboolean  </RETURNS>
GstLV2 * lv2, GstObject *obj
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_object_set_property</NAME>
<RETURNS>void  </RETURNS>
GstLV2 * lv2, GObject * object, guint prop_id, const GValue * value, GParamSpec * pspec
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_object_get_property</NAME>
<RETURNS>void  </RETURNS>
GstLV2 * lv2, GObject * object, guint prop_id, GValue * value, GParamSpec * pspec
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_class_install_properties</NAME>
<RETURNS>void  </RETURNS>
GstLV2Class * lv2_class, GObjectClass * object_class, guint offset
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_element_class_set_metadata</NAME>
<RETURNS>void  </RETURNS>
GstLV2Class * lv2_class, GstElementClass * elem_class, const gchar * lv2_class_tags
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_class_init</NAME>
<RETURNS>void  </RETURNS>
GstLV2Class * lv2_class, GType type
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_class_finalize</NAME>
<RETURNS>void  </RETURNS>
GstLV2Class * lv2_class
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_filter_register_element</NAME>
<RETURNS>void  </RETURNS>
GstPlugin *plugin, GstStructure * lv2_meta
</FUNCTION>
<FUNCTION>
<NAME>gst_lv2_source_register_element</NAME>
<RETURNS>void  </RETURNS>
GstPlugin *plugin, GstStructure * lv2_meta
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_X265_ENC</NAME>
#define GST_TYPE_X265_ENC \
  (gst_x265_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_X265_ENC</NAME>
#define GST_X265_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_X265_ENC,GstX265Enc))
</MACRO>
<MACRO>
<NAME>GST_X265_ENC_CLASS</NAME>
#define GST_X265_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_X265_ENC,GstX265EncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_X265_ENC</NAME>
#define GST_IS_X265_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_X265_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_X265_ENC_CLASS</NAME>
#define GST_IS_X265_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_X265_ENC))
</MACRO>
<STRUCT>
<NAME>GstX265Enc</NAME>
struct _GstX265Enc
{
  GstVideoEncoder element;

  /*< private > */
  x265_encoder *x265enc;
  x265_param x265param;
  GstClockTime dts_offset;
  gboolean push_header;

  /* List of frame/buffer mapping structs for
   * pending frames */
  GList *pending_frames;

  /* properties */
  guint bitrate;
  gint qp;
  gint log_level;
  gint tune;
  gint speed_preset;
  GString *option_string_prop;  /* option-string property */
  /*GString *option_string; *//* used by set prop */

  /* input description */
  GstVideoCodecState *input_state;

  /* configuration changed  while playing */
  gboolean reconfig;

  /* from the downstream caps */
  const gchar *peer_profile;
  gboolean peer_intra_profile;
  /*const x265_level_t *peer_level; */
};
</STRUCT>
<STRUCT>
<NAME>GstX265EncClass</NAME>
struct _GstX265EncClass
{
  GstVideoEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_x265_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_NEONHTTP_SRC</NAME>
#define GST_TYPE_NEONHTTP_SRC \
  (gst_neonhttp_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_NEONHTTP_SRC</NAME>
#define GST_NEONHTTP_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_NEONHTTP_SRC,GstNeonhttpSrc))
</MACRO>
<MACRO>
<NAME>GST_NEONHTTP_SRC_CLASS</NAME>
#define GST_NEONHTTP_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_NEONHTTP_SRC,GstNeonhttpSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_NEONHTTP_SRC</NAME>
#define GST_IS_NEONHTTP_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_NEONHTTP_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_NEONHTTP_SRC_CLASS</NAME>
#define GST_IS_NEONHTTP_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_NEONHTTP_SRC))
</MACRO>
<STRUCT>
<NAME>GstNeonhttpSrc</NAME>
struct _GstNeonhttpSrc {
  GstPushSrc element;

  /* socket */
  ne_session *session;
  ne_request *request;
  ne_uri uri;
  gchar *location;
  gchar *query_string;
  ne_uri proxy;
  gchar *user_agent;
  gchar **cookies;

  guint64 content_size;

  gboolean eos;

  /* whether to request icecast metadata */
  gboolean iradio_mode;

  /* enable Neon HTTP redirects (HTTP 302 status code) */
  gboolean automatic_redirect;

  /* enable Neon HTTP debug messages */
  gboolean neon_http_debug;

  /* accept self-signed certificates */
  gboolean accept_self_signed;

  gint64 read_position;
  gboolean seekable;

  /* seconds before timing out when connecting or reading to/from a socket */
  guint connect_timeout;
  guint read_timeout;
};
</STRUCT>
<STRUCT>
<NAME>GstNeonhttpSrcClass</NAME>
struct _GstNeonhttpSrcClass {
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_neonhttp_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_HLS_DEMUX</NAME>
#define GST_TYPE_HLS_DEMUX \
  (gst_hls_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_HLS_DEMUX</NAME>
#define GST_HLS_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_HLS_DEMUX,GstHLSDemux))
</MACRO>
<MACRO>
<NAME>GST_HLS_DEMUX_CLASS</NAME>
#define GST_HLS_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_HLS_DEMUX,GstHLSDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_HLS_DEMUX</NAME>
#define GST_IS_HLS_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_HLS_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_HLS_DEMUX_CLASS</NAME>
#define GST_IS_HLS_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_HLS_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_HLS_DEMUX_GET_CLASS</NAME>
#define GST_HLS_DEMUX_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_HLS_DEMUX,GstHLSDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_HLS_DEMUX_CAST</NAME>
#define GST_HLS_DEMUX_CAST(obj) \
  ((GstHLSDemux *)obj)
</MACRO>
<MACRO>
<NAME>GST_HLS_DEMUX_STREAM_CAST</NAME>
#define GST_HLS_DEMUX_STREAM_CAST(stream) ((GstHLSDemuxStream *)(stream))
</MACRO>
<ENUM>
<NAME>GstHLSTSReaderType</NAME>
typedef enum {
  GST_HLS_TSREADER_NONE,
  GST_HLS_TSREADER_MPEGTS,
  GST_HLS_TSREADER_ID3
} GstHLSTSReaderType;
</ENUM>
<STRUCT>
<NAME>GstHLSTSReader</NAME>
struct _GstHLSTSReader
{
  GstHLSTSReaderType rtype;
  gboolean have_id3;

  gint packet_size;
  gint pmt_pid;
  gint pcr_pid;

  GstClockTime last_pcr;
  GstClockTime first_pcr;
};
</STRUCT>
<STRUCT>
<NAME>GstHLSDemuxStream</NAME>
struct _GstHLSDemuxStream
{
  GstAdaptiveDemuxStream adaptive_demux_stream;

  GstHLSTSReaderType stream_type;

  GstM3U8 *playlist;
  gboolean is_primary_playlist;

  gboolean do_typefind;         /* Whether we need to typefind the next buffer */
  GstBuffer *pending_typefind_buffer; /* for collecting data until typefind succeeds */

  GstAdapter *pending_encrypted_data;  /* for chunking data into 16 byte multiples for decryption */
  GstBuffer *pending_decrypted_buffer; /* last decrypted buffer for pkcs7 unpadding.
                                          We only know that it is the last at EOS */
  guint64 current_offset;              /* offset we're currently at */
  gboolean reset_pts;

  /* decryption tooling */
#if defined(HAVE_OPENSSL)
  EVP_CIPHER_CTX aes_ctx;
#elif defined(HAVE_NETTLE)
  struct CBC_CTX (struct aes_ctx, AES_BLOCK_SIZE) aes_ctx;
#else
  gcry_cipher_hd_t aes_ctx;
#endif

  gchar     *current_key;
  guint8    *current_iv;

  /* Accumulator for reading PAT/PMT/PCR from
   * the stream so we can set timestamps/segments
   * and switch cleanly */
  GstBuffer *pending_pcr_buffer;

  GstHLSTSReader tsreader;
};
</STRUCT>
<STRUCT>
<NAME>GstHLSKey</NAME>
typedef struct {
  guint8 data[16];
} GstHLSKey;
</STRUCT>
<STRUCT>
<NAME>GstHLSDemux</NAME>
struct _GstHLSDemux
{
  GstAdaptiveDemux parent;

  gint srcpad_counter;

  /* Decryption key cache: url => GstHLSKey */
  GHashTable *keys;
  GMutex      keys_lock;

  /* FIXME: check locking, protected automatically by manifest_lock already? */
  /* The master playlist with the available variant streams */
  GstHLSMasterPlaylist *master;

  GstHLSVariantStream  *current_variant;
};
</STRUCT>
<STRUCT>
<NAME>GstHLSDemuxClass</NAME>
struct _GstHLSDemuxClass
{
  GstAdaptiveDemuxClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_hlsdemux_tsreader_init</NAME>
<RETURNS>void  </RETURNS>
GstHLSTSReader *r
</FUNCTION>
<FUNCTION>
<NAME>gst_hlsdemux_tsreader_set_type</NAME>
<RETURNS>void  </RETURNS>
GstHLSTSReader *r, GstHLSTSReaderType rtype
</FUNCTION>
<FUNCTION>
<NAME>gst_hlsdemux_tsreader_find_pcrs</NAME>
<RETURNS>gboolean  </RETURNS>
GstHLSTSReader *r, GstBuffer **buffer, GstClockTime *first_pcr, GstClockTime *last_pcr, GstTagList **tags
</FUNCTION>
<FUNCTION>
<NAME>gst_hls_demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstM3U8Playlist</NAME>
struct _GstM3U8Playlist
{
  guint version;
  gboolean allow_cache;
  gint window_size;
  gint type;
  gboolean end_list;
  guint sequence_number;

  /*< Private >*/
  GQueue *entries;
};
</STRUCT>
<FUNCTION>
<NAME>gst_m3u8_playlist_new</NAME>
<RETURNS>GstM3U8Playlist  * </RETURNS>
guint version, guint window_size, gboolean allow_cache
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_playlist_free</NAME>
<RETURNS>void               </RETURNS>
GstM3U8Playlist * playlist
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_playlist_add_entry</NAME>
<RETURNS>gboolean           </RETURNS>
GstM3U8Playlist * playlist, const gchar     * url, const gchar     * title, gfloat            duration, guint             index, gboolean          discontinuous
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_playlist_render</NAME>
<RETURNS>gchar  *           </RETURNS>
GstM3U8Playlist * playlist
</FUNCTION>
<MACRO>
<NAME>GST_M3U8</NAME>
#define GST_M3U8(m) ((GstM3U8*)m)
</MACRO>
<MACRO>
<NAME>GST_M3U8_MEDIA_FILE</NAME>
#define GST_M3U8_MEDIA_FILE(f) ((GstM3U8MediaFile*)f)
</MACRO>
<MACRO>
<NAME>GST_M3U8_LOCK</NAME>
#define GST_M3U8_LOCK(m) g_mutex_lock (&m->lock);
</MACRO>
<MACRO>
<NAME>GST_M3U8_UNLOCK</NAME>
#define GST_M3U8_UNLOCK(m) g_mutex_unlock (&m->lock);
</MACRO>
<MACRO>
<NAME>GST_M3U8_IS_LIVE</NAME>
#define GST_M3U8_IS_LIVE(m) ((m)->endlist == FALSE)
</MACRO>
<MACRO>
<NAME>GST_M3U8_LIVE_MIN_FRAGMENT_DISTANCE</NAME>
#define GST_M3U8_LIVE_MIN_FRAGMENT_DISTANCE 3
</MACRO>
<STRUCT>
<NAME>GstM3U8</NAME>
struct _GstM3U8
{
  gchar *uri;                   /* actually downloaded URI */
  gchar *base_uri;              /* URI to use as base for resolving relative URIs.
                                 * This will be different to uri in case of redirects */
  gchar *name;                  /* This will be the "name" of the playlist, the original
                                 * relative/absolute uri in a variant playlist */

  /* parsed info */
  gboolean endlist;             /* if ENDLIST has been reached */
  gint version;                 /* last EXT-X-VERSION */
  GstClockTime targetduration;  /* last EXT-X-TARGETDURATION */
  gboolean allowcache;          /* last EXT-X-ALLOWCACHE */

  GList *files;

  /* state */
  GList *current_file;
  GstClockTime current_file_duration; /* Duration of current fragment */
  gint64 sequence;                    /* the next sequence for this client */
  GstClockTime sequence_position;     /* position of this sequence */
  gint64 highest_sequence_number;     /* largest seen sequence number */
  GstClockTime first_file_start;      /* timecode of the start of the first fragment in the current media playlist */
  GstClockTime last_file_end;         /* timecode of the end of the last fragment in the current media playlist */
  GstClockTime duration;              /* cached total duration */
  gint discont_sequence;              /* currently expected EXT-X-DISCONTINUITY-SEQUENCE */

  /*< private > */
  gchar *last_data;
  GMutex lock;

  gint ref_count;               /* ATOMIC */
};
</STRUCT>
<FUNCTION>
<NAME>gst_m3u8_ref</NAME>
<RETURNS>GstM3U8  *          </RETURNS>
GstM3U8 * m3u8
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_unref</NAME>
<RETURNS>void                </RETURNS>
GstM3U8 * m3u8
</FUNCTION>
<STRUCT>
<NAME>GstM3U8MediaFile</NAME>
struct _GstM3U8MediaFile
{
  gchar *title;
  GstClockTime duration;
  gchar *uri;
  gint64 sequence;               /* the sequence nb of this file */
  gboolean discont;             /* this file marks a discontinuity */
  gchar *key;
  guint8 iv[16];
  gint64 offset, size;
  gint ref_count;               /* ATOMIC */
};
</STRUCT>
<FUNCTION>
<NAME>gst_m3u8_media_file_ref</NAME>
<RETURNS>GstM3U8MediaFile  * </RETURNS>
GstM3U8MediaFile * mfile
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_media_file_unref</NAME>
<RETURNS>void                </RETURNS>
GstM3U8MediaFile * mfile
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_new</NAME>
<RETURNS>GstM3U8  *          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_update</NAME>
<RETURNS>gboolean            </RETURNS>
GstM3U8  * m3u8, gchar    * data
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_set_uri</NAME>
<RETURNS>void                </RETURNS>
GstM3U8      * m3u8, const gchar  * uri, const gchar  * base_uri, const gchar  * name
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_get_next_fragment</NAME>
<RETURNS>GstM3U8MediaFile  * </RETURNS>
GstM3U8      * m3u8, gboolean       forward, GstClockTime * sequence_position, gboolean     * discont
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_has_next_fragment</NAME>
<RETURNS>gboolean            </RETURNS>
GstM3U8 * m3u8, gboolean  forward
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_advance_fragment</NAME>
<RETURNS>void                </RETURNS>
GstM3U8 * m3u8, gboolean  forward
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_get_duration</NAME>
<RETURNS>GstClockTime        </RETURNS>
GstM3U8 * m3u8
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_get_target_duration</NAME>
<RETURNS>GstClockTime        </RETURNS>
GstM3U8 * m3u8
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_get_uri</NAME>
<RETURNS>gchar  *            </RETURNS>
GstM3U8 * m3u8
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_is_live</NAME>
<RETURNS>gboolean            </RETURNS>
GstM3U8 * m3u8
</FUNCTION>
<FUNCTION>
<NAME>gst_m3u8_get_seek_range</NAME>
<RETURNS>gboolean            </RETURNS>
GstM3U8 * m3u8, gint64  * start, gint64  * stop
</FUNCTION>
<ENUM>
<NAME>GstHLSMediaType</NAME>
typedef enum
{
  GST_HLS_MEDIA_TYPE_INVALID = -1,
  GST_HLS_MEDIA_TYPE_AUDIO,
  GST_HLS_MEDIA_TYPE_VIDEO,
  GST_HLS_MEDIA_TYPE_SUBTITLES,
  GST_HLS_MEDIA_TYPE_CLOSED_CAPTIONS,
  GST_HLS_N_MEDIA_TYPES
} GstHLSMediaType;
</ENUM>
<STRUCT>
<NAME>GstHLSMedia</NAME>
struct _GstHLSMedia {
  GstHLSMediaType mtype;
  gchar *group_id;
  gchar *name;
  gchar *lang;
  gchar *uri;
  gboolean is_default;
  gboolean autoselect;
  gboolean forced;

  GstM3U8 *playlist;            /* media playlist */

  gint ref_count;               /* ATOMIC */
};
</STRUCT>
<FUNCTION>
<NAME>gst_hls_media_ref</NAME>
<RETURNS>GstHLSMedia  * </RETURNS>
GstHLSMedia * media
</FUNCTION>
<FUNCTION>
<NAME>gst_hls_media_unref</NAME>
<RETURNS>void           </RETURNS>
GstHLSMedia * media
</FUNCTION>
<STRUCT>
<NAME>GstHLSVariantStream</NAME>
struct _GstHLSVariantStream {
  gchar *name;         /* This will be the "name" of the playlist, the original
                        * relative/absolute uri in a variant playlist */
  gchar *uri;
  gchar *codecs;
  gint bandwidth;
  gint program_id;
  gint width;
  gint height;
  gboolean iframe;

  gint refcount;       /* ATOMIC */

  GstM3U8 *m3u8;       /* media playlist */

  /* alternative renditions */
  gchar *media_groups[GST_HLS_N_MEDIA_TYPES];
  GList *media[GST_HLS_N_MEDIA_TYPES];
};
</STRUCT>
<FUNCTION>
<NAME>gst_hls_variant_stream_ref</NAME>
<RETURNS>GstHLSVariantStream  * </RETURNS>
GstHLSVariantStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_hls_variant_stream_unref</NAME>
<RETURNS>void                   </RETURNS>
GstHLSVariantStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_hls_variant_stream_is_live</NAME>
<RETURNS>gboolean               </RETURNS>
GstHLSVariantStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_hls_variant_find_matching_media</NAME>
<RETURNS>GstHLSMedia  *         </RETURNS>
GstHLSVariantStream  * stream, GstHLSMedia *media
</FUNCTION>
<STRUCT>
<NAME>GstHLSMasterPlaylist</NAME>
struct _GstHLSMasterPlaylist
{
  /* Available variant streams, sorted by bitrate (low -> high) */
  GList    *variants;
  GList    *iframe_variants;

  GstHLSVariantStream *default_variant;  /* first in the list */

  gint      version;                     /* EXT-X-VERSION */

  gint      refcount;                    /* ATOMIC */

  gboolean  is_simple;                   /* TRUE if simple main media playlist,
                                          * FALSE if variant playlist (either
                                          * way the variants list will be set) */

  /*< private > */
  gchar   *last_data;
};
</STRUCT>
<FUNCTION>
<NAME>gst_hls_master_playlist_new_from_data</NAME>
<RETURNS>GstHLSMasterPlaylist  * </RETURNS>
gchar       * data, const gchar * base_uri
</FUNCTION>
<FUNCTION>
<NAME>gst_hls_master_playlist_get_variant_for_bitrate</NAME>
<RETURNS>GstHLSVariantStream  *  </RETURNS>
GstHLSMasterPlaylist * playlist, GstHLSVariantStream  * current_variant, guint                  bitrate
</FUNCTION>
<FUNCTION>
<NAME>gst_hls_master_playlist_get_matching_variant</NAME>
<RETURNS>GstHLSVariantStream  *  </RETURNS>
GstHLSMasterPlaylist * playlist, GstHLSVariantStream  * current_variant
</FUNCTION>
<FUNCTION>
<NAME>gst_hls_master_playlist_unref</NAME>
<RETURNS>void                    </RETURNS>
GstHLSMasterPlaylist * playlist
</FUNCTION>
<STRUCT>
<NAME>GstM3U8Client</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_HLS_SINK</NAME>
#define GST_TYPE_HLS_SINK   (gst_hls_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_HLS_SINK</NAME>
#define GST_HLS_SINK(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_HLS_SINK,GstHlsSink))
</MACRO>
<MACRO>
<NAME>GST_HLS_SINK_CAST</NAME>
#define GST_HLS_SINK_CAST(obj)   ((GstHlsSink *) obj)
</MACRO>
<MACRO>
<NAME>GST_HLS_SINK_CLASS</NAME>
#define GST_HLS_SINK_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_HLS_SINK,GstHlsSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_HLS_SINK</NAME>
#define GST_IS_HLS_SINK(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_HLS_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_HLS_SINK_CLASS</NAME>
#define GST_IS_HLS_SINK_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_HLS_SINK))
</MACRO>
<STRUCT>
<NAME>GstHlsSink</NAME>
struct _GstHlsSink
{
  GstBin bin;

  GstPad *ghostpad;
  GstElement *multifilesink;
  gboolean elements_created;
  GstEvent *force_key_unit_event;

  gchar *location;
  gchar *playlist_location;
  gchar *playlist_root;
  guint playlist_length;
  GstM3U8Playlist *playlist;
  guint index;
  gint max_files;
  gint target_duration;
  GstSegment segment;
  gboolean waiting_fku;
  GstClockTime last_running_time;
};
</STRUCT>
<STRUCT>
<NAME>GstHlsSinkClass</NAME>
struct _GstHlsSinkClass
{
  GstBinClass bin_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_hls_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_hls_sink_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GSMENC</NAME>
#define GST_TYPE_GSMENC \
  (gst_gsmenc_get_type())
</MACRO>
<MACRO>
<NAME>GST_GSMENC</NAME>
#define GST_GSMENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GSMENC,GstGSMEnc))
</MACRO>
<MACRO>
<NAME>GST_GSMENC_CLASS</NAME>
#define GST_GSMENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GSMENC,GstGSMEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GSMENC</NAME>
#define GST_IS_GSMENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GSMENC))
</MACRO>
<MACRO>
<NAME>GST_IS_GSMENC_CLASS</NAME>
#define GST_IS_GSMENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GSMENC))
</MACRO>
<STRUCT>
<NAME>GstGSMEnc</NAME>
struct _GstGSMEnc
{
  GstAudioEncoder element;

  gsm state;
};
</STRUCT>
<STRUCT>
<NAME>GstGSMEncClass</NAME>
struct _GstGSMEncClass
{
  GstAudioEncoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gsmenc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GSMDEC</NAME>
#define GST_TYPE_GSMDEC \
  (gst_gsmdec_get_type())
</MACRO>
<MACRO>
<NAME>GST_GSMDEC</NAME>
#define GST_GSMDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GSMDEC,GstGSMDec))
</MACRO>
<MACRO>
<NAME>GST_GSMDEC_CLASS</NAME>
#define GST_GSMDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GSMDEC,GstGSMDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GSMDEC</NAME>
#define GST_IS_GSMDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GSMDEC))
</MACRO>
<MACRO>
<NAME>GST_IS_GSMDEC_CLASS</NAME>
#define GST_IS_GSMDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GSMDEC))
</MACRO>
<STRUCT>
<NAME>GstGSMDec</NAME>
struct _GstGSMDec
{
  GstAudioDecoder element;

  gsm state;
  gint use_wav49;
  gint needed;
};
</STRUCT>
<STRUCT>
<NAME>GstGSMDecClass</NAME>
struct _GstGSMDecClass
{
  GstAudioDecoderClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gsmdec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_CAT_DEFAULT</NAME>
#define GST_CAT_DEFAULT mssdemux_debug
</MACRO>
<MACRO>
<NAME>GST_TYPE_MSS_DEMUX</NAME>
#define GST_TYPE_MSS_DEMUX \
  (gst_mss_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_MSS_DEMUX</NAME>
#define GST_MSS_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MSS_DEMUX,GstMssDemux))
</MACRO>
<MACRO>
<NAME>GST_MSS_DEMUX_CLASS</NAME>
#define GST_MSS_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MSS_DEMUX,GstMssDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MSS_DEMUX</NAME>
#define GST_IS_MSS_DEMUX(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MSS_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_MSS_DEMUX_CLASS</NAME>
#define GST_IS_MSS_DEMUX_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MSS_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_MSS_DEMUX_CAST</NAME>
#define GST_MSS_DEMUX_CAST(obj) ((GstMssDemux *)(obj))
</MACRO>
<STRUCT>
<NAME>GstMssDemuxStream</NAME>
struct _GstMssDemuxStream {
  GstAdaptiveDemuxStream parent;

  GstMssStream *manifest_stream;
};
</STRUCT>
<STRUCT>
<NAME>GstMssDemux</NAME>
struct _GstMssDemux {
  GstAdaptiveDemux bin;

  /* pads */
  GstPad *sinkpad;

  GstMssManifest *manifest;
  gchar *base_url;

  guint n_videos;
  guint n_audios;

  /* properties */
  guint data_queue_max_size;
};
</STRUCT>
<STRUCT>
<NAME>GstMssDemuxClass</NAME>
struct _GstMssDemuxClass {
  GstAdaptiveDemuxClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mss_demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_MSS_FRAGMENT_FOURCC_MOOF</NAME>
#define GST_MSS_FRAGMENT_FOURCC_MOOF GST_MAKE_FOURCC('m','o','o','f')
</MACRO>
<MACRO>
<NAME>GST_MSS_FRAGMENT_FOURCC_MFHD</NAME>
#define GST_MSS_FRAGMENT_FOURCC_MFHD GST_MAKE_FOURCC('m','f','h','d')
</MACRO>
<MACRO>
<NAME>GST_MSS_FRAGMENT_FOURCC_TRAF</NAME>
#define GST_MSS_FRAGMENT_FOURCC_TRAF GST_MAKE_FOURCC('t','r','a','f')
</MACRO>
<MACRO>
<NAME>GST_MSS_FRAGMENT_FOURCC_TFHD</NAME>
#define GST_MSS_FRAGMENT_FOURCC_TFHD GST_MAKE_FOURCC('t','f','h','d')
</MACRO>
<MACRO>
<NAME>GST_MSS_FRAGMENT_FOURCC_TRUN</NAME>
#define GST_MSS_FRAGMENT_FOURCC_TRUN GST_MAKE_FOURCC('t','r','u','n')
</MACRO>
<MACRO>
<NAME>GST_MSS_FRAGMENT_FOURCC_UUID</NAME>
#define GST_MSS_FRAGMENT_FOURCC_UUID GST_MAKE_FOURCC('u','u','i','d')
</MACRO>
<MACRO>
<NAME>GST_MSS_FRAGMENT_FOURCC_MDAT</NAME>
#define GST_MSS_FRAGMENT_FOURCC_MDAT GST_MAKE_FOURCC('m','d','a','t')
</MACRO>
<ENUM>
<NAME>GstFragmentHeaderParserStatus</NAME>
typedef enum _GstFragmentHeaderParserStatus
{
  GST_MSS_FRAGMENT_HEADER_PARSER_INIT,
  GST_MSS_FRAGMENT_HEADER_PARSER_FINISHED
} GstFragmentHeaderParserStatus;
</ENUM>
<FUNCTION>
<NAME>gst_mss_fragment_parser_init</NAME>
<RETURNS>void  </RETURNS>
GstMssFragmentParser * parser
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_fragment_parser_clear</NAME>
<RETURNS>void  </RETURNS>
GstMssFragmentParser * parser
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_fragment_parser_add_buffer</NAME>
<RETURNS>gboolean  </RETURNS>
GstMssFragmentParser * parser, GstBuffer * buf
</FUNCTION>
<ENUM>
<NAME>GstMssStreamType</NAME>
typedef enum _GstMssStreamType {
  MSS_STREAM_TYPE_UNKNOWN = 0,
  MSS_STREAM_TYPE_VIDEO = 1,
  MSS_STREAM_TYPE_AUDIO = 2
} GstMssStreamType;
</ENUM>
<FUNCTION>
<NAME>gst_mss_manifest_new</NAME>
<RETURNS>GstMssManifest  * </RETURNS>
GstBuffer * data
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_free</NAME>
<RETURNS>void  </RETURNS>
GstMssManifest * manifest
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_get_streams</NAME>
<RETURNS>GSList  * </RETURNS>
GstMssManifest * manifest
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_get_timescale</NAME>
<RETURNS>guint64  </RETURNS>
GstMssManifest * manifest
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_get_duration</NAME>
<RETURNS>guint64  </RETURNS>
GstMssManifest * manifest
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_get_gst_duration</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstMssManifest * manifest
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_seek</NAME>
<RETURNS>void  </RETURNS>
GstMssManifest * manifest, gboolean forward, guint64 time
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_change_bitrate</NAME>
<RETURNS>gboolean  </RETURNS>
GstMssManifest *manifest, guint64 bitrate
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_get_current_bitrate</NAME>
<RETURNS>guint64  </RETURNS>
GstMssManifest * manifest
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_is_live</NAME>
<RETURNS>gboolean  </RETURNS>
GstMssManifest * manifest
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_get_dvr_window_length</NAME>
<RETURNS>gint64  </RETURNS>
GstMssManifest * manifest
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_get_look_ahead_fragments_count</NAME>
<RETURNS>gint  </RETURNS>
GstMssManifest * manifest
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_reload_fragments</NAME>
<RETURNS>void  </RETURNS>
GstMssManifest * manifest, GstBuffer * data
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_get_min_fragment_duration</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstMssManifest * manifest
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_get_protection_system_id</NAME>
<RETURNS>const gchar  * </RETURNS>
GstMssManifest * manifest
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_get_protection_data</NAME>
<RETURNS>const gchar  * </RETURNS>
GstMssManifest * manifest
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_get_live_seek_range</NAME>
<RETURNS>gboolean  </RETURNS>
GstMssManifest * manifest, gint64 * start, gint64 * stop
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_get_type</NAME>
<RETURNS>GstMssStreamType  </RETURNS>
GstMssStream *stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_get_caps</NAME>
<RETURNS>GstCaps  * </RETURNS>
GstMssStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_select_bitrate</NAME>
<RETURNS>gboolean  </RETURNS>
GstMssStream * stream, guint64 bitrate
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_get_current_bitrate</NAME>
<RETURNS>guint64  </RETURNS>
GstMssStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_set_active</NAME>
<RETURNS>void  </RETURNS>
GstMssStream * stream, gboolean active
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_get_timescale</NAME>
<RETURNS>guint64  </RETURNS>
GstMssStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_get_fragment_url</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstMssStream * stream, gchar ** url
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_get_fragment_gst_timestamp</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstMssStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_get_fragment_gst_duration</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstMssStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_has_next_fragment</NAME>
<RETURNS>gboolean  </RETURNS>
GstMssStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_advance_fragment</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstMssStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_regress_fragment</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstMssStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_seek</NAME>
<RETURNS>void  </RETURNS>
GstMssStream * stream, gboolean forward, GstSeekFlags flags, guint64 time, guint64 * final_time
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_get_lang</NAME>
<RETURNS>const gchar  * </RETURNS>
GstMssStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_type_name</NAME>
<RETURNS>const gchar  * </RETURNS>
GstMssStreamType streamtype
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_live_adapter_push</NAME>
<RETURNS>void  </RETURNS>
GstMssStream * stream, GstBuffer * buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_live_adapter_available</NAME>
<RETURNS>gsize  </RETURNS>
GstMssStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_manifest_live_adapter_take_buffer</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstMssStream * stream, gsize nbytes
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_fragment_parsing_needed</NAME>
<RETURNS>gboolean  </RETURNS>
GstMssStream * stream
</FUNCTION>
<FUNCTION>
<NAME>gst_mss_stream_parse_fragment</NAME>
<RETURNS>void  </RETURNS>
GstMssStream * stream, GstBuffer * buffer
</FUNCTION>
<STRUCT>
<NAME>GstMssManifest</NAME>
</STRUCT>
<STRUCT>
<NAME>GstMssStream</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_LADSPA_FILTER</NAME>
#define GST_TYPE_LADSPA_FILTER              (gst_ladspa_filter_get_type())
</MACRO>
<MACRO>
<NAME>GST_LADSPA_FILTER</NAME>
#define GST_LADSPA_FILTER(obj)              (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_LADSPA_FILTER,GstLADSPAFilter))
</MACRO>
<MACRO>
<NAME>GST_LADSPA_FILTER_CAST</NAME>
#define GST_LADSPA_FILTER_CAST(obj)         ((GstLADSPAFilter *) (obj))
</MACRO>
<MACRO>
<NAME>GST_LADSPA_FILTER_CLASS</NAME>
#define GST_LADSPA_FILTER_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_LADSPA_FILTER,GstLADSPAFilterClass))
</MACRO>
<MACRO>
<NAME>GST_LADSPA_FILTER_CLASS_CAST</NAME>
#define GST_LADSPA_FILTER_CLASS_CAST(klass) ((GstLADSPAFilterClass *) (klass))
</MACRO>
<MACRO>
<NAME>GST_LADSPA_FILTER_GET_CLASS</NAME>
#define GST_LADSPA_FILTER_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_LADSPA_FILTER,GstLADSPAFilterClass))
</MACRO>
<MACRO>
<NAME>GST_IS_LADSPA_FILTER</NAME>
#define GST_IS_LADSPA_FILTER(obj)           (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_LADSPA_FILTER))
</MACRO>
<MACRO>
<NAME>GST_IS_LADSPA_FILTER_CLASS</NAME>
#define GST_IS_LADSPA_FILTER_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_LADSPA_FILTER))
</MACRO>
<STRUCT>
<NAME>GstLADSPAFilter</NAME>
struct _GstLADSPAFilter
{
  GstAudioFilter parent;

  GstLADSPA ladspa;
};
</STRUCT>
<STRUCT>
<NAME>GstLADSPAFilterClass</NAME>
struct _GstLADSPAFilterClass
{
  GstAudioFilterClass parent_class;

  GstLADSPAClass ladspa;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ladspa_filter_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ladspa_register_filter_element</NAME>
<RETURNS>void </RETURNS>
GstPlugin * plugin, GstStructure *ladspa_meta
</FUNCTION>
<FUNCTION>
<NAME>gst_my_audio_filter_class_add_pad_templates</NAME>
<RETURNS>void </RETURNS>
GstAudioFilterClass * audio_class, GstCaps * srccaps, GstCaps * sinkcaps
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_LADSPA_SOURCE</NAME>
#define GST_TYPE_LADSPA_SOURCE              (gst_ladspa_source_get_type())
</MACRO>
<MACRO>
<NAME>GST_LADSPA_SOURCE</NAME>
#define GST_LADSPA_SOURCE(obj)              (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_LADSPA_SOURCE,GstLADSPASource))
</MACRO>
<MACRO>
<NAME>GST_LADSPA_SOURCE_CAST</NAME>
#define GST_LADSPA_SOURCE_CAST(obj)         ((GstLADSPASource *) (obj))
</MACRO>
<MACRO>
<NAME>GST_LADSPA_SOURCE_CLASS</NAME>
#define GST_LADSPA_SOURCE_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_LADSPA_SOURCE,GstLADSPASourceClass))
</MACRO>
<MACRO>
<NAME>GST_LADSPA_SOURCE_CLASS_CAST</NAME>
#define GST_LADSPA_SOURCE_CLASS_CAST(klass) ((GstLADSPASourceClass *) (klass))
</MACRO>
<MACRO>
<NAME>GST_LADSPA_SOURCE_GET_CLASS</NAME>
#define GST_LADSPA_SOURCE_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_LADSPA_SOURCE,GstLADSPASourceClass))
</MACRO>
<MACRO>
<NAME>GST_IS_LADSPA_SOURCE</NAME>
#define GST_IS_LADSPA_SOURCE(obj)           (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_LADSPA_SOURCE))
</MACRO>
<MACRO>
<NAME>GST_IS_LADSPA_SOURCE_CLASS</NAME>
#define GST_IS_LADSPA_SOURCE_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_LADSPA_SOURCE))
</MACRO>
<STRUCT>
<NAME>GstLADSPASource</NAME>
struct _GstLADSPASource
{
  GstBaseSrc parent;

  GstLADSPA ladspa;

  /* audio parameters */
  GstAudioInfo info;
  gint samples_per_buffer;

  /*< private > */
  gboolean tags_pushed;              /* send tags just once ? */
  GstClockTimeDiff timestamp_offset; /* base offset */
  GstClockTime next_time;            /* next timestamp */
  gint64 next_sample;                /* next sample to send */
  gint64 next_byte;                  /* next byte to send */
  gint64 sample_stop;
  gboolean check_seek_stop;
  gboolean eos_reached;
  gint generate_samples_per_buffer;  /* used to generate a partial buffer */
  gboolean can_activate_pull;
  gboolean reverse;                  /* play backwards */
};
</STRUCT>
<STRUCT>
<NAME>GstLADSPASourceClass</NAME>
struct _GstLADSPASourceClass
{
  GstBaseSrcClass parent_class;

  GstLADSPAClass ladspa;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ladspa_source_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ladspa_register_source_element</NAME>
<RETURNS>void </RETURNS>
GstPlugin * plugin, GstStructure *ladspa_meta
</FUNCTION>
<FUNCTION>
<NAME>gst_my_base_source_class_add_pad_template</NAME>
<RETURNS>void </RETURNS>
GstBaseSrcClass * base_class, GstCaps * srccaps
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_LADSPA_SINK</NAME>
#define GST_TYPE_LADSPA_SINK              (gst_ladspa_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_LADSPA_SINK</NAME>
#define GST_LADSPA_SINK(obj)              (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_LADSPA_SINK,GstLADSPASink))
</MACRO>
<MACRO>
<NAME>GST_LADSPA_SINK_CAST</NAME>
#define GST_LADSPA_SINK_CAST(obj)         ((GstLADSPASink *) (obj))
</MACRO>
<MACRO>
<NAME>GST_LADSPA_SINK_CLASS</NAME>
#define GST_LADSPA_SINK_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_LADSPA_SINK,GstLADSPASinkClass))
</MACRO>
<MACRO>
<NAME>GST_LADSPA_SINK_CLASS_CAST</NAME>
#define GST_LADSPA_SINK_CLASS_CAST(klass) ((GstLADSPASinkClass *) (klass))
</MACRO>
<MACRO>
<NAME>GST_LADSPA_SINK_GET_CLASS</NAME>
#define GST_LADSPA_SINK_GET_CLASS(obj)    (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_LADSPA_SINK,GstLADSPASinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_LADSPA_SINK</NAME>
#define GST_IS_LADSPA_SINK(obj)           (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_LADSPA_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_LADSPA_SINK_CLASS</NAME>
#define GST_IS_LADSPA_SINK_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_LADSPA_SINK))
</MACRO>
<STRUCT>
<NAME>GstLADSPASink</NAME>
struct _GstLADSPASink
{
  GstBaseSink parent;

  GstLADSPA ladspa;

  GstAudioInfo info;

  gint num_buffers;
  gint num_buffers_left;
};
</STRUCT>
<STRUCT>
<NAME>GstLADSPASinkClass</NAME>
struct _GstLADSPASinkClass
{
  GstBaseSinkClass parent_class;

  GstLADSPAClass ladspa;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ladspa_sink_get_type</NAME>
<RETURNS>GType </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ladspa_register_sink_element</NAME>
<RETURNS>void </RETURNS>
GstPlugin * plugin, GstStructure *ladspa_meta
</FUNCTION>
<FUNCTION>
<NAME>gst_my_base_sink_class_add_pad_template</NAME>
<RETURNS>void </RETURNS>
GstBaseSinkClass * base_class, GstCaps * sinkcaps
</FUNCTION>
<STRUCT>
<NAME>GstLADSPA</NAME>
struct _GstLADSPA
{
  GstLADSPAClass *klass;

  LADSPA_Handle *handle;
  gboolean activated;
  unsigned long rate;

  struct
  {
    struct
    {
      LADSPA_Data *in;
      LADSPA_Data *out;
    } control;

    struct
    {
      LADSPA_Data **in;
      LADSPA_Data **out;
    } audio;
  } ports;
};
</STRUCT>
<STRUCT>
<NAME>GstLADSPAClass</NAME>
struct _GstLADSPAClass
{
  guint properties;

  GModule *plugin;
  const LADSPA_Descriptor *descriptor;

  struct
  {
    struct
    {
      guint in;
      guint out;
    } control;

    struct
    {
      guint in;
      guint out;
    } audio;
  } count;

  struct
  {
    struct
    {
      unsigned long *in;
      unsigned long *out;
    } control;

    struct
    {
      unsigned long *in;
      unsigned long *out;
    } audio;
  } map;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ladspa_transform</NAME>
<RETURNS>gboolean </RETURNS>
GstLADSPA * ladspa, guint8 * outdata, guint samples, guint8 * indata
</FUNCTION>
<FUNCTION>
<NAME>gst_ladspa_setup</NAME>
<RETURNS>gboolean </RETURNS>
GstLADSPA * ladspa, unsigned long rate
</FUNCTION>
<FUNCTION>
<NAME>gst_ladspa_cleanup</NAME>
<RETURNS>gboolean </RETURNS>
GstLADSPA * ladspa
</FUNCTION>
<FUNCTION>
<NAME>gst_ladspa_object_set_property</NAME>
<RETURNS>void </RETURNS>
GstLADSPA * ladspa, GObject * object, guint prop_id, const GValue * value, GParamSpec * pspec
</FUNCTION>
<FUNCTION>
<NAME>gst_ladspa_object_get_property</NAME>
<RETURNS>void </RETURNS>
GstLADSPA * ladspa, GObject * object, guint prop_id, GValue * value, GParamSpec * pspec
</FUNCTION>
<FUNCTION>
<NAME>gst_ladspa_object_class_install_properties</NAME>
<RETURNS>void </RETURNS>
GstLADSPAClass * ladspa_class, GObjectClass * object_class, guint offset
</FUNCTION>
<FUNCTION>
<NAME>gst_ladspa_element_class_set_metadata</NAME>
<RETURNS>void </RETURNS>
GstLADSPAClass * ladspa_class, GstElementClass * elem_class, const gchar * ladspa_class_tags
</FUNCTION>
<FUNCTION>
<NAME>gst_ladspa_filter_type_class_add_pad_templates</NAME>
<RETURNS>void </RETURNS>
GstLADSPAClass * ladspa_class, GstAudioFilterClass * audio_class
</FUNCTION>
<FUNCTION>
<NAME>gst_ladspa_source_type_class_add_pad_template</NAME>
<RETURNS>void </RETURNS>
GstLADSPAClass * ladspa_class, GstBaseSrcClass * audio_class
</FUNCTION>
<FUNCTION>
<NAME>gst_ladspa_sink_type_class_add_pad_template</NAME>
<RETURNS>void </RETURNS>
GstLADSPAClass * ladspa_class, GstBaseSinkClass * base_class
</FUNCTION>
<FUNCTION>
<NAME>gst_ladspa_init</NAME>
<RETURNS>void </RETURNS>
GstLADSPA * ladspa, GstLADSPAClass * ladspa_class
</FUNCTION>
<FUNCTION>
<NAME>gst_ladspa_finalize</NAME>
<RETURNS>void </RETURNS>
GstLADSPA * ladspa
</FUNCTION>
<FUNCTION>
<NAME>gst_ladspa_class_init</NAME>
<RETURNS>void </RETURNS>
GstLADSPAClass * ladspa_class, GType type
</FUNCTION>
<FUNCTION>
<NAME>gst_ladspa_class_finalize</NAME>
<RETURNS>void </RETURNS>
GstLADSPAClass * ladspa_class
</FUNCTION>
<FUNCTION>
<NAME>ladspa_register_element</NAME>
<RETURNS>void </RETURNS>
GstPlugin * plugin, GType parent_type, const GTypeInfo * info, GstStructure * ladspa_meta
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TELETEXTDEC</NAME>
#define GST_TYPE_TELETEXTDEC \
  (gst_teletextdec_get_type())
</MACRO>
<MACRO>
<NAME>GST_TELETEXTDEC</NAME>
#define GST_TELETEXTDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TELETEXTDEC,GstTeletextDec))
</MACRO>
<MACRO>
<NAME>GST_TELETEXTDEC_CLASS</NAME>
#define GST_TELETEXTDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TELETEXTDEC,GstTeletextDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TELETEXTDEC</NAME>
#define GST_IS_TELETEXTDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TELETEXTDEC))
</MACRO>
<MACRO>
<NAME>GST_IS_TELETEXTDEC_CLASS</NAME>
#define GST_IS_TELETEXTDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TELETEXTDEC))
</MACRO>
<USER_FUNCTION>
<NAME>GstTeletextExportFunc</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstTeletextDec * teletext,
    vbi_page * page, GstBuffer ** buf
</USER_FUNCTION>
<STRUCT>
<NAME>GstTeletextDec</NAME>
struct _GstTeletextDec
{
  GstElement element;

  GstPad *sinkpad;
  GstPad *srcpad;
  GstEvent *segment;

  GstClockTime in_timestamp;
  GstClockTime in_duration;
  gint rate_numerator;
  gint rate_denominator;

  /* Props */
  gint pageno;
  gint subno;
  gboolean subtitles_mode;
  gchar *subtitles_template;
  gchar *font_description;

  vbi_decoder *decoder;

  GQueue *queue;
  GMutex queue_lock;

  GstTeletextFrame *frame;
  float last_ts;

  GstTeletextExportFunc export_func;

  /* negotiated size of the output image in RGBA mode. */
  guint width;
  guint height;

  /* buffer pool received from the peer pad - used in RGBA output only. */
  GstBufferPool *buf_pool;
};
</STRUCT>
<STRUCT>
<NAME>GstTeletextFrame</NAME>
struct _GstTeletextFrame
{
  vbi_sliced *sliced_begin;
  vbi_sliced *sliced_end;
  vbi_sliced *current_slice;

  guint last_field;
  guint last_field_line;
  guint last_frame_line;
};
</STRUCT>
<STRUCT>
<NAME>GstTeletextDecClass</NAME>
struct _GstTeletextDecClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_teletextdec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FLUID_DEC</NAME>
#define GST_TYPE_FLUID_DEC \
  (gst_fluid_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_FLUID_DEC</NAME>
#define GST_FLUID_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FLUID_DEC,GstFluidDec))
</MACRO>
<MACRO>
<NAME>GST_FLUID_DEC_CLASS</NAME>
#define GST_FLUID_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FLUID_DEC,GstFluidDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FLUID_DEC</NAME>
#define GST_IS_FLUID_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FLUID_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_FLUID_DEC_CLASS</NAME>
#define GST_IS_FLUID_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FLUID_DEC))
</MACRO>
<STRUCT>
<NAME>GstFluidDec</NAME>
struct _GstFluidDec
{
  GstElement element;

  GstPad *sinkpad, *srcpad;

  /* properties */
  gchar *soundfont;
  gboolean synth_chorus;
  gboolean synth_reverb;
  gdouble synth_gain;
  gint synth_polyphony;

  fluid_settings_t* settings;
  fluid_synth_t* synth;
  int sf;

  GstSegment segment;
  gboolean discont;
  GstClockTime last_pts;
  guint64 last_sample;
};
</STRUCT>
<STRUCT>
<NAME>GstFluidDecClass</NAME>
struct _GstFluidDecClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_fluid_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>VK_PROTOTYPES</NAME>
#define VK_PROTOTYPES
</MACRO>
<MACRO>
<NAME>VK_USE_PLATFORM_XCB_KHR</NAME>
#define VK_USE_PLATFORM_XCB_KHR
</MACRO>
<MACRO>
<NAME>VK_USE_PLATFORM_WAYLAND_KHR</NAME>
#define VK_USE_PLATFORM_WAYLAND_KHR
</MACRO>
<MACRO>
<NAME>GST_TYPE_VULKAN_MEMORY_ALLOCATOR</NAME>
#define GST_TYPE_VULKAN_MEMORY_ALLOCATOR (gst_vulkan_memory_allocator_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_vulkan_memory_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_IS_VULKAN_MEMORY_ALLOCATOR</NAME>
#define GST_IS_VULKAN_MEMORY_ALLOCATOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_VULKAN_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_MEMORY_ALLOCATOR_CLASS</NAME>
#define GST_IS_VULKAN_MEMORY_ALLOCATOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_VULKAN_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_MEMORY_ALLOCATOR_GET_CLASS</NAME>
#define GST_VULKAN_MEMORY_ALLOCATOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_VULKAN_MEMORY_ALLOCATOR, GstVulkanMemoryAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_MEMORY_ALLOCATOR</NAME>
#define GST_VULKAN_MEMORY_ALLOCATOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_VULKAN_MEMORY_ALLOCATOR, GstVulkanMemoryAllocator))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_MEMORY_ALLOCATOR_CLASS</NAME>
#define GST_VULKAN_MEMORY_ALLOCATOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_VULKAN_MEMORY_ALLOCATOR, GstVulkanMemoryAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_MEMORY_ALLOCATOR_CAST</NAME>
#define GST_VULKAN_MEMORY_ALLOCATOR_CAST(obj)            ((GstVulkanMemoryAllocator *)(obj))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_MEMORY_ALLOCATOR_NAME</NAME>
#define GST_VULKAN_MEMORY_ALLOCATOR_NAME "Vulkan"
</MACRO>
<STRUCT>
<NAME>GstVulkanMemory</NAME>
struct _GstVulkanMemory
{
  GstMemory                 mem;

  GstVulkanDevice          *device;

  VkDeviceMemory            mem_ptr;

  /* <protected> */
  GMutex                    lock;
  guint                     map_count;

  /* <private> */
  GDestroyNotify            notify;
  gpointer                  user_data;

  VkMemoryAllocateInfo      alloc_info;
  VkMemoryPropertyFlags     properties;

  /* we need our own offset because GstMemory's is used to offset into the
   * mapped pointer which when suballocating, we need to avoid.  This in
   * relation to the root memory */
  guint64                   vk_offset;
  gboolean                  wrapped;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanMemoryAllocator</NAME>
struct _GstVulkanMemoryAllocator
{
  GstAllocator parent;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanMemoryAllocatorClass</NAME>
struct _GstVulkanMemoryAllocatorClass
{
  GstAllocatorClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_memory_init_once</NAME>
<RETURNS>void             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_is_vulkan_memory</NAME>
<RETURNS>gboolean         </RETURNS>
GstMemory * mem
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_memory_alloc</NAME>
<RETURNS>GstMemory  *     </RETURNS>
GstVulkanDevice * device, guint32 memory_type_index, GstAllocationParams * params, gsize size, VkMemoryPropertyFlags mem_prop_flags
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_memory_find_memory_type_index_with_type_properties</NAME>
<RETURNS>gboolean         </RETURNS>
GstVulkanDevice * device, guint32 typeBits, VkMemoryPropertyFlags properties, guint32 * typeIndex
</FUNCTION>
<STRUCT>
<NAME>GstVulkanBufferMemory</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanBufferMemoryAllocator</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanBufferMemoryAllocatorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanBufferPool</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanBufferPoolClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanBufferPoolPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanDevice</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanDeviceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanDevicePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanDisplay</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanDisplayClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanDisplayPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanFence</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanImageMemory</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanImageMemoryAllocator</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanImageMemoryAllocatorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanInstance</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanInstanceClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanInstancePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanMemory</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanMemoryAllocator</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanMemoryAllocatorClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanQueue</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanQueueClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanSwapper</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanSwapperClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanSwapperPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanTrash</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanWindow</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanWindowClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVulkanWindowPrivate</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_buffer_pool_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_BUFFER_POOL</NAME>
#define GST_TYPE_VULKAN_BUFFER_POOL      (gst_vulkan_buffer_pool_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_BUFFER_POOL</NAME>
#define GST_IS_VULKAN_BUFFER_POOL(obj)   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_VULKAN_BUFFER_POOL))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_BUFFER_POOL</NAME>
#define GST_VULKAN_BUFFER_POOL(obj)      (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_VULKAN_BUFFER_POOL, GstVulkanBufferPool))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_BUFFER_POOL_CAST</NAME>
#define GST_VULKAN_BUFFER_POOL_CAST(obj) ((GstVulkanBufferPool*)(obj))
</MACRO>
<STRUCT>
<NAME>GstVulkanBufferPool</NAME>
struct _GstVulkanBufferPool
{
  GstBufferPool bufferpool;

  GstVulkanDevice *device;

  GstVulkanBufferPoolPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanBufferPoolClass</NAME>
struct _GstVulkanBufferPoolClass
{
  GstBufferPoolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_buffer_pool_new</NAME>
<RETURNS>GstBufferPool  *</RETURNS>
GstVulkanDevice * device
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_BUFFER_MEMORY_ALLOCATOR</NAME>
#define GST_TYPE_VULKAN_BUFFER_MEMORY_ALLOCATOR (gst_vulkan_buffer_memory_allocator_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_vulkan_buffer_memory_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_IS_VULKAN_BUFFER_MEMORY_ALLOCATOR</NAME>
#define GST_IS_VULKAN_BUFFER_MEMORY_ALLOCATOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_VULKAN_BUFFER_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_BUFFER_MEMORY_ALLOCATOR_CLASS</NAME>
#define GST_IS_VULKAN_BUFFER_MEMORY_ALLOCATOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_VULKAN_BUFFER_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_BUFFER_MEMORY_ALLOCATOR_GET_CLASS</NAME>
#define GST_VULKAN_BUFFER_MEMORY_ALLOCATOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_VULKAN_MEMORY_ALLOCATOR, GstVulkanBufferMemoryAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_BUFFER_MEMORY_ALLOCATOR</NAME>
#define GST_VULKAN_BUFFER_MEMORY_ALLOCATOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_VULKAN_MEMORY_ALLOCATOR, GstVulkanBufferMemoryAllocator))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_BUFFER_MEMORY_ALLOCATOR_CLASS</NAME>
#define GST_VULKAN_BUFFER_MEMORY_ALLOCATOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_VULKAN_MEMORY_ALLOCATOR, GstVulkanBufferMemoryAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_BUFFER_MEMORY_ALLOCATOR_CAST</NAME>
#define GST_VULKAN_BUFFER_MEMORY_ALLOCATOR_CAST(obj)            ((GstVulkanBufferMemoryAllocator *)(obj))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_BUFFER_MEMORY_ALLOCATOR_NAME</NAME>
#define GST_VULKAN_BUFFER_MEMORY_ALLOCATOR_NAME "VulkanBuffer"
</MACRO>
<MACRO>
<NAME>GST_CAPS_FEATURE_MEMORY_VULKAN_BUFFER</NAME>
#define GST_CAPS_FEATURE_MEMORY_VULKAN_BUFFER "memory:" GST_VULKAN_BUFFER_MEMORY_ALLOCATOR_NAME
</MACRO>
<STRUCT>
<NAME>GstVulkanBufferMemory</NAME>
struct _GstVulkanBufferMemory
{
  GstMemory parent;

  GstVulkanDevice * device;

  VkBuffer buffer;
  VkBufferView view;
  GstVulkanMemory *vk_mem;

  VkMemoryRequirements requirements;
  VkBufferUsageFlags usage;

  GMutex lock;
  gboolean wrapped;
  GDestroyNotify notify;
  gpointer user_data;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanBufferMemoryAllocator</NAME>
struct _GstVulkanBufferMemoryAllocator
{
  GstAllocator parent;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanBufferMemoryAllocatorClass</NAME>
struct _GstVulkanBufferMemoryAllocatorClass
{
  GstAllocatorClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_buffer_memory_init_once</NAME>
<RETURNS>void             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_is_vulkan_buffer_memory</NAME>
<RETURNS>gboolean         </RETURNS>
GstMemory * mem
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_buffer_memory_alloc</NAME>
<RETURNS>GstMemory  *     </RETURNS>
GstVulkanDevice * device, VkFormat format, gsize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags mem_prop_flags
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_buffer_memory_wrapped</NAME>
<RETURNS>GstMemory  *     </RETURNS>
GstVulkanDevice * device, VkBuffer buffer, VkFormat format, VkBufferUsageFlags usage, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_WINDOW</NAME>
#define GST_TYPE_VULKAN_WINDOW         (gst_vulkan_window_get_type())
</MACRO>
<MACRO>
<NAME>GST_VULKAN_WINDOW</NAME>
#define GST_VULKAN_WINDOW(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_VULKAN_WINDOW, GstVulkanWindow))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_WINDOW_CLASS</NAME>
#define GST_VULKAN_WINDOW_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GST_TYPE_VULKAN_WINDOW, GstVulkanWindowClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_WINDOW</NAME>
#define GST_IS_VULKAN_WINDOW(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_VULKAN_WINDOW))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_WINDOW_CLASS</NAME>
#define GST_IS_VULKAN_WINDOW_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_VULKAN_WINDOW))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_WINDOW_GET_CLASS</NAME>
#define GST_VULKAN_WINDOW_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_VULKAN_WINDOW, GstVulkanWindowClass))
</MACRO>
<FUNCTION>
<NAME>gst_vulkan_window_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_VULKAN_WINDOW_LOCK</NAME>
#define GST_VULKAN_WINDOW_LOCK(w) g_mutex_lock(&GST_VULKAN_WINDOW(w)->lock)
</MACRO>
<MACRO>
<NAME>GST_VULKAN_WINDOW_UNLOCK</NAME>
#define GST_VULKAN_WINDOW_UNLOCK(w) g_mutex_unlock(&GST_VULKAN_WINDOW(w)->lock)
</MACRO>
<MACRO>
<NAME>GST_VULKAN_WINDOW_GET_LOCK</NAME>
#define GST_VULKAN_WINDOW_GET_LOCK(w) (&GST_VULKAN_WINDOW(w)->lock)
</MACRO>
<MACRO>
<NAME>GST_VULKAN_WINDOW_ERROR</NAME>
#define GST_VULKAN_WINDOW_ERROR (gst_vulkan_window_error_quark ())
</MACRO>
<FUNCTION>
<NAME>gst_vulkan_window_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstVulkanWindowError</NAME>
typedef enum
{
  GST_VULKAN_WINDOW_ERROR_FAILED,
  GST_VULKAN_WINDOW_ERROR_OLD_LIBS,
  GST_VULKAN_WINDOW_ERROR_RESOURCE_UNAVAILABLE,
} GstVulkanWindowError;
</ENUM>
<STRUCT>
<NAME>GstVulkanWindow</NAME>
struct _GstVulkanWindow {
  /*< private >*/
  GstObject parent;

  GstVulkanDisplay       *display;

  GMutex                  lock;

  GstVulkanWindowPrivate *priv;

  gpointer                _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanWindowClass</NAME>
struct _GstVulkanWindowClass {
  GstObjectClass parent_class;

  gboolean      (*open)                         (GstVulkanWindow *window,
                                                 GError **error);
  void          (*close)                        (GstVulkanWindow *window);

  VkSurfaceKHR  (*get_surface)                  (GstVulkanWindow *window,
                                                 GError **error);
  gboolean      (*get_presentation_support)     (GstVulkanWindow *window,
                                                 GstVulkanDevice *device,
                                                 guint32 queue_family_idx);

  /*< private >*/
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_window_new</NAME>
<RETURNS>GstVulkanWindow  *  </RETURNS>
GstVulkanDisplay *display
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_window_get_display</NAME>
<RETURNS>GstVulkanDisplay  * </RETURNS>
GstVulkanWindow *window
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_window_get_surface</NAME>
<RETURNS>VkSurfaceKHR        </RETURNS>
GstVulkanWindow *window, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_window_get_presentation_support</NAME>
<RETURNS>gboolean            </RETURNS>
GstVulkanWindow *window, GstVulkanDevice *device, guint32 queue_family_idx
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_window_open</NAME>
<RETURNS>gboolean            </RETURNS>
GstVulkanWindow *window, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_window_close</NAME>
<RETURNS>void                </RETURNS>
GstVulkanWindow *window
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_window_resize</NAME>
<RETURNS>void                </RETURNS>
GstVulkanWindow *window, gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_window_redraw</NAME>
<RETURNS>void                </RETURNS>
GstVulkanWindow *window
</FUNCTION>
<MACRO>
<NAME>GST_VK_STRUCT_1</NAME>
#define GST_VK_STRUCT_1(a) \
  { a }
</MACRO>
<MACRO>
<NAME>GST_VK_STRUCT_2</NAME>
#define GST_VK_STRUCT_2(a, b) \
  { a, b }
</MACRO>
<MACRO>
<NAME>GST_VK_STRUCT_3</NAME>
#define GST_VK_STRUCT_3(a, b, c) \
  { a, b, c }
</MACRO>
<MACRO>
<NAME>GST_VK_STRUCT_4</NAME>
#define GST_VK_STRUCT_4(a, b, c, d) \
  { a, b, c, d }
</MACRO>
<MACRO>
<NAME>GST_VK_STRUCT_5</NAME>
#define GST_VK_STRUCT_5(a, b, c, d, e) \
  { a, b, c, d, e }
</MACRO>
<MACRO>
<NAME>GST_VK_STRUCT_6</NAME>
#define GST_VK_STRUCT_6(a, b, c, d, e, f) \
  { a, b, c, d, e, f }
</MACRO>
<MACRO>
<NAME>GST_VK_STRUCT_7</NAME>
#define GST_VK_STRUCT_7(a, b, c, d, e, f, g) \
  { a, b, c, d, e, f, g }
</MACRO>
<MACRO>
<NAME>GST_VK_STRUCT_8</NAME>
#define GST_VK_STRUCT_8(a, b, c, d, e, f, g, h) \
  { a, b, c, d, e, f, g, h }
</MACRO>
<MACRO>
<NAME>GST_VK_BUFFER_IMAGE_COPY_INIT</NAME>
#define GST_VK_BUFFER_IMAGE_COPY_INIT GST_VK_STRUCT_6
</MACRO>
<MACRO>
<NAME>GST_VK_BUFFER_IMAGE_COPY</NAME>
#define GST_VK_BUFFER_IMAGE_COPY(info,bufferOffset_,bufferRowLength_,bufferImageHeight_,imageSubresourceLayers_,imageOffset_,imageExtent_) \
  G_STMT_START { \
    VkImageSubresourceLayers sub = imageSubresourceLayers_; \
    VkOffset3D offset = imageOffset_; \
    VkExtent3D extent = imageExtent_; \
    VkBufferImageCopy tmp = GST_VK_BUFFER_IMAGE_COPY_INIT(bufferOffset_,bufferRowLength_,bufferImageHeight_,sub,offset,extent); \
    (region) = tmp; \
  } G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_VK_COMPONENT_MAPPING_INIT</NAME>
#define GST_VK_COMPONENT_MAPPING_INIT GST_VK_STRUCT_4
</MACRO>
<MACRO>
<NAME>GST_VK_COMPONENT_MAPPING</NAME>
#define GST_VK_COMPONENT_MAPPING(component, r_, g_, b_, a_) \
  G_STMT_START { \
    VkComponentMapping tmp = GST_VK_COMPONENT_MAPPING_INIT(r_, g_, b_, a_); \
    (component) = tmp; \
  } G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_VK_EXTENT3D_INIT</NAME>
#define GST_VK_EXTENT3D_INIT GST_VK_STRUCT_3
</MACRO>
<MACRO>
<NAME>GST_VK_EXTENT3D</NAME>
#define GST_VK_EXTENT3D(extent,w,h,d) \
  G_STMT_START { \
    VkExtent3D tmp = GST_VK_EXTENT3D_INIT(w,h,d); \
    (extent) = tmp; \
  } G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_VK_IMAGE_COPY_INIT</NAME>
#define GST_VK_IMAGE_COPY_INIT GST_VK_STRUCT_5
</MACRO>
<MACRO>
<NAME>GST_VK_IMAGE_COPY</NAME>
#define GST_VK_IMAGE_COPY(copy,srcSubresource_,srcOffset_,dstSubresource_,dstOffset_,extent_) \
  G_STMT_START { \
    VkImageSubresourceLayers src_res = srcSubresource_; \
    VkOffset3D src_offset = srcOffset_; \
    VkImageSubresourceLayers dst_res = dstSubresource_; \
    VkOffset3D dst_offset = dstOffset_; \
    VkExtent3D ext = extent_; \
    VkImageCopy tmp = GST_VK_IMAGE_COPY_INIT(src_res,src_offset,dst_res,dst_offset,ext); \
    (copy) = tmp; \
  } G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_VK_IMAGE_BLIT_INIT</NAME>
#define GST_VK_IMAGE_BLIT_INIT GST_VK_STRUCT_6
</MACRO>
<MACRO>
<NAME>GST_VK_IMAGE_BLIT</NAME>
#define GST_VK_IMAGE_BLIT(blit,srcSubresource_,srcOffset_,srcExtent_,dstSubresource_,dstOffset_,dstExtent_) \
  G_STMT_START { \
    VkImageSubresourceLayers src_res = srcSubresource_; \
    VkOffset3D src_offset = srcOffset; \
    VkExtent3D src_ext = srcExtent_; \
    VkImageSubresourceLayers dst_res = dstSubresource_; \
    VkOffset3D dst_offset = dstSubresource_; \
    VkExtent3D dst_ext = dstExtent_; \
    VkImageBlit tmp = GST_VK_IMAGE_BLIT_INIT(src_res, src_offset, src_ext, dst_res, dst_offset, dst_ext); \
    (blit) = tmp; \
  } G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_VK_IMAGE_SUBRESOURCE_INIT</NAME>
#define GST_VK_IMAGE_SUBRESOURCE_INIT GST_VK_STRUCT_3
</MACRO>
<MACRO>
<NAME>GST_VK_IMAGE_SUBRESOURCE</NAME>
#define GST_VK_IMAGE_SUBRESOURCE(subresource,aspectMast,mipLevel,arrayLayer) \
  G_STMT_START { \
    VkImageSubresource tmp = GST_VK_IMAGE_SUBRESOURCE_INIT(aspectMast,mipLevel,arrayLayer); \
    (subresource) = tmp; \
  } G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_VK_IMAGE_SUBRESOURCE_LAYERS_INIT</NAME>
#define GST_VK_IMAGE_SUBRESOURCE_LAYERS_INIT GST_VK_STRUCT_4
</MACRO>
<MACRO>
<NAME>GST_VK_IMAGE_SUBRESOURCE_LAYERS</NAME>
#define GST_VK_IMAGE_SUBRESOURCE_LAYERS(res,aspect_,mip,base_layer,layer_count) \
  G_STMT_START { \
    VkImageSubresourceLayers tmp = GST_VK_IMAGE_SUBRESOURCE_LAYERS_INIT(aspect_,mip,base_layer,layer_count); \
    (res) = tmp; \
  } G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_VK_IMAGE_SUBRESOURCE_RANGE_INIT</NAME>
#define GST_VK_IMAGE_SUBRESOURCE_RANGE_INIT GST_VK_STRUCT_5
</MACRO>
<MACRO>
<NAME>GST_VK_IMAGE_SUBRESOURCE_RANGE</NAME>
#define GST_VK_IMAGE_SUBRESOURCE_RANGE(range, aspect, mip_lvl, mip_lvl_count, array, layer_count) \
  G_STMT_START { \
    VkImageSubresourceRange tmp = GST_VK_IMAGE_SUBRESOURCE_RANGE_INIT(aspect,mip_lvl,mip_lvl_count,array,layer_count); \
    (range) = tmp; \
  } G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_VK_OFFSET3D_INIT</NAME>
#define GST_VK_OFFSET3D_INIT GST_VK_STRUCT_3
</MACRO>
<MACRO>
<NAME>GST_VK_OFFSET3D</NAME>
#define GST_VK_OFFSET3D(offset,x_,y_,z_) \
  G_STMT_START { \
    VkOffset3D tmp = GST_VK_OFFSET3D_INIT (x_,y_,z_); \
    (offset) = tmp; \
  } G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_VULKAN_ERROR</NAME>
#define GST_VULKAN_ERROR (gst_vulkan_error_quark ())
</MACRO>
<FUNCTION>
<NAME>gst_vulkan_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_error_to_g_error</NAME>
<RETURNS>VkResult  </RETURNS>
VkResult result, GError ** error, const char * format, ...
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_DEVICE</NAME>
#define GST_TYPE_VULKAN_DEVICE         (gst_vulkan_device_get_type())
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DEVICE</NAME>
#define GST_VULKAN_DEVICE(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_VULKAN_DEVICE, GstVulkanDevice))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DEVICE_CLASS</NAME>
#define GST_VULKAN_DEVICE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GST_TYPE_VULKAN_DEVICE, GstVulkanDeviceClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_DEVICE</NAME>
#define GST_IS_VULKAN_DEVICE(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_VULKAN_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_DEVICE_CLASS</NAME>
#define GST_IS_VULKAN_DEVICE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_VULKAN_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DEVICE_GET_CLASS</NAME>
#define GST_VULKAN_DEVICE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_VULKAN_DEVICE, GstVulkanDeviceClass))
</MACRO>
<FUNCTION>
<NAME>gst_vulkan_device_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_VULKAN_DEVICE_CONTEXT_TYPE_STR</NAME>
#define GST_VULKAN_DEVICE_CONTEXT_TYPE_STR "gst.vulkan.device"
</MACRO>
<USER_FUNCTION>
<NAME>GstVulkanDeviceForEachQueueFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstVulkanDevice * device, GstVulkanQueue * queue, gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GstVulkanDevice</NAME>
struct _GstVulkanDevice
{
  GstObject parent;

  GstVulkanInstance *instance;

  guint device_index;
  VkDevice device; /* hides a pointer */
  VkPhysicalDeviceProperties gpu_props;
  VkPhysicalDeviceFeatures gpu_features;
  VkPhysicalDeviceMemoryProperties memory_properties;

  VkQueueFamilyProperties *queue_family_props;
  guint32 n_queue_families;

  guint32 queue_family_id;
  guint32 n_queues;

  VkCommandPool cmd_pool;

  GstVulkanDevicePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanDeviceClass</NAME>
struct _GstVulkanDeviceClass
{
  GstObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_device_new</NAME>
<RETURNS>GstVulkanDevice  *   </RETURNS>
GstVulkanInstance * instance
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_device_get_instance</NAME>
<RETURNS>GstVulkanInstance  * </RETURNS>
GstVulkanDevice * device
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_device_open</NAME>
<RETURNS>gboolean             </RETURNS>
GstVulkanDevice * device, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_device_get_proc_address</NAME>
<RETURNS>gpointer             </RETURNS>
GstVulkanDevice * device, const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_device_foreach_queue</NAME>
<RETURNS>void                 </RETURNS>
GstVulkanDevice * device, GstVulkanDeviceForEachQueueFunc func, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_device_get_queue</NAME>
<RETURNS>GstVulkanQueue  *    </RETURNS>
GstVulkanDevice * device, guint32 queue_family, guint32 queue_i
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_device_get_physical_device</NAME>
<RETURNS>VkPhysicalDevice     </RETURNS>
GstVulkanDevice * device
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_device_create_cmd_buffer</NAME>
<RETURNS>gboolean             </RETURNS>
GstVulkanDevice * device, VkCommandBuffer * cmd, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_context_set_vulkan_device</NAME>
<RETURNS>void                 </RETURNS>
GstContext * context, GstVulkanDevice * device
</FUNCTION>
<FUNCTION>
<NAME>gst_context_get_vulkan_device</NAME>
<RETURNS>gboolean             </RETURNS>
GstContext * context, GstVulkanDevice ** device
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_device_handle_context_query</NAME>
<RETURNS>gboolean             </RETURNS>
GstElement * element, GstQuery * query, GstVulkanDevice ** device
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_device_run_context_query</NAME>
<RETURNS>gboolean             </RETURNS>
GstElement * element, GstVulkanDevice ** device
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_FENCE</NAME>
#define GST_TYPE_VULKAN_FENCE (gst_vulkan_fence_get_type ())
</MACRO>
<FUNCTION>
<NAME>gst_vulkan_fence_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_VULKAN_FENCE_CAST</NAME>
#define GST_VULKAN_FENCE_CAST(f) ((GstVulkanFence *) f)
</MACRO>
<MACRO>
<NAME>GST_VULKAN_FENCE_FENCE</NAME>
#define GST_VULKAN_FENCE_FENCE(f) (GST_VULKAN_FENCE_CAST(f)->fence)
</MACRO>
<STRUCT>
<NAME>GstVulkanFence</NAME>
struct _GstVulkanFence
{
  GstMiniObject parent;

  GstVulkanDevice *device;

  VkFence fence;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_fence_new</NAME>
<RETURNS>GstVulkanFence  *    </RETURNS>
GstVulkanDevice * device, VkFenceCreateFlags flags, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_fence_wait</NAME>
<RETURNS>GstVulkanFence  *    </RETURNS>
GstVulkanFence * fence
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_fence_is_signaled</NAME>
<RETURNS>gboolean             </RETURNS>
GstVulkanFence * fence
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_fence_ref</NAME>
<RETURNS>GstVulkanFence  *</RETURNS>
GstVulkanFence * fence
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_fence_unref</NAME>
<RETURNS>void </RETURNS>
GstVulkanFence * fence
</FUNCTION>
<USER_FUNCTION>
<NAME>GstVulkanTrashNotify</NAME>
<RETURNS>void </RETURNS>
GstVulkanDevice * device, gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GstVulkanTrash</NAME>
struct _GstVulkanTrash
{
  GstVulkanFence       *fence;

  GstVulkanTrashNotify  notify;
  gpointer              user_data;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_trash_new</NAME>
<RETURNS>GstVulkanTrash  *    </RETURNS>
GstVulkanFence * fence, GstVulkanTrashNotify notify, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_trash_new_free_command_buffer</NAME>
<RETURNS>GstVulkanTrash  *    </RETURNS>
GstVulkanFence * fence, VkCommandBuffer cmd
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_trash_new_free_semaphore</NAME>
<RETURNS>GstVulkanTrash  *    </RETURNS>
GstVulkanFence * fence, VkSemaphore cmd
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_trash_free</NAME>
<RETURNS>void                 </RETURNS>
GstVulkanTrash * trash
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_trash_list_gc</NAME>
<RETURNS>GList  *             </RETURNS>
GList * trash_list
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_trash_list_wait</NAME>
<RETURNS>gboolean             </RETURNS>
GList * trash_list, guint64 timeout
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_SINK</NAME>
#define GST_TYPE_VULKAN_SINK            (gst_vulkan_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_VULKAN_SINK</NAME>
#define GST_VULKAN_SINK(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VULKAN_SINK,GstVulkanSink))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_SINK_CLASS</NAME>
#define GST_VULKAN_SINK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VULKAN_SINK,GstVulkanSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_SINK</NAME>
#define GST_IS_VULKAN_SINK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VULKAN_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_SINK_CLASS</NAME>
#define GST_IS_VULKAN_SINK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VULKAN_SINK))
</MACRO>
<STRUCT>
<NAME>GstVulkanSink</NAME>
struct _GstVulkanSink
{
  GstVideoSink video_sink;

  GstVulkanInstance *instance;
  GstVulkanDevice *device;

  GstVulkanDisplay *display;
  GstVulkanWindow *window;

  GstVulkanSwapper *swapper;

  /* properties */
  gboolean force_aspect_ratio;
  gint par_n;
  gint par_d;

  /* stream configuration */
  GstVideoInfo v_info;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanSinkClass</NAME>
struct _GstVulkanSinkClass
{
    GstVideoSinkClass video_sink_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_UPLOAD</NAME>
#define GST_TYPE_VULKAN_UPLOAD            (gst_vulkan_upload_get_type())
</MACRO>
<MACRO>
<NAME>GST_VULKAN_UPLOAD</NAME>
#define GST_VULKAN_UPLOAD(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VULKAN_UPLOAD,GstVulkanUpload))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_UPLOAD_CLASS</NAME>
#define GST_VULKAN_UPLOAD_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VULKAN_UPLOAD,GstVulkanUploadClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_UPLOAD</NAME>
#define GST_IS_VULKAN_UPLOAD(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VULKAN_UPLOAD))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_UPLOAD_CLASS</NAME>
#define GST_IS_VULKAN_UPLOAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VULKAN_UPLOAD))
</MACRO>
<STRUCT>
<NAME>UploadMethod</NAME>
struct UploadMethod
{
  const gchar       *name;

  GstStaticCaps     *in_template;
  GstStaticCaps     *out_template;

  gpointer          (*new_impl)                 (GstVulkanUpload * upload);
  GstCaps *         (*transform_caps)           (gpointer impl,
                                                 GstPadDirection direction,
                                                 GstCaps * caps);
  gboolean          (*set_caps)                 (gpointer impl,
                                                 GstCaps * in_caps,
                                                 GstCaps * out_caps);
  void              (*propose_allocation)       (gpointer impl,
                                                 GstQuery * decide_query,
                                                 GstQuery * query);
  GstFlowReturn     (*perform)                  (gpointer impl,
                                                 GstBuffer * buffer,
                                                 GstBuffer ** outbuf);
  void              (*free)                     (gpointer impl);
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanUpload</NAME>
struct _GstVulkanUpload
{
  GstBaseTransform      parent;

  GstVulkanInstance     *instance;
  GstVulkanDevice       *device;

  GstVulkanDisplay      *display;

  GstCaps               *in_caps;
  GstCaps               *out_caps;

  /* all impl pointers */
  gpointer              *upload_impls;
  guint                 current_impl;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanUploadClass</NAME>
struct _GstVulkanUploadClass
{
  GstBaseTransformClass video_sink_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_upload_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_INSTANCE</NAME>
#define GST_TYPE_VULKAN_INSTANCE         (gst_vulkan_instance_get_type())
</MACRO>
<MACRO>
<NAME>GST_VULKAN_INSTANCE</NAME>
#define GST_VULKAN_INSTANCE(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_VULKAN_INSTANCE, GstVulkanInstance))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_INSTANCE_CLASS</NAME>
#define GST_VULKAN_INSTANCE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GST_TYPE_VULKAN_INSTANCE, GstVulkanInstanceClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_INSTANCE</NAME>
#define GST_IS_VULKAN_INSTANCE(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_VULKAN_INSTANCE))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_INSTANCE_CLASS</NAME>
#define GST_IS_VULKAN_INSTANCE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_VULKAN_INSTANCE))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_INSTANCE_GET_CLASS</NAME>
#define GST_VULKAN_INSTANCE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_VULKAN_INSTANCE, GstVulkanInstanceClass))
</MACRO>
<FUNCTION>
<NAME>gst_vulkan_instance_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_VULKAN_INSTANCE_CONTEXT_TYPE_STR</NAME>
#define GST_VULKAN_INSTANCE_CONTEXT_TYPE_STR "gst.vulkan.instance"
</MACRO>
<STRUCT>
<NAME>GstVulkanInstance</NAME>
struct _GstVulkanInstance
{
  GstObject parent;

  VkInstance instance; /* hides a pointer */
  VkPhysicalDevice *physical_devices; /* hides a pointer */
  guint32 n_physical_devices;

  VkDebugReportCallbackEXT msg_callback;
  PFN_vkCreateDebugReportCallbackEXT dbgCreateDebugReportCallback;
  PFN_vkDestroyDebugReportCallbackEXT dbgDestroyDebugReportCallback;
  PFN_vkDebugReportMessageEXT dbgReportMessage;

  GstVulkanInstancePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanInstanceClass</NAME>
struct _GstVulkanInstanceClass
{
  GstObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_instance_new</NAME>
<RETURNS>GstVulkanInstance  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_instance_open</NAME>
<RETURNS>gboolean             </RETURNS>
GstVulkanInstance * instance, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_instance_get_proc_address</NAME>
<RETURNS>gpointer             </RETURNS>
GstVulkanInstance * instance, const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_instance_create_device</NAME>
<RETURNS>GstVulkanDevice  *   </RETURNS>
GstVulkanInstance * instance, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_context_set_vulkan_instance</NAME>
<RETURNS>void                 </RETURNS>
GstContext * context, GstVulkanInstance * instance
</FUNCTION>
<FUNCTION>
<NAME>gst_context_get_vulkan_instance</NAME>
<RETURNS>gboolean             </RETURNS>
GstContext * context, GstVulkanInstance ** instance
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_instance_handle_context_query</NAME>
<RETURNS>gboolean             </RETURNS>
GstElement * element, GstQuery * query, GstVulkanInstance ** instance
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_instance_run_context_query</NAME>
<RETURNS>gboolean             </RETURNS>
GstElement * element, GstVulkanInstance ** instance
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_QUEUE</NAME>
#define GST_TYPE_VULKAN_QUEUE         (gst_vulkan_queue_get_type())
</MACRO>
<MACRO>
<NAME>GST_VULKAN_QUEUE</NAME>
#define GST_VULKAN_QUEUE(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_VULKAN_QUEUE, GstVulkanQueue))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_QUEUE_CLASS</NAME>
#define GST_VULKAN_QUEUE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GST_TYPE_VULKAN_QUEUE, GstVulkanQueueClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_QUEUE</NAME>
#define GST_IS_VULKAN_QUEUE(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_VULKAN_QUEUE))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_QUEUE_CLASS</NAME>
#define GST_IS_VULKAN_QUEUE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_VULKAN_QUEUE))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_QUEUE_GET_CLASS</NAME>
#define GST_VULKAN_QUEUE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_VULKAN_QUEUE, GstVulkanQueueClass))
</MACRO>
<FUNCTION>
<NAME>gst_vulkan_queue_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_VULKAN_QUEUE_CONTEXT_TYPE_STR</NAME>
#define GST_VULKAN_QUEUE_CONTEXT_TYPE_STR "gst.vulkan.queue"
</MACRO>
<STRUCT>
<NAME>GstVulkanQueue</NAME>
struct _GstVulkanQueue
{
  GstObject parent;

  GstVulkanDevice *device;

  VkQueue queue; /* hides a pointer */
  guint32 family;
  guint32 index;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanQueueClass</NAME>
struct _GstVulkanQueueClass
{
  GstObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_queue_get_device</NAME>
<RETURNS>GstVulkanDevice  *   </RETURNS>
GstVulkanQueue * queue
</FUNCTION>
<FUNCTION>
<NAME>gst_context_set_vulkan_queue</NAME>
<RETURNS>void                 </RETURNS>
GstContext * context, GstVulkanQueue * queue
</FUNCTION>
<FUNCTION>
<NAME>gst_context_get_vulkan_queue</NAME>
<RETURNS>gboolean             </RETURNS>
GstContext * context, GstVulkanQueue ** queue
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_queue_handle_context_query</NAME>
<RETURNS>gboolean             </RETURNS>
GstElement * element, GstQuery * query, GstVulkanQueue ** queue
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_queue_run_context_query</NAME>
<RETURNS>gboolean             </RETURNS>
GstElement * element, GstVulkanQueue ** queue
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_IMAGE_MEMORY_ALLOCATOR</NAME>
#define GST_TYPE_VULKAN_IMAGE_MEMORY_ALLOCATOR (gst_vulkan_image_memory_allocator_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_vulkan_image_memory_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_IS_VULKAN_IMAGE_MEMORY_ALLOCATOR</NAME>
#define GST_IS_VULKAN_IMAGE_MEMORY_ALLOCATOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_VULKAN_IMAGE_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_IMAGE_MEMORY_ALLOCATOR_CLASS</NAME>
#define GST_IS_VULKAN_IMAGE_MEMORY_ALLOCATOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_VULKAN_IMAGE_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_IMAGE_MEMORY_ALLOCATOR_GET_CLASS</NAME>
#define GST_VULKAN_IMAGE_MEMORY_ALLOCATOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_VULKAN_MEMORY_ALLOCATOR, GstVulkanImageMemoryAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_IMAGE_MEMORY_ALLOCATOR</NAME>
#define GST_VULKAN_IMAGE_MEMORY_ALLOCATOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_VULKAN_MEMORY_ALLOCATOR, GstVulkanImageMemoryAllocator))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_IMAGE_MEMORY_ALLOCATOR_CLASS</NAME>
#define GST_VULKAN_IMAGE_MEMORY_ALLOCATOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_VULKAN_MEMORY_ALLOCATOR, GstVulkanImageMemoryAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_IMAGE_MEMORY_ALLOCATOR_CAST</NAME>
#define GST_VULKAN_IMAGE_MEMORY_ALLOCATOR_CAST(obj)            ((GstVulkanImageMemoryAllocator *)(obj))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_IMAGE_MEMORY_ALLOCATOR_NAME</NAME>
#define GST_VULKAN_IMAGE_MEMORY_ALLOCATOR_NAME "VulkanImage"
</MACRO>
<MACRO>
<NAME>GST_CAPS_FEATURE_MEMORY_VULKAN_IMAGE</NAME>
#define GST_CAPS_FEATURE_MEMORY_VULKAN_IMAGE "memory:" GST_VULKAN_IMAGE_MEMORY_ALLOCATOR_NAME
</MACRO>
<STRUCT>
<NAME>GstVulkanImageMemory</NAME>
struct _GstVulkanImageMemory
{
  GstMemory parent;

  GstVulkanDevice * device;

  VkImage image;
  VkImageLayout image_layout;
  VkImageView view;
  GstVulkanMemory *vk_mem;

  VkImageCreateInfo create_info;
  VkMemoryRequirements requirements;
  VkImageFormatProperties format_properties;
  VkImageUsageFlags usage;

  GMutex lock;
  gboolean wrapped;
  GDestroyNotify notify;
  gpointer user_data;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanImageMemoryAllocator</NAME>
struct _GstVulkanImageMemoryAllocator
{
  GstAllocator parent;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanImageMemoryAllocatorClass</NAME>
struct _GstVulkanImageMemoryAllocatorClass
{
  GstAllocatorClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_image_memory_init_once</NAME>
<RETURNS>void             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_is_vulkan_image_memory</NAME>
<RETURNS>gboolean         </RETURNS>
GstMemory * mem
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_image_memory_alloc</NAME>
<RETURNS>GstMemory  *     </RETURNS>
GstVulkanDevice * device, VkFormat format, gsize width, gsize height, VkImageTiling tiling, VkImageUsageFlags usage, VkMemoryPropertyFlags mem_prop_flags
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_image_memory_wrapped</NAME>
<RETURNS>GstMemory  *     </RETURNS>
GstVulkanDevice * device, VkImage image, VkFormat format, gsize width, gsize height, VkImageTiling tiling, VkImageUsageFlags usage, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_image_memory_set_layout</NAME>
<RETURNS>gboolean         </RETURNS>
GstVulkanImageMemory * vk_mem, VkImageLayout, VkImageMemoryBarrier * barrier
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_image_memory_get_width</NAME>
<RETURNS>guint32          </RETURNS>
GstVulkanImageMemory * image
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_image_memory_get_height</NAME>
<RETURNS>guint32          </RETURNS>
GstVulkanImageMemory * image
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_format_from_video_format</NAME>
<RETURNS>VkFormat  </RETURNS>
GstVideoFormat v_format, guint plane
</FUNCTION>
<MACRO>
<NAME>GST_VULKAN_HAVE_WINDOW_XCB</NAME>
#define GST_VULKAN_HAVE_WINDOW_XCB 1
</MACRO>
<MACRO>
<NAME>GST_VULKAN_HAVE_WINDOW_WAYLAND</NAME>
#define GST_VULKAN_HAVE_WINDOW_WAYLAND 1
</MACRO>
<MACRO>
<NAME>GST_TYPE_VULKAN_DISPLAY</NAME>
#define GST_TYPE_VULKAN_DISPLAY             (gst_vulkan_display_get_type())
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DISPLAY</NAME>
#define GST_VULKAN_DISPLAY(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VULKAN_DISPLAY,GstVulkanDisplay))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DISPLAY_CLASS</NAME>
#define GST_VULKAN_DISPLAY_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_VULKAN_DISPLAY,GstVulkanDisplayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_DISPLAY</NAME>
#define GST_IS_VULKAN_DISPLAY(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VULKAN_DISPLAY))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_DISPLAY_CLASS</NAME>
#define GST_IS_VULKAN_DISPLAY_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_VULKAN_DISPLAY))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DISPLAY_CAST</NAME>
#define GST_VULKAN_DISPLAY_CAST(obj)        ((GstVulkanDisplay*)(obj))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DISPLAY_GET_CLASS</NAME>
#define GST_VULKAN_DISPLAY_GET_CLASS(o)     (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_VULKAN_DISPLAY, GstVulkanDisplayClass))
</MACRO>
<FUNCTION>
<NAME>gst_vulkan_display_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_VULKAN_DISPLAY_CONTEXT_TYPE_STR</NAME>
#define GST_VULKAN_DISPLAY_CONTEXT_TYPE_STR "gst.vulkan.display"
</MACRO>
<STRUCT>
<NAME>GstVulkanDisplay</NAME>
struct _GstVulkanDisplay
{
  /* <private> */
  GstObject                 object;

  GstVulkanDisplayType      type;

  GstVulkanInstance        *instance;

  /* <protected> */
  GList                    *windows;        /* OBJECT lock */
  GMainContext             *main_context;
  GMainLoop                *main_loop;
  GSource                  *event_source;

  /* <private> */
  GstVulkanDisplayPrivate  *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanDisplayClass</NAME>
struct _GstVulkanDisplayClass
{
  GstObjectClass object_class;

  gpointer          (*get_handle)           (GstVulkanDisplay * display);
  GstVulkanWindow * (*create_window)        (GstVulkanDisplay * display);
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_display_new</NAME>
<RETURNS>GstVulkanDisplay  *      </RETURNS>
GstVulkanInstance *instance
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_display_new_with_type</NAME>
<RETURNS>GstVulkanDisplay  *      </RETURNS>
GstVulkanInstance *instance, GstVulkanDisplayType type
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_display_choose_type</NAME>
<RETURNS>GstVulkanDisplayType     </RETURNS>
GstVulkanInstance *instance
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_display_type_to_extension_string</NAME>
<RETURNS>const gchar  *           </RETURNS>
GstVulkanDisplayType type
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_display_get_handle</NAME>
<RETURNS>gpointer                 </RETURNS>
GstVulkanDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_display_get_handle_type</NAME>
<RETURNS>GstVulkanDisplayType     </RETURNS>
GstVulkanDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_display_create_window</NAME>
<RETURNS>GstVulkanWindow  *       </RETURNS>
GstVulkanDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_context_get_vulkan_display</NAME>
<RETURNS>gboolean                 </RETURNS>
GstContext * context, GstVulkanDisplay ** display
</FUNCTION>
<FUNCTION>
<NAME>gst_context_set_vulkan_display</NAME>
<RETURNS>void                     </RETURNS>
GstContext * context, GstVulkanDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_display_handle_context_query</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement * element, GstQuery * query, GstVulkanDisplay ** display
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_display_run_context_query</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement * element, GstVulkanDisplay ** display
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_display_remove_window</NAME>
<RETURNS>gboolean                 </RETURNS>
GstVulkanDisplay * display, GstVulkanWindow * window
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_SWAPPER</NAME>
#define GST_TYPE_VULKAN_SWAPPER         (gst_vulkan_swapper_get_type())
</MACRO>
<MACRO>
<NAME>GST_VULKAN_SWAPPER</NAME>
#define GST_VULKAN_SWAPPER(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_VULKAN_SWAPPER, GstVulkanSwapper))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_SWAPPER_CLASS</NAME>
#define GST_VULKAN_SWAPPER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), GST_TYPE_VULKAN_SWAPPER, GstVulkanSwapperClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_SWAPPER</NAME>
#define GST_IS_VULKAN_SWAPPER(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_VULKAN_SWAPPER))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_SWAPPER_CLASS</NAME>
#define GST_IS_VULKAN_SWAPPER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_VULKAN_SWAPPER))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_SWAPPER_GET_CLASS</NAME>
#define GST_VULKAN_SWAPPER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_VULKAN_SWAPPER, GstVulkanSwapperClass))
</MACRO>
<FUNCTION>
<NAME>gst_vulkan_swapper_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_VULKAN_SWAPPER_VIDEO_FORMATS</NAME>
#define GST_VULKAN_SWAPPER_VIDEO_FORMATS " { RGBA, BGRA, RGB, BGR } "
</MACRO>
<STRUCT>
<NAME>GstVulkanSwapper</NAME>
struct _GstVulkanSwapper
{
  GstObject parent;

  GstVulkanDevice *device;
  GstVulkanWindow *window;
  GstVulkanQueue *queue;

  VkSurfaceKHR    surface;

  VkSurfaceCapabilitiesKHR surf_props;
  VkSurfaceFormatKHR *surf_formats;
  guint32 n_surf_formats;
  VkPresentModeKHR *surf_present_modes;
  guint32 n_surf_present_modes;

  VkSwapchainKHR swap_chain;
  GstVulkanImageMemory **swap_chain_images;
  guint32 n_swap_chain_images;

  GstCaps *caps;
  GstVideoInfo v_info;

  PFN_vkGetPhysicalDeviceSurfaceSupportKHR GetPhysicalDeviceSurfaceSupportKHR;
  PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR GetPhysicalDeviceSurfaceCapabilitiesKHR;
  PFN_vkGetPhysicalDeviceSurfaceFormatsKHR GetPhysicalDeviceSurfaceFormatsKHR;
  PFN_vkGetPhysicalDeviceSurfacePresentModesKHR GetPhysicalDeviceSurfacePresentModesKHR;
  PFN_vkCreateSwapchainKHR CreateSwapchainKHR;
  PFN_vkDestroySwapchainKHR DestroySwapchainKHR;
  PFN_vkGetSwapchainImagesKHR GetSwapchainImagesKHR;
  PFN_vkAcquireNextImageKHR AcquireNextImageKHR;
  PFN_vkQueuePresentKHR QueuePresentKHR;

  /* <private> */
  /* runtime variables */
  gint to_quit;
  GstBuffer *current_buffer;

  /* signal handlers */
  gulong close_id;
  gulong draw_id;

  GstVulkanSwapperPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanSwapperClass</NAME>
struct _GstVulkanSwapperClass
{
  GstObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_swapper_new</NAME>
<RETURNS>GstVulkanSwapper  *  </RETURNS>
GstVulkanDevice * device, GstVulkanWindow * window
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_swapper_get_supported_caps</NAME>
<RETURNS>GstCaps  *           </RETURNS>
GstVulkanSwapper * swapper, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_swapper_set_caps</NAME>
<RETURNS>gboolean             </RETURNS>
GstVulkanSwapper * swapper, GstCaps * caps, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_swapper_render_buffer</NAME>
<RETURNS>gboolean             </RETURNS>
GstVulkanSwapper * swapper, GstBuffer * buffer, GError ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_ensure_element_data</NAME>
<RETURNS>gboolean  </RETURNS>
gpointer element, GstVulkanDisplay **display_ptr, GstVulkanInstance ** instance_ptr
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_handle_set_context</NAME>
<RETURNS>gboolean  </RETURNS>
GstElement * element, GstContext * context, GstVulkanDisplay ** display, GstVulkanInstance ** instance
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_handle_context_query</NAME>
<RETURNS>gboolean  </RETURNS>
GstElement * element, GstQuery * query, GstVulkanDisplay ** display, GstVulkanInstance ** instance, GstVulkanDevice ** device
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_global_context_query</NAME>
<RETURNS>void  </RETURNS>
GstElement * element, const gchar * context_type
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_local_context_query</NAME>
<RETURNS>GstQuery  * </RETURNS>
GstElement * element, const gchar * context_type, gboolean set_context
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_run_query</NAME>
<RETURNS>gboolean  </RETURNS>
GstElement * element, GstQuery * query, GstPadDirection direction
</FUNCTION>
<FUNCTION>
<NAME>xcb_event_source_new</NAME>
<RETURNS>GSource  *</RETURNS>
GstVulkanDisplayXCB *display_xcb
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_WINDOW_XCB</NAME>
#define GST_TYPE_VULKAN_WINDOW_XCB         (gst_vulkan_window_xcb_get_type())
</MACRO>
<MACRO>
<NAME>GST_VULKAN_WINDOW_XCB</NAME>
#define GST_VULKAN_WINDOW_XCB(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_VULKAN_WINDOW_XCB, GstVulkanWindowXCB))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_WINDOW_XCB_CLASS</NAME>
#define GST_VULKAN_WINDOW_XCB_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_VULKAN_WINDOW_XCB, GstVulkanWindowXCBClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_WINDOW_XCB</NAME>
#define GST_IS_VULKAN_WINDOW_XCB(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_VULKAN_WINDOW_XCB))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_WINDOW_XCB_CLASS</NAME>
#define GST_IS_VULKAN_WINDOW_XCB_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_VULKAN_WINDOW_XCB))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_WINDOW_XCB_GET_CLASS</NAME>
#define GST_VULKAN_WINDOW_XCB_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_VULKAN_WINDOW_XCB, GstVulkanWindowXCBClass))
</MACRO>
<STRUCT>
<NAME>GstVulkanWindowXCB</NAME>
struct _GstVulkanWindowXCB
{
  /*< private >*/
  GstVulkanWindow parent;

  /* X window */
  xcb_window_t win_id;

  gint          visible :1;

  PFN_vkCreateXcbSurfaceKHR CreateXcbSurface;
  PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR GetPhysicalDeviceXcbPresentationSupport;

  /*< private >*/
  GstVulkanWindowXCBPrivate *priv;
  
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanWindowXCBClass</NAME>
struct _GstVulkanWindowXCBClass {
  /*< private >*/
  GstVulkanWindowClass parent_class;

  /*< private >*/
  gpointer _reserved[GST_PADDING_LARGE];
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_window_xcb_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_window_xcb_new</NAME>
<RETURNS>GstVulkanWindowXCB  * </RETURNS>
GstVulkanDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_window_xcb_create_window</NAME>
<RETURNS>gboolean  </RETURNS>
GstVulkanWindowXCB * window_xcb
</FUNCTION>
<STRUCT>
<NAME>GstVulkanWindowXCBPrivate</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_display_xcb_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_DISPLAY_XCB</NAME>
#define GST_TYPE_VULKAN_DISPLAY_XCB             (gst_vulkan_display_xcb_get_type())
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DISPLAY_XCB</NAME>
#define GST_VULKAN_DISPLAY_XCB(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VULKAN_DISPLAY_XCB,GstVulkanDisplayXCB))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DISPLAY_XCB_CLASS</NAME>
#define GST_VULKAN_DISPLAY_XCB_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_VULKAN_DISPLAY_XCB,GstVulkanDisplayXCBClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_DISPLAY_XCB</NAME>
#define GST_IS_VULKAN_DISPLAY_XCB(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VULKAN_DISPLAY_XCB))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_DISPLAY_XCB_CLASS</NAME>
#define GST_IS_VULKAN_DISPLAY_XCB_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_VULKAN_DISPLAY_XCB))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DISPLAY_XCB_CAST</NAME>
#define GST_VULKAN_DISPLAY_XCB_CAST(obj)        ((GstVulkanDisplayXCB*)(obj))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DISPLAY_XCB_CONNECTION</NAME>
#define GST_VULKAN_DISPLAY_XCB_CONNECTION(d) (GST_VULKAN_DISPLAY_XCB(d)->connection)
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DISPLAY_XCB_ROOT_WINDOW</NAME>
#define GST_VULKAN_DISPLAY_XCB_ROOT_WINDOW(d) (GST_VULKAN_DISPLAY_XCB(d)->root_window)
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DISPLAY_XCB_SCREEN</NAME>
#define GST_VULKAN_DISPLAY_XCB_SCREEN(d) (GST_VULKAN_DISPLAY_XCB(d)->screen)
</MACRO>
<STRUCT>
<NAME>GstVulkanDisplayXCB</NAME>
struct _GstVulkanDisplayXCB
{
  GstVulkanDisplay          parent;

  xcb_connection_t *connection;
  xcb_window_t      root_window;
  xcb_screen_t     *screen;

  /* <private> */
  gboolean foreign_display;

  GSource *event_source;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanDisplayXCBClass</NAME>
struct _GstVulkanDisplayXCBClass
{
  GstVulkanDisplayClass object_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_display_xcb_new</NAME>
<RETURNS>GstVulkanDisplayXCB  * </RETURNS>
const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_display_xcb_new_with_connection</NAME>
<RETURNS>GstVulkanDisplayXCB  * </RETURNS>
xcb_connection_t * connection, int screen_no
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_display_wayland_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_DISPLAY_WAYLAND</NAME>
#define GST_TYPE_VULKAN_DISPLAY_WAYLAND             (gst_vulkan_display_wayland_get_type())
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DISPLAY_WAYLAND</NAME>
#define GST_VULKAN_DISPLAY_WAYLAND(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VULKAN_DISPLAY_WAYLAND,GstVulkanDisplayWayland))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DISPLAY_WAYLAND_CLASS</NAME>
#define GST_VULKAN_DISPLAY_WAYLAND_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_VULKAN_DISPLAY_WAYLAND,GstVulkanDisplayWaylandClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_DISPLAY_WAYLAND</NAME>
#define GST_IS_VULKAN_DISPLAY_WAYLAND(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VULKAN_DISPLAY_WAYLAND))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_DISPLAY_WAYLAND_CLASS</NAME>
#define GST_IS_VULKAN_DISPLAY_WAYLAND_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_VULKAN_DISPLAY_WAYLAND))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_DISPLAY_WAYLAND_CAST</NAME>
#define GST_VULKAN_DISPLAY_WAYLAND_CAST(obj)        ((GstVulkanDisplayWayland*)(obj))
</MACRO>
<STRUCT>
<NAME>GstVulkanDisplayWayland</NAME>
struct _GstVulkanDisplayWayland
{
  GstVulkanDisplay            parent;

  struct wl_display       *display;
  struct wl_registry      *registry;
  struct wl_compositor    *compositor;
  struct wl_subcompositor *subcompositor;
  struct wl_shell         *shell;

  /* <private> */
  gboolean foreign_display;
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanDisplayWaylandClass</NAME>
struct _GstVulkanDisplayWaylandClass
{
  GstVulkanDisplayClass object_class;
};
</STRUCT>
<MACRO>
<NAME>GST_VULKAN_DISPLAY_WAYLAND_DISPLAY</NAME>
#define GST_VULKAN_DISPLAY_WAYLAND_DISPLAY(display_) (GST_VULKAN_DISPLAY_WAYLAND (display_)->display)
</MACRO>
<FUNCTION>
<NAME>gst_vulkan_display_wayland_new</NAME>
<RETURNS>GstVulkanDisplayWayland  *</RETURNS>
const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_display_wayland_new_with_display</NAME>
<RETURNS>GstVulkanDisplayWayland  *</RETURNS>
struct wl_display *display
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_display_wayland_roundtrip_async</NAME>
<RETURNS>void  </RETURNS>
GstVulkanDisplayWayland * display
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VULKAN_WINDOW_WAYLAND</NAME>
#define GST_TYPE_VULKAN_WINDOW_WAYLAND         (gst_vulkan_window_wayland_get_type())
</MACRO>
<MACRO>
<NAME>GST_VULKAN_WINDOW_WAYLAND</NAME>
#define GST_VULKAN_WINDOW_WAYLAND(o)           (G_TYPE_CHECK_INSTANCE_CAST((o), GST_TYPE_VULKAN_WINDOW_WAYLAND, GstVulkanWindowWayland))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_WINDOW_WAYLAND_CLASS</NAME>
#define GST_VULKAN_WINDOW_WAYLAND_CLASS(k)     (G_TYPE_CHECK_CLASS((k), GST_TYPE_VULKAN_WINDOW_WAYLAND, GstVulkanWindowWaylandClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_WINDOW_WAYLAND</NAME>
#define GST_IS_VULKAN_WINDOW_WAYLAND(o)        (G_TYPE_CHECK_INSTANCE_TYPE((o), GST_TYPE_VULKAN_WINDOW_WAYLAND))
</MACRO>
<MACRO>
<NAME>GST_IS_VULKAN_WINDOW_WAYLAND_CLASS</NAME>
#define GST_IS_VULKAN_WINDOW_WAYLAND_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE((k), GST_TYPE_VULKAN_WINDOW_WAYLAND))
</MACRO>
<MACRO>
<NAME>GST_VULKAN_WINDOW_WAYLAND_GET_CLASS</NAME>
#define GST_VULKAN_WINDOW_WAYLAND_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS((o), GST_TYPE_VULKAN_WINDOW_WAYLAND, GstVulkanWindowWaylandClass))
</MACRO>
<STRUCT>
<NAME>GstVulkanWindowWayland</NAME>
struct _GstVulkanWindowWayland {
  /*< private >*/
  GstVulkanWindow parent;

  PFN_vkCreateWaylandSurfaceKHR CreateWaylandSurface;
  PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR GetPhysicalDeviceWaylandPresentationSupport;

  struct wl_event_queue     *queue;
  struct wl_surface         *surface;
  struct wl_shell_surface   *shell_surface;
  struct wl_callback        *callback;

  int window_width, window_height;

  GSource *wl_source;

  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstVulkanWindowWaylandClass</NAME>
struct _GstVulkanWindowWaylandClass {
  /*< private >*/
  GstVulkanWindowClass parent_class;

  /*< private >*/
  gpointer _reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_vulkan_window_wayland_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vulkan_window_wayland_new</NAME>
<RETURNS>GstVulkanWindowWayland  * </RETURNS>
GstVulkanDisplay * display
</FUNCTION>
<FUNCTION>
<NAME>wayland_event_source_new</NAME>
<RETURNS>GSource  * </RETURNS>
struct wl_display *display, struct wl_event_queue *queue
</FUNCTION>
<MACRO>
<NAME>GST_SCHRO_YUV_LIST</NAME>
#define GST_SCHRO_YUV_LIST "{ I420, YV12, YUY2, UYVY, AYUV, Y42B, Y444, v216, v210, AY64, ARGB }"
</MACRO>
<FUNCTION>
<NAME>gst_schro_buffer_wrap</NAME>
<RETURNS>SchroFrame  *</RETURNS>
GstBuffer *buf, gboolean write, GstVideoInfo * vinfo
</FUNCTION>
<FUNCTION>
<NAME>gst_schro_frame_get_buffer</NAME>
<RETURNS>GstBuffer  * </RETURNS>
SchroFrame * frame
</FUNCTION>
<FUNCTION>
<NAME>gst_schro_wrap_schro_buffer</NAME>
<RETURNS>GstBuffer  * </RETURNS>
SchroBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_schro_wrap_gst_buffer</NAME>
<RETURNS>SchroBuffer  * </RETURNS>
GstBuffer *buffer
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_KS_DEVICE_PROVIDER</NAME>
#define GST_TYPE_KS_DEVICE_PROVIDER                 (gst_ks_device_provider_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_KS_DEVICE_PROVIDER</NAME>
#define GST_IS_KS_DEVICE_PROVIDER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_KS_DEVICE_PROVIDER))
</MACRO>
<MACRO>
<NAME>GST_IS_KS_DEVICE_PROVIDER_CLASS</NAME>
#define GST_IS_KS_DEVICE_PROVIDER_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_KS_DEVICE_PROVIDER))
</MACRO>
<MACRO>
<NAME>GST_KS_DEVICE_PROVIDER_GET_CLASS</NAME>
#define GST_KS_DEVICE_PROVIDER_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_KS_DEVICE_PROVIDER, GstKsDeviceProviderClass))
</MACRO>
<MACRO>
<NAME>GST_KS_DEVICE_PROVIDER</NAME>
#define GST_KS_DEVICE_PROVIDER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_KS_DEVICE_PROVIDER, GstKsDeviceProvider))
</MACRO>
<MACRO>
<NAME>GST_KS_DEVICE_PROVIDER_CLASS</NAME>
#define GST_KS_DEVICE_PROVIDER_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DEVICE_PROVIDER, GstKsDeviceProviderClass))
</MACRO>
<MACRO>
<NAME>GST_KS_DEVICE_PROVIDER_CAST</NAME>
#define GST_KS_DEVICE_PROVIDER_CAST(obj)            ((GstKsDeviceProvider *)(obj))
</MACRO>
<STRUCT>
<NAME>GstKsDeviceProvider</NAME>
struct _GstKsDeviceProvider {
  GstDeviceProvider parent;

  HANDLE            message_window;
  ATOM              message_window_class;
  HDEVNOTIFY        device_notify_handle;
  HANDLE            wakeup_event;
  GThread          *message_thread;
};
</STRUCT>
<ENUM>
<NAME>GstKsDeviceType</NAME>
typedef enum {
  GST_KS_DEVICE_TYPE_INVALID = 0,
  GST_KS_DEVICE_TYPE_VIDEO_SOURCE,
  GST_KS_DEVICE_TYPE_VIDEO_SINK,
  GST_KS_DEVICE_TYPE_AUDIO_SOURCE,
  GST_KS_DEVICE_TYPE_AUDIO_SINK
} GstKsDeviceType;
</ENUM>
<STRUCT>
<NAME>GstKsDeviceProviderClass</NAME>
struct _GstKsDeviceProviderClass {
  GstDeviceProviderClass    parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ks_device_provider_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_KS_DEVICE</NAME>
#define GST_TYPE_KS_DEVICE                 (gst_ks_device_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_KS_DEVICE</NAME>
#define GST_IS_KS_DEVICE(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_KS_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_IS_KS_DEVICE_CLASS</NAME>
#define GST_IS_KS_DEVICE_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_KS_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_KS_DEVICE_GET_CLASS</NAME>
#define GST_KS_DEVICE_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_KS_DEVICE, GstKsDeviceClass))
</MACRO>
<MACRO>
<NAME>GST_KS_DEVICE</NAME>
#define GST_KS_DEVICE(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_KS_DEVICE, GstKsDevice))
</MACRO>
<MACRO>
<NAME>GST_KS_DEVICE_CLASS</NAME>
#define GST_KS_DEVICE_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DEVICE, GstKsDeviceClass))
</MACRO>
<MACRO>
<NAME>GST_KS_DEVICE_CAST</NAME>
#define GST_KS_DEVICE_CAST(obj)            ((GstKsDevice *)(obj))
</MACRO>
<STRUCT>
<NAME>GstKsDevice</NAME>
struct _GstKsDevice {
  GstDevice         parent;

  GstKsDeviceType   type;
  guint             device_index;
  gchar            *path;
  const gchar      *element;
};
</STRUCT>
<STRUCT>
<NAME>GstKsDeviceClass</NAME>
struct _GstKsDeviceClass {
  GstDeviceClass    parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ks_device_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstKsDevicePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstKsDeviceProviderPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_KS_CLOCK</NAME>
#define GST_TYPE_KS_CLOCK \
  (gst_ks_clock_get_type ())
</MACRO>
<MACRO>
<NAME>GST_KS_CLOCK</NAME>
#define GST_KS_CLOCK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_KS_CLOCK, GstKsClock))
</MACRO>
<MACRO>
<NAME>GST_KS_CLOCK_CLASS</NAME>
#define GST_KS_CLOCK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_KS_CLOCK, GstKsClockClass))
</MACRO>
<MACRO>
<NAME>GST_IS_KS_CLOCK</NAME>
#define GST_IS_KS_CLOCK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_KS_CLOCK))
</MACRO>
<MACRO>
<NAME>GST_IS_KS_CLOCK_CLASS</NAME>
#define GST_IS_KS_CLOCK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_KS_CLOCK))
</MACRO>
<STRUCT>
<NAME>GstKsClock</NAME>
struct _GstKsClock
{
  GObject parent;

  GstKsClockPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstKsClockClass</NAME>
struct _GstKsClockClass
{
  GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ks_clock_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_clock_open</NAME>
<RETURNS>gboolean  </RETURNS>
GstKsClock * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_clock_close</NAME>
<RETURNS>void  </RETURNS>
GstKsClock * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_clock_get_handle</NAME>
<RETURNS>HANDLE  </RETURNS>
GstKsClock * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_clock_prepare</NAME>
<RETURNS>void  </RETURNS>
GstKsClock * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_clock_start</NAME>
<RETURNS>void  </RETURNS>
GstKsClock * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_clock_provide_master_clock</NAME>
<RETURNS>void  </RETURNS>
GstKsClock * self, GstClock * master_clock
</FUNCTION>
<STRUCT>
<NAME>GstKsClockPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_KS_VIDEO_DEVICE</NAME>
#define GST_TYPE_KS_VIDEO_DEVICE \
  (gst_ks_video_device_get_type ())
</MACRO>
<MACRO>
<NAME>GST_KS_VIDEO_DEVICE</NAME>
#define GST_KS_VIDEO_DEVICE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_KS_VIDEO_DEVICE, GstKsVideoDevice))
</MACRO>
<MACRO>
<NAME>GST_KS_VIDEO_DEVICE_CLASS</NAME>
#define GST_KS_VIDEO_DEVICE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_KS_VIDEO_DEVICE, GstKsVideoDeviceClass))
</MACRO>
<MACRO>
<NAME>GST_IS_KS_VIDEO_DEVICE</NAME>
#define GST_IS_KS_VIDEO_DEVICE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_KS_VIDEO_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_IS_KS_VIDEO_DEVICE_CLASS</NAME>
#define GST_IS_KS_VIDEO_DEVICE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_KS_VIDEO_DEVICE))
</MACRO>
<USER_FUNCTION>
<NAME>GstKsAllocFunction</NAME>
<RETURNS>GstBuffer *</RETURNS>
guint buf_size, guint alignment, gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GstKsVideoDevice</NAME>
struct _GstKsVideoDevice
{
  GObject parent;

  GstKsAllocFunction allocfunc;
  gpointer allocfunc_data;

  GstKsVideoDevicePrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstKsVideoDeviceClass</NAME>
struct _GstKsVideoDeviceClass
{
  GObjectClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ks_video_device_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_video_device_new</NAME>
<RETURNS>GstKsVideoDevice  * </RETURNS>
const gchar * device_path, GstKsClock * clock, GstKsAllocFunction allocfunc, gpointer allocfunc_data
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_video_device_open</NAME>
<RETURNS>gboolean  </RETURNS>
GstKsVideoDevice * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_video_device_close</NAME>
<RETURNS>void  </RETURNS>
GstKsVideoDevice * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_video_device_get_available_caps</NAME>
<RETURNS>GstCaps  * </RETURNS>
GstKsVideoDevice * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_video_device_has_caps</NAME>
<RETURNS>gboolean  </RETURNS>
GstKsVideoDevice * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_video_device_set_caps</NAME>
<RETURNS>gboolean  </RETURNS>
GstKsVideoDevice * self, GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_video_device_set_state</NAME>
<RETURNS>gboolean  </RETURNS>
GstKsVideoDevice * self, KSSTATE state, gulong * error_code
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_video_device_get_duration</NAME>
<RETURNS>GstClockTime  </RETURNS>
GstKsVideoDevice * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_video_device_get_latency</NAME>
<RETURNS>gboolean  </RETURNS>
GstKsVideoDevice * self, GstClockTime * min_latency, GstClockTime * max_latency
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_video_device_read_frame</NAME>
<RETURNS>GstFlowReturn  </RETURNS>
GstKsVideoDevice * self, GstBuffer ** buf, GstClockTime * presentation_time, gulong * error_code, gchar ** error_str
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_video_device_postprocess_frame</NAME>
<RETURNS>gboolean  </RETURNS>
GstKsVideoDevice * self, GstBuffer **buf
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_video_device_cancel</NAME>
<RETURNS>void  </RETURNS>
GstKsVideoDevice * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_video_device_cancel_stop</NAME>
<RETURNS>void  </RETURNS>
GstKsVideoDevice * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ks_video_device_stream_is_muxed</NAME>
<RETURNS>gboolean  </RETURNS>
GstKsVideoDevice * self
</FUNCTION>
<STRUCT>
<NAME>GstKsVideoDevicePrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>KsDeviceEntry</NAME>
struct _KsDeviceEntry
{
  guint index;
  gchar * name;
  gchar * path;
};
</STRUCT>
<FUNCTION>
<NAME>ks_is_valid_handle</NAME>
<RETURNS>gboolean  </RETURNS>
HANDLE h
</FUNCTION>
<FUNCTION>
<NAME>ks_enumerate_devices</NAME>
<RETURNS>GList  * </RETURNS>
const GUID * devtype, const GUID * direction_category
</FUNCTION>
<FUNCTION>
<NAME>ks_device_entry_free</NAME>
<RETURNS>void  </RETURNS>
KsDeviceEntry * entry
</FUNCTION>
<FUNCTION>
<NAME>ks_device_list_free</NAME>
<RETURNS>void  </RETURNS>
GList * devices
</FUNCTION>
<FUNCTION>
<NAME>ks_filter_get_pin_property</NAME>
<RETURNS>gboolean  </RETURNS>
HANDLE filter_handle, gulong pin_id, GUID prop_set, gulong prop_id, gpointer value, gulong value_size, gulong * error
</FUNCTION>
<FUNCTION>
<NAME>ks_filter_get_pin_property_multi</NAME>
<RETURNS>gboolean  </RETURNS>
HANDLE filter_handle, gulong pin_id, GUID prop_set, gulong prop_id, KSMULTIPLE_ITEM ** items, gulong * error
</FUNCTION>
<FUNCTION>
<NAME>ks_object_query_property</NAME>
<RETURNS>gboolean  </RETURNS>
HANDLE handle, GUID prop_set, gulong prop_id, gulong prop_flags, gpointer * value, gulong * value_size, gulong * error
</FUNCTION>
<FUNCTION>
<NAME>ks_object_get_property</NAME>
<RETURNS>gboolean  </RETURNS>
HANDLE handle, GUID prop_set, gulong prop_id, gpointer * value, gulong * value_size, gulong * error
</FUNCTION>
<FUNCTION>
<NAME>ks_object_set_property</NAME>
<RETURNS>gboolean  </RETURNS>
HANDLE handle, GUID prop_set, gulong prop_id, gpointer value, gulong value_size, gulong * error
</FUNCTION>
<FUNCTION>
<NAME>ks_object_get_supported_property_sets</NAME>
<RETURNS>gboolean  </RETURNS>
HANDLE handle, GUID ** propsets, gulong * len
</FUNCTION>
<FUNCTION>
<NAME>ks_object_set_connection_state</NAME>
<RETURNS>gboolean  </RETURNS>
HANDLE handle, KSSTATE state, gulong * error
</FUNCTION>
<FUNCTION>
<NAME>ks_guid_to_string</NAME>
<RETURNS>gchar  * </RETURNS>
const GUID * guid
</FUNCTION>
<FUNCTION>
<NAME>ks_state_to_string</NAME>
<RETURNS>const gchar  * </RETURNS>
KSSTATE state
</FUNCTION>
<FUNCTION>
<NAME>ks_options_flags_to_string</NAME>
<RETURNS>gchar  * </RETURNS>
gulong flags
</FUNCTION>
<FUNCTION>
<NAME>ks_property_set_to_string</NAME>
<RETURNS>gchar  * </RETURNS>
const GUID * guid
</FUNCTION>
<STRUCT>
<NAME>KsVideoMediaType</NAME>
struct _KsVideoMediaType
{
  guint pin_id;

  const KSDATARANGE * range;
  const KS_VIDEO_STREAM_CONFIG_CAPS vscc;

  guint8 * format;
  guint format_size;

  guint sample_size;

  GstCaps * translated_caps;
  gboolean is_rgb;
};
</STRUCT>
<STRUCT>
<NAME>DVINFO</NAME>
typedef struct DVINFO {
  DWORD dwDVAAuxSrc;
  DWORD dwDVAAuxCtl;
  DWORD dwDVAAuxSrc1;
  DWORD dwDVAAuxCtl1;
  DWORD dwDVVAuxSrc;
  DWORD dwDVVAuxCtl;
  DWORD dwDVReserved[2];
} DVINFO;
</STRUCT>
<MACRO>
<NAME>GST_TYPE_KS_VIDEO_SRC</NAME>
#define GST_TYPE_KS_VIDEO_SRC \
  (gst_ks_video_src_get_type ())
</MACRO>
<MACRO>
<NAME>GST_KS_VIDEO_SRC</NAME>
#define GST_KS_VIDEO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_KS_VIDEO_SRC, GstKsVideoSrc))
</MACRO>
<MACRO>
<NAME>GST_KS_VIDEO_SRC_CLASS</NAME>
#define GST_KS_VIDEO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_KS_VIDEO_SRC, GstKsVideoSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_KS_VIDEO_SRC</NAME>
#define GST_IS_KS_VIDEO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_KS_VIDEO_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_KS_VIDEO_SRC_CLASS</NAME>
#define GST_IS_KS_VIDEO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_KS_VIDEO_SRC))
</MACRO>
<STRUCT>
<NAME>GstKsVideoSrc</NAME>
struct _GstKsVideoSrc
{
  GstPushSrc push_src;

  GstKsVideoSrcPrivate * priv;
};
</STRUCT>
<STRUCT>
<NAME>GstKsVideoSrcClass</NAME>
struct _GstKsVideoSrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ks_video_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstKsVideoSrcPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_BUFFER_POOL_OPTION_KMS_BUFFER</NAME>
#define GST_BUFFER_POOL_OPTION_KMS_BUFFER "GstBufferPoolOptionKMSBuffer"
</MACRO>
<MACRO>
<NAME>GST_TYPE_KMS_BUFFER_POOL</NAME>
#define GST_TYPE_KMS_BUFFER_POOL \
  (gst_kms_buffer_pool_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_KMS_BUFFER_POOL</NAME>
#define GST_IS_KMS_BUFFER_POOL(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_KMS_BUFFER_POOL))
</MACRO>
<MACRO>
<NAME>GST_KMS_BUFFER_POOL</NAME>
#define GST_KMS_BUFFER_POOL(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_KMS_BUFFER_POOL, GstKMSBufferPool))
</MACRO>
<MACRO>
<NAME>GST_KMS_BUFFER_POOL_CAST</NAME>
#define GST_KMS_BUFFER_POOL_CAST(obj) \
  ((GstKMSBufferPool*)(obj))
</MACRO>
<STRUCT>
<NAME>GstKMSBufferPool</NAME>
struct _GstKMSBufferPool
{
  GstVideoBufferPool parent;
  GstKMSBufferPoolPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstKMSBufferPoolClass</NAME>
struct _GstKMSBufferPoolClass
{
  GstVideoBufferPoolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_kms_buffer_pool_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_kms_buffer_pool_new</NAME>
<RETURNS>GstBufferPool  *</RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstKMSBufferPoolPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_KMS_ALLOCATOR</NAME>
#define GST_TYPE_KMS_ALLOCATOR	\
   (gst_kms_allocator_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_KMS_ALLOCATOR</NAME>
#define GST_IS_KMS_ALLOCATOR(obj)				\
   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_KMS_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_KMS_ALLOCATOR_CLASS</NAME>
#define GST_IS_KMS_ALLOCATOR_CLASS(klass)			\
   (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_KMS_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_KMS_ALLOCATOR_GET_CLASS</NAME>
#define GST_KMS_ALLOCATOR_GET_CLASS(obj)			\
   (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_KMS_ALLOCATOR, GstKMSAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_KMS_ALLOCATOR</NAME>
#define GST_KMS_ALLOCATOR(obj)				\
   (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_KMS_ALLOCATOR, GstKMSAllocator))
</MACRO>
<MACRO>
<NAME>GST_KMS_ALLOCATOR_CLASS</NAME>
#define GST_KMS_ALLOCATOR_CLASS(klass)			\
   (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_KMS_ALLOCATOR, GstKMSAllocatorClass))
</MACRO>
<STRUCT>
<NAME>GstKMSMemory</NAME>
struct _GstKMSMemory
{
  GstMemory parent;

  guint32 fb_id;
  guint32 gem_handle[GST_VIDEO_MAX_PLANES];
  struct kms_bo *bo;
};
</STRUCT>
<STRUCT>
<NAME>GstKMSAllocator</NAME>
struct _GstKMSAllocator
{
  GstAllocator parent;
  GstKMSAllocatorPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstKMSAllocatorClass</NAME>
struct _GstKMSAllocatorClass {
  GstAllocatorClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_kms_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_is_kms_memory</NAME>
<RETURNS>gboolean  </RETURNS>
GstMemory *mem
</FUNCTION>
<FUNCTION>
<NAME>gst_kms_memory_get_fb_id</NAME>
<RETURNS>guint32  </RETURNS>
GstMemory *mem
</FUNCTION>
<FUNCTION>
<NAME>gst_kms_allocator_new</NAME>
<RETURNS>GstAllocator * </RETURNS>
gint fd
</FUNCTION>
<FUNCTION>
<NAME>gst_kms_allocator_bo_alloc</NAME>
<RETURNS>GstMemory *    </RETURNS>
GstAllocator *allocator, GstVideoInfo *vinfo
</FUNCTION>
<FUNCTION>
<NAME>gst_kms_allocator_dmabuf_import</NAME>
<RETURNS>GstKMSMemory * </RETURNS>
GstAllocator *allocator, gint *prime_fds, gint n_planes, gsize offsets[GST_VIDEO_MAX_PLANES], GstVideoInfo *vinfo
</FUNCTION>
<STRUCT>
<NAME>GstKMSAllocatorPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>kms_bo</NAME>
struct kms_bo;
</STRUCT>
<MACRO>
<NAME>GST_TYPE_KMS_SINK</NAME>
#define GST_TYPE_KMS_SINK \
  (gst_kms_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_KMS_SINK</NAME>
#define GST_KMS_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_KMS_SINK, GstKMSSink))
</MACRO>
<MACRO>
<NAME>GST_KMS_SINK_CLASS</NAME>
#define GST_KMS_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_KMS_SINK, GstKMSSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_KMS_SINK</NAME>
#define GST_IS_KMS_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_KMS_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_KMS_SINK_CLASS</NAME>
#define GST_IS_KMS_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_KMS_SINK))
</MACRO>
<STRUCT>
<NAME>GstKMSSink</NAME>
struct _GstKMSSink {
  GstVideoSink videosink;

  /*< private >*/
  gint fd;
  gint conn_id;
  gint crtc_id;
  gint plane_id;
  guint pipe;

  /* crtc data */
  guint16 hdisplay, vdisplay;
  guint32 buffer_id;

  /* capabilities */
  gboolean has_prime_import;
  gboolean has_async_page_flip;
  gboolean can_scale;

  gboolean modesetting_enabled;

  GstVideoInfo vinfo;
  GstCaps *allowed_caps;
  GstBufferPool *pool;
  GstAllocator *allocator;
  GstBuffer *last_buffer;
  GstMemory *tmp_kmsmem;

  gchar *devname;

  guint32 mm_width, mm_height;

  GstPoll *poll;
  GstPollFD pollfd;
};
</STRUCT>
<STRUCT>
<NAME>GstKMSSinkClass</NAME>
struct _GstKMSSinkClass {
  GstVideoSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_kms_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_video_format_from_drm</NAME>
<RETURNS>GstVideoFormat  </RETURNS>
guint32 drmfmt
</FUNCTION>
<FUNCTION>
<NAME>gst_drm_format_from_video</NAME>
<RETURNS>guint32         </RETURNS>
GstVideoFormat fmt
</FUNCTION>
<FUNCTION>
<NAME>gst_drm_bpp_from_drm</NAME>
<RETURNS>guint32         </RETURNS>
guint32 drmfmt
</FUNCTION>
<FUNCTION>
<NAME>gst_drm_height_from_drm</NAME>
<RETURNS>guint32         </RETURNS>
guint32 drmfmt, guint32 height
</FUNCTION>
<FUNCTION>
<NAME>gst_kms_sink_caps_template_fill</NAME>
<RETURNS>GstCaps  *      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_video_calculate_device_ratio</NAME>
<RETURNS>void            </RETURNS>
guint dev_width, guint dev_height, guint dev_width_mm, guint dev_height_mm, guint * dpy_par_n, guint * dpy_par_d
</FUNCTION>
<MACRO>
<NAME>VCD_BYTES_PER_SECTOR</NAME>
#define VCD_BYTES_PER_SECTOR 2352
</MACRO>
<MACRO>
<NAME>GST_TYPE_VCDSRC</NAME>
#define GST_TYPE_VCDSRC \
  (gst_vcdsrc_get_type())
</MACRO>
<MACRO>
<NAME>GST_VCDSRC</NAME>
#define GST_VCDSRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VCDSRC,GstVCDSrc))
</MACRO>
<MACRO>
<NAME>GST_VCDSRC_CLASS</NAME>
#define GST_VCDSRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VCDSRC,GstVCDSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VCDSRC</NAME>
#define GST_IS_VCDSRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VCDSRC))
</MACRO>
<MACRO>
<NAME>GST_IS_VCDSRC_CLASS</NAME>
#define GST_IS_VCDSRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VCDSRC))
</MACRO>
<STRUCT>
<NAME>GstVCDSrc</NAME>
struct _GstVCDSrc {
  GstPushSrc parent_object;

  /* device */
  gchar *device;
  /* track number */
  gint track;
  int max_errors;

  /* fd */
  gint fd;
  gint numtracks;
  struct cdrom_tochdr tochdr;
  struct cdrom_tocentry *tracks;

  /* current time offset */
  gulong trackoffset;
  gulong curoffset;                     /* current offset in file */
  gulong bytes_per_read;                /* bytes per read */
};
</STRUCT>
<STRUCT>
<NAME>GstVCDSrcClass</NAME>
struct _GstVCDSrcClass {
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vcdsrc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<USER_FUNCTION>
<NAME>sp_buffer_free_callback</NAME>
<RETURNS>void </RETURNS>
void * tag, void * user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>sp_writer_create</NAME>
<RETURNS>ShmPipe  *</RETURNS>
const char *path, size_t size, mode_t perms
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_get_path</NAME>
<RETURNS>const char  *</RETURNS>
ShmPipe *pipe
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_close</NAME>
<RETURNS>void  </RETURNS>
ShmPipe * self, sp_buffer_free_callback callback, void * user_data
</FUNCTION>
<FUNCTION>
<NAME>sp_get_data</NAME>
<RETURNS>void  *</RETURNS>
ShmPipe * self
</FUNCTION>
<FUNCTION>
<NAME>sp_set_data</NAME>
<RETURNS>void  </RETURNS>
ShmPipe * self, void *data
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_setperms_shm</NAME>
<RETURNS>int  </RETURNS>
ShmPipe * self, mode_t perms
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_resize</NAME>
<RETURNS>int  </RETURNS>
ShmPipe * self, size_t size
</FUNCTION>
<FUNCTION>
<NAME>sp_get_fd</NAME>
<RETURNS>int  </RETURNS>
ShmPipe * self
</FUNCTION>
<FUNCTION>
<NAME>sp_get_shm_area_name</NAME>
<RETURNS>const char  *</RETURNS>
ShmPipe *self
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_get_client_fd</NAME>
<RETURNS>int  </RETURNS>
ShmClient * client
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_alloc_block</NAME>
<RETURNS>ShmBlock  *</RETURNS>
ShmPipe * self, size_t size
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_free_block</NAME>
<RETURNS>void  </RETURNS>
ShmBlock *block
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_send_buf</NAME>
<RETURNS>int  </RETURNS>
ShmPipe * self, char *buf, size_t size, void * tag
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_block_get_buf</NAME>
<RETURNS>char  *</RETURNS>
ShmBlock *block
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_block_get_pipe</NAME>
<RETURNS>ShmPipe  *</RETURNS>
ShmBlock *block
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_get_max_buf_size</NAME>
<RETURNS>size_t  </RETURNS>
ShmPipe * self
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_accept_client</NAME>
<RETURNS>ShmClient  * </RETURNS>
ShmPipe * self
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_close_client</NAME>
<RETURNS>void  </RETURNS>
ShmPipe *self, ShmClient * client, sp_buffer_free_callback callback, void * user_data
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_recv</NAME>
<RETURNS>int  </RETURNS>
ShmPipe * self, ShmClient * client, void ** tag
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_pending_writes</NAME>
<RETURNS>int  </RETURNS>
ShmPipe * self
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_get_pending_buffers</NAME>
<RETURNS>ShmBuffer  *</RETURNS>
ShmPipe * self
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_get_next_buffer</NAME>
<RETURNS>ShmBuffer  *</RETURNS>
ShmBuffer * buffer
</FUNCTION>
<FUNCTION>
<NAME>sp_writer_buf_get_tag</NAME>
<RETURNS>void  *</RETURNS>
ShmBuffer * buffer
</FUNCTION>
<FUNCTION>
<NAME>sp_client_open</NAME>
<RETURNS>ShmPipe  *</RETURNS>
const char *path
</FUNCTION>
<FUNCTION>
<NAME>sp_client_recv</NAME>
<RETURNS>long int  </RETURNS>
ShmPipe * self, char **buf
</FUNCTION>
<FUNCTION>
<NAME>sp_client_recv_finish</NAME>
<RETURNS>int  </RETURNS>
ShmPipe * self, char *buf
</FUNCTION>
<FUNCTION>
<NAME>sp_client_close</NAME>
<RETURNS>void  </RETURNS>
ShmPipe * self
</FUNCTION>
<STRUCT>
<NAME>ShmBlock</NAME>
</STRUCT>
<STRUCT>
<NAME>ShmBuffer</NAME>
</STRUCT>
<STRUCT>
<NAME>ShmClient</NAME>
</STRUCT>
<STRUCT>
<NAME>ShmPipe</NAME>
</STRUCT>
<MACRO>
<NAME>spalloc_new</NAME>
#define spalloc_new(type) g_slice_new (type)
</MACRO>
<MACRO>
<NAME>spalloc_alloc</NAME>
#define spalloc_alloc(size) g_slice_alloc (size)
</MACRO>
<MACRO>
<NAME>spalloc_free</NAME>
#define spalloc_free(type, buf) g_slice_free (type, buf)
</MACRO>
<MACRO>
<NAME>spalloc_free1</NAME>
#define spalloc_free1(size, buf) g_slice_free1 (size, buf)
</MACRO>
<FUNCTION>
<NAME>shm_alloc_space_new</NAME>
<RETURNS>ShmAllocSpace  *</RETURNS>
size_t size
</FUNCTION>
<FUNCTION>
<NAME>shm_alloc_space_free</NAME>
<RETURNS>void  </RETURNS>
ShmAllocSpace * self
</FUNCTION>
<FUNCTION>
<NAME>shm_alloc_space_alloc_block</NAME>
<RETURNS>ShmAllocBlock  *</RETURNS>
ShmAllocSpace * self, unsigned long size
</FUNCTION>
<FUNCTION>
<NAME>shm_alloc_space_alloc_block_get_offset</NAME>
<RETURNS>unsigned long  </RETURNS>
ShmAllocBlock *block
</FUNCTION>
<FUNCTION>
<NAME>shm_alloc_space_block_inc</NAME>
<RETURNS>void  </RETURNS>
ShmAllocBlock * block
</FUNCTION>
<FUNCTION>
<NAME>shm_alloc_space_block_dec</NAME>
<RETURNS>void  </RETURNS>
ShmAllocBlock * block
</FUNCTION>
<FUNCTION>
<NAME>shm_alloc_space_block_get</NAME>
<RETURNS>ShmAllocBlock  * </RETURNS>
ShmAllocSpace * space, unsigned long offset
</FUNCTION>
<STRUCT>
<NAME>ShmAllocBlock</NAME>
</STRUCT>
<STRUCT>
<NAME>ShmAllocSpace</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_FBDEVSINK</NAME>
#define GST_TYPE_FBDEVSINK \
  (gst_fbdevsink_get_type())
</MACRO>
<MACRO>
<NAME>GST_FBDEVSINK</NAME>
#define GST_FBDEVSINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FBDEVSINK,GstFBDEVSink))
</MACRO>
<MACRO>
<NAME>GST_FBDEVSINK_CLASS</NAME>
#define GST_FBDEVSINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FBDEVSINK,GstFBDEVSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FBDEVSINK</NAME>
#define GST_IS_FBDEVSINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FBDEVSINK))
</MACRO>
<MACRO>
<NAME>GST_IS_FBDEVSINK_CLASS</NAME>
#define GST_IS_FBDEVSINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FBDEVSINK))
</MACRO>
<STRUCT>
<NAME>GstFBDEVSink</NAME>
struct _GstFBDEVSink {
  GstVideoSink videosink;

  /*< private >*/
  struct fb_fix_screeninfo fixinfo;
  struct fb_var_screeninfo varinfo;

  int fd;
  unsigned char *framebuffer;

  char *device;

  int width, height;
  int cx, cy, linelen, lines, bytespp;

  int fps_n, fps_d;
};
</STRUCT>
<STRUCT>
<NAME>GstFBDEVSinkClass</NAME>
struct _GstFBDEVSinkClass {
  GstVideoSinkClass videosink_class;

};
</STRUCT>
<FUNCTION>
<NAME>gst_fbdevsink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>HOST_BUFFER_SIZE</NAME>
#define HOST_BUFFER_SIZE 1024
</MACRO>
<MACRO>
<NAME>CAM_TL</NAME>
#define CAM_TL(obj) ((CamTL *) obj)
</MACRO>
<MACRO>
<NAME>CAM_TL_CONNECTION</NAME>
#define CAM_TL_CONNECTION(obj) ((CamTLConnection *) obj)
</MACRO>
<ENUM>
<NAME>CamTLConnectionState</NAME>
typedef enum
{
  CAM_TL_CONNECTION_STATE_CLOSED,
  CAM_TL_CONNECTION_STATE_IN_CREATION,
  CAM_TL_CONNECTION_STATE_OPEN,
  CAM_TL_CONNECTION_STATE_IN_DELETION
} CamTLConnectionState;
</ENUM>
<STRUCT>
<NAME>CamTL</NAME>
struct _CamTL
{
  int fd;
  guint connection_ids;

  GHashTable *connections;

  guint expected_tpdus;

  /* buffer containing module data */
  guint8 buffer [HOST_BUFFER_SIZE];
  /* number of bytes written in the buffer */
  guint buffer_size;
  /* index pointing to the first byte of a TPDU's body */
  guint8 *body;
  /* length of the body part */
  guint body_length;

  /* callbacks */
  void (*request_connection) (CamTL *tl, CamTLConnection *connection);
  void (*connection_created) (CamTL *tl, CamTLConnection *connection);
  void (*connection_deleted) (CamTL *tl, CamTLConnection *connection);
  CamReturn (*connection_data) (CamTL *tl, CamTLConnection *connection,
    guint8 *data, guint length);

  /* used by the upper layer to extend this layer */
  gpointer user_data;
};
</STRUCT>
<STRUCT>
<NAME>CamTLConnection</NAME>
struct _CamTLConnection
{
  CamTL *tl;

  guint8 slot;
  guint id;
  CamTLConnectionState state;
  /* TRUE if the last status byte was 0x80, FALSE otherwise */
  gboolean has_data;
  /* NCAS 1.0 sometimes reports that it has data even if it doesn't. After
   * MAX_EMPTY_DATA times that we don't get any data we assume that there's
   * actually no data.
   */
  guint empty_data;
  /* timer restarted every time the connection is polled */
  GTimer *last_poll;

  gpointer user_data;
};
</STRUCT>
<FUNCTION>
<NAME>cam_tl_new</NAME>
<RETURNS>CamTL  *</RETURNS>
int cam_device_fd
</FUNCTION>
<FUNCTION>
<NAME>cam_tl_destroy</NAME>
<RETURNS>void  </RETURNS>
CamTL *tl
</FUNCTION>
<FUNCTION>
<NAME>cam_tl_create_connection</NAME>
<RETURNS>CamReturn  </RETURNS>
CamTL *tl, guint8 slot, CamTLConnection **connnection
</FUNCTION>
<FUNCTION>
<NAME>cam_tl_connection_delete</NAME>
<RETURNS>CamReturn  </RETURNS>
CamTLConnection *connection
</FUNCTION>
<FUNCTION>
<NAME>cam_tl_calc_buffer_size</NAME>
<RETURNS>void  </RETURNS>
CamTL *tl, guint body_length, guint *buffer_size, guint *offset
</FUNCTION>
<FUNCTION>
<NAME>cam_tl_connection_write</NAME>
<RETURNS>CamReturn  </RETURNS>
CamTLConnection *connection, guint8 *data, guint buffer_size, guint body_length
</FUNCTION>
<FUNCTION>
<NAME>cam_tl_connection_poll</NAME>
<RETURNS>CamReturn  </RETURNS>
CamTLConnection *connection, gboolean force
</FUNCTION>
<FUNCTION>
<NAME>cam_tl_read_all</NAME>
<RETURNS>CamReturn  </RETURNS>
CamTL *tl, gboolean poll
</FUNCTION>
<STRUCT>
<NAME>CamTLConnectionPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>CamTLPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>CAM_RESOURCE_MANAGER</NAME>
#define CAM_RESOURCE_MANAGER(obj) ((CamResourceManager *) obj)
</MACRO>
<STRUCT>
<NAME>CamResourceManager</NAME>
struct _CamResourceManager
{
  CamALApplication application;
};
</STRUCT>
<FUNCTION>
<NAME>cam_resource_manager_new</NAME>
<RETURNS>CamResourceManager  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>cam_resource_manager_destroy</NAME>
<RETURNS>void  </RETURNS>
CamResourceManager *manager
</FUNCTION>
<FUNCTION>
<NAME>cam_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>TPDU_HEADER_SIZE_INDICATOR</NAME>
#define TPDU_HEADER_SIZE_INDICATOR 0x80
</MACRO>
<MACRO>
<NAME>CAM_FAILED</NAME>
#define CAM_FAILED(ret) (ret <= CAM_RETURN_ERROR)
</MACRO>
<ENUM>
<NAME>CamReturn</NAME>
typedef enum
{
  /* generic */
  CAM_RETURN_OK = 0,
  CAM_RETURN_ERROR = -1,

  /* transport specific */
  CAM_RETURN_TRANSPORT_ERROR = -10,
  CAM_RETURN_TRANSPORT_TOO_MANY_CONNECTIONS = -11,
  CAM_RETURN_TRANSPORT_TIMEOUT = -12,
  CAM_RETURN_TRANSPORT_POLL = -13,

  /* session specific */
  CAM_RETURN_SESSION_ERROR = -30,
  CAM_RETURN_SESSION_TOO_MANY_SESSIONS = -31,

  /* application specific */
  CAM_RETURN_APPLICATION_ERROR = -40,
} CamReturn;
</ENUM>
<FUNCTION>
<NAME>cam_calc_length_field_size</NAME>
<RETURNS>guint8  </RETURNS>
guint length
</FUNCTION>
<FUNCTION>
<NAME>cam_write_length_field</NAME>
<RETURNS>guint8  </RETURNS>
guint8 *buff, guint length
</FUNCTION>
<FUNCTION>
<NAME>cam_read_length_field</NAME>
<RETURNS>guint8  </RETURNS>
guint8 *buff, guint *length
</FUNCTION>
<FUNCTION>
<NAME>cam_build_ca_pmt</NAME>
<RETURNS>guint8  *</RETURNS>
GstMpegtsPMT *pmt, guint8 list_management, guint8 cmd_id, guint *size
</FUNCTION>
<ENUM>
<NAME>CamDeviceState</NAME>
typedef enum
{
  CAM_DEVICE_STATE_CLOSED,
  CAM_DEVICE_STATE_OPEN,
} CamDeviceState;
</ENUM>
<FUNCTION>
<NAME>cam_device_new</NAME>
<RETURNS>CamDevice  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>cam_device_free</NAME>
<RETURNS>void  </RETURNS>
CamDevice *device
</FUNCTION>
<FUNCTION>
<NAME>cam_device_open</NAME>
<RETURNS>gboolean  </RETURNS>
CamDevice *device, const char *filename
</FUNCTION>
<FUNCTION>
<NAME>cam_device_close</NAME>
<RETURNS>void  </RETURNS>
CamDevice *device
</FUNCTION>
<FUNCTION>
<NAME>cam_device_ready</NAME>
<RETURNS>gboolean  </RETURNS>
CamDevice *device
</FUNCTION>
<FUNCTION>
<NAME>cam_device_poll</NAME>
<RETURNS>void  </RETURNS>
CamDevice *device
</FUNCTION>
<FUNCTION>
<NAME>cam_device_set_pmt</NAME>
<RETURNS>void  </RETURNS>
CamDevice *device, GstMpegtsPMT *pmt, CamConditionalAccessPmtFlag flag
</FUNCTION>
<MACRO>
<NAME>CAM_CONDITIONAL_ACCESS</NAME>
#define CAM_CONDITIONAL_ACCESS(obj) ((CamConditionalAccess *) obj)
</MACRO>
<ENUM>
<NAME>CamConditionalAccessPmtFlag</NAME>
typedef enum
{
  CAM_CONDITIONAL_ACCESS_PMT_FLAG_MORE = 0,
  CAM_CONDITIONAL_ACCESS_PMT_FLAG_FIRST,
  CAM_CONDITIONAL_ACCESS_PMT_FLAG_LAST,
  CAM_CONDITIONAL_ACCESS_PMT_FLAG_ONLY,
  CAM_CONDITIONAL_ACCESS_PMT_FLAG_ADD,
  CAM_CONDITIONAL_ACCESS_PMT_FLAG_UPDATE,
} CamConditionalAccessPmtFlag;
</ENUM>
<STRUCT>
<NAME>CamConditionalAccess</NAME>
struct _CamConditionalAccess
{
  CamALApplication application;
  gboolean ready;
};
</STRUCT>
<FUNCTION>
<NAME>cam_conditional_access_new</NAME>
<RETURNS>CamConditionalAccess  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>cam_conditional_access_destroy</NAME>
<RETURNS>void  </RETURNS>
CamConditionalAccess *cas
</FUNCTION>
<FUNCTION>
<NAME>cam_conditional_access_set_pmt</NAME>
<RETURNS>CamReturn  </RETURNS>
CamConditionalAccess *cas, GstMpegtsPMT *pmt, CamConditionalAccessPmtFlag flag
</FUNCTION>
<FUNCTION>
<NAME>set_properties_for_channel</NAME>
<RETURNS>gboolean  </RETURNS>
GstElement  * dvbbasebin, const gchar * channel_name, GError     ** error
</FUNCTION>
<ENUM>
<NAME>CamSwClientState</NAME>
typedef enum
{
  CAM_SW_CLIENT_STATE_CLOSED,
  CAM_SW_CLIENT_STATE_OPEN,
} CamSwClientState;
</ENUM>
<FUNCTION>
<NAME>cam_sw_client_new</NAME>
<RETURNS>CamSwClient  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>cam_sw_client_free</NAME>
<RETURNS>void  </RETURNS>
CamSwClient *sw_client
</FUNCTION>
<FUNCTION>
<NAME>cam_sw_client_open</NAME>
<RETURNS>gboolean  </RETURNS>
CamSwClient *sw_client, const char *sock_path
</FUNCTION>
<FUNCTION>
<NAME>cam_sw_client_close</NAME>
<RETURNS>void  </RETURNS>
CamSwClient *sw_client
</FUNCTION>
<FUNCTION>
<NAME>cam_sw_client_set_pmt</NAME>
<RETURNS>void  </RETURNS>
CamSwClient *sw_client, GstMpegtsPMT *pmt
</FUNCTION>
<FUNCTION>
<NAME>cam_sw_client_update_pmt</NAME>
<RETURNS>void  </RETURNS>
CamSwClient *sw_client, GstMpegtsPMT *pmt
</FUNCTION>
<MACRO>
<NAME>CAM_APPLICATION_INFO</NAME>
#define CAM_APPLICATION_INFO(obj) ((CamApplicationInfo *) obj)
</MACRO>
<STRUCT>
<NAME>CamApplicationInfo</NAME>
struct _CamApplicationInfo
{
  CamALApplication application;
};
</STRUCT>
<FUNCTION>
<NAME>cam_application_info_new</NAME>
<RETURNS>CamApplicationInfo  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>cam_application_info_destroy</NAME>
<RETURNS>void  </RETURNS>
CamApplicationInfo *info
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DVB_BASE_BIN</NAME>
#define GST_TYPE_DVB_BASE_BIN \
  (dvb_base_bin_get_type())
</MACRO>
<MACRO>
<NAME>GST_DVB_BASE_BIN</NAME>
#define GST_DVB_BASE_BIN(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DVB_BASE_BIN,DvbBaseBin))
</MACRO>
<MACRO>
<NAME>GST_DVB_BASE_BIN_CLASS</NAME>
#define GST_DVB_BASE_BIN_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DVB_BASE_BIN,DvbBaseBinClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DVB_BASE_BIN</NAME>
#define GST_IS_DVB_BASE_BIN(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DVB_BASE_BIN))
</MACRO>
<MACRO>
<NAME>GST_IS_DVB_BASE_BIN_CLASS</NAME>
#define GST_IS_DVB_BASE_BIN_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DVB_BASE_BIN))
</MACRO>
<STRUCT>
<NAME>DvbBaseBin</NAME>
struct _DvbBaseBin {
  GstBin bin;

  GstElement *dvbsrc;
  GstElement *buffer_queue;
  GstElement *tsparse;
  CamDevice *hwcam;
  gboolean trycam;
  GList *pmtlist;
  gboolean pmtlist_changed;
  gchar *filter;
  GHashTable *streams;
  GHashTable *programs;
  gboolean disposed;

  GstTask *task;
  GstPoll *poll;
  GRecMutex lock;

  /* Cached value */
  gchar *program_numbers;
};
</STRUCT>
<STRUCT>
<NAME>DvbBaseBinClass</NAME>
struct _DvbBaseBinClass {
  GstBinClass parent_class;

  /* signals */
  void (*do_tune) (DvbBaseBin * dvbbasebin);
};
</STRUCT>
<FUNCTION>
<NAME>dvb_base_bin_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_dvb_base_bin_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin *plugin
</FUNCTION>
<MACRO>
<NAME>CAM_SL</NAME>
#define CAM_SL(obj) ((CamSL *) obj)
</MACRO>
<MACRO>
<NAME>CAM_SL_SESSION</NAME>
#define CAM_SL_SESSION(obj) ((CamSLSession *) obj)
</MACRO>
<ENUM>
<NAME>CamSLSessionState</NAME>
typedef enum
{
  CAM_SL_SESSION_STATE_IDLE,
  CAM_SL_SESSION_STATE_OPENING,
  CAM_SL_SESSION_STATE_ACTIVE,
  CAM_SL_SESSION_STATE_CLOSING
} CamSLSessionState;
</ENUM>
<ENUM>
<NAME>CamSLResourceStatus</NAME>
typedef enum
{
  CAM_SL_RESOURCE_STATUS_OPEN = 0x00,
  CAM_SL_RESOURCE_STATUS_NOT_FOUND = 0xF0,
  CAM_SL_RESOURCE_STATUS_UNAVAILABLE = 0xF1,
  CAM_SL_RESOURCE_STATUS_INVALID_VERSION = 0xF2,
  CAM_SL_RESOURCE_STATUS_BUSY = 0xF3
} CamSLResourceStatus;
</ENUM>
<STRUCT>
<NAME>CamSL</NAME>
struct _CamSL
{
  CamTL *tl;

  GHashTable *sessions;
  guint session_ids;

  /* callbacks */
  CamReturn (*open_session_request) (CamSL *sl, CamSLSession *session,
    CamSLResourceStatus *status);
  CamReturn (*session_opened) (CamSL *sl, CamSLSession *session);
  CamReturn (*session_closed) (CamSL *sl, CamSLSession *session);
  CamReturn (*session_data) (CamSL *sl, CamSLSession *session,
    guint8 *data, guint length);

  gpointer user_data;
};
</STRUCT>
<STRUCT>
<NAME>CamSLSession</NAME>
struct _CamSLSession
{
  CamSL *sl;
  CamTLConnection *connection;

  guint resource_id;
  guint16 session_nb;

  CamSLSessionState state;

  gpointer user_data;
};
</STRUCT>
<FUNCTION>
<NAME>cam_sl_new</NAME>
<RETURNS>CamSL  *</RETURNS>
CamTL *transport
</FUNCTION>
<FUNCTION>
<NAME>cam_sl_destroy</NAME>
<RETURNS>void  </RETURNS>
CamSL *sl
</FUNCTION>
<FUNCTION>
<NAME>cam_sl_create_session</NAME>
<RETURNS>CamReturn  </RETURNS>
CamSL *sl, CamTLConnection *connection, guint resource_id, CamSLSession **session
</FUNCTION>
<FUNCTION>
<NAME>cam_sl_session_close</NAME>
<RETURNS>CamReturn  </RETURNS>
CamSLSession *session
</FUNCTION>
<FUNCTION>
<NAME>cam_sl_calc_buffer_size</NAME>
<RETURNS>void  </RETURNS>
CamSL *sl, guint body_length, guint *buffer_size, guint *offset
</FUNCTION>
<FUNCTION>
<NAME>cam_sl_session_write</NAME>
<RETURNS>CamReturn  </RETURNS>
CamSLSession *session, guint8 *buffe, guint buffer_size, guint body_length
</FUNCTION>
<MACRO>
<NAME>CAM_AL</NAME>
#define CAM_AL(obj) ((CamAL *) obj)
</MACRO>
<MACRO>
<NAME>CAM_AL_APPLICATION</NAME>
#define CAM_AL_APPLICATION(obj) ((CamALApplication *) obj)
</MACRO>
<MACRO>
<NAME>CAM_AL_RESOURCE_ID_IS_PUBLIC</NAME>
#define CAM_AL_RESOURCE_ID_IS_PUBLIC(resource_id) ((resource_id >> 30) != 3)
</MACRO>
<MACRO>
<NAME>CAM_AL_RESOURCE_ID_CLASS</NAME>
#define CAM_AL_RESOURCE_ID_CLASS(resource_id) ((resource_id >> 16) & 0x3FFF)
</MACRO>
<MACRO>
<NAME>CAM_AL_RESOURCE_ID_TYPE</NAME>
#define CAM_AL_RESOURCE_ID_TYPE(resource_id) ((resource_id >> 6) & 0x03FF)
</MACRO>
<MACRO>
<NAME>CAM_AL_RESOURCE_ID_VERSION</NAME>
#define CAM_AL_RESOURCE_ID_VERSION(resource_id) (resource_id & 0x3F)
</MACRO>
<MACRO>
<NAME>CAM_AL_RESOURCE_MANAGER_ID</NAME>
#define CAM_AL_RESOURCE_MANAGER_ID 0x10041
</MACRO>
<MACRO>
<NAME>CAM_AL_APPLICATION_INFO_ID</NAME>
#define CAM_AL_APPLICATION_INFO_ID 0x20041
</MACRO>
<MACRO>
<NAME>CAM_AL_CONDITIONAL_ACCESS_ID</NAME>
#define CAM_AL_CONDITIONAL_ACCESS_ID 0x30041
</MACRO>
<STRUCT>
<NAME>CamAL</NAME>
struct _CamAL
{
  CamSL *sl;

  GHashTable *applications;
};
</STRUCT>
<STRUCT>
<NAME>CamALApplication</NAME>
struct _CamALApplication
{
  CamAL *al;
  guint resource_id;
  GList *sessions;

  /* vtable */
  CamReturn (*session_request) (CamALApplication *application,
    CamSLSession *session, CamSLResourceStatus *status);
  CamReturn (*open) (CamALApplication *application, CamSLSession *session);
  CamReturn (*close) (CamALApplication *application, CamSLSession *session);
  CamReturn (*data) (CamALApplication *application, CamSLSession *session,
    guint tag, guint8 *buffer, guint length);
};
</STRUCT>
<FUNCTION>
<NAME>cam_al_new</NAME>
<RETURNS>CamAL  *</RETURNS>
CamSL *sl
</FUNCTION>
<FUNCTION>
<NAME>cam_al_destroy</NAME>
<RETURNS>void  </RETURNS>
CamAL *al
</FUNCTION>
<FUNCTION>
<NAME>cam_al_install</NAME>
<RETURNS>gboolean  </RETURNS>
CamAL *al, CamALApplication *application
</FUNCTION>
<FUNCTION>
<NAME>cam_al_uninstall</NAME>
<RETURNS>gboolean  </RETURNS>
CamAL *al, CamALApplication *application
</FUNCTION>
<FUNCTION>
<NAME>cam_al_get</NAME>
<RETURNS>CamALApplication  *</RETURNS>
CamAL *al, guint resource_id
</FUNCTION>
<FUNCTION>
<NAME>cam_al_get_resource_ids</NAME>
<RETURNS>GList  *</RETURNS>
CamAL *al
</FUNCTION>
<FUNCTION>
<NAME>cam_al_calc_buffer_size</NAME>
<RETURNS>void  </RETURNS>
CamAL *al, guint body_length, guint *buffer_size, guint *offset
</FUNCTION>
<FUNCTION>
<NAME>cam_al_application_write</NAME>
<RETURNS>CamReturn  </RETURNS>
CamALApplication *application, CamSLSession *session, guint tag, guint8 *buffer, guint buffer_size, guint body_length
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DIRECTSOUND_SRC</NAME>
#define GST_TYPE_DIRECTSOUND_SRC (gst_directsound_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_DIRECTSOUND_SRC</NAME>
#define GST_DIRECTSOUND_SRC(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DIRECTSOUND_SRC,GstDirectSoundSrc))
</MACRO>
<MACRO>
<NAME>GST_DIRECTSOUND_SRC_CLASS</NAME>
#define GST_DIRECTSOUND_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DIRECTSOUND_SRC,GstDirectSoundSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DIRECTSOUND_SRC</NAME>
#define GST_IS_DIRECTSOUND_SRC(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DIRECTSOUND_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_DIRECTSOUND_SRC_CLASS</NAME>
#define GST_IS_DIRECTSOUND_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DIRECTSOUND_SRC))
</MACRO>
<MACRO>
<NAME>GST_DSOUND_LOCK</NAME>
#define GST_DSOUND_LOCK(obj)	(g_mutex_lock (&obj->dsound_lock))
</MACRO>
<MACRO>
<NAME>GST_DSOUND_UNLOCK</NAME>
#define GST_DSOUND_UNLOCK(obj)	(g_mutex_unlock (&obj->dsound_lock))
</MACRO>
<STRUCT>
<NAME>GstDirectSoundSrc</NAME>
struct _GstDirectSoundSrc
{

  GstAudioSrc src;

  HINSTANCE DSoundDLL; /* DLL instance */
  LPDIRECTSOUNDCAPTURE pDSC; /* DirectSoundCapture*/
  LPDIRECTSOUNDCAPTUREBUFFER pDSBSecondary;  /*Secondaty capturebuffer*/
  DWORD current_circular_offset;

  guint buffer_size;
  guint bytes_per_sample;

  guint latency_time;

  HMIXER mixer;
  DWORD mixerline_cchannels;
  gint control_id_volume;
  gint control_id_mute;
  glong dw_vol_max;
  glong dw_vol_min;

  glong volume;
  gboolean mute;

  GUID *device_guid;

  char *device_name;
  char *device_id;

  GMutex dsound_lock;

  GstClock *system_clock;
  GstClockID *read_wait_clock_id;
  gboolean reset_while_sleeping;
};
</STRUCT>
<STRUCT>
<NAME>GstDirectSoundSrcClass</NAME>
struct _GstDirectSoundSrcClass 
{
  GstAudioSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_directsound_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WASAPI_SINK</NAME>
#define GST_TYPE_WASAPI_SINK \
  (gst_wasapi_sink_get_type ())
</MACRO>
<MACRO>
<NAME>GST_WASAPI_SINK</NAME>
#define GST_WASAPI_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WASAPI_SINK, GstWasapiSink))
</MACRO>
<MACRO>
<NAME>GST_WASAPI_SINK_CLASS</NAME>
#define GST_WASAPI_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_WASAPI_SINK, GstWasapiSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WASAPI_SINK</NAME>
#define GST_IS_WASAPI_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WASAPI_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_WASAPI_SINK_CLASS</NAME>
#define GST_IS_WASAPI_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_WASAPI_SINK))
</MACRO>
<STRUCT>
<NAME>GstWasapiSink</NAME>
struct _GstWasapiSink
{
  GstAudioSink parent;

  GstAudioInfo info;

  IAudioClient * client;
  IAudioRenderClient * render_client;
  HANDLE event_handle;
};
</STRUCT>
<STRUCT>
<NAME>GstWasapiSinkClass</NAME>
struct _GstWasapiSinkClass
{
  GstAudioSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wasapi_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_WASAPI_SRC</NAME>
#define GST_TYPE_WASAPI_SRC \
  (gst_wasapi_src_get_type ())
</MACRO>
<MACRO>
<NAME>GST_WASAPI_SRC</NAME>
#define GST_WASAPI_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_WASAPI_SRC, GstWasapiSrc))
</MACRO>
<MACRO>
<NAME>GST_WASAPI_SRC_CLASS</NAME>
#define GST_WASAPI_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_WASAPI_SRC, GstWasapiSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_WASAPI_SRC</NAME>
#define GST_IS_WASAPI_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_WASAPI_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_WASAPI_SRC_CLASS</NAME>
#define GST_IS_WASAPI_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_WASAPI_SRC))
</MACRO>
<STRUCT>
<NAME>GstWasapiSrc</NAME>
struct _GstWasapiSrc
{
  GstAudioSrc parent;

  GstAudioInfo info;

  IAudioClient * client;
  IAudioClock * client_clock;
  guint64 client_clock_freq;
  IAudioCaptureClient * capture_client;
  HANDLE event_handle;
};
</STRUCT>
<STRUCT>
<NAME>GstWasapiSrcClass</NAME>
struct _GstWasapiSrcClass
{
  GstAudioSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_wasapi_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_wasapi_util_hresult_to_string</NAME>
<RETURNS>const gchar  *</RETURNS>
HRESULT hr
</FUNCTION>
<FUNCTION>
<NAME>gst_wasapi_util_get_default_device_client</NAME>
<RETURNS>gboolean </RETURNS>
GstElement * element, gboolean capture, IAudioClient ** ret_client
</FUNCTION>
<FUNCTION>
<NAME>gst_wasapi_util_get_render_client</NAME>
<RETURNS>gboolean  </RETURNS>
GstElement * element, IAudioClient *client, IAudioRenderClient ** ret_render_client
</FUNCTION>
<FUNCTION>
<NAME>gst_wasapi_util_get_capture_client</NAME>
<RETURNS>gboolean  </RETURNS>
GstElement * element, IAudioClient * client, IAudioCaptureClient ** ret_capture_client
</FUNCTION>
<FUNCTION>
<NAME>gst_wasapi_util_get_clock</NAME>
<RETURNS>gboolean  </RETURNS>
GstElement * element, IAudioClient * client, IAudioClock ** ret_clock
</FUNCTION>
<FUNCTION>
<NAME>gst_wasapi_util_audio_info_to_waveformatex</NAME>
<RETURNS>void </RETURNS>
GstAudioInfo *info, WAVEFORMATEXTENSIBLE *format
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_D3DVIDEOSINK</NAME>
#define GST_TYPE_D3DVIDEOSINK                     (gst_d3dvideosink_get_type())
</MACRO>
<MACRO>
<NAME>GST_D3DVIDEOSINK</NAME>
#define GST_D3DVIDEOSINK(obj)                     (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_D3DVIDEOSINK,GstD3DVideoSink))
</MACRO>
<MACRO>
<NAME>GST_D3DVIDEOSINK_CLASS</NAME>
#define GST_D3DVIDEOSINK_CLASS(klass)             (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_D3DVIDEOSINK,GstD3DVideoSinkClass))
</MACRO>
<MACRO>
<NAME>GST_D3DVIDEOSINK_GET_CLASS</NAME>
#define GST_D3DVIDEOSINK_GET_CLASS(obj)           (GST_D3DVIDEOSINK_CLASS(G_OBJECT_GET_CLASS(obj)))
</MACRO>
<MACRO>
<NAME>GST_IS_D3DVIDEOSINK</NAME>
#define GST_IS_D3DVIDEOSINK(obj)                  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_D3DVIDEOSINK))
</MACRO>
<MACRO>
<NAME>GST_IS_D3DVIDEOSINK_CLASS</NAME>
#define GST_IS_D3DVIDEOSINK_CLASS(klass)          (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_D3DVIDEOSINK))
</MACRO>
<STRUCT>
<NAME>GstD3DVideoSink</NAME>
struct _GstD3DVideoSink
{
  GstVideoSink       sink;
  GstD3DData         d3d;

  GstCaps *          supported_caps;

  GstVideoFormat     format;
  GstVideoInfo       info;
  gint               width;
  gint               height;
  GstBufferPool      *pool;
  GstBufferPool      *fallback_pool;
  GstBuffer          *fallback_buffer;

  GstVideoRectangle  crop_rect;
  GstVideoRectangle  render_rect;

  GRecMutex    lock;

  /* Properties */
  gboolean           force_aspect_ratio;
  gboolean           create_internal_window;
  gboolean           stream_stop_on_close;
  gboolean           enable_navigation_events;
};
</STRUCT>
<STRUCT>
<NAME>GstD3DVideoSinkClass</NAME>
struct _GstD3DVideoSinkClass
{
  GstVideoSinkClass parent_class;
  GstD3DDataClass   d3d;
  GRecMutex   lock;
};
</STRUCT>
<MACRO>
<NAME>LOCK_SINK</NAME>
# define LOCK_SINK(sink)          g_rec_mutex_lock(&sink->lock);
</MACRO>
<MACRO>
<NAME>UNLOCK_SINK</NAME>
# define UNLOCK_SINK(sink)        g_rec_mutex_unlock(&sink->lock);
</MACRO>
<MACRO>
<NAME>LOCK_CLASS</NAME>
# define LOCK_CLASS(obj, klass)   g_rec_mutex_lock(&klass->lock);
</MACRO>
<MACRO>
<NAME>UNLOCK_CLASS</NAME>
# define UNLOCK_CLASS(obj, klass) g_rec_mutex_unlock(&klass->lock);
</MACRO>
<FUNCTION>
<NAME>gst_d3dvideosink_get_type</NAME>
<RETURNS>GType     </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>DECLARE_INTERFACE_IID_</NAME>
#    define DECLARE_INTERFACE_IID_(i,b,d) _COM_interface __attribute__((com_interface)) i : public b
</MACRO>
<STRUCT>
<NAME>GstD3DDisplayDevice</NAME>
typedef struct _GstD3DDisplayDevice {
  UINT                   adapter;
  D3DFORMAT              format;
  D3DTEXTUREFILTERTYPE   filter_type;
  LPDIRECT3DDEVICE9      d3d_device;
  D3DPRESENT_PARAMETERS  present_params;
} GstD3DDisplayDevice;
</STRUCT>
<STRUCT>
<NAME>GstD3DDataClass</NAME>
typedef struct _GstD3DDataClass {
  guint                  refs;
  LPDIRECT3D9            d3d;
  GstD3DDisplayDevice    device;

  /* Track individual sink instances */
  GList *                sink_list;
  gboolean               device_lost;

  /* Window class for internal windows */
  WNDCLASS               wnd_class;

  /* Windows Message Handling */
  GThread *              thread;
  HWND                   hidden_window;
  gboolean               running;
  gboolean               error_exit;
} GstD3DDataClass;
</STRUCT>
<STRUCT>
<NAME>GstD3DData</NAME>
typedef struct _GstD3DData {
  /* Window Proc Stuff */
  HWND                   external_window_handle;
  HWND                   window_handle;
  gboolean               window_is_internal;
  WNDPROC                orig_wnd_proc;

  /* Render Constructs */
  LPDIRECT3DSWAPCHAIN9   swapchain;
  LPDIRECT3DSURFACE9     surface;
  D3DTEXTUREFILTERTYPE   filtertype;
  D3DFORMAT              format;
  GstVideoRectangle    * render_rect;
  gboolean               renderable;
  gboolean               device_lost;
} GstD3DData;
</STRUCT>
<FUNCTION>
<NAME>d3d_class_init</NAME>
<RETURNS>gboolean        </RETURNS>
GstD3DVideoSink * klass
</FUNCTION>
<FUNCTION>
<NAME>d3d_class_destroy</NAME>
<RETURNS>void            </RETURNS>
GstD3DVideoSink * klass
</FUNCTION>
<FUNCTION>
<NAME>d3d_prepare_window</NAME>
<RETURNS>gboolean        </RETURNS>
GstD3DVideoSink * sink
</FUNCTION>
<FUNCTION>
<NAME>d3d_stop</NAME>
<RETURNS>gboolean        </RETURNS>
GstD3DVideoSink * sink
</FUNCTION>
<FUNCTION>
<NAME>d3d_set_window_handle</NAME>
<RETURNS>void            </RETURNS>
GstD3DVideoSink * sink, guintptr window_id, gboolean internal
</FUNCTION>
<FUNCTION>
<NAME>d3d_set_render_rectangle</NAME>
<RETURNS>void            </RETURNS>
GstD3DVideoSink * sink
</FUNCTION>
<FUNCTION>
<NAME>d3d_expose_window</NAME>
<RETURNS>void            </RETURNS>
GstD3DVideoSink * sink
</FUNCTION>
<FUNCTION>
<NAME>d3d_render_buffer</NAME>
<RETURNS>GstFlowReturn   </RETURNS>
GstD3DVideoSink * sink, GstBuffer * buf
</FUNCTION>
<FUNCTION>
<NAME>d3d_supported_caps</NAME>
<RETURNS>GstCaps  *      </RETURNS>
GstD3DVideoSink * sink
</FUNCTION>
<FUNCTION>
<NAME>d3d_set_render_format</NAME>
<RETURNS>gboolean        </RETURNS>
GstD3DVideoSink * sink
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_D3DSURFACE_BUFFER_POOL</NAME>
#define GST_TYPE_D3DSURFACE_BUFFER_POOL      (gst_d3dsurface_buffer_pool_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_D3DSURFACE_BUFFER_POOL</NAME>
#define GST_IS_D3DSURFACE_BUFFER_POOL(obj)   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_D3DSURFACE_BUFFER_POOL))
</MACRO>
<MACRO>
<NAME>GST_D3DSURFACE_BUFFER_POOL</NAME>
#define GST_D3DSURFACE_BUFFER_POOL(obj)      (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_D3DSURFACE_BUFFER_POOL, GstD3DSurfaceBufferPool))
</MACRO>
<MACRO>
<NAME>GST_D3DSURFACE_BUFFER_POOL_CAST</NAME>
#define GST_D3DSURFACE_BUFFER_POOL_CAST(obj) ((GstD3DSurfaceBufferPool*)(obj))
</MACRO>
<STRUCT>
<NAME>GstD3DSurfaceBufferPool</NAME>
typedef struct _GstD3DSurfaceBufferPool {
  GstVideoBufferPool parent;

  GstD3DVideoSink *sink;
  GstVideoInfo info;
  gboolean add_metavideo;

  GstAllocator *allocator;
} GstD3DSurfaceBufferPool;
</STRUCT>
<STRUCT>
<NAME>GstD3DSurfaceBufferPoolClass</NAME>
typedef struct _GstD3DSurfaceBufferPoolClass {
  GstVideoBufferPoolClass parent_class;
} GstD3DSurfaceBufferPoolClass;
</STRUCT>
<FUNCTION>
<NAME>gst_d3dsurface_meta_api_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_D3DSURFACE_META_API_TYPE</NAME>
#define GST_D3DSURFACE_META_API_TYPE  (gst_d3dsurface_meta_api_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_d3dsurface_meta_get_info</NAME>
<RETURNS>const GstMetaInfo  * </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_D3DSURFACE_META_INFO</NAME>
#define GST_D3DSURFACE_META_INFO  (gst_d3dsurface_meta_get_info())
</MACRO>
<MACRO>
<NAME>gst_buffer_get_d3dsurface_meta</NAME>
#define gst_buffer_get_d3dsurface_meta(b) ((GstD3DSurfaceMeta*)gst_buffer_get_meta((b),GST_D3DSURFACE_META_API_TYPE))
</MACRO>
<FUNCTION>
<NAME>gst_d3dsurface_buffer_pool_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_d3dsurface_buffer_pool_new</NAME>
<RETURNS>GstBufferPool  * </RETURNS>
GstD3DVideoSink * sink
</FUNCTION>
<STRUCT>
<NAME>GstD3DVideoSink</NAME>
</STRUCT>
<STRUCT>
<NAME>GstD3DVideoSinkClass</NAME>
</STRUCT>
<VARIABLE>
<NAME>ImageFormat_JPEG</NAME>
extern gint ImageFormat_JPEG;
</VARIABLE>
<VARIABLE>
<NAME>ImageFormat_NV16</NAME>
extern gint ImageFormat_NV16;
</VARIABLE>
<VARIABLE>
<NAME>ImageFormat_NV21</NAME>
extern gint ImageFormat_NV21;
</VARIABLE>
<VARIABLE>
<NAME>ImageFormat_RGB_565</NAME>
extern gint ImageFormat_RGB_565;
</VARIABLE>
<VARIABLE>
<NAME>ImageFormat_UNKNOWN</NAME>
extern gint ImageFormat_UNKNOWN;
</VARIABLE>
<VARIABLE>
<NAME>ImageFormat_YUY2</NAME>
extern gint ImageFormat_YUY2;
</VARIABLE>
<VARIABLE>
<NAME>ImageFormat_YV12</NAME>
extern gint ImageFormat_YV12;
</VARIABLE>
<FUNCTION>
<NAME>gst_android_graphics_imageformat_init</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_android_graphics_imageformat_deinit</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_ag_imageformat_get_bits_per_pixel</NAME>
<RETURNS>gint  </RETURNS>
gint format
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AMC_VIDEO_DEC</NAME>
#define GST_TYPE_AMC_VIDEO_DEC \
  (gst_amc_video_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_AMC_VIDEO_DEC</NAME>
#define GST_AMC_VIDEO_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AMC_VIDEO_DEC,GstAmcVideoDec))
</MACRO>
<MACRO>
<NAME>GST_AMC_VIDEO_DEC_CLASS</NAME>
#define GST_AMC_VIDEO_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AMC_VIDEO_DEC,GstAmcVideoDecClass))
</MACRO>
<MACRO>
<NAME>GST_AMC_VIDEO_DEC_GET_CLASS</NAME>
#define GST_AMC_VIDEO_DEC_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_AMC_VIDEO_DEC,GstAmcVideoDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AMC_VIDEO_DEC</NAME>
#define GST_IS_AMC_VIDEO_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AMC_VIDEO_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_AMC_VIDEO_DEC_CLASS</NAME>
#define GST_IS_AMC_VIDEO_DEC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AMC_VIDEO_DEC))
</MACRO>
<STRUCT>
<NAME>GstAmcVideoDec</NAME>
struct _GstAmcVideoDec
{
  GstVideoDecoder parent;

  /* < private > */
  GstAmcCodec *codec;
  GstAmcCodecConfig codec_config;

  GstVideoCodecState *input_state;
  gboolean input_state_changed;

  /* Output format of the codec */
  GstVideoFormat format;
  GstAmcColorFormatInfo color_format_info;

  /* Output dimensions */
  guint width;
  guint height;

  guint8 *codec_data;
  gsize codec_data_size;
  /* TRUE if the component is configured and saw
   * the first buffer */
  gboolean started;
  gboolean flushing;

  GstClockTime last_upstream_ts;

  /* Draining state */
  GMutex drain_lock;
  GCond drain_cond;
  /* TRUE if EOS buffers shouldn't be forwarded */
  gboolean draining;
  /* TRUE if the component is drained currently */
  gboolean drained;

  GstAmcSurface *surface;

  GstGLDisplay *gl_display;
  GstGLContext *gl_context;
  GstGLContext *other_gl_context;

  gboolean downstream_supports_gl;
  GstFlowReturn downstream_flow_ret;

  jobject listener;
  jmethodID set_context_id;

  gboolean gl_mem_attached;
  GstGLMemory *oes_mem;
  GError *gl_error;
  GMutex gl_lock;
  GCond gl_cond;
  guint gl_last_rendered_frame;
  guint gl_pushed_frame_count; /* n buffers pushed */
  guint gl_ready_frame_count;  /* n buffers ready for GL access */
  guint gl_released_frame_count;  /* n buffers released */
  GQueue *gl_queue;
};
</STRUCT>
<STRUCT>
<NAME>GstAmcVideoDecClass</NAME>
struct _GstAmcVideoDecClass
{
  GstVideoDecoderClass parent_class;

  const GstAmcCodecInfo *codec_info;
};
</STRUCT>
<FUNCTION>
<NAME>gst_amc_video_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_android_sensor_type_from_string</NAME>
<RETURNS>gint  </RETURNS>
const gchar * type_str
</FUNCTION>
<USER_FUNCTION>
<NAME>GstAHSensorCallback</NAME>
<RETURNS>void </RETURNS>
jobject sensor_event, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstAHSAccuracyCallback</NAME>
<RETURNS>void </RETURNS>
jobject sensor, gint32 accuracy,
    gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_android_hardware_sensor_init</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_android_hardware_sensor_deinit</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_sensor_get_manager</NAME>
<RETURNS>GstAHSensorManager  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_sensor_get_default_sensor</NAME>
<RETURNS>GstAHSensor  *</RETURNS>
GstAHSensorManager * manager, gint32 sensor_type
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_sensor_create_listener</NAME>
<RETURNS>GstAHSensorEventListener  *</RETURNS>
GstAHSensorCallback sensor_cb, GstAHSAccuracyCallback accuracy_cb, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_sensor_register_listener</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHSensorManager * self, GstAHSensorEventListener * listener, GstAHSensor * sensor, gint32 delay
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_sensor_unregister_listener</NAME>
<RETURNS>void  </RETURNS>
GstAHSensorManager * self, GstAHSensorEventListener * listener
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_sensor_populate_event</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHSensorEvent * event, jobject event_object, gint size
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_sensor_free_sensor_data</NAME>
<RETURNS>void  </RETURNS>
GstAHSensorData * data
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_sensor_get_sensor_data_size</NAME>
<RETURNS>gsize  </RETURNS>
gint sensor_type
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_get_class</NAME>
<RETURNS>jclass     </RETURNS>
JNIEnv * env, GError ** err, const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_get_method_id</NAME>
<RETURNS>jmethodID  </RETURNS>
JNIEnv * env, GError ** err, jclass klass, const gchar * name, const gchar * signature
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_get_static_method_id</NAME>
<RETURNS>jmethodID  </RETURNS>
JNIEnv * env, GError ** err, jclass klass, const gchar * name, const gchar * signature
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_get_field_id</NAME>
<RETURNS>jfieldID  </RETURNS>
JNIEnv * env, GError ** err, jclass klass, const gchar * name, const gchar * type
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_get_static_field_id</NAME>
<RETURNS>jfieldID  </RETURNS>
JNIEnv * env, GError ** err, jclass klass, const gchar * name, const gchar * type
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_new_object</NAME>
<RETURNS>jobject  </RETURNS>
JNIEnv * env, GError ** err, gboolean global, jclass klass, jmethodID constructor, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_new_object_from_static</NAME>
<RETURNS>jobject  </RETURNS>
JNIEnv * env, GError ** err, gboolean global, jclass klass, jmethodID constructor, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_object_make_global</NAME>
<RETURNS>jobject  </RETURNS>
JNIEnv * env, jobject object
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_object_ref</NAME>
<RETURNS>jobject  </RETURNS>
JNIEnv * env, jobject object
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_object_unref</NAME>
<RETURNS>void  </RETURNS>
JNIEnv * env, jobject object
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_object_local_unref</NAME>
<RETURNS>void  </RETURNS>
JNIEnv * env, jobject object
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_string_to_gchar</NAME>
<RETURNS>gchar  *</RETURNS>
JNIEnv * env, jstring string, gboolean release
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_string_from_gchar</NAME>
<RETURNS>jstring  </RETURNS>
JNIEnv * env, GError ** error, gboolean global, const gchar * string
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_set_error</NAME>
<RETURNS>void  </RETURNS>
JNIEnv * env, GError ** error, GQuark domain, gint code, const gchar * format, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_set_java_vm</NAME>
<RETURNS>void  </RETURNS>
JavaVM *java_vm
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_initialize</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_is_vm_started</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_get_env</NAME>
<RETURNS>JNIEnv  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_get_application_class</NAME>
<RETURNS>jclass  </RETURNS>
JNIEnv * env, const gchar * name, GError ** err
</FUNCTION>
<MACRO>
<NAME>DEF_CALL_STATIC_TYPE_METHOD</NAME>
#define DEF_CALL_STATIC_TYPE_METHOD(_type, _name,  _jname, _retval) \
gboolean gst_amc_jni_call_static_##_name##_method (JNIEnv *env, GError ** err, jclass klass, jmethodID methodID, _type * value, ...)
</MACRO>
<FUNCTION>
<NAME>gst_amc_jni_call_static_void_method</NAME>
<RETURNS>gboolean  </RETURNS>
JNIEnv * env, GError ** error, jclass klass, jmethodID method, ...
</FUNCTION>
<MACRO>
<NAME>DEF_CALL_TYPE_METHOD</NAME>
#define DEF_CALL_TYPE_METHOD(_type, _name,  _jname, _retval) \
gboolean gst_amc_jni_call_##_name##_method (JNIEnv *env, GError ** err, jobject obj, jmethodID methodID, _type * value, ...)
</MACRO>
<FUNCTION>
<NAME>gst_amc_jni_call_void_method</NAME>
<RETURNS>gboolean  </RETURNS>
JNIEnv * env, GError ** error, jobject obj, jmethodID method, ...
</FUNCTION>
<MACRO>
<NAME>DEF_GET_TYPE_FIELD</NAME>
#define DEF_GET_TYPE_FIELD(_type, _name, _jname) \
gboolean gst_amc_jni_get_##_name##_field (JNIEnv *env, GError ** err, jobject obj, jfieldID fieldID, _type * value)
</MACRO>
<MACRO>
<NAME>DEF_GET_STATIC_TYPE_FIELD</NAME>
#define DEF_GET_STATIC_TYPE_FIELD(_type, _name, _jname) \
gboolean gst_amc_jni_get_static_##_name##_field (JNIEnv *env, GError ** err, jclass klass, jfieldID fieldID, _type * value)
</MACRO>
<STRUCT>
<NAME>GstAmcBuffer</NAME>
struct _GstAmcBuffer {
  jobject object; /* global reference */
  guint8 *data;
  gsize size;
};
</STRUCT>
<FUNCTION>
<NAME>gst_amc_buffer_get_position_and_limit</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcBuffer * buffer, GError ** err, gint * position, gint * limit
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_buffer_set_position_and_limit</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcBuffer * buffer, GError ** err, gint position, gint limit
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_buffer_clear</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcBuffer * buffer, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_buffer_copy</NAME>
<RETURNS>GstAmcBuffer  * </RETURNS>
GstAmcBuffer * buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_buffer_free</NAME>
<RETURNS>void      </RETURNS>
GstAmcBuffer * buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_get_buffer_array</NAME>
<RETURNS>gboolean  </RETURNS>
JNIEnv * env, GError ** err, jobject array, GstAmcBuffer ** buffers, gsize * n_buffers
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_jni_free_buffer_array</NAME>
<RETURNS>void  </RETURNS>
JNIEnv * env, GstAmcBuffer * buffers, gsize n_buffers
</FUNCTION>
<MACRO>
<NAME>GST_SENSOR_FORMATS_ALL</NAME>
#define GST_SENSOR_FORMATS_ALL "{" \
     "accelerometer, " \
     "ambient-temperature, " \
     "game-rotation-vector, " \
     "geomagnetic-rotation-vector, " \
     "gravity, " \
     "gyroscope, " \
     "gyroscope-uncalibrated, " \
     "heart-rate, " \
     "light, " \
     "linear-acceleration, " \
     "magnetic-field, " \
     "magnetic-field-uncalibrated, " \
     "orientation, " \
     "pressure, " \
     "proximity, " \
     "relative-humidity, " \
     "rotation-vector, " \
     "significant-motion, " \
     "step-counter, " \
     "step-detector" \
   "}"
</MACRO>
<MACRO>
<NAME>GST_SENSOR_CAPS_MAKE</NAME>
#define GST_SENSOR_CAPS_MAKE(format)                             \
    "application/sensor, " \
    "type = (string) " format
</MACRO>
<STRUCT>
<NAME>GstAmcCodecType</NAME>
struct _GstAmcCodecType {
  gchar *mime;

  gint *color_formats;
  gint n_color_formats;

  struct {
    gint profile;
    gint level;
  } *profile_levels;
  gint n_profile_levels;
};
</STRUCT>
<STRUCT>
<NAME>GstAmcCodecInfo</NAME>
struct _GstAmcCodecInfo {
  gchar *name;
  gboolean is_encoder;
  gboolean gl_output_only;
  GstAmcCodecType *supported_types;
  gint n_supported_types;
};
</STRUCT>
<STRUCT>
<NAME>GstAmcFormat</NAME>
struct _GstAmcFormat {
  /* < private > */
  jobject object; /* global reference */
};
</STRUCT>
<STRUCT>
<NAME>GstAmcCodec</NAME>
struct _GstAmcCodec {
  /* < private > */
  jobject object; /* global reference */

  GstAmcBuffer *input_buffers, *output_buffers;
  gsize n_input_buffers, n_output_buffers;
};
</STRUCT>
<STRUCT>
<NAME>GstAmcBufferInfo</NAME>
struct _GstAmcBufferInfo {
  gint flags;
  gint offset;
  gint64 presentation_time_us;
  gint size;
};
</STRUCT>
<VARIABLE>
<NAME>gst_amc_codec_info_quark</NAME>
extern GQuark gst_amc_codec_info_quark;
</VARIABLE>
<FUNCTION>
<NAME>gst_amc_codec_new</NAME>
<RETURNS>GstAmcCodec  * </RETURNS>
const gchar *name, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_codec_free</NAME>
<RETURNS>void  </RETURNS>
GstAmcCodec * codec
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_codec_configure</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcCodec * codec, GstAmcFormat * format, jobject surface, gint flags, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_codec_get_output_format</NAME>
<RETURNS>GstAmcFormat  * </RETURNS>
GstAmcCodec * codec, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_codec_start</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcCodec * codec, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_codec_stop</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcCodec * codec, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_codec_flush</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcCodec * codec, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_codec_release</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcCodec * codec, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_codec_get_output_buffer</NAME>
<RETURNS>GstAmcBuffer  * </RETURNS>
GstAmcCodec * codec, gint index, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_codec_get_input_buffer</NAME>
<RETURNS>GstAmcBuffer  * </RETURNS>
GstAmcCodec * codec, gint index, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_codec_dequeue_input_buffer</NAME>
<RETURNS>gint  </RETURNS>
GstAmcCodec * codec, gint64 timeoutUs, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_codec_dequeue_output_buffer</NAME>
<RETURNS>gint  </RETURNS>
GstAmcCodec * codec, GstAmcBufferInfo *info, gint64 timeoutUs, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_codec_queue_input_buffer</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcCodec * codec, gint index, const GstAmcBufferInfo *info, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_codec_release_output_buffer</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcCodec * codec, gint index, gboolean render, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_format_new_audio</NAME>
<RETURNS>GstAmcFormat  * </RETURNS>
const gchar *mime, gint sample_rate, gint channels, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_format_new_video</NAME>
<RETURNS>GstAmcFormat  * </RETURNS>
const gchar *mime, gint width, gint height, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_format_free</NAME>
<RETURNS>void  </RETURNS>
GstAmcFormat * format
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_format_to_string</NAME>
<RETURNS>gchar  * </RETURNS>
GstAmcFormat * format, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_format_contains_key</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcFormat *format, const gchar *key, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_format_get_float</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcFormat *format, const gchar *key, gfloat *value, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_format_set_float</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcFormat *format, const gchar *key, gfloat value, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_format_get_int</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcFormat *format, const gchar *key, gint *value, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_format_set_int</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcFormat *format, const gchar *key, gint value, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_format_get_string</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcFormat *format, const gchar *key, gchar **value, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_format_set_string</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcFormat *format, const gchar *key, const gchar *value, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_format_get_buffer</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcFormat *format, const gchar *key, guint8 **data, gsize *size, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_format_set_buffer</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcFormat *format, const gchar *key, guint8 *data, gsize size, GError **err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_color_format_to_video_format</NAME>
<RETURNS>GstVideoFormat  </RETURNS>
const GstAmcCodecInfo * codec_info, const gchar * mime, gint color_format
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_video_format_to_color_format</NAME>
<RETURNS>gint  </RETURNS>
const GstAmcCodecInfo * codec_info, const gchar * mime, GstVideoFormat video_format
</FUNCTION>
<STRUCT>
<NAME>GstAmcColorFormatInfo</NAME>
struct _GstAmcColorFormatInfo {
  gint color_format;
  gint width, height, stride, slice_height;
  gint crop_left, crop_right;
  gint crop_top, crop_bottom;
  gint frame_size;
};
</STRUCT>
<FUNCTION>
<NAME>gst_amc_color_format_info_set</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcColorFormatInfo * color_format_info, const GstAmcCodecInfo * codec_info, const gchar * mime, gint color_format, gint width, gint height, gint stride, gint slice_height, gint crop_left, gint crop_right, gint crop_top, gint crop_bottom
</FUNCTION>
<ENUM>
<NAME>GstAmcColorFormatCopyDirection</NAME>
typedef enum
{
  COLOR_FORMAT_COPY_OUT,
  COLOR_FORMAT_COPY_IN
} GstAmcColorFormatCopyDirection;
</ENUM>
<FUNCTION>
<NAME>gst_amc_color_format_copy</NAME>
<RETURNS>gboolean  </RETURNS>
 GstAmcColorFormatInfo * cinfo, GstAmcBuffer * cbuffer, const GstAmcBufferInfo * cbuffer_info, GstVideoInfo * vinfo, GstBuffer * vbuffer, GstAmcColorFormatCopyDirection direction
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_avc_profile_to_string</NAME>
<RETURNS>const gchar  * </RETURNS>
gint profile, const gchar **alternative
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_avc_profile_from_string</NAME>
<RETURNS>gint  </RETURNS>
const gchar *profile
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_avc_level_to_string</NAME>
<RETURNS>const gchar  * </RETURNS>
gint level
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_avc_level_from_string</NAME>
<RETURNS>gint  </RETURNS>
const gchar *level
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_hevc_profile_to_string</NAME>
<RETURNS>const gchar  * </RETURNS>
gint profile
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_hevc_profile_from_string</NAME>
<RETURNS>gint  </RETURNS>
const gchar *profile
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_hevc_tier_level_to_string</NAME>
<RETURNS>const gchar  * </RETURNS>
gint tier_level, const gchar ** tier
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_hevc_tier_level_from_string</NAME>
<RETURNS>gint  </RETURNS>
const gchar * tier, const gchar *level
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_h263_profile_to_gst_id</NAME>
<RETURNS>gint  </RETURNS>
gint profile
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_h263_profile_from_gst_id</NAME>
<RETURNS>gint  </RETURNS>
gint profile
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_h263_level_to_gst_id</NAME>
<RETURNS>gint  </RETURNS>
gint level
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_h263_level_from_gst_id</NAME>
<RETURNS>gint  </RETURNS>
gint level
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_mpeg4_profile_to_string</NAME>
<RETURNS>const gchar  * </RETURNS>
gint profile
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_mpeg4_profile_from_string</NAME>
<RETURNS>gint  </RETURNS>
const gchar *profile
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_mpeg4_level_to_string</NAME>
<RETURNS>const gchar  * </RETURNS>
gint level
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_mpeg4_level_from_string</NAME>
<RETURNS>gint  </RETURNS>
const gchar *level
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_aac_profile_to_string</NAME>
<RETURNS>const gchar  * </RETURNS>
gint profile
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_aac_profile_from_string</NAME>
<RETURNS>gint  </RETURNS>
const gchar *profile
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_audio_channel_mask_to_positions</NAME>
<RETURNS>gboolean  </RETURNS>
guint32 channel_mask, gint channels, GstAudioChannelPosition *pos
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_audio_channel_mask_from_positions</NAME>
<RETURNS>guint32  </RETURNS>
GstAudioChannelPosition *positions, gint channels
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_codec_info_to_caps</NAME>
<RETURNS>void  </RETURNS>
const GstAmcCodecInfo * codec_info, GstCaps **sink_caps, GstCaps **src_caps
</FUNCTION>
<MACRO>
<NAME>GST_ELEMENT_ERROR_FROM_ERROR</NAME>
#define GST_ELEMENT_ERROR_FROM_ERROR(el, err) G_STMT_START {            \
  gchar *__dbg;                                                         \
  g_assert (err != NULL);                                               \
  __dbg = g_strdup (err->message);                                      \
  GST_WARNING_OBJECT (el, "error: %s", __dbg);                          \
  gst_element_message_full (GST_ELEMENT(el), GST_MESSAGE_ERROR,         \
    err->domain, err->code,                                             \
    NULL, __dbg, __FILE__, GST_FUNCTION, __LINE__);                     \
  g_clear_error (&err); \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_WARNING_FROM_ERROR</NAME>
#define GST_ELEMENT_WARNING_FROM_ERROR(el, err) G_STMT_START {          \
  gchar *__dbg;                                                         \
  g_assert (err != NULL);                                               \
  __dbg = g_strdup (err->message);                                      \
  GST_WARNING_OBJECT (el, "error: %s", __dbg);                          \
  gst_element_message_full (GST_ELEMENT(el), GST_MESSAGE_WARNING,       \
    err->domain, err->code,                                             \
    NULL, __dbg, __FILE__, GST_FUNCTION, __LINE__);                     \
  g_clear_error (&err); \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_TYPE_AHC_SRC</NAME>
#define GST_TYPE_AHC_SRC \
  (gst_ahc_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_AHC_SRC</NAME>
#define GST_AHC_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_AHC_SRC, GstAHCSrc))
</MACRO>
<MACRO>
<NAME>GST_AHC_SRC_CLASS</NAME>
#define GST_AHC_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_AHC_SRC, GstAHCSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AHC_SRC</NAME>
#define GST_IS_AHC_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_AHC_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_AHC_SRC_CLASS</NAME>
#define GST_IS_AHC_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_AHC_SRC))
</MACRO>
<STRUCT>
<NAME>GstAHCSrc</NAME>
struct _GstAHCSrc
{
  /*< private >*/
  GstPushSrc parent;

  GstAHCamera *camera;
  GstAmcSurfaceTexture *texture;
  GList *data;
  GstDataQueue *queue;
  gint buffer_size;
  GstClockTime previous_ts;
  gint format;
  gint width;
  gint height;
  gint fps_min;
  gint fps_max;
  gboolean start;
  gboolean smooth_zoom;
  GMutex mutex;

  /* Properties */
  gint device;
};
</STRUCT>
<STRUCT>
<NAME>GstAHCSrcClass</NAME>
struct _GstAHCSrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ahc_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AHS_SRC</NAME>
#define GST_TYPE_AHS_SRC   (gst_ahs_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_AHS_SRC</NAME>
#define GST_AHS_SRC(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AHS_SRC,GstAHSSrc))
</MACRO>
<MACRO>
<NAME>GST_AHS_SRC_CLASS</NAME>
#define GST_AHS_SRC_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AHS_SRC,GstAHSSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AHS_SRC</NAME>
#define GST_IS_AHS_SRC(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AHS_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_AHS_SRC_CLASS</NAME>
#define GST_IS_AHS_SRC_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AHS_SRC))
</MACRO>
<STRUCT>
<NAME>GstAHSSrc</NAME>
struct _GstAHSSrc
{
  /* < private > */
  GstPushSrc parent;

  /* properties */
  gint32 sensor_delay;
  gdouble alpha;
  guint sample_interval;

  /* sensor type information */
  GEnumClass *sensor_enum_class;
  gint sensor_type;
  const gchar *sensor_type_name;

  /* JNI wrapper classes */
  GstAHSensorManager *manager;
  GstAHSensor *sensor;
  GstAHSensorEventListener *listener;

  /* timestamping */
  GstClockTime previous_time;
  gfloat *current_sample;

  /* buffers */
  gboolean callback_registered;
  gint sample_index;
  gint sample_length;
  gint buffer_size;

  /* multiprocessing */
  GstDataQueue *queue;
};
</STRUCT>
<STRUCT>
<NAME>GstAHSSrcClass</NAME>
struct _GstAHSSrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ahs_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AMC_SURFACE_TEXTURE</NAME>
#define GST_TYPE_AMC_SURFACE_TEXTURE                  (gst_amc_surface_texture_get_type ())
</MACRO>
<MACRO>
<NAME>GST_AMC_SURFACE_TEXTURE</NAME>
#define GST_AMC_SURFACE_TEXTURE(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_AMC_SURFACE_TEXTURE, GstAmcSurfaceTexture))
</MACRO>
<MACRO>
<NAME>GST_IS_AMC_SURFACE_TEXTURE</NAME>
#define GST_IS_AMC_SURFACE_TEXTURE(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_AMC_SURFACE_TEXTURE))
</MACRO>
<MACRO>
<NAME>GST_AMC_SURFACE_TEXTURE_CLASS</NAME>
#define GST_AMC_SURFACE_TEXTURE_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_AMC_SURFACE_TEXTURE, GstAmcSurfaceTextureClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AMC_SURFACE_TEXTURE_CLASS</NAME>
#define GST_IS_AMC_SURFACE_TEXTURE_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_AMC_SURFACE_TEXTURE))
</MACRO>
<MACRO>
<NAME>GST_AMC_SURFACE_TEXTURE_GET_CLASS</NAME>
#define GST_AMC_SURFACE_TEXTURE_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_AMC_SURFACE_TEXTURE, GstAmcSurfaceTextureClass))
</MACRO>
<STRUCT>
<NAME>GstAmcSurfaceTexture</NAME>
struct _GstAmcSurfaceTexture
{
  GObject parent_instance;

  /* instance members */
  gint texture_id;
  jobject jobject;
};
</STRUCT>
<STRUCT>
<NAME>GstAmcSurfaceTextureClass</NAME>
struct _GstAmcSurfaceTextureClass
{
  GObjectClass parent_class;

  /* class members */
  gint texture_id;

  jclass jklass;
  jmethodID constructor;
  jmethodID set_on_frame_available_listener;
  jmethodID set_default_buffer_size;
  jmethodID update_tex_image;
  jmethodID detach_from_gl_context;
  jmethodID attach_to_gl_context;
  jmethodID get_transform_matrix;
  jmethodID get_timestamp;
  jmethodID release;
};
</STRUCT>
<FUNCTION>
<NAME>gst_amc_surface_texture_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_surface_texture_new</NAME>
<RETURNS>GstAmcSurfaceTexture  * </RETURNS>
GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_surface_texture_set_default_buffer_size</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcSurfaceTexture *texture, gint width, gint height, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_surface_texture_update_tex_image</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcSurfaceTexture *texture, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_surface_texture_detach_from_gl_context</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcSurfaceTexture *texture, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_surface_texture_attach_to_gl_context</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcSurfaceTexture *texture, gint index, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_surface_texture_get_transform_matrix</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcSurfaceTexture *texture, const gfloat *matrix, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_surface_texture_get_timestamp</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcSurfaceTexture *texture, gint64 * result, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_surface_texture_release</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcSurfaceTexture *texture, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_surface_texture_set_on_frame_available_listener</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcSurfaceTexture * self, jobject listener, GError ** err
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AMC_SURFACE</NAME>
#define GST_TYPE_AMC_SURFACE                  (gst_amc_surface_get_type ())
</MACRO>
<MACRO>
<NAME>GST_AMC_SURFACE</NAME>
#define GST_AMC_SURFACE(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_AMC_SURFACE, GstAmcSurface))
</MACRO>
<MACRO>
<NAME>GST_IS_AMC_SURFACE</NAME>
#define GST_IS_AMC_SURFACE(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_AMC_SURFACE))
</MACRO>
<MACRO>
<NAME>GST_AMC_SURFACE_CLASS</NAME>
#define GST_AMC_SURFACE_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_AMC_SURFACE, GstAmcSurfaceClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AMC_SURFACE_CLASS</NAME>
#define GST_IS_AMC_SURFACE_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_AMC_SURFACE))
</MACRO>
<MACRO>
<NAME>GST_AMC_SURFACE_GET_CLASS</NAME>
#define GST_AMC_SURFACE_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_AMC_SURFACE, GstAmcSurfaceClass))
</MACRO>
<STRUCT>
<NAME>GstAmcSurface</NAME>
struct _GstAmcSurface
{
  GObject parent_instance;

  /* instance members */
  jobject jobject;
  GstAmcSurfaceTexture *texture;
};
</STRUCT>
<STRUCT>
<NAME>GstAmcSurfaceClass</NAME>
struct _GstAmcSurfaceClass
{
  GObjectClass parent_class;

  /* class members */
  jclass jklass;
  jmethodID constructor;
  jmethodID is_valid;
  jmethodID release;
  jmethodID describe_contents;
};
</STRUCT>
<FUNCTION>
<NAME>gst_amc_surface_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_surface_new</NAME>
<RETURNS>GstAmcSurface  * </RETURNS>
GstAmcSurfaceTexture *texture, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_surface_is_valid</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcSurface *surface, gboolean * result, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_surface_release</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcSurface *surface, GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_amc_surface_describe_contents</NAME>
<RETURNS>gboolean  </RETURNS>
GstAmcSurface *surface, gint * result, GError ** err
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AMC_AUDIO_DEC</NAME>
#define GST_TYPE_AMC_AUDIO_DEC \
  (gst_amc_audio_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_AMC_AUDIO_DEC</NAME>
#define GST_AMC_AUDIO_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AMC_AUDIO_DEC,GstAmcAudioDec))
</MACRO>
<MACRO>
<NAME>GST_AMC_AUDIO_DEC_CLASS</NAME>
#define GST_AMC_AUDIO_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AMC_AUDIO_DEC,GstAmcAudioDecClass))
</MACRO>
<MACRO>
<NAME>GST_AMC_AUDIO_DEC_GET_CLASS</NAME>
#define GST_AMC_AUDIO_DEC_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_AMC_AUDIO_DEC,GstAmcAudioDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AMC_AUDIO_DEC</NAME>
#define GST_IS_AMC_AUDIO_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AMC_AUDIO_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_AMC_AUDIO_DEC_CLASS</NAME>
#define GST_IS_AMC_AUDIO_DEC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AMC_AUDIO_DEC))
</MACRO>
<STRUCT>
<NAME>GstAmcAudioDec</NAME>
struct _GstAmcAudioDec
{
  GstAudioDecoder parent;

  /* < private > */
  GstAmcCodec *codec;

  GstCaps *input_caps;
  GList *codec_datas;
  gboolean input_caps_changed;
  gint spf;

  /* For collecting complete frames for the output */
  GstAdapter *output_adapter;

  /* Output format of the codec */
  GstAudioInfo info;
  /* AMC positions, might need reordering */
  GstAudioChannelPosition positions[64];
  gboolean needs_reorder;
  gint reorder_map[64];

  /* TRUE if the component is configured and saw
   * the first buffer */
  gboolean started;
  gboolean flushing;

  GstClockTime last_upstream_ts;

  /* Draining state */
  GMutex drain_lock;
  GCond drain_cond;
  /* TRUE if EOS buffers shouldn't be forwarded */
  gboolean draining;
  /* TRUE if the component is drained currently */
  gboolean drained;

  GstFlowReturn downstream_flow_ret;
};
</STRUCT>
<STRUCT>
<NAME>GstAmcAudioDecClass</NAME>
struct _GstAmcAudioDecClass
{
  GstAudioDecoderClass parent_class;

  const GstAmcCodecInfo *codec_info;
};
</STRUCT>
<FUNCTION>
<NAME>gst_amc_audio_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AMC_VIDEO_ENC</NAME>
#define GST_TYPE_AMC_VIDEO_ENC \
  (gst_amc_video_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_AMC_VIDEO_ENC</NAME>
#define GST_AMC_VIDEO_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AMC_VIDEO_ENC,GstAmcVideoEnc))
</MACRO>
<MACRO>
<NAME>GST_AMC_VIDEO_ENC_CLASS</NAME>
#define GST_AMC_VIDEO_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AMC_VIDEO_ENC,GstAmcVideoEncClass))
</MACRO>
<MACRO>
<NAME>GST_AMC_VIDEO_ENC_GET_CLASS</NAME>
#define GST_AMC_VIDEO_ENC_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_AMC_VIDEO_ENC,GstAmcVideoEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AMC_VIDEO_ENC</NAME>
#define GST_IS_AMC_VIDEO_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AMC_VIDEO_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_AMC_VIDEO_ENC_CLASS</NAME>
#define GST_IS_AMC_VIDEO_ENC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AMC_VIDEO_ENC))
</MACRO>
<STRUCT>
<NAME>GstAmcVideoEnc</NAME>
struct _GstAmcVideoEnc
{
  GstVideoEncoder parent;

  /* < private > */
  GstAmcCodec *codec;
  GstAmcFormat *amc_format;

  GstVideoCodecState *input_state;

  /* Input format of the codec */
  GstVideoFormat format;
  GstAmcColorFormatInfo color_format_info;

  guint bitrate;
  guint i_frame_int;

  /* TRUE if the component is configured and saw
   * the first buffer */
  gboolean started;
  gboolean flushing;

  GstClockTime last_upstream_ts;

  /* Draining state */
  GMutex drain_lock;
  GCond drain_cond;
  /* TRUE if EOS buffers shouldn't be forwarded */
  gboolean draining;
  /* TRUE if the component is drained */
  gboolean drained;

  GstFlowReturn downstream_flow_ret;
};
</STRUCT>
<STRUCT>
<NAME>GstAmcVideoEncClass</NAME>
struct _GstAmcVideoEncClass
{
  GstVideoEncoderClass parent_class;

  const GstAmcCodecInfo *codec_info;
};
</STRUCT>
<FUNCTION>
<NAME>gst_amc_video_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstAHCamera</NAME>
struct _GstAHCamera
{
  /* < private > */
  jobject object;               /* global reference */
};
</STRUCT>
<STRUCT>
<NAME>GstAHCCameraInfo</NAME>
struct _GstAHCCameraInfo
{
  gint facing;
  gint orientation;
};
</STRUCT>
<VARIABLE>
<NAME>CameraInfo_CAMERA_FACING_BACK</NAME>
extern gint CameraInfo_CAMERA_FACING_BACK;
</VARIABLE>
<VARIABLE>
<NAME>CameraInfo_CAMERA_FACING_FRONT</NAME>
extern gint CameraInfo_CAMERA_FACING_FRONT;
</VARIABLE>
<STRUCT>
<NAME>GstAHCSize</NAME>
struct _GstAHCSize
{
  gint width;
  gint height;
};
</STRUCT>
<STRUCT>
<NAME>GstAHCParameters</NAME>
struct _GstAHCParameters
{
  /* < private > */
  jobject object;               /* global reference */
};
</STRUCT>
<VARIABLE>
<NAME>Parameters_WHITE_BALANCE_AUTO</NAME>
extern const gchar *Parameters_WHITE_BALANCE_AUTO;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_WHITE_BALANCE_INCANDESCENT</NAME>
extern const gchar *Parameters_WHITE_BALANCE_INCANDESCENT;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_WHITE_BALANCE_FLUORESCENT</NAME>
extern const gchar *Parameters_WHITE_BALANCE_FLUORESCENT;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_WHITE_BALANCE_WARM_FLUORESCENT</NAME>
extern const gchar *Parameters_WHITE_BALANCE_WARM_FLUORESCENT;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_WHITE_BALANCE_DAYLIGHT</NAME>
extern const gchar *Parameters_WHITE_BALANCE_DAYLIGHT;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_WHITE_BALANCE_CLOUDY_DAYLIGHT</NAME>
extern const gchar *Parameters_WHITE_BALANCE_CLOUDY_DAYLIGHT;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_WHITE_BALANCE_TWILIGHT</NAME>
extern const gchar *Parameters_WHITE_BALANCE_TWILIGHT;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_WHITE_BALANCE_SHADE</NAME>
extern const gchar *Parameters_WHITE_BALANCE_SHADE;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_EFFECT_NONE</NAME>
extern const gchar *Parameters_EFFECT_NONE;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_EFFECT_MONO</NAME>
extern const gchar *Parameters_EFFECT_MONO;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_EFFECT_NEGATIVE</NAME>
extern const gchar *Parameters_EFFECT_NEGATIVE;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_EFFECT_SOLARIZE</NAME>
extern const gchar *Parameters_EFFECT_SOLARIZE;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_EFFECT_SEPIA</NAME>
extern const gchar *Parameters_EFFECT_SEPIA;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_EFFECT_POSTERIZE</NAME>
extern const gchar *Parameters_EFFECT_POSTERIZE;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_EFFECT_WHITEBOARD</NAME>
extern const gchar *Parameters_EFFECT_WHITEBOARD;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_EFFECT_BLACKBOARD</NAME>
extern const gchar *Parameters_EFFECT_BLACKBOARD;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_EFFECT_AQUA</NAME>
extern const gchar *Parameters_EFFECT_AQUA;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_ANTIBANDING_AUTO</NAME>
extern const gchar *Parameters_ANTIBANDING_AUTO;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_ANTIBANDING_50HZ</NAME>
extern const gchar *Parameters_ANTIBANDING_50HZ;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_ANTIBANDING_60HZ</NAME>
extern const gchar *Parameters_ANTIBANDING_60HZ;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_ANTIBANDING_OFF</NAME>
extern const gchar *Parameters_ANTIBANDING_OFF;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_FLASH_MODE_OFF</NAME>
extern const gchar *Parameters_FLASH_MODE_OFF;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_FLASH_MODE_AUTO</NAME>
extern const gchar *Parameters_FLASH_MODE_AUTO;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_FLASH_MODE_ON</NAME>
extern const gchar *Parameters_FLASH_MODE_ON;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_FLASH_MODE_RED_EYE</NAME>
extern const gchar *Parameters_FLASH_MODE_RED_EYE;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_FLASH_MODE_TORCH</NAME>
extern const gchar *Parameters_FLASH_MODE_TORCH;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_AUTO</NAME>
extern const gchar *Parameters_SCENE_MODE_AUTO;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_ACTION</NAME>
extern const gchar *Parameters_SCENE_MODE_ACTION;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_PORTRAIT</NAME>
extern const gchar *Parameters_SCENE_MODE_PORTRAIT;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_LANDSCAPE</NAME>
extern const gchar *Parameters_SCENE_MODE_LANDSCAPE;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_NIGHT</NAME>
extern const gchar *Parameters_SCENE_MODE_NIGHT;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_NIGHT_PORTRAIT</NAME>
extern const gchar *Parameters_SCENE_MODE_NIGHT_PORTRAIT;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_THEATRE</NAME>
extern const gchar *Parameters_SCENE_MODE_THEATRE;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_BEACH</NAME>
extern const gchar *Parameters_SCENE_MODE_BEACH;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_SNOW</NAME>
extern const gchar *Parameters_SCENE_MODE_SNOW;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_SUNSET</NAME>
extern const gchar *Parameters_SCENE_MODE_SUNSET;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_STEADYPHOTO</NAME>
extern const gchar *Parameters_SCENE_MODE_STEADYPHOTO;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_FIREWORKS</NAME>
extern const gchar *Parameters_SCENE_MODE_FIREWORKS;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_SPORTS</NAME>
extern const gchar *Parameters_SCENE_MODE_SPORTS;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_PARTY</NAME>
extern const gchar *Parameters_SCENE_MODE_PARTY;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_CANDLELIGHT</NAME>
extern const gchar *Parameters_SCENE_MODE_CANDLELIGHT;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_SCENE_MODE_BARCODE</NAME>
extern const gchar *Parameters_SCENE_MODE_BARCODE;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_FOCUS_MODE_AUTO</NAME>
extern const gchar *Parameters_FOCUS_MODE_AUTO;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_FOCUS_MODE_INFINITY</NAME>
extern const gchar *Parameters_FOCUS_MODE_INFINITY;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_FOCUS_MODE_MACRO</NAME>
extern const gchar *Parameters_FOCUS_MODE_MACRO;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_FOCUS_MODE_FIXED</NAME>
extern const gchar *Parameters_FOCUS_MODE_FIXED;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_FOCUS_MODE_EDOF</NAME>
extern const gchar *Parameters_FOCUS_MODE_EDOF;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_FOCUS_MODE_CONTINUOUS_VIDEO</NAME>
extern const gchar *Parameters_FOCUS_MODE_CONTINUOUS_VIDEO;
</VARIABLE>
<VARIABLE>
<NAME>Parameters_FOCUS_MODE_CONTINUOUS_PICTURE</NAME>
extern const gchar *Parameters_FOCUS_MODE_CONTINUOUS_PICTURE;
</VARIABLE>
<USER_FUNCTION>
<NAME>GstAHCErrorCallback</NAME>
<RETURNS>void </RETURNS>
gint error, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstAHCPreviewCallback</NAME>
<RETURNS>void </RETURNS>
jbyteArray data, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstAHCAutoFocusCallback</NAME>
<RETURNS>void </RETURNS>
gboolean success, gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_android_hardware_camera_init</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_android_hardware_camera_deinit</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_add_callback_buffer</NAME>
<RETURNS>void  </RETURNS>
GstAHCamera * self, jbyteArray buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_auto_focus</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCamera * self, GstAHCAutoFocusCallback cb, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_cancel_auto_focus</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCamera * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_get_camera_info</NAME>
<RETURNS>gboolean  </RETURNS>
gint camera_id, GstAHCCameraInfo * camera_info
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_get_number_of_cameras</NAME>
<RETURNS>gint  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_get_parameters</NAME>
<RETURNS>GstAHCParameters  *</RETURNS>
GstAHCamera * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_lock</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCamera * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_open</NAME>
<RETURNS>GstAHCamera  *</RETURNS>
gint camera_id
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_reconnect</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCamera * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_release</NAME>
<RETURNS>void  </RETURNS>
GstAHCamera * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_free</NAME>
<RETURNS>void  </RETURNS>
GstAHCamera * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_set_parameters</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCamera * self, GstAHCParameters * params
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_set_error_callback</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCamera * self, GstAHCErrorCallback cb, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_set_preview_callback_with_buffer</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCamera * self, GstAHCPreviewCallback cb, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_set_preview_texture</NAME>
<RETURNS>void  </RETURNS>
GstAHCamera * self, GstAmcSurfaceTexture * surfaceTexture
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_start_preview</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCamera * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_start_smooth_zoom</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCamera * self, gint value
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_stop_preview</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCamera * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_stop_smooth_zoom</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCamera * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ah_camera_unlock</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCamera * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_size_new</NAME>
<RETURNS>GstAHCSize  *</RETURNS>
gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_size_free</NAME>
<RETURNS>void  </RETURNS>
GstAHCSize * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_flatten</NAME>
<RETURNS>gchar  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_antibanding</NAME>
<RETURNS>const gchar  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_color_effect</NAME>
<RETURNS>const gchar  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_exposure_compensation</NAME>
<RETURNS>gint  </RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_exposure_compensation_step</NAME>
<RETURNS>gfloat  </RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_flash_mode</NAME>
<RETURNS>const gchar  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_focal_length</NAME>
<RETURNS>gfloat  </RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_focus_mode</NAME>
<RETURNS>const gchar  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_horizontal_view_angle</NAME>
<RETURNS>gfloat  </RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_max_exposure_compensation</NAME>
<RETURNS>gint  </RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_max_zoom</NAME>
<RETURNS>gint  </RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_min_exposure_compensation</NAME>
<RETURNS>gint  </RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_preview_format</NAME>
<RETURNS>gint  </RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_preview_fps_range</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self, gint * min, gint * max
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_preview_size</NAME>
<RETURNS>GstAHCSize  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_scene_mode</NAME>
<RETURNS>const gchar  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_supported_antibanding</NAME>
<RETURNS>GList  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_supported_antibanding_free</NAME>
<RETURNS>void  </RETURNS>
GList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_supported_color_effects</NAME>
<RETURNS>GList  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_supported_color_effects_free</NAME>
<RETURNS>void  </RETURNS>
GList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_supported_flash_modes</NAME>
<RETURNS>GList  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_supported_flash_modes_free</NAME>
<RETURNS>void  </RETURNS>
GList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_supported_focus_modes</NAME>
<RETURNS>GList  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_supported_focus_modes_free</NAME>
<RETURNS>void  </RETURNS>
GList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_supported_preview_formats</NAME>
<RETURNS>GList  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_supported_preview_formats_free</NAME>
<RETURNS>void  </RETURNS>
GList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_supported_preview_fps_range</NAME>
<RETURNS>GList  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_supported_preview_fps_range_free</NAME>
<RETURNS>void  </RETURNS>
GList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_supported_preview_sizes</NAME>
<RETURNS>GList  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_supported_preview_sizes_free</NAME>
<RETURNS>void  </RETURNS>
GList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_supported_scene_modes</NAME>
<RETURNS>GList  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_supported_scene_modes_free</NAME>
<RETURNS>void  </RETURNS>
GList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_supported_white_balance</NAME>
<RETURNS>GList  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_supported_white_balance_free</NAME>
<RETURNS>void  </RETURNS>
GList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_vertical_view_angle</NAME>
<RETURNS>gfloat  </RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_video_stabilization</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_white_balance</NAME>
<RETURNS>const gchar  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_zoom</NAME>
<RETURNS>gint  </RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_get_zoom_ratios</NAME>
<RETURNS>GList  *</RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_zoom_ratios_free</NAME>
<RETURNS>void  </RETURNS>
GList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_is_smooth_zoom_supported</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_is_video_stabilization_supported</NAME>
<RETURNS>gboolean  </RETURNS>
 GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_is_zoom_supported</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_set_antibanding</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self, const gchar * antibanding
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_set_color_effect</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self, const gchar * value
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_set_exposure_compensation</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self, gint value
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_set_flash_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self, const gchar * value
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_set_focus_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self, const gchar * value
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_set_preview_format</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self, gint format
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_set_preview_fps_range</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self, gint min, gint max
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_set_preview_size</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self, gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_set_scene_mode</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self, const gchar * value
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_set_white_balance</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self, const gchar * value
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_set_video_stabilization</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self, gboolean toggle
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_set_zoom</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self, gint value
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_unflatten</NAME>
<RETURNS>gboolean  </RETURNS>
GstAHCParameters * self, const gchar * flattened
</FUNCTION>
<FUNCTION>
<NAME>gst_ahc_parameters_free</NAME>
<RETURNS>void  </RETURNS>
GstAHCParameters * self
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MSDKH265DEC</NAME>
#define GST_TYPE_MSDKH265DEC \
  (gst_msdkh265dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_MSDKH265DEC</NAME>
#define GST_MSDKH265DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MSDKH265DEC,GstMsdkH265Dec))
</MACRO>
<MACRO>
<NAME>GST_MSDKH265DEC_CLASS</NAME>
#define GST_MSDKH265DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MSDKH265DEC,GstMsdkH265DecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKH265DEC</NAME>
#define GST_IS_MSDKH265DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MSDKH265DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKH265DEC_CLASS</NAME>
#define GST_IS_MSDKH265DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MSDKH265DEC))
</MACRO>
<STRUCT>
<NAME>GstMsdkH265Dec</NAME>
struct _GstMsdkH265Dec
{
  GstMsdkDec base;
};
</STRUCT>
<STRUCT>
<NAME>GstMsdkH265DecClass</NAME>
struct _GstMsdkH265DecClass
{
  GstMsdkDecClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_msdkh265dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MSDKH264DEC</NAME>
#define GST_TYPE_MSDKH264DEC \
  (gst_msdkh264dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_MSDKH264DEC</NAME>
#define GST_MSDKH264DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MSDKH264DEC,GstMsdkH264Dec))
</MACRO>
<MACRO>
<NAME>GST_MSDKH264DEC_CLASS</NAME>
#define GST_MSDKH264DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MSDKH264DEC,GstMsdkH264DecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKH264DEC</NAME>
#define GST_IS_MSDKH264DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MSDKH264DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKH264DEC_CLASS</NAME>
#define GST_IS_MSDKH264DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MSDKH264DEC))
</MACRO>
<STRUCT>
<NAME>GstMsdkH264Dec</NAME>
struct _GstMsdkH264Dec
{
  GstMsdkDec base;
};
</STRUCT>
<STRUCT>
<NAME>GstMsdkH264DecClass</NAME>
struct _GstMsdkH264DecClass
{
  GstMsdkDecClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_msdkh264dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MSDKVP8ENC</NAME>
#define GST_TYPE_MSDKVP8ENC \
  (gst_msdkvp8enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_MSDKVP8ENC</NAME>
#define GST_MSDKVP8ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MSDKVP8ENC,GstMsdkVP8Enc))
</MACRO>
<MACRO>
<NAME>GST_MSDKVP8ENC_CLASS</NAME>
#define GST_MSDKVP8ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MSDKVP8ENC,GstMsdkVP8EncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKVP8ENC</NAME>
#define GST_IS_MSDKVP8ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MSDKVP8ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKVP8ENC_CLASS</NAME>
#define GST_IS_MSDKVP8ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MSDKVP8ENC))
</MACRO>
<STRUCT>
<NAME>GstMsdkVP8Enc</NAME>
struct _GstMsdkVP8Enc
{
  GstMsdkEnc base;

  gint profile;
};
</STRUCT>
<STRUCT>
<NAME>GstMsdkVP8EncClass</NAME>
struct _GstMsdkVP8EncClass
{
  GstMsdkEncClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_msdkvp8enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MSDKH264ENC</NAME>
#define GST_TYPE_MSDKH264ENC \
  (gst_msdkh264enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_MSDKH264ENC</NAME>
#define GST_MSDKH264ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MSDKH264ENC,GstMsdkH264Enc))
</MACRO>
<MACRO>
<NAME>GST_MSDKH264ENC_CLASS</NAME>
#define GST_MSDKH264ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MSDKH264ENC,GstMsdkH264EncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKH264ENC</NAME>
#define GST_IS_MSDKH264ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MSDKH264ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKH264ENC_CLASS</NAME>
#define GST_IS_MSDKH264ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MSDKH264ENC))
</MACRO>
<STRUCT>
<NAME>GstMsdkH264Enc</NAME>
struct _GstMsdkH264Enc
{
  GstMsdkEnc base;

  mfxExtCodingOption option;

  gint profile;
  gint level;

  gboolean cabac;
  gboolean lowpower;
};
</STRUCT>
<STRUCT>
<NAME>GstMsdkH264EncClass</NAME>
struct _GstMsdkH264EncClass
{
  GstMsdkEncClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_msdkh264enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>msdk_open_session</NAME>
<RETURNS>mfxSession  </RETURNS>
gboolean hardware
</FUNCTION>
<FUNCTION>
<NAME>msdk_close_session</NAME>
<RETURNS>void  </RETURNS>
mfxSession session
</FUNCTION>
<FUNCTION>
<NAME>msdk_is_available</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>msdk_open_context</NAME>
<RETURNS>MsdkContext  *</RETURNS>
gboolean hardware
</FUNCTION>
<FUNCTION>
<NAME>msdk_close_context</NAME>
<RETURNS>void  </RETURNS>
MsdkContext * context
</FUNCTION>
<FUNCTION>
<NAME>msdk_context_get_session</NAME>
<RETURNS>mfxSession  </RETURNS>
MsdkContext * context
</FUNCTION>
<FUNCTION>
<NAME>msdk_get_free_surface</NAME>
<RETURNS>mfxFrameSurface1  *</RETURNS>
mfxFrameSurface1 * surfaces, guint size
</FUNCTION>
<FUNCTION>
<NAME>msdk_frame_to_surface</NAME>
<RETURNS>void  </RETURNS>
GstVideoFrame * frame, mfxFrameSurface1 * surface
</FUNCTION>
<FUNCTION>
<NAME>msdk_status_to_string</NAME>
<RETURNS>const gchar  *</RETURNS>
mfxStatus status
</FUNCTION>
<STRUCT>
<NAME>MsdkContext</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_MSDKMPEG2ENC</NAME>
#define GST_TYPE_MSDKMPEG2ENC \
  (gst_msdkmpeg2enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_MSDKMPEG2ENC</NAME>
#define GST_MSDKMPEG2ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MSDKMPEG2ENC,GstMsdkMPEG2Enc))
</MACRO>
<MACRO>
<NAME>GST_MSDKMPEG2ENC_CLASS</NAME>
#define GST_MSDKMPEG2ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MSDKMPEG2ENC,GstMsdkMPEG2EncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKMPEG2ENC</NAME>
#define GST_IS_MSDKMPEG2ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MSDKMPEG2ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKMPEG2ENC_CLASS</NAME>
#define GST_IS_MSDKMPEG2ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MSDKMPEG2ENC))
</MACRO>
<STRUCT>
<NAME>GstMsdkMPEG2Enc</NAME>
struct _GstMsdkMPEG2Enc
{
  GstMsdkEnc base;

  gint profile;
};
</STRUCT>
<STRUCT>
<NAME>GstMsdkMPEG2EncClass</NAME>
struct _GstMsdkMPEG2EncClass
{
  GstMsdkEncClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_msdkmpeg2enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MSDKH265ENC</NAME>
#define GST_TYPE_MSDKH265ENC \
  (gst_msdkh265enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_MSDKH265ENC</NAME>
#define GST_MSDKH265ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MSDKH265ENC,GstMsdkH265Enc))
</MACRO>
<MACRO>
<NAME>GST_MSDKH265ENC_CLASS</NAME>
#define GST_MSDKH265ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MSDKH265ENC,GstMsdkH265EncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKH265ENC</NAME>
#define GST_IS_MSDKH265ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MSDKH265ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKH265ENC_CLASS</NAME>
#define GST_IS_MSDKH265ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MSDKH265ENC))
</MACRO>
<STRUCT>
<NAME>GstMsdkH265Enc</NAME>
struct _GstMsdkH265Enc
{
  GstMsdkEnc base;
};
</STRUCT>
<STRUCT>
<NAME>GstMsdkH265EncClass</NAME>
struct _GstMsdkH265EncClass
{
  GstMsdkEncClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_msdkh265enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MSDKDEC</NAME>
#define GST_TYPE_MSDKDEC \
  (gst_msdkdec_get_type())
</MACRO>
<MACRO>
<NAME>GST_MSDKDEC</NAME>
#define GST_MSDKDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MSDKDEC,GstMsdkDec))
</MACRO>
<MACRO>
<NAME>GST_MSDKDEC_CLASS</NAME>
#define GST_MSDKDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MSDKDEC,GstMsdkDecClass))
</MACRO>
<MACRO>
<NAME>GST_MSDKDEC_GET_CLASS</NAME>
#define GST_MSDKDEC_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_MSDKDEC,GstMsdkDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKDEC</NAME>
#define GST_IS_MSDKDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MSDKDEC))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKDEC_CLASS</NAME>
#define GST_IS_MSDKDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MSDKDEC))
</MACRO>
<STRUCT>
<NAME>GstMsdkDec</NAME>
struct _GstMsdkDec
{
  GstVideoDecoder element;

  /* input description */
  GstVideoCodecState *input_state;
  GstVideoInfo output_info;
  GstBufferPool *pool;
  GstVideoInfo pool_info;

  /* MFX context */
  MsdkContext *context;
  mfxVideoParam param;
  GPtrArray *extra_params;
  GArray *surfaces;
  GArray *tasks;
  guint next_task;

  /* element properties */
  gboolean hardware;
  guint async_depth;
};
</STRUCT>
<STRUCT>
<NAME>GstMsdkDecClass</NAME>
struct _GstMsdkDecClass
{
  GstVideoDecoderClass parent_class;

  gboolean (*configure) (GstMsdkDec * decoder);
};
</STRUCT>
<STRUCT>
<NAME>MsdkDecTask</NAME>
struct _MsdkDecTask
{
  mfxFrameSurface1 *surface;
  mfxSyncPoint sync_point;
};
</STRUCT>
<FUNCTION>
<NAME>gst_msdkdec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MSDKMJPEGENC</NAME>
#define GST_TYPE_MSDKMJPEGENC \
  (gst_msdkmjpegenc_get_type())
</MACRO>
<MACRO>
<NAME>GST_MSDKMJPEGENC</NAME>
#define GST_MSDKMJPEGENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MSDKMJPEGENC,GstMsdkMJPEGEnc))
</MACRO>
<MACRO>
<NAME>GST_MSDKMJPEGENC_CLASS</NAME>
#define GST_MSDKMJPEGENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MSDKMJPEGENC,GstMsdkMJPEGEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKMJPEGENC</NAME>
#define GST_IS_MSDKMJPEGENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MSDKMJPEGENC))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKMJPEGENC_CLASS</NAME>
#define GST_IS_MSDKMJPEGENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MSDKMJPEGENC))
</MACRO>
<STRUCT>
<NAME>GstMsdkMJPEGEnc</NAME>
struct _GstMsdkMJPEGEnc
{
  GstMsdkEnc base;
  guint quality;
};
</STRUCT>
<STRUCT>
<NAME>GstMsdkMJPEGEncClass</NAME>
struct _GstMsdkMJPEGEncClass
{
  GstMsdkEncClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_msdkmjpegenc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MSDKMJPEGDEC</NAME>
#define GST_TYPE_MSDKMJPEGDEC \
  (gst_msdkmjpegdec_get_type())
</MACRO>
<MACRO>
<NAME>GST_MSDKMJPEGDEC</NAME>
#define GST_MSDKMJPEGDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MSDKMJPEGDEC,GstMsdkMJPEGDec))
</MACRO>
<MACRO>
<NAME>GST_MSDKMJPEGDEC_CLASS</NAME>
#define GST_MSDKMJPEGDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MSDKMJPEGDEC,GstMsdkMJPEGDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKMJPEGDEC</NAME>
#define GST_IS_MSDKMJPEGDEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MSDKMJPEGDEC))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKMJPEGDEC_CLASS</NAME>
#define GST_IS_MSDKMJPEGDEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MSDKMJPEGDEC))
</MACRO>
<STRUCT>
<NAME>GstMsdkMJPEGDec</NAME>
struct _GstMsdkMJPEGDec
{
  GstMsdkDec base;
};
</STRUCT>
<STRUCT>
<NAME>GstMsdkMJPEGDecClass</NAME>
struct _GstMsdkMJPEGDecClass
{
  GstMsdkDecClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_msdkmjpegdec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MSDKENC</NAME>
#define GST_TYPE_MSDKENC \
  (gst_msdkenc_get_type())
</MACRO>
<MACRO>
<NAME>GST_MSDKENC</NAME>
#define GST_MSDKENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MSDKENC,GstMsdkEnc))
</MACRO>
<MACRO>
<NAME>GST_MSDKENC_CLASS</NAME>
#define GST_MSDKENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MSDKENC,GstMsdkEncClass))
</MACRO>
<MACRO>
<NAME>GST_MSDKENC_GET_CLASS</NAME>
#define GST_MSDKENC_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_MSDKENC,GstMsdkEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKENC</NAME>
#define GST_IS_MSDKENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MSDKENC))
</MACRO>
<MACRO>
<NAME>GST_IS_MSDKENC_CLASS</NAME>
#define GST_IS_MSDKENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MSDKENC))
</MACRO>
<MACRO>
<NAME>MAX_EXTRA_PARAMS</NAME>
#define MAX_EXTRA_PARAMS 8
</MACRO>
<STRUCT>
<NAME>GstMsdkEnc</NAME>
struct _GstMsdkEnc
{
  GstVideoEncoder element;

  /* input description */
  GstVideoCodecState *input_state;

  /* List of frame/buffer mapping structs for
   * pending frames */
  GList *pending_frames;

  /* MFX context */
  MsdkContext *context;
  mfxVideoParam param;
  guint num_surfaces;
  mfxFrameSurface1 *surfaces;
  guint num_tasks;
  MsdkEncTask *tasks;
  guint next_task;

  mfxExtBuffer *extra_params[MAX_EXTRA_PARAMS];
  guint num_extra_params;

  /* element properties */
  gboolean hardware;

  guint async_depth;
  guint target_usage;
  guint rate_control;
  guint bitrate;
  guint qpi;
  guint qpp;
  guint qpb;
  guint gop_size;
  guint ref_frames;
  guint i_frames;
  guint b_frames;

  gboolean reconfig;
};
</STRUCT>
<STRUCT>
<NAME>GstMsdkEncClass</NAME>
struct _GstMsdkEncClass
{
  GstVideoEncoderClass parent_class;

  gboolean (*set_format) (GstMsdkEnc * encoder);
  gboolean (*configure) (GstMsdkEnc * encoder);
  GstCaps *(*set_src_caps) (GstMsdkEnc * encoder);
};
</STRUCT>
<STRUCT>
<NAME>MsdkEncTask</NAME>
struct _MsdkEncTask
{
  GstVideoCodecFrame *input_frame;
  mfxSyncPoint sync_point;
  mfxBitstream output_bitstream;
};
</STRUCT>
<FUNCTION>
<NAME>gst_msdkenc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_msdkenc_add_extra_param</NAME>
<RETURNS>void  </RETURNS>
GstMsdkEnc * thiz, mfxExtBuffer * param
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DSHOWVIDEOSRC</NAME>
#define GST_TYPE_DSHOWVIDEOSRC              (gst_dshowvideosrc_get_type())
</MACRO>
<MACRO>
<NAME>GST_DSHOWVIDEOSRC</NAME>
#define GST_DSHOWVIDEOSRC(obj)              (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DSHOWVIDEOSRC,GstDshowVideoSrc))
</MACRO>
<MACRO>
<NAME>GST_DSHOWVIDEOSRC_CLASS</NAME>
#define GST_DSHOWVIDEOSRC_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DSHOWVIDEOSRC,GstDshowVideoSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DSHOWVIDEOSRC</NAME>
#define GST_IS_DSHOWVIDEOSRC(obj)           (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DSHOWVIDEOSRC))
</MACRO>
<MACRO>
<NAME>GST_IS_DSHOWVIDEOSRC_CLASS</NAME>
#define GST_IS_DSHOWVIDEOSRC_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DSHOWVIDEOSRC))
</MACRO>
<STRUCT>
<NAME>GstDshowVideoSrc</NAME>
struct _GstDshowVideoSrc
{
  GstPushSrc src;

  /* device dshow reference (generally classid/name) */
  gchar *device;

  /* device friendly name */
  gchar *device_name;

  /* list of caps created from the list of supported media types of the dshow capture filter */
  GstCaps *caps;

  /* list of dshow media types from the filter's capture pins */
  GList *pins_mediatypes;

  /* dshow video capture filter */
  IBaseFilter *video_cap_filter;

  /* dshow sink filter */
  CDshowFakeSink *dshow_fakesink;

  /* graph manager interfaces */
  IMediaFilter *media_filter;
  IFilterGraph *filter_graph;

  IGraphBuilder	*graph_builder;
  ICaptureGraphBuilder2 *capture_builder;
  IAMVideoCompression *pVC;
  //IAMVfwCaptureDialogs *pDlg;
  //IAMStreamConfig *pASC;      // for audio cap
  IAMStreamConfig *pVSC;      // for video cap

  /* the last buffer from DirectShow */
  GCond buffer_cond;
  GMutex buffer_mutex;
  GstBuffer *buffer;
  gboolean stop_requested;

  gboolean is_rgb;
  gboolean is_running;
  gint width;
  gint height;
};
</STRUCT>
<STRUCT>
<NAME>GstDshowVideoSrcClass</NAME>
struct _GstDshowVideoSrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dshowvideosrc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DSHOWAUDIOSRC</NAME>
#define GST_TYPE_DSHOWAUDIOSRC              (gst_dshowaudiosrc_get_type())
</MACRO>
<MACRO>
<NAME>GST_DSHOWAUDIOSRC</NAME>
#define GST_DSHOWAUDIOSRC(obj)              (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DSHOWAUDIOSRC,GstDshowAudioSrc))
</MACRO>
<MACRO>
<NAME>GST_DSHOWAUDIOSRC_CLASS</NAME>
#define GST_DSHOWAUDIOSRC_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DSHOWAUDIOSRC,GstDshowAudioSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DSHOWAUDIOSRC</NAME>
#define GST_IS_DSHOWAUDIOSRC(obj)           (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DSHOWAUDIOSRC))
</MACRO>
<MACRO>
<NAME>GST_IS_DSHOWAUDIOSRC_CLASS</NAME>
#define GST_IS_DSHOWAUDIOSRC_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DSHOWAUDIOSRC))
</MACRO>
<STRUCT>
<NAME>GstDshowAudioSrc</NAME>
struct _GstDshowAudioSrc
{
  GstAudioSrc src;

  /* device dshow reference (generally classid/name) */
  gchar *device;

  /* device friendly name */
  gchar *device_name;

  /* list of caps created from the list of supported media types of the dshow capture filter */
  GstCaps *caps;

  /* list of dshow media types filter's pins mediatypes */
  GList *pins_mediatypes;

  /* dshow audio capture filter */
  IBaseFilter *audio_cap_filter;

  /* dshow fakesink filter */
  CDshowFakeSink *dshow_fakesink;

  /* graph manager interfaces */
  IMediaFilter *media_filter;
  IFilterGraph *filter_graph;

  /* bytes array */
  GByteArray *gbarray;
  GMutex gbarray_lock;

  gboolean is_running;
};
</STRUCT>
<STRUCT>
<NAME>GstDshowAudioSrcClass</NAME>
struct _GstDshowAudioSrcClass
{
  GstAudioSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dshowaudiosrc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<USER_FUNCTION>
<NAME>push_buffer_func</NAME>
<RETURNS>bool </RETURNS>
guint8 * buffer, guint size, gpointer src_object,
    GstClockTime duration
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_dshow_free_pin_mediatype</NAME>
<RETURNS>void  </RETURNS>
gpointer pt
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_free_mediatype</NAME>
<RETURNS>void  </RETURNS>
AM_MEDIA_TYPE * pmt
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_new_pin_mediatype</NAME>
<RETURNS>GstCapturePinMediaType  *</RETURNS>
IPin * pin
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_new_pin_mediatype_from_enum_mediatypes</NAME>
<RETURNS>GstCapturePinMediaType  * </RETURNS>
IPin * pin, IEnumMediaTypes *enum_mediatypes
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_new_pin_mediatype_from_streamcaps</NAME>
<RETURNS>GstCapturePinMediaType  *</RETURNS>
IPin * pin, gint id, IAMStreamConfig * streamcaps
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_free_pins_mediatypes</NAME>
<RETURNS>void  </RETURNS>
GList * mediatypes
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_check_mediatype</NAME>
<RETURNS>gboolean  </RETURNS>
AM_MEDIA_TYPE * media_type, const GUID sub_type, const GUID format_type
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_get_pin_from_filter</NAME>
<RETURNS>gboolean  </RETURNS>
IBaseFilter * filter, PIN_DIRECTION pindir, IPin ** pin
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_find_filter</NAME>
<RETURNS>gboolean  </RETURNS>
CLSID input_majortype, CLSID input_subtype, CLSID output_majortype, CLSID output_subtype, gchar * prefered_filter_name, IBaseFilter ** filter
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_getdevice_from_devicename</NAME>
<RETURNS>gchar  *</RETURNS>
const GUID * device_category, gchar ** device_name
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_show_propertypage</NAME>
<RETURNS>gboolean  </RETURNS>
IBaseFilter * base_filter
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_guid_to_gst_video_format</NAME>
<RETURNS>GstVideoFormat  </RETURNS>
AM_MEDIA_TYPE *mediatype
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_is_pin_connected</NAME>
<RETURNS>gboolean  </RETURNS>
IPin *pin
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_new_video_caps</NAME>
<RETURNS>GstCaps  *</RETURNS>
GstVideoFormat video_format, const gchar * name, GstCapturePinMediaType * pin_mediatype
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_configure_latency</NAME>
<RETURNS>bool  </RETURNS>
IPin *pCapturePin, guint bufSizeMS
</FUNCTION>
<FUNCTION>
<NAME>gst_opensles_get_engine</NAME>
<RETURNS>SLObjectItf  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_opensles_release_engine</NAME>
<RETURNS>void  </RETURNS>
SLObjectItf engine_object
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OPENSLES_SRC</NAME>
#define GST_TYPE_OPENSLES_SRC \
  (gst_opensles_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPENSLES_SRC</NAME>
#define GST_OPENSLES_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OPENSLES_SRC,GstOpenSLESSrc))
</MACRO>
<MACRO>
<NAME>GST_OPENSLES_SRC_CLASS</NAME>
#define GST_OPENSLES_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OPENSLES_SRC,GstOpenSLESSrcClass))
</MACRO>
<STRUCT>
<NAME>GstOpenSLESSrc</NAME>
struct _GstOpenSLESSrc
{
  GstAudioBaseSrc src;
  GstOpenSLESRecordingPreset preset;
};
</STRUCT>
<STRUCT>
<NAME>GstOpenSLESSrcClass</NAME>
struct _GstOpenSLESSrcClass
{
  GstAudioBaseSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_opensles_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstOpenSLESRecordingPreset</NAME>
typedef enum {
  GST_OPENSLES_RECORDING_PRESET_NONE,
  GST_OPENSLES_RECORDING_PRESET_GENERIC,
  GST_OPENSLES_RECORDING_PRESET_CAMCORDER,
  GST_OPENSLES_RECORDING_PRESET_VOICE_RECOGNITION,
  GST_OPENSLES_RECORDING_PRESET_VOICE_COMMUNICATION,
} GstOpenSLESRecordingPreset;
</ENUM>
<MACRO>
<NAME>GST_TYPE_OPENSLES_RECORDING_PRESET</NAME>
#define GST_TYPE_OPENSLES_RECORDING_PRESET \
  (gst_opensles_recording_preset_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_opensles_recording_preset_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_to_opensles_recording_preset</NAME>
<RETURNS>SLint32  </RETURNS>
GstOpenSLESRecordingPreset preset
</FUNCTION>
<ENUM>
<NAME>GstOpenSLESStreamType</NAME>
typedef enum {
  GST_OPENSLES_STREAM_TYPE_VOICE,
  GST_OPENSLES_STREAM_TYPE_SYSTEM,
  GST_OPENSLES_STREAM_TYPE_RING,
  GST_OPENSLES_STREAM_TYPE_MEDIA,
  GST_OPENSLES_STREAM_TYPE_ALARM,
  GST_OPENSLES_STREAM_TYPE_NOTIFICATION,
  GST_OPENSLES_STREAM_TYPE_NONE = -1, /* If we don't want to set a type */
} GstOpenSLESStreamType;
</ENUM>
<MACRO>
<NAME>GST_TYPE_OPENSLES_STREAM_TYPE</NAME>
#define GST_TYPE_OPENSLES_STREAM_TYPE \
  (gst_opensles_stream_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_opensles_stream_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_to_opensles_stream_type</NAME>
<RETURNS>SLint32  </RETURNS>
GstOpenSLESStreamType stream_type
</FUNCTION>
<MACRO>
<NAME>MAX_NUMBER_OUTPUT_DEVICES</NAME>
#define MAX_NUMBER_OUTPUT_DEVICES 16
</MACRO>
<MACRO>
<NAME>GST_TYPE_OPENSLES_RING_BUFFER</NAME>
#define GST_TYPE_OPENSLES_RING_BUFFER \
  (gst_opensles_ringbuffer_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPENSLES_RING_BUFFER</NAME>
#define GST_OPENSLES_RING_BUFFER(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OPENSLES_RING_BUFFER,GstOpenSLESRingBuffer))
</MACRO>
<MACRO>
<NAME>GST_OPENSLES_RING_BUFFER_CAST</NAME>
#define GST_OPENSLES_RING_BUFFER_CAST(obj) \
  ((GstOpenSLESRingBuffer*) obj)
</MACRO>
<MACRO>
<NAME>GST_OPENSLES_RING_BUFFER_CLASS</NAME>
#define GST_OPENSLES_RING_BUFFER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OPENSLES_RING_BUFFER,GstOpenSLESRingBufferClass))
</MACRO>
<MACRO>
<NAME>GST_OPENSLES_RING_BUFFER_GET_CLASS</NAME>
#define GST_OPENSLES_RING_BUFFER_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_OPENSLES_RING_BUFFER,GstOpenSLESRingBufferClass))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENSLES_RING_BUFFER</NAME>
#define GST_IS_OPENSLES_RING_BUFFER(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OPENSLES_RING_BUFFER))
</MACRO>
<MACRO>
<NAME>GST_IS_OPENSLES_RING_BUFFER_CLASS</NAME>
#define GST_IS_OPENSLES_RING_BUFFER_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OPENSLES_RING_BUFFER))
</MACRO>
<ENUM>
<NAME>RingBufferMode</NAME>
typedef enum
{
  RB_MODE_NONE = 0,
  RB_MODE_SRC,
  RB_MODE_SINK_PCM,
  RB_MODE_SINK_COMPRESSED,
  RB_MODE_LAST
} RingBufferMode;
</ENUM>
<USER_FUNCTION>
<NAME>AcquireFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstAudioRingBuffer * rb, GstAudioRingBufferSpec * spec
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>StateFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstAudioRingBuffer * rb
</USER_FUNCTION>
<STRUCT>
<NAME>GstOpenSLESRingBuffer</NAME>
struct _GstOpenSLESRingBuffer
{
  GstAudioRingBuffer object;

  RingBufferMode mode;

  /* engine interfaces */
  SLObjectItf engineObject;
  SLEngineItf engineEngine;

  /* outputMixObject */
  SLObjectItf outputMixObject;

  /* player interfaces */
  SLObjectItf playerObject;
  SLPlayItf playerPlay;
  SLVolumeItf playerVolume;
  gfloat volume;
  gboolean mute;
  gint is_prerolled; /* ATOMIC */
  GstOpenSLESStreamType stream_type;

  /* recorder interfaces */
  SLObjectItf recorderObject;
  SLRecordItf recorderRecord;
  GstOpenSLESRecordingPreset preset;

  /* buffer queue */
  SLAndroidSimpleBufferQueueItf bufferQueue;
  guint data_segtotal;
  guint8 * data;
  guint data_size;
  guint cursor;
  gint segqueued; /* ATOMIC */
  gboolean is_queue_callback_registered;

  /* vmethods */
  AcquireFunc acquire;
  StateFunc start;
  StateFunc pause;
  StateFunc stop;
  StateFunc change_volume;
  StateFunc change_mute;
};
</STRUCT>
<STRUCT>
<NAME>GstOpenSLESRingBufferClass</NAME>
struct _GstOpenSLESRingBufferClass
{
  GstAudioRingBufferClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_opensles_ringbuffer_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_opensles_ringbuffer_new</NAME>
<RETURNS>GstAudioRingBuffer  *</RETURNS>
RingBufferMode mode
</FUNCTION>
<FUNCTION>
<NAME>gst_opensles_ringbuffer_set_volume</NAME>
<RETURNS>void  </RETURNS>
GstAudioRingBuffer * rb, gfloat volume
</FUNCTION>
<FUNCTION>
<NAME>gst_opensles_ringbuffer_set_mute</NAME>
<RETURNS>void  </RETURNS>
GstAudioRingBuffer * rb, gboolean mute
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OPENSLES_SINK</NAME>
#define GST_TYPE_OPENSLES_SINK \
  (gst_opensles_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_OPENSLES_SINK</NAME>
#define GST_OPENSLES_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OPENSLES_SINK,GstOpenSLESSink))
</MACRO>
<MACRO>
<NAME>GST_OPENSLES_SINK_CLASS</NAME>
#define GST_OPENSLES_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OPENSLES_SINK,GstOpenSLESSinkClass))
</MACRO>
<STRUCT>
<NAME>GstOpenSLESSink</NAME>
struct _GstOpenSLESSink
{
  GstAudioBaseSink sink;

  GstOpenSLESStreamType stream_type;

  gfloat volume;
  gboolean mute;
};
</STRUCT>
<STRUCT>
<NAME>GstOpenSLESSinkClass</NAME>
struct _GstOpenSLESSinkClass
{
  GstAudioBaseSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_opensles_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_VTENC_CAST</NAME>
#define GST_VTENC_CAST(obj) \
  ((GstVTEnc *) (obj))
</MACRO>
<MACRO>
<NAME>GST_VTENC_CLASS_GET_CODEC_DETAILS</NAME>
#define GST_VTENC_CLASS_GET_CODEC_DETAILS(klass) \
  ((const GstVTEncoderDetails *) g_type_get_qdata (G_OBJECT_CLASS_TYPE (klass), \
      GST_VTENC_CODEC_DETAILS_QDATA))
</MACRO>
<STRUCT>
<NAME>GstVTEncoderDetails</NAME>
struct _GstVTEncoderDetails
{
  const gchar * name;
  const gchar * element_name;
  const gchar * mimetype;
  CMVideoCodecType format_id;
  gboolean require_hardware;
};
</STRUCT>
<STRUCT>
<NAME>GstVTEncClass</NAME>
struct _GstVTEncClass
{
  GstVideoEncoderClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GstVTEnc</NAME>
struct _GstVTEnc
{
  GstVideoEncoder parent;

  const GstVTEncoderDetails * details;

  CFStringRef profile_level;
  guint bitrate;
  gboolean allow_frame_reordering;
  gboolean realtime;
  gdouble quality;
  gint max_keyframe_interval;
  GstClockTime max_keyframe_interval_duration;
  gint latency_frames;

  gboolean dump_properties;
  gboolean dump_attributes;

  gint negotiated_width, negotiated_height;
  gint negotiated_fps_n, negotiated_fps_d;
  gint caps_width, caps_height;
  gint caps_fps_n, caps_fps_d;
  GstVideoCodecState *input_state;
  GstVideoInfo video_info;
  VTCompressionSessionRef session;
  CFDictionaryRef keyframe_props;

  GAsyncQueue * cur_outframes;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vtenc_register_elements</NAME>
<RETURNS>void  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<STRUCT>
<NAME>GstVTEncClassParams</NAME>
</STRUCT>
<ENUM>
<NAME>GstAppleCoreVideoLockState</NAME>
typedef enum
{
  GST_APPLE_CORE_VIDEO_MEMORY_UNLOCKED,
  GST_APPLE_CORE_VIDEO_MEMORY_LOCKED_READONLY,
  GST_APPLE_CORE_VIDEO_MEMORY_LOCKED_READ_WRITE
} GstAppleCoreVideoLockState;
</ENUM>
<FUNCTION>
<NAME>gst_apple_core_video_memory_init</NAME>
<RETURNS>void </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_apple_core_video_pixel_buffer_new</NAME>
<RETURNS>GstAppleCoreVideoPixelBuffer  *</RETURNS>
CVPixelBufferRef pixbuf
</FUNCTION>
<FUNCTION>
<NAME>gst_apple_core_video_pixel_buffer_ref</NAME>
<RETURNS>GstAppleCoreVideoPixelBuffer  *</RETURNS>
GstAppleCoreVideoPixelBuffer * shared
</FUNCTION>
<FUNCTION>
<NAME>gst_apple_core_video_pixel_buffer_unref</NAME>
<RETURNS>void </RETURNS>
GstAppleCoreVideoPixelBuffer * shared
</FUNCTION>
<FUNCTION>
<NAME>gst_is_apple_core_video_memory</NAME>
<RETURNS>gboolean </RETURNS>
GstMemory * mem
</FUNCTION>
<FUNCTION>
<NAME>gst_apple_core_video_memory_new_wrapped</NAME>
<RETURNS>GstAppleCoreVideoMemory  *</RETURNS>
GstAppleCoreVideoPixelBuffer * shared, gsize plane, gsize size
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_IOS_GL_MEMORY_ALLOCATOR</NAME>
#define GST_TYPE_IOS_GL_MEMORY_ALLOCATOR (gst_ios_gl_memory_allocator_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_ios_gl_memory_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_IS_IOS_GL_MEMORY_ALLOCATOR</NAME>
#define GST_IS_IOS_GL_MEMORY_ALLOCATOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_IOS_GL_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_IOS_GL_MEMORY_ALLOCATOR_CLASS</NAME>
#define GST_IS_IOS_GL_MEMORY_ALLOCATOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_IOS_GL_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IOS_GL_MEMORY_ALLOCATOR_GET_CLASS</NAME>
#define GST_IOS_GL_MEMORY_ALLOCATOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_IOS_GL_MEMORY_ALLOCATOR, GstIOSGLMemoryAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_IOS_GL_MEMORY_ALLOCATOR</NAME>
#define GST_IOS_GL_MEMORY_ALLOCATOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_IOS_GL_MEMORY_ALLOCATOR, GstIOSGLMemoryAllocator))
</MACRO>
<MACRO>
<NAME>GST_IOS_GL_MEMORY_ALLOCATOR_CLASS</NAME>
#define GST_IOS_GL_MEMORY_ALLOCATOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_IOS_GL_MEMORY_ALLOCATOR, GstIOSGLMemoryAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_IOS_GL_MEMORY_ALLOCATOR_CAST</NAME>
#define GST_IOS_GL_MEMORY_ALLOCATOR_CAST(obj)            ((GstIOSGLMemoryAllocator *)(obj))
</MACRO>
<MACRO>
<NAME>GST_IOS_GL_MEMORY_ALLOCATOR_NAME</NAME>
#define GST_IOS_GL_MEMORY_ALLOCATOR_NAME   "IOSGLMemory"
</MACRO>
<FUNCTION>
<NAME>gst_ios_gl_memory_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_ios_gl_memory_new_wrapped</NAME>
<RETURNS>GstIOSGLMemory  *</RETURNS>
GstGLContext * context, GstAppleCoreVideoMemory *cv_mem, GstGLTextureTarget target, GstGLFormat tex_format, guint tex_id, GstVideoInfo * info, guint plane, GstVideoAlignment *valign, gpointer gl_data, GDestroyNotify gl_notify
</FUNCTION>
<FUNCTION>
<NAME>gst_is_ios_gl_memory</NAME>
<RETURNS>gboolean  </RETURNS>
GstMemory * mem
</FUNCTION>
<FUNCTION>
<NAME>gst_video_texture_cache_new</NAME>
<RETURNS>GstVideoTextureCache  *</RETURNS>
GstGLContext * ctx
</FUNCTION>
<FUNCTION>
<NAME>gst_video_texture_cache_free</NAME>
<RETURNS>void  </RETURNS>
GstVideoTextureCache * cache
</FUNCTION>
<FUNCTION>
<NAME>gst_video_texture_cache_set_format</NAME>
<RETURNS>void  </RETURNS>
GstVideoTextureCache * cache, GstVideoFormat in_format, GstCaps * out_caps
</FUNCTION>
<FUNCTION>
<NAME>gst_video_texture_cache_upload</NAME>
<RETURNS>gboolean  </RETURNS>
GstVideoGLTextureUploadMeta * meta, guint texture_id[4]
</FUNCTION>
<FUNCTION>
<NAME>gst_video_texture_cache_create_memory</NAME>
<RETURNS>GstMemory  *</RETURNS>
GstVideoTextureCache * cache, GstAppleCoreVideoPixelBuffer *gpixbuf, guint plane, gsize size
</FUNCTION>
<MACRO>
<NAME>GST_CORE_VIDEO_META_API_TYPE</NAME>
#define GST_CORE_VIDEO_META_API_TYPE (gst_core_video_meta_api_get_type())
</MACRO>
<MACRO>
<NAME>gst_buffer_get_core_video_meta</NAME>
#define gst_buffer_get_core_video_meta(b) \
  ((GstCoreVideoMeta*)gst_buffer_get_meta((b),GST_CORE_VIDEO_META_API_TYPE))
</MACRO>
<FUNCTION>
<NAME>gst_core_video_buffer_new</NAME>
<RETURNS>GstBuffer  * </RETURNS>
CVBufferRef cvbuf, GstVideoInfo *info, GstVideoTextureCache *cache
</FUNCTION>
<FUNCTION>
<NAME>gst_core_video_info_init_from_pixel_buffer</NAME>
<RETURNS>gboolean  </RETURNS>
GstVideoInfo * info, CVPixelBufferRef pixel_buf
</FUNCTION>
<FUNCTION>
<NAME>gst_core_video_wrap_pixel_buffer</NAME>
<RETURNS>void  </RETURNS>
GstBuffer * buf, GstVideoInfo * info, CVPixelBufferRef pixel_buf, GstVideoTextureCache *cache, gboolean * has_padding
</FUNCTION>
<FUNCTION>
<NAME>gst_core_video_meta_api_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_helper_new</NAME>
<RETURNS>GstGLContextHelper  * </RETURNS>
GstElement *element
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_helper_free</NAME>
<RETURNS>void  </RETURNS>
GstGLContextHelper *ctxh
</FUNCTION>
<FUNCTION>
<NAME>gst_gl_context_helper_ensure_context</NAME>
<RETURNS>void  </RETURNS>
GstGLContextHelper *ctxh
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AVF_VIDEO_SRC</NAME>
#define GST_TYPE_AVF_VIDEO_SRC \
  (gst_avf_video_src_get_type ())
</MACRO>
<MACRO>
<NAME>GST_AVF_VIDEO_SRC</NAME>
#define GST_AVF_VIDEO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_AVF_VIDEO_SRC, GstAVFVideoSrc))
</MACRO>
<MACRO>
<NAME>GST_AVF_VIDEO_SRC_CAST</NAME>
#define GST_AVF_VIDEO_SRC_CAST(obj) \
  ((GstAVFVideoSrc *) (obj))
</MACRO>
<MACRO>
<NAME>GST_AVF_VIDEO_SRC_CLASS</NAME>
#define GST_AVF_VIDEO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_AVF_VIDEO_SRC, GstAVFVideoSrcClass))
</MACRO>
<MACRO>
<NAME>GST_AVF_VIDEO_SRC_IMPL</NAME>
#define GST_AVF_VIDEO_SRC_IMPL(obj) \
  ((__bridge GstAVFVideoSrcImpl *) GST_AVF_VIDEO_SRC_CAST (obj)->impl)
</MACRO>
<MACRO>
<NAME>GST_IS_AVF_VIDEO_SRC</NAME>
#define GST_IS_AVF_VIDEO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_AVF_VIDEO_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_AVF_VIDEO_SRC_CLASS</NAME>
#define GST_IS_AVF_VIDEO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_AVF_VIDEO_SRC))
</MACRO>
<ENUM>
<NAME>GstAVFVideoSourcePosition</NAME>
typedef enum
{
    GST_AVF_VIDEO_SOURCE_POSITION_DEFAULT,
    GST_AVF_VIDEO_SOURCE_POSITION_FRONT,
    GST_AVF_VIDEO_SOURCE_POSITION_BACK,
} GstAVFVideoSourcePosition;
</ENUM>
<ENUM>
<NAME>GstAVFVideoSourceOrientation</NAME>
typedef enum
{
    GST_AVF_VIDEO_SOURCE_ORIENTATION_DEFAULT,
    GST_AVF_VIDEO_SOURCE_ORIENTATION_PORTRAIT,
    GST_AVF_VIDEO_SOURCE_ORIENTATION_PORTRAIT_UPSIDE_DOWN,
    GST_AVF_VIDEO_SOURCE_ORIENTATION_LANDSCAPE_RIGHT,
    GST_AVF_VIDEO_SOURCE_ORIENTATION_LANDSCAPE_LEFT,
} GstAVFVideoSourceOrientation;
</ENUM>
<ENUM>
<NAME>GstAVFVideoSourceDeviceType</NAME>
typedef enum
{
    GST_AVF_VIDEO_SOURCE_DEVICE_TYPE_DEFAULT,
    GST_AVF_VIDEO_SOURCE_DEVICE_TYPE_BUILT_IN_WIDE_ANGLE_CAMERA,
    GST_AVF_VIDEO_SOURCE_DEVICE_TYPE_BUILT_IN_TELEPHOTO_CAMERA,
    GST_AVF_VIDEO_SOURCE_DEVICE_TYPE_BUILT_IN_DUAL_CAMERA,
} GstAVFVideoSourceDeviceType;
</ENUM>
<STRUCT>
<NAME>GstAVFVideoSrc</NAME>
struct _GstAVFVideoSrc
{
  GstPushSrc push_src;

  /* NOTE: ARC no longer allows Objective-C pointers in structs. */
  /* Instead, use gpointer with explicit __bridge_* calls */
  gpointer impl;
};
</STRUCT>
<STRUCT>
<NAME>GstAVFVideoSrcClass</NAME>
struct _GstAVFVideoSrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_avf_video_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ATDEC</NAME>
#define GST_TYPE_ATDEC   (gst_atdec_get_type())
</MACRO>
<MACRO>
<NAME>GST_ATDEC</NAME>
#define GST_ATDEC(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ATDEC,GstATDec))
</MACRO>
<MACRO>
<NAME>GST_ATDEC_CLASS</NAME>
#define GST_ATDEC_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ATDEC,GstATDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ATDEC</NAME>
#define GST_IS_ATDEC(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ATDEC))
</MACRO>
<MACRO>
<NAME>GST_IS_ATDEC_CLASS</NAME>
#define GST_IS_ATDEC_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ATDEC))
</MACRO>
<STRUCT>
<NAME>GstATDec</NAME>
struct _GstATDec
{
  GstAudioDecoder decoder;
  AudioQueueRef queue;
  gint spf;
  guint64 input_position, output_position;
};
</STRUCT>
<STRUCT>
<NAME>GstATDecClass</NAME>
struct _GstATDecClass
{
  GstAudioDecoderClass decoder_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_atdec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_CORE_MEDIA_META_API_TYPE</NAME>
#define GST_CORE_MEDIA_META_API_TYPE (gst_core_media_meta_api_get_type())
</MACRO>
<MACRO>
<NAME>gst_buffer_get_core_media_meta</NAME>
#define gst_buffer_get_core_media_meta(b) \
  ((GstCoreMediaMeta*)gst_buffer_get_meta((b),GST_CORE_MEDIA_META_API_TYPE))
</MACRO>
<FUNCTION>
<NAME>gst_core_media_buffer_new</NAME>
<RETURNS>GstBuffer  * </RETURNS>
CMSampleBufferRef sample_buf, gboolean use_video_meta, GstVideoTextureCache *cache
</FUNCTION>
<FUNCTION>
<NAME>gst_core_media_buffer_get_pixel_buffer</NAME>
<RETURNS>CVPixelBufferRef  </RETURNS>
GstBuffer * buf
</FUNCTION>
<FUNCTION>
<NAME>gst_core_media_meta_api_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vtutil_object_to_string</NAME>
<RETURNS>gchar  * </RETURNS>
CFTypeRef obj
</FUNCTION>
<FUNCTION>
<NAME>gst_vtutil_string_to_utf8</NAME>
<RETURNS>gchar  * </RETURNS>
CFStringRef s
</FUNCTION>
<FUNCTION>
<NAME>gst_vtutil_dict_set_i32</NAME>
<RETURNS>void  </RETURNS>
CFMutableDictionaryRef dict, CFStringRef key, gint32 value
</FUNCTION>
<FUNCTION>
<NAME>gst_vtutil_dict_set_string</NAME>
<RETURNS>void  </RETURNS>
CFMutableDictionaryRef dict, CFStringRef key, const gchar * value
</FUNCTION>
<FUNCTION>
<NAME>gst_vtutil_dict_set_boolean</NAME>
<RETURNS>void  </RETURNS>
CFMutableDictionaryRef dict, CFStringRef key, gboolean value
</FUNCTION>
<FUNCTION>
<NAME>gst_vtutil_dict_set_data</NAME>
<RETURNS>void  </RETURNS>
CFMutableDictionaryRef dict, CFStringRef key, guint8 * value, guint64 length
</FUNCTION>
<FUNCTION>
<NAME>gst_vtutil_dict_set_object</NAME>
<RETURNS>void  </RETURNS>
CFMutableDictionaryRef dict, CFStringRef key, CFTypeRef * value
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AVF_ASSET_SRC</NAME>
#define GST_TYPE_AVF_ASSET_SRC \
  (gst_avf_asset_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_AVF_ASSET_SRC_READER</NAME>
#define GST_AVF_ASSET_SRC_READER(obj) \
  ((__bridge GstAVFAssetReader *)(obj->reader))
</MACRO>
<MACRO>
<NAME>GST_AVF_ASSET_SRC</NAME>
#define GST_AVF_ASSET_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AVF_ASSET_SRC,GstAVFAssetSrc))
</MACRO>
<MACRO>
<NAME>GST_AVF_ASSET_SRC_CLASS</NAME>
#define GST_AVF_ASSET_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AVF_ASSET_SRC,GstAVFAssetSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AVF_ASSET_SRC</NAME>
#define GST_IS_AVF_ASSET_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AVF_ASSET_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_AVF_ASSET_SRC_CLASS</NAME>
#define GST_IS_AVF_ASSET_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AVF_ASSET_SRC))
</MACRO>
<MACRO>
<NAME>GST_AVF_ASSET_SRC_ERROR</NAME>
#define GST_AVF_ASSET_SRC_ERROR gst_avf_asset_src_error_quark ()
</MACRO>
<ENUM>
<NAME>GstAVFAssetReaderMediaType</NAME>
typedef enum
{
  GST_AVF_ASSET_READER_MEDIA_TYPE_AUDIO,
  GST_AVF_ASSET_READER_MEDIA_TYPE_VIDEO,
} GstAVFAssetReaderMediaType;
</ENUM>
<ENUM>
<NAME>GstAVFAssetError</NAME>
typedef enum
{
  GST_AVF_ASSET_ERROR_NOT_PLAYABLE,
  GST_AVF_ASSET_ERROR_INIT,
  GST_AVF_ASSET_ERROR_START,
  GST_AVF_ASSET_ERROR_READ,
} GstAVFAssetError;
</ENUM>
<ENUM>
<NAME>GstAVFAssetSrcState</NAME>
typedef enum
{
  GST_AVF_ASSET_SRC_STATE_STOPPED,
  GST_AVF_ASSET_SRC_STATE_STARTED,
  GST_AVF_ASSET_SRC_STATE_READING,
} GstAVFAssetSrcState;
</ENUM>
<STRUCT>
<NAME>GstAVFAssetSrc</NAME>
struct _GstAVFAssetSrc
{
  GstElement element;

  GstPad *videopad;
  GstPad *audiopad;
  gint selected_video_track;
  gint selected_audio_track;

  /* NOTE: ARC no longer allows Objective-C pointers in structs. */
  /* Instead, use gpointer with explicit __bridge_* calls */
  gpointer reader;

  GstAVFAssetSrcState state;
  GMutex lock;
  GstEvent *seek_event;

  GstFlowReturn last_audio_pad_ret;
  GstFlowReturn last_video_pad_ret;

  /* Properties */
  gchar * uri;
};
</STRUCT>
<STRUCT>
<NAME>GstAVFAssetSrcClass</NAME>
struct _GstAVFAssetSrcClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_avf_asset_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_IOS_ASSET_SRC</NAME>
#define GST_TYPE_IOS_ASSET_SRC \
  (gst_ios_asset_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_IOS_ASSET_SRC</NAME>
#define GST_IOS_ASSET_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_IOS_ASSET_SRC,GstIOSAssetSrc))
</MACRO>
<MACRO>
<NAME>GST_IOS_ASSET_SRC_CLASS</NAME>
#define GST_IOS_ASSET_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_IOS_ASSET_SRC,GstIOSAssetSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_IOS_ASSET_SRC</NAME>
#define GST_IS_IOS_ASSET_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_IOS_ASSET_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_IOS_ASSET_SRC_CLASS</NAME>
#define GST_IS_IOS_ASSET_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_IOS_ASSET_SRC))
</MACRO>
<MACRO>
<NAME>GST_IOS_ASSET_SRC_CAST</NAME>
#define GST_IOS_ASSET_SRC_CAST(obj) ((GstIOSAssetSrc*) obj)
</MACRO>
<MACRO>
<NAME>GST_IOS_ASSET_SRC_ASSET</NAME>
#define GST_IOS_ASSET_SRC_ASSET(obj) \
  (__bridge ALAssetRepresentation *)(obj->asset)
</MACRO>
<MACRO>
<NAME>GST_IOS_ASSET_SRC_LIBRARY</NAME>
#define GST_IOS_ASSET_SRC_LIBRARY(obj) \
  (__bridge GstAssetsLibrary *)(obj->library)
</MACRO>
<MACRO>
<NAME>GST_IOS_ASSET_SRC_URL</NAME>
#define GST_IOS_ASSET_SRC_URL(obj) \
  (__bridge NSURL *)(obj->url)
</MACRO>
<STRUCT>
<NAME>GstIOSAssetSrc</NAME>
struct _GstIOSAssetSrc {
  GstBaseSrc element;

  /*< private >*/
  gchar * uri;                    /* asset uri */

  /* NOTE: ARC no longer allows Objective-C pointers in structs. */
  /* Instead, use gpointer with explicit __bridge_* calls */
  gpointer url;                    /* asset url */
  gpointer asset;  /* asset representation */
  gpointer library;     /* assets library */
};
</STRUCT>
<STRUCT>
<NAME>GstIOSAssetSrcClass</NAME>
struct _GstIOSAssetSrcClass {
  GstBaseSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ios_asset_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_IO_SURFACE_MEMORY_ALLOCATOR</NAME>
#define GST_TYPE_IO_SURFACE_MEMORY_ALLOCATOR (gst_io_surface_memory_allocator_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_io_surface_memory_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_IS_IO_SURFACE_MEMORY_ALLOCATOR</NAME>
#define GST_IS_IO_SURFACE_MEMORY_ALLOCATOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_IO_SURFACE_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_IO_SURFACE_MEMORY_ALLOCATOR_CLASS</NAME>
#define GST_IS_IO_SURFACE_MEMORY_ALLOCATOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_IO_SURFACE_MEMORY_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IO_SURFACE_MEMORY_ALLOCATOR_GET_CLASS</NAME>
#define GST_IO_SURFACE_MEMORY_ALLOCATOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_IO_SURFACE_MEMORY_ALLOCATOR, GstIOSurfaceMemoryAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_IO_SURFACE_MEMORY_ALLOCATOR</NAME>
#define GST_IO_SURFACE_MEMORY_ALLOCATOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_IO_SURFACE_MEMORY_ALLOCATOR, GstIOSurfaceMemoryAllocator))
</MACRO>
<MACRO>
<NAME>GST_IO_SURFACE_MEMORY_ALLOCATOR_CLASS</NAME>
#define GST_IO_SURFACE_MEMORY_ALLOCATOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_IO_SURFACE_MEMORY_ALLOCATOR, GstIOSurfaceMemoryAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_IO_SURFACE_MEMORY_ALLOCATOR_CAST</NAME>
#define GST_IO_SURFACE_MEMORY_ALLOCATOR_CAST(obj)            ((GstIOSurfaceMemoryAllocator *)(obj))
</MACRO>
<MACRO>
<NAME>GST_IO_SURFACE_MEMORY_ALLOCATOR_NAME</NAME>
#define GST_IO_SURFACE_MEMORY_ALLOCATOR_NAME   "IOSurfaceMemory"
</MACRO>
<FUNCTION>
<NAME>gst_ios_surface_memory_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_io_surface_memory_wrapped</NAME>
<RETURNS>GstIOSurfaceMemory  *</RETURNS>
GstGLContext * context, IOSurfaceRef surface, GstGLTextureTarget target, GstGLFormat tex_format, GstVideoInfo * info, guint plane, GstVideoAlignment *valign, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_io_surface_memory_set_surface</NAME>
<RETURNS>void  </RETURNS>
GstIOSurfaceMemory *memory, IOSurfaceRef surface
</FUNCTION>
<FUNCTION>
<NAME>gst_is_io_surface_memory</NAME>
<RETURNS>gboolean  </RETURNS>
GstMemory * mem
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AV_SAMPLE_VIDEO_SINK</NAME>
#define GST_TYPE_AV_SAMPLE_VIDEO_SINK \
    (gst_av_sample_video_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_AV_SAMPLE_VIDEO_SINK</NAME>
#define GST_AV_SAMPLE_VIDEO_SINK(obj) \
    (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AV_SAMPLE_VIDEO_SINK,GstAVSampleVideoSink))
</MACRO>
<MACRO>
<NAME>GST_AV_SAMPLE_VIDEO_SINK_CLASS</NAME>
#define GST_AV_SAMPLE_VIDEO_SINK_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AV_SAMPLE_VIDEO_SINK,GstAVSampleVideoSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AV_SAMPLE_VIDEO_SINK</NAME>
#define GST_IS_AV_SAMPLE_VIDEO_SINK(obj) \
    (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AV_SAMPLE_VIDEO_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_AV_SAMPLE_VIDEO_SINK_CLASS</NAME>
#define GST_IS_AV_SAMPLE_VIDEO_SINK_CLASS(klass) \
    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AV_SAMPLE_VIDEO_SINK))
</MACRO>
<MACRO>
<NAME>GST_AV_SAMPLE_VIDEO_SINK_LAYER</NAME>
#define GST_AV_SAMPLE_VIDEO_SINK_LAYER(obj) \
    ((__bridge AVSampleBufferDisplayLayer *)(obj->layer))
</MACRO>
<STRUCT>
<NAME>GstAVSampleVideoSink</NAME>
struct _GstAVSampleVideoSink
{
    GstVideoSink video_sink;

    /* NOTE: ARC no longer allows Objective-C pointers in structs. */
    /* Instead, use gpointer with explicit __bridge_* calls */
    gpointer layer;

    GstVideoInfo info;

    gboolean keep_aspect_ratio;

    GstBufferPool *pool;

    gboolean layer_requesting_data;

    GMutex render_lock;
    GstBuffer *buffer;
    GstFlowReturn render_flow_return;
};
</STRUCT>
<STRUCT>
<NAME>GstAVSampleVideoSinkClass</NAME>
struct _GstAVSampleVideoSinkClass
{
    GstVideoSinkClass video_sink_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_av_sample_video_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VTDEC</NAME>
#define GST_TYPE_VTDEC   (gst_vtdec_get_type())
</MACRO>
<MACRO>
<NAME>GST_VTDEC</NAME>
#define GST_VTDEC(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VTDEC,GstVtdec))
</MACRO>
<MACRO>
<NAME>GST_VTDEC_CLASS</NAME>
#define GST_VTDEC_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VTDEC,GstVtdecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VTDEC</NAME>
#define GST_IS_VTDEC(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VTDEC))
</MACRO>
<MACRO>
<NAME>GST_IS_VTDEC_CLASS</NAME>
#define GST_IS_VTDEC_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VTDEC))
</MACRO>
<STRUCT>
<NAME>GstVtdec</NAME>
struct _GstVtdec
{
  GstVideoDecoder base_vtdec;
  GstVideoCodecState *input_state;
  GstVideoInfo video_info;
  CMFormatDescriptionRef format_description;
  VTDecompressionSessionRef session;
  GAsyncQueue *reorder_queue;
  gint reorder_queue_length;
  GstVideoTextureCache *texture_cache;
  GstGLContextHelper *ctxh;

  gboolean require_hardware;
};
</STRUCT>
<STRUCT>
<NAME>GstVtdecClass</NAME>
struct _GstVtdecClass
{
  GstVideoDecoderClass base_vtdec_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vtdec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vtdec_register_elements</NAME>
<RETURNS>void  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_win32_get_monitor_rect</NAME>
<RETURNS>RECT  </RETURNS>
UINT index
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GDISCREENCAPSRC</NAME>
#define GST_TYPE_GDISCREENCAPSRC  (gst_gdiscreencapsrc_get_type())
</MACRO>
<MACRO>
<NAME>GST_GDISCREENCAPSRC</NAME>
#define GST_GDISCREENCAPSRC(obj)                                          \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj),                                     \
  GST_TYPE_GDISCREENCAPSRC,GstGDIScreenCapSrc))
</MACRO>
<MACRO>
<NAME>GST_GDISCREENCAPSRC_CLASS</NAME>
#define GST_GDISCREENCAPSRC_CLASS(klass)                                  \
  (G_TYPE_CHECK_CLASS_CAST ((klass),                                      \
  GST_TYPE_GDISCREENCAPSRC,GstGDIScreenCapSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GDISCREENCAPSRC</NAME>
#define GST_IS_GDISCREENCAPSRC(obj)                                       \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj),GST_TYPE_GDISCREENCAPSRC))
</MACRO>
<MACRO>
<NAME>GST_IS_GDISCREENCAPSRC_CLASS</NAME>
#define GST_IS_GDISCREENCAPSRC_CLASS(klass)                               \
  (G_TYPE_CHECK_CLASS_TYPE ((klass),GST_TYPE_GDISCREENCAPSRC))
</MACRO>
<STRUCT>
<NAME>GstGDIScreenCapSrc</NAME>
struct _GstGDIScreenCapSrc
{
  /* Parent */
  GstPushSrc src;

  /* Properties */
  gint capture_x;
  gint capture_y;
  gint capture_w;
  gint capture_h;
  gint monitor;
  gboolean show_cursor;

  /* Source pad frame rate */
  gint rate_numerator;
  gint rate_denominator;

  /* Runtime variables */
  RECT screen_rect;
  RECT src_rect;
  guint64 frame_number;
  GstClockID clock_id;

  BITMAPINFO info;
  BYTE *dibMem;
  HBITMAP hBitmap;
  HDC memDC;
};
</STRUCT>
<STRUCT>
<NAME>GstGDIScreenCapSrcClass</NAME>
struct _GstGDIScreenCapSrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gdiscreencapsrc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DX9SCREENCAPSRC</NAME>
#define GST_TYPE_DX9SCREENCAPSRC  (gst_dx9screencapsrc_get_type())
</MACRO>
<MACRO>
<NAME>GST_DX9SCREENCAPSRC</NAME>
#define GST_DX9SCREENCAPSRC(obj)                                      \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),                                  \
  GST_TYPE_DX9SCREENCAPSRC,GstDX9ScreenCapSrc))
</MACRO>
<MACRO>
<NAME>GST_DX9SCREENCAPSRC_CLASS</NAME>
#define GST_DX9SCREENCAPSRC_CLASS(klass)                              \
  (G_TYPE_CHECK_CLASS_CAST((klass),                                   \
  GST_TYPE_DX9SCREENCAPSRC,GstDX9ScreenCapSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DX9SCREENCAPSRC</NAME>
#define GST_IS_DX9SCREENCAPSRC(obj)                                   \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DX9SCREENCAPSRC))
</MACRO>
<MACRO>
<NAME>GST_IS_DX9SCREENCAPSRC_CLASS</NAME>
#define GST_IS_DX9SCREENCAPSRC_CLASS(klass)                           \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DX9SCREENCAPSRC))
</MACRO>
<STRUCT>
<NAME>GstDX9ScreenCapSrc</NAME>
struct _GstDX9ScreenCapSrc
{
  /* Parent */
  GstPushSrc src;

  /* Properties */
  gint capture_x;
  gint capture_y;
  gint capture_w;
  gint capture_h;
  guint monitor;
  gboolean show_cursor;

  /* Source pad frame rate */
  gint rate_numerator;
  gint rate_denominator;

  /* Runtime variables */
  RECT screen_rect;
  RECT src_rect;
  guint64 frame_number;
  GstClockID clock_id;

  D3DDISPLAYMODE disp_mode;
  IDirect3DSurface9 *surface;
  IDirect3DDevice9 *d3d9_device;
  MONITORINFO monitor_info;
};
</STRUCT>
<STRUCT>
<NAME>GstDX9ScreenCapSrcClass</NAME>
struct _GstDX9ScreenCapSrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dx9screencapsrc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AVDTP_SINK</NAME>
#define GST_TYPE_AVDTP_SINK \
	(gst_avdtp_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_AVDTP_SINK</NAME>
#define GST_AVDTP_SINK(obj) \
	(G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AVDTP_SINK,\
		GstAvdtpSink))
</MACRO>
<MACRO>
<NAME>GST_AVDTP_SINK_CLASS</NAME>
#define GST_AVDTP_SINK_CLASS(klass) \
	(G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AVDTP_SINK,\
		GstAvdtpSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AVDTP_SINK</NAME>
#define GST_IS_AVDTP_SINK(obj) \
	(G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AVDTP_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_AVDTP_SINK_CLASS</NAME>
#define GST_IS_AVDTP_SINK_CLASS(obj) \
	(G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AVDTP_SINK))
</MACRO>
<STRUCT>
<NAME>GstAvdtpSink</NAME>
struct _GstAvdtpSink
{
  GstBaseSink sink;

  GstAvdtpConnection conn;

  gboolean autoconnect;

  /* mp3 stream data (outside caps data) */
  gint mp3_using_crc;
  gint channel_mode;

  /* stream connection data */
  GstCaps *stream_caps;

  GstCaps *dev_caps;

  GMutex sink_lock;

  guint watch_id;
};
</STRUCT>
<STRUCT>
<NAME>GstAvdtpSinkClass</NAME>
struct _GstAvdtpSinkClass
{
  GstBaseSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_avdtp_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_sink_get_device_caps</NAME>
<RETURNS>GstCaps  *</RETURNS>
GstAvdtpSink * sink
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_sink_get_link_mtu</NAME>
<RETURNS>guint  </RETURNS>
GstAvdtpSink * sink
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_sink_set_device</NAME>
<RETURNS>void  </RETURNS>
GstAvdtpSink * sink, const gchar * device
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_sink_set_transport</NAME>
<RETURNS>void  </RETURNS>
GstAvdtpSink * sink, const gchar * transport
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_sink_get_device</NAME>
<RETURNS>gchar  *</RETURNS>
GstAvdtpSink * sink
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_sink_get_transport</NAME>
<RETURNS>gchar  *</RETURNS>
GstAvdtpSink * sink
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_sink_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_sink_set_crc</NAME>
<RETURNS>void  </RETURNS>
GstAvdtpSink * self, gboolean crc
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_sink_set_channel_mode</NAME>
<RETURNS>void  </RETURNS>
GstAvdtpSink * self, const gchar * mode
</FUNCTION>
<MACRO>
<NAME>DEFAULT_CODEC_BUFFER_SIZE</NAME>
#define DEFAULT_CODEC_BUFFER_SIZE 2048
</MACRO>
<MACRO>
<NAME>TEMPLATE_MAX_BITPOOL_STR</NAME>
#define TEMPLATE_MAX_BITPOOL_STR "64"
</MACRO>
<STRUCT>
<NAME>bluetooth_data</NAME>
struct bluetooth_data
{
  guint link_mtu;

  BluezMediaTransport1 *conn;
  guint8 codec;                 /* Bluetooth transport configuration */
  gchar *uuid;
  guint8 *config;
  gint config_size;
  gboolean is_acquired;

  gchar buffer[DEFAULT_CODEC_BUFFER_SIZE];      /* Codec transfer buffer */
};
</STRUCT>
<STRUCT>
<NAME>GstAvdtpConnection</NAME>
struct _GstAvdtpConnection
{
  gchar *device;
  gchar *transport;
  GIOChannel *stream;

  struct bluetooth_data data;
};
</STRUCT>
<FUNCTION>
<NAME>gst_avdtp_connection_acquire</NAME>
<RETURNS>gboolean  </RETURNS>
GstAvdtpConnection * conn, gboolean use_try
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_connection_release</NAME>
<RETURNS>void  </RETURNS>
GstAvdtpConnection * conn
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_connection_reset</NAME>
<RETURNS>void  </RETURNS>
GstAvdtpConnection * conn
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_connection_get_properties</NAME>
<RETURNS>gboolean  </RETURNS>
GstAvdtpConnection * conn
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_connection_get_caps</NAME>
<RETURNS>GstCaps  *</RETURNS>
GstAvdtpConnection * conn
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_connection_set_device</NAME>
<RETURNS>void  </RETURNS>
GstAvdtpConnection * conn, const char *device
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_connection_set_transport</NAME>
<RETURNS>void  </RETURNS>
GstAvdtpConnection * conn, const char *transport
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_connection_conf_recv_stream_fd</NAME>
<RETURNS>gboolean  </RETURNS>
GstAvdtpConnection * conn
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AVDTP_SRC</NAME>
#define GST_TYPE_AVDTP_SRC \
	(gst_avdtp_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_AVDTP_SRC</NAME>
#define GST_AVDTP_SRC(obj) \
	(G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AVDTP_SRC, GstAvdtpSrc))
</MACRO>
<MACRO>
<NAME>GST_AVDTP_SRC_CLASS</NAME>
#define GST_AVDTP_SRC_CLASS(klass) \
	(G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AVDTP_SRC, GstAvdtpSrc))
</MACRO>
<MACRO>
<NAME>GST_IS_AVDTP_SRC</NAME>
#define GST_IS_AVDTP_SRC(obj) \
	(G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AVDTP_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_AVDTP_SRC_CLASS</NAME>
#define GST_IS_AVDTP_SRC_CLASS(obj) \
	(G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AVDTP_SRC))
</MACRO>
<STRUCT>
<NAME>GstAvdtpSrcClass</NAME>
struct _GstAvdtpSrcClass
{
  GstBaseSrcClass parentclass;
};
</STRUCT>
<STRUCT>
<NAME>GstAvdtpSrc</NAME>
struct _GstAvdtpSrc
{
  GstBaseSrc basesrc;

  GstAvdtpConnection conn;
  GstCaps *dev_caps;

  GstAvrcpConnection *avrcp;

  GstPoll *poll;
  GstPollFD pfd;
  volatile gint unlocked;

  GstClockTime duration;
};
</STRUCT>
<FUNCTION>
<NAME>gst_avdtp_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_avdtp_src_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_A2DP_SINK</NAME>
#define GST_TYPE_A2DP_SINK \
	(gst_a2dp_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_A2DP_SINK</NAME>
#define GST_A2DP_SINK(obj) \
	(G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_A2DP_SINK,GstA2dpSink))
</MACRO>
<MACRO>
<NAME>GST_A2DP_SINK_CLASS</NAME>
#define GST_A2DP_SINK_CLASS(klass) \
	(G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_A2DP_SINK,GstA2dpSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_A2DP_SINK</NAME>
#define GST_IS_A2DP_SINK(obj) \
	(G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_A2DP_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_A2DP_SINK_CLASS</NAME>
#define GST_IS_A2DP_SINK_CLASS(obj) \
	(G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_A2DP_SINK))
</MACRO>
<STRUCT>
<NAME>GstA2dpSink</NAME>
struct _GstA2dpSink
{
  GstBin bin;

  GstElement *rtp;
  GstAvdtpSink *sink;

  gchar *device;
  gchar *transport;
  gboolean autoconnect;

  GstPad *ghostpad;

  /* Store the tags received before the a2dpsender sink is created
   * when it is created we forward this to it */
  GstTagList *taglist;
};
</STRUCT>
<STRUCT>
<NAME>GstA2dpSinkClass</NAME>
struct _GstA2dpSinkClass
{
  GstBinClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_a2dp_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_a2dp_sink_plugin_init</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_a2dp_sink_get_device_caps</NAME>
<RETURNS>GstCaps  *</RETURNS>
GstA2dpSink * self
</FUNCTION>
<USER_FUNCTION>
<NAME>GstAvrcpMetadataCb</NAME>
<RETURNS>void </RETURNS>
GstAvrcpConnection *, GstTagList *,
    gpointer
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_avrcp_connection_new</NAME>
<RETURNS>GstAvrcpConnection  *</RETURNS>
const gchar * dev_path, GstAvrcpMetadataCb cb, gpointer user_data, GDestroyNotify user_data_free_cb
</FUNCTION>
<FUNCTION>
<NAME>gst_avrcp_connection_free</NAME>
<RETURNS>void  </RETURNS>
GstAvrcpConnection * avrcp
</FUNCTION>
<STRUCT>
<NAME>GstAvrcpConnection</NAME>
</STRUCT>
<MACRO>
<NAME>A2DP_CODEC_SBC</NAME>
#define A2DP_CODEC_SBC			0x00
</MACRO>
<MACRO>
<NAME>A2DP_CODEC_MPEG12</NAME>
#define A2DP_CODEC_MPEG12		0x01
</MACRO>
<MACRO>
<NAME>A2DP_CODEC_MPEG24</NAME>
#define A2DP_CODEC_MPEG24		0x02
</MACRO>
<MACRO>
<NAME>A2DP_CODEC_ATRAC</NAME>
#define A2DP_CODEC_ATRAC		0x03
</MACRO>
<MACRO>
<NAME>A2DP_CODEC_VENDOR</NAME>
#define A2DP_CODEC_VENDOR		0xFF
</MACRO>
<MACRO>
<NAME>SBC_SAMPLING_FREQ_16000</NAME>
#define SBC_SAMPLING_FREQ_16000		(1 << 3)
</MACRO>
<MACRO>
<NAME>SBC_SAMPLING_FREQ_32000</NAME>
#define SBC_SAMPLING_FREQ_32000		(1 << 2)
</MACRO>
<MACRO>
<NAME>SBC_SAMPLING_FREQ_44100</NAME>
#define SBC_SAMPLING_FREQ_44100		(1 << 1)
</MACRO>
<MACRO>
<NAME>SBC_SAMPLING_FREQ_48000</NAME>
#define SBC_SAMPLING_FREQ_48000		1
</MACRO>
<MACRO>
<NAME>SBC_CHANNEL_MODE_MONO</NAME>
#define SBC_CHANNEL_MODE_MONO		(1 << 3)
</MACRO>
<MACRO>
<NAME>SBC_CHANNEL_MODE_DUAL_CHANNEL</NAME>
#define SBC_CHANNEL_MODE_DUAL_CHANNEL	(1 << 2)
</MACRO>
<MACRO>
<NAME>SBC_CHANNEL_MODE_STEREO</NAME>
#define SBC_CHANNEL_MODE_STEREO		(1 << 1)
</MACRO>
<MACRO>
<NAME>SBC_CHANNEL_MODE_JOINT_STEREO</NAME>
#define SBC_CHANNEL_MODE_JOINT_STEREO	1
</MACRO>
<MACRO>
<NAME>SBC_BLOCK_LENGTH_4</NAME>
#define SBC_BLOCK_LENGTH_4		(1 << 3)
</MACRO>
<MACRO>
<NAME>SBC_BLOCK_LENGTH_8</NAME>
#define SBC_BLOCK_LENGTH_8		(1 << 2)
</MACRO>
<MACRO>
<NAME>SBC_BLOCK_LENGTH_12</NAME>
#define SBC_BLOCK_LENGTH_12		(1 << 1)
</MACRO>
<MACRO>
<NAME>SBC_BLOCK_LENGTH_16</NAME>
#define SBC_BLOCK_LENGTH_16		1
</MACRO>
<MACRO>
<NAME>SBC_SUBBANDS_4</NAME>
#define SBC_SUBBANDS_4			(1 << 1)
</MACRO>
<MACRO>
<NAME>SBC_SUBBANDS_8</NAME>
#define SBC_SUBBANDS_8			1
</MACRO>
<MACRO>
<NAME>SBC_ALLOCATION_SNR</NAME>
#define SBC_ALLOCATION_SNR		(1 << 1)
</MACRO>
<MACRO>
<NAME>SBC_ALLOCATION_LOUDNESS</NAME>
#define SBC_ALLOCATION_LOUDNESS		1
</MACRO>
<MACRO>
<NAME>MAX_BITPOOL</NAME>
#define MAX_BITPOOL 64
</MACRO>
<MACRO>
<NAME>MIN_BITPOOL</NAME>
#define MIN_BITPOOL 2
</MACRO>
<MACRO>
<NAME>MPEG_CHANNEL_MODE_MONO</NAME>
#define MPEG_CHANNEL_MODE_MONO		(1 << 3)
</MACRO>
<MACRO>
<NAME>MPEG_CHANNEL_MODE_DUAL_CHANNEL</NAME>
#define MPEG_CHANNEL_MODE_DUAL_CHANNEL	(1 << 2)
</MACRO>
<MACRO>
<NAME>MPEG_CHANNEL_MODE_STEREO</NAME>
#define MPEG_CHANNEL_MODE_STEREO	(1 << 1)
</MACRO>
<MACRO>
<NAME>MPEG_CHANNEL_MODE_JOINT_STEREO</NAME>
#define MPEG_CHANNEL_MODE_JOINT_STEREO	1
</MACRO>
<MACRO>
<NAME>MPEG_LAYER_MP1</NAME>
#define MPEG_LAYER_MP1			(1 << 2)
</MACRO>
<MACRO>
<NAME>MPEG_LAYER_MP2</NAME>
#define MPEG_LAYER_MP2			(1 << 1)
</MACRO>
<MACRO>
<NAME>MPEG_LAYER_MP3</NAME>
#define MPEG_LAYER_MP3			1
</MACRO>
<MACRO>
<NAME>MPEG_SAMPLING_FREQ_16000</NAME>
#define MPEG_SAMPLING_FREQ_16000	(1 << 5)
</MACRO>
<MACRO>
<NAME>MPEG_SAMPLING_FREQ_22050</NAME>
#define MPEG_SAMPLING_FREQ_22050	(1 << 4)
</MACRO>
<MACRO>
<NAME>MPEG_SAMPLING_FREQ_24000</NAME>
#define MPEG_SAMPLING_FREQ_24000	(1 << 3)
</MACRO>
<MACRO>
<NAME>MPEG_SAMPLING_FREQ_32000</NAME>
#define MPEG_SAMPLING_FREQ_32000	(1 << 2)
</MACRO>
<MACRO>
<NAME>MPEG_SAMPLING_FREQ_44100</NAME>
#define MPEG_SAMPLING_FREQ_44100	(1 << 1)
</MACRO>
<MACRO>
<NAME>MPEG_SAMPLING_FREQ_48000</NAME>
#define MPEG_SAMPLING_FREQ_48000	1
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_VBR</NAME>
#define MPEG_BIT_RATE_VBR		0x8000
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_320000</NAME>
#define MPEG_BIT_RATE_320000		0x4000
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_256000</NAME>
#define MPEG_BIT_RATE_256000		0x2000
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_224000</NAME>
#define MPEG_BIT_RATE_224000		0x1000
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_192000</NAME>
#define MPEG_BIT_RATE_192000		0x0800
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_160000</NAME>
#define MPEG_BIT_RATE_160000		0x0400
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_128000</NAME>
#define MPEG_BIT_RATE_128000		0x0200
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_112000</NAME>
#define MPEG_BIT_RATE_112000		0x0100
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_96000</NAME>
#define MPEG_BIT_RATE_96000		0x0080
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_80000</NAME>
#define MPEG_BIT_RATE_80000		0x0040
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_64000</NAME>
#define MPEG_BIT_RATE_64000		0x0020
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_56000</NAME>
#define MPEG_BIT_RATE_56000		0x0010
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_48000</NAME>
#define MPEG_BIT_RATE_48000		0x0008
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_40000</NAME>
#define MPEG_BIT_RATE_40000		0x0004
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_32000</NAME>
#define MPEG_BIT_RATE_32000		0x0002
</MACRO>
<MACRO>
<NAME>MPEG_BIT_RATE_FREE</NAME>
#define MPEG_BIT_RATE_FREE		0x0001
</MACRO>
<MACRO>
<NAME>AAC_OBJECT_TYPE_MPEG2_AAC_LC</NAME>
#define AAC_OBJECT_TYPE_MPEG2_AAC_LC		0x80
</MACRO>
<MACRO>
<NAME>AAC_OBJECT_TYPE_MPEG4_AAC_LC</NAME>
#define AAC_OBJECT_TYPE_MPEG4_AAC_LC		0x40
</MACRO>
<MACRO>
<NAME>AAC_OBJECT_TYPE_MPEG4_AAC_LTP</NAME>
#define AAC_OBJECT_TYPE_MPEG4_AAC_LTP		0x20
</MACRO>
<MACRO>
<NAME>AAC_OBJECT_TYPE_MPEG4_AAC_SCALABLE</NAME>
#define AAC_OBJECT_TYPE_MPEG4_AAC_SCALABLE	0x10
</MACRO>
<MACRO>
<NAME>AAC_SAMPLING_FREQ_8000</NAME>
#define AAC_SAMPLING_FREQ_8000		0x0800
</MACRO>
<MACRO>
<NAME>AAC_SAMPLING_FREQ_11025</NAME>
#define AAC_SAMPLING_FREQ_11025		0x0400
</MACRO>
<MACRO>
<NAME>AAC_SAMPLING_FREQ_12000</NAME>
#define AAC_SAMPLING_FREQ_12000		0x0200
</MACRO>
<MACRO>
<NAME>AAC_SAMPLING_FREQ_16000</NAME>
#define AAC_SAMPLING_FREQ_16000		0x0100
</MACRO>
<MACRO>
<NAME>AAC_SAMPLING_FREQ_22050</NAME>
#define AAC_SAMPLING_FREQ_22050		0x0080
</MACRO>
<MACRO>
<NAME>AAC_SAMPLING_FREQ_24000</NAME>
#define AAC_SAMPLING_FREQ_24000		0x0040
</MACRO>
<MACRO>
<NAME>AAC_SAMPLING_FREQ_32000</NAME>
#define AAC_SAMPLING_FREQ_32000		0x0020
</MACRO>
<MACRO>
<NAME>AAC_SAMPLING_FREQ_44100</NAME>
#define AAC_SAMPLING_FREQ_44100		0x0010
</MACRO>
<MACRO>
<NAME>AAC_SAMPLING_FREQ_48000</NAME>
#define AAC_SAMPLING_FREQ_48000		0x0008
</MACRO>
<MACRO>
<NAME>AAC_SAMPLING_FREQ_64000</NAME>
#define AAC_SAMPLING_FREQ_64000		0x0004
</MACRO>
<MACRO>
<NAME>AAC_SAMPLING_FREQ_88200</NAME>
#define AAC_SAMPLING_FREQ_88200		0x0002
</MACRO>
<MACRO>
<NAME>AAC_SAMPLING_FREQ_96000</NAME>
#define AAC_SAMPLING_FREQ_96000		0x0001
</MACRO>
<MACRO>
<NAME>AAC_CHANNELS_1</NAME>
#define AAC_CHANNELS_1		0x02
</MACRO>
<MACRO>
<NAME>AAC_CHANNELS_2</NAME>
#define AAC_CHANNELS_2		0x01
</MACRO>
<STRUCT>
<NAME>AudioCodecEntry</NAME>
typedef struct {
  gchar *element_name;      /* The gst element factory name */
  gchar *element_longname;  /* Description string for element */
  gint32 format;            /* WAVEFORMATEX format */
  gchar *sinkcaps;          /* GStreamer caps of input format */
  PreferredFilter *preferred_filters; /* NULL-terminated list of preferred filters */
} AudioCodecEntry;
</STRUCT>
<MACRO>
<NAME>GST_TYPE_DSHOWAUDIODEC</NAME>
#define GST_TYPE_DSHOWAUDIODEC               (gst_dshowaudiodec_get_type())
</MACRO>
<MACRO>
<NAME>GST_DSHOWAUDIODEC</NAME>
#define GST_DSHOWAUDIODEC(obj)              (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DSHOWAUDIODEC,GstDshowAudioDec))
</MACRO>
<MACRO>
<NAME>GST_DSHOWAUDIODEC_CLASS</NAME>
#define GST_DSHOWAUDIODEC_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DSHOWAUDIODEC,GstDshowAudioDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DSHOWAUDIODEC</NAME>
#define GST_IS_DSHOWAUDIODEC(obj)           (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DSHOWAUDIODEC))
</MACRO>
<MACRO>
<NAME>GST_IS_DSHOWAUDIODEC_CLASS</NAME>
#define GST_IS_DSHOWAUDIODEC_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DSHOWAUDIODEC))
</MACRO>
<STRUCT>
<NAME>GstDshowAudioDec</NAME>
struct _GstDshowAudioDec
{
  GstElement element;

  /* element pads */
  GstPad *sinkpad;
  GstPad *srcpad;
  
  GstFlowReturn last_ret;

  /* filters interfaces*/
  FakeSrc *fakesrc;
  AudioFakeSink *fakesink;

  IBaseFilterPtr decfilter;
  
  /* graph manager interfaces */  
  IMediaFilterPtr mediafilter;
  IFilterGraphPtr filtergraph;

  /* true when dshow graph is setup */
  gboolean setup;

  /* audio settings */
  gint bitrate;
  gint block_align;
  gint depth;
  gint channels;
  gint rate;
  gint layer;
  GstBuffer *codec_data;
  
  /* current segment */
  GstSegment * segment;

  /* timestamp of the next buffer */
  GstClockTime timestamp;

  gboolean comInitialized;
  GMutex   com_init_lock;
  GMutex   com_deinit_lock;
  GCond    com_initialized;
  GCond    com_uninitialize;
  GCond    com_uninitialized;
};
</STRUCT>
<STRUCT>
<NAME>GstDshowAudioDecClass</NAME>
struct _GstDshowAudioDecClass
{
  GstElementClass parent_class;
  const AudioCodecEntry *entry;
};
</STRUCT>
<FUNCTION>
<NAME>dshow_adec_register</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<VARIABLE>
<NAME>CLSID_AudioFakeSink</NAME>
const GUID CLSID_AudioFakeSink = 
</VARIABLE>
<FUNCTION>
<NAME>DoRenderSample</NAME>
<RETURNS>HRESULT  </RETURNS>
IMediaSample *pMediaSample
</FUNCTION>
<FUNCTION>
<NAME>CheckMediaType</NAME>
<RETURNS>HRESULT  </RETURNS>
const CMediaType *pmt
</FUNCTION>
<FUNCTION>
<NAME>SetMediaType</NAME>
<RETURNS>HRESULT  </RETURNS>
AM_MEDIA_TYPE *pmt) { m_MediaType.Set (*pmt
</FUNCTION>
<FUNCTION>
<NAME>GetBufferSize</NAME>
<RETURNS>int  </RETURNS>

</FUNCTION>
<STRUCT>
<NAME>VideoCodecEntry</NAME>
typedef struct {
  gchar *element_name;      /* The gst element factory name */
  gchar *element_longname;  /* Description string for element */
  gint32 format;            /* ??? */
  GUID input_majortype;
  GUID input_subtype;
  gchar *sinkcaps;          /* GStreamer caps of input format */
  GUID output_majortype;
  GUID output_subtype;
  gchar *srccaps;
  PreferredFilter *preferred_filters;
} VideoCodecEntry;
</STRUCT>
<MACRO>
<NAME>GST_TYPE_DSHOWVIDEODEC</NAME>
#define GST_TYPE_DSHOWVIDEODEC               (gst_dshowvideodec_get_type())
</MACRO>
<MACRO>
<NAME>GST_DSHOWVIDEODEC</NAME>
#define GST_DSHOWVIDEODEC(obj)              (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DSHOWVIDEODEC,GstDshowVideoDec))
</MACRO>
<MACRO>
<NAME>GST_DSHOWVIDEODEC_CLASS</NAME>
#define GST_DSHOWVIDEODEC_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DSHOWVIDEODEC,GstDshowVideoDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DSHOWVIDEODEC</NAME>
#define GST_IS_DSHOWVIDEODEC(obj)           (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DSHOWVIDEODEC))
</MACRO>
<MACRO>
<NAME>GST_IS_DSHOWVIDEODEC_CLASS</NAME>
#define GST_IS_DSHOWVIDEODEC_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DSHOWVIDEODEC))
</MACRO>
<STRUCT>
<NAME>GstDshowVideoDec</NAME>
struct _GstDshowVideoDec
{
  GstElement element;

  /* element pads */
  GstPad *sinkpad;
  GstPad *srcpad;

  /* caps of our src pad */
  GstCaps *srccaps;
  
  GstFlowReturn last_ret;

  /* list of dshow mediatypes coresponding to the caps list */
  GList *mediatypes;

  /* filters interfaces */
  FakeSrc *fakesrc;
  VideoFakeSink *fakesink;

  IBaseFilter *decfilter;

  /* graph manager interfaces */
  IMediaFilter *mediafilter;
  IFilterGraph *filtergraph;

  /* settings */
  gint width, height;
  gint fps_n, fps_d;
  gint par_n, par_d;

  /* current segment */
  GstSegment *segment;

  gboolean setup;

  gboolean comInitialized;
  GMutex   com_init_lock;
  GMutex   com_deinit_lock;
  GCond    com_initialized;
  GCond    com_uninitialize;
  GCond    com_uninitialized;

  GstBufferPool *buffer_pool;
};
</STRUCT>
<STRUCT>
<NAME>GstDshowVideoDecClass</NAME>
struct _GstDshowVideoDecClass
{
  GstElementClass parent_class;
  const VideoCodecEntry *entry;
};
</STRUCT>
<FUNCTION>
<NAME>dshow_vdec_register</NAME>
<RETURNS>gboolean  </RETURNS>
GstPlugin * plugin
</FUNCTION>
<VARIABLE>
<NAME>CLSID_VideoFakeSink</NAME>
const GUID CLSID_VideoFakeSink = 
</VARIABLE>
<FUNCTION>
<NAME>DoRenderSample</NAME>
<RETURNS>HRESULT  </RETURNS>
IMediaSample *pMediaSample
</FUNCTION>
<FUNCTION>
<NAME>CheckMediaType</NAME>
<RETURNS>HRESULT  </RETURNS>
const CMediaType *pmt
</FUNCTION>
<FUNCTION>
<NAME>SetMediaType</NAME>
<RETURNS>HRESULT  </RETURNS>
AM_MEDIA_TYPE *pmt) { m_MediaType.Set (*pmt
</FUNCTION>
<STRUCT>
<NAME>PreferredFilter</NAME>
typedef struct {
  const GUID *filter_guid;  /* The filter GUID, or DMO GUID */
  const GUID *dmo_category; /* If non-NULL, the filter is a DMO of this
                               category */
} PreferredFilter;
</STRUCT>
<FUNCTION>
<NAME>gst_dshow_get_pin_from_filter</NAME>
<RETURNS>IPin  *</RETURNS>
IBaseFilter *filter, PIN_DIRECTION pindir
</FUNCTION>
<FUNCTION>
<NAME>gst_dshow_find_filter</NAME>
<RETURNS>IBaseFilter  *</RETURNS>
CLSID input_majortype, CLSID input_subtype, CLSID output_majortype, CLSID output_subtype, PreferredFilter *preferred_filters
</FUNCTION>
<MACRO>
<NAME>DSHOW_CODEC_QDATA</NAME>
#define DSHOW_CODEC_QDATA g_quark_from_string ("dshow-codec")
</MACRO>
<FUNCTION>
<NAME>GetMediaType</NAME>
<RETURNS>HRESULT  </RETURNS>
int iPosition, CMediaType *pMediaType
</FUNCTION>
<FUNCTION>
<NAME>GetOutputPin</NAME>
<RETURNS>FakeOutputPin  *</RETURNS>

</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TINYALSA_SINK</NAME>
#define GST_TYPE_TINYALSA_SINK \
  (gst_tinyalsa_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_TINYALSA_SINK</NAME>
#define GST_TINYALSA_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TINYALSA_SINK,GstTinyalsaSink))
</MACRO>
<MACRO>
<NAME>GST_TINYALSA_SINK_CLASS</NAME>
#define GST_TINYALSA_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TINYALSA_SINK,GstTinyalsaSinkClass))
</MACRO>
<STRUCT>
<NAME>GstTinyalsaSink</NAME>
struct _GstTinyalsaSink {
  GstAudioSink parent;

  int card;
  int device;

  struct pcm *pcm;

  GstCaps *cached_caps; /* for queries made while the device is open */
};
</STRUCT>
<STRUCT>
<NAME>GstTinyalsaSinkClass</NAME>
struct _GstTinyalsaSinkClass {
  GstAudioSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_tinyalsa_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_UVC_H264_SRC</NAME>
#define GST_TYPE_UVC_H264_SRC                   \
  (gst_uvc_h264_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_UVC_H264_SRC</NAME>
#define GST_UVC_H264_SRC(obj)                                           \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_UVC_H264_SRC, GstUvcH264Src))
</MACRO>
<MACRO>
<NAME>GST_UVC_H264_SRC_CLASS</NAME>
#define GST_UVC_H264_SRC_CLASS(klass)                                   \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_UVC_H264_SRC, GstUvcH264SrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_UVC_H264_SRC</NAME>
#define GST_IS_UVC_H264_SRC(obj)                                \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_UVC_H264_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_UVC_H264_SRC_CLASS</NAME>
#define GST_IS_UVC_H264_SRC_CLASS(klass)                        \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_UVC_H264_SRC))
</MACRO>
<FUNCTION>
<NAME>gst_uvc_h264_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstVideoRecordingStatus</NAME>
enum GstVideoRecordingStatus {
  GST_VIDEO_RECORDING_STATUS_DONE,
  GST_VIDEO_RECORDING_STATUS_STARTING,
  GST_VIDEO_RECORDING_STATUS_RUNNING,
  GST_VIDEO_RECORDING_STATUS_FINISHING
};
</ENUM>
<ENUM>
<NAME>GstUvcH264SrcFormat</NAME>
typedef enum {
  UVC_H264_SRC_FORMAT_NONE,
  UVC_H264_SRC_FORMAT_JPG,
  UVC_H264_SRC_FORMAT_H264,
  UVC_H264_SRC_FORMAT_RAW
} GstUvcH264SrcFormat;
</ENUM>
<STRUCT>
<NAME>GstUvcH264Src</NAME>
struct _GstUvcH264Src
{
  GstBaseCameraSrc parent;

  GstPad *vfsrc;
  GstPad *imgsrc;
  GstPad *vidsrc;

  /* source elements */
  GstElement *v4l2_src;
  GstElement *mjpg_demux;
  GstElement *jpeg_dec;
  GstElement *vid_colorspace;
  GstElement *vf_colorspace;

  GstUvcH264SrcFormat main_format;
  guint16 main_width;
  guint16 main_height;
  guint32 main_frame_interval;
  UvcH264StreamFormat main_stream_format;
  guint16 main_profile;
  GstUvcH264SrcFormat secondary_format;
  guint16 secondary_width;
  guint16 secondary_height;
  guint32 secondary_frame_interval;

  int v4l2_fd;
  guint8 h264_unit_id;
  libusb_context *usb_ctx;

  GstPadEventFunction srcpad_event_func;
  GstEvent *key_unit_event;
  GstSegment segment;

  gboolean started;

  /* When restarting the source */
  gboolean reconfiguring;
  gboolean vid_newseg;
  gboolean vf_newseg;

  gchar *colorspace_name;
  gchar *jpeg_decoder_name;
  int num_clock_samples;

  /* v4l2src proxied properties */
  guint32 num_buffers;
  gchar *device;

  /* Static controls */
  guint32 initial_bitrate;
  guint16 slice_units;
  UvcH264SliceMode slice_mode;
  guint16 iframe_period;
  UvcH264UsageType usage_type;
  UvcH264Entropy entropy;
  gboolean enable_sei;
  guint8 num_reorder_frames;
  gboolean preview_flipped;
  guint16 leaky_bucket_size;

  /* Dynamic controls */
  UvcH264RateControl rate_control;
  gboolean fixed_framerate;
  guint8 level_idc;
  guint32 peak_bitrate;
  guint32 average_bitrate;
  gint8 min_qp[QP_FRAMES];
  gint8 max_qp[QP_FRAMES];
  guint8 ltr_buffer_size;
  guint8 ltr_encoder_control;
};
</STRUCT>
<STRUCT>
<NAME>GstUvcH264SrcClass</NAME>
struct _GstUvcH264SrcClass
{
  GstBaseCameraSrcClass parent;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_UVC_H264_MJPG_DEMUX</NAME>
#define GST_TYPE_UVC_H264_MJPG_DEMUX             \
  (gst_uvc_h264_mjpg_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_UVC_H264_MJPG_DEMUX</NAME>
#define GST_UVC_H264_MJPG_DEMUX(obj)             \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),            \
      GST_TYPE_UVC_H264_MJPG_DEMUX,              \
      GstUvcH264MjpgDemux))
</MACRO>
<MACRO>
<NAME>GST_UVC_H264_MJPG_DEMUX_CLASS</NAME>
#define GST_UVC_H264_MJPG_DEMUX_CLASS(klass)     \
  (G_TYPE_CHECK_CLASS_CAST((klass),             \
      GST_TYPE_UVC_H264_MJPG_DEMUX,              \
      GstUvcH264MjpgDemuxClass))
</MACRO>
<MACRO>
<NAME>GST_IS_UVC_H264_MJPG_DEMUX</NAME>
#define GST_IS_UVC_H264_MJPG_DEMUX(obj)          \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),            \
      GST_TYPE_UVC_H264_MJPG_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_UVC_H264_MJPG_DEMUX_CLASS</NAME>
#define GST_IS_UVC_H264_MJPG_DEMUX_CLASS(klass)  \
  (G_TYPE_CHECK_CLASS_TYPE((klass),             \
      GST_TYPE_UVC_H264_MJPG_DEMUX))
</MACRO>
<STRUCT>
<NAME>GstUvcH264MjpgDemux</NAME>
struct _GstUvcH264MjpgDemux {
  GstElement element;
  GstUvcH264MjpgDemuxPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstUvcH264MjpgDemuxClass</NAME>
struct _GstUvcH264MjpgDemuxClass {
  GstElementClass  parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_uvc_h264_mjpg_demux_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstUvcH264MjpgDemuxPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>UVC_H264_BMHINTS_RESOLUTION</NAME>
#define UVC_H264_BMHINTS_RESOLUTION        (0x0001)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_PROFILE</NAME>
#define UVC_H264_BMHINTS_PROFILE           (0x0002)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_RATECONTROL</NAME>
#define UVC_H264_BMHINTS_RATECONTROL       (0x0004)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_USAGE</NAME>
#define UVC_H264_BMHINTS_USAGE             (0x0008)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_SLICEMODE</NAME>
#define UVC_H264_BMHINTS_SLICEMODE         (0x0010)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_SLICEUNITS</NAME>
#define UVC_H264_BMHINTS_SLICEUNITS        (0x0020)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_MVCVIEW</NAME>
#define UVC_H264_BMHINTS_MVCVIEW           (0x0040)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_TEMPORAL</NAME>
#define UVC_H264_BMHINTS_TEMPORAL          (0x0080)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_SNR</NAME>
#define UVC_H264_BMHINTS_SNR               (0x0100)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_SPATIAL</NAME>
#define UVC_H264_BMHINTS_SPATIAL           (0x0200)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_SPATIAL_RATIO</NAME>
#define UVC_H264_BMHINTS_SPATIAL_RATIO     (0x0400)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_FRAME_INTERVAL</NAME>
#define UVC_H264_BMHINTS_FRAME_INTERVAL    (0x0800)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_LEAKY_BKT_SIZE</NAME>
#define UVC_H264_BMHINTS_LEAKY_BKT_SIZE    (0x1000)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_BITRATE</NAME>
#define UVC_H264_BMHINTS_BITRATE           (0x2000)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_ENTROPY</NAME>
#define UVC_H264_BMHINTS_ENTROPY           (0x4000)
</MACRO>
<MACRO>
<NAME>UVC_H264_BMHINTS_IFRAMEPERIOD</NAME>
#define UVC_H264_BMHINTS_IFRAMEPERIOD      (0x8000)
</MACRO>
<MACRO>
<NAME>UVC_H264_QP_STEPS_I_FRAME_TYPE</NAME>
#define UVC_H264_QP_STEPS_I_FRAME_TYPE     (0x01)
</MACRO>
<MACRO>
<NAME>UVC_H264_QP_STEPS_P_FRAME_TYPE</NAME>
#define UVC_H264_QP_STEPS_P_FRAME_TYPE     (0x02)
</MACRO>
<MACRO>
<NAME>UVC_H264_QP_STEPS_B_FRAME_TYPE</NAME>
#define UVC_H264_QP_STEPS_B_FRAME_TYPE     (0x04)
</MACRO>
<MACRO>
<NAME>UVC_H264_QP_STEPS_ALL_FRAME_TYPES</NAME>
#define UVC_H264_QP_STEPS_ALL_FRAME_TYPES  (UVC_H264_QP_STEPS_I_FRAME_TYPE | \
      UVC_H264_QP_STEPS_P_FRAME_TYPE | UVC_H264_QP_STEPS_B_FRAME_TYPE)
</MACRO>
<ENUM>
<NAME>UvcH264SliceMode</NAME>
typedef enum
{
  UVC_H264_SLICEMODE_IGNORED = 0x0000,
  UVC_H264_SLICEMODE_BITSPERSLICE = 0x0001,
  UVC_H264_SLICEMODE_MBSPERSLICE = 0x0002,
  UVC_H264_SLICEMODE_SLICEPERFRAME = 0x0003
} UvcH264SliceMode;
</ENUM>
<MACRO>
<NAME>UVC_H264_SLICEMODE_TYPE</NAME>
#define UVC_H264_SLICEMODE_TYPE (uvc_h264_slicemode_get_type())
</MACRO>
<FUNCTION>
<NAME>uvc_h264_slicemode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>UvcH264UsageType</NAME>
typedef enum {
  UVC_H264_USAGETYPE_REALTIME = 0x01,
  UVC_H264_USAGETYPE_BROADCAST = 0x02,
  UVC_H264_USAGETYPE_STORAGE = 0x03,
  UVC_H264_USAGETYPE_UCCONFIG_0 = 0x04,
  UVC_H264_USAGETYPE_UCCONFIG_1 = 0x05,
  UVC_H264_USAGETYPE_UCCONFIG_2Q = 0x06,
  UVC_H264_USAGETYPE_UCCONFIG_2S = 0x07,
  UVC_H264_USAGETYPE_UCCONFIG_3 = 0x08,
} UvcH264UsageType;
</ENUM>
<MACRO>
<NAME>UVC_H264_USAGETYPE_TYPE</NAME>
#define UVC_H264_USAGETYPE_TYPE (uvc_h264_usagetype_get_type())
</MACRO>
<FUNCTION>
<NAME>uvc_h264_usagetype_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>UvcH264RateControl</NAME>
typedef enum {
  UVC_H264_RATECONTROL_CBR = 0x01,
  UVC_H264_RATECONTROL_VBR = 0x02,
  UVC_H264_RATECONTROL_CONST_QP = 0x03,
} UvcH264RateControl;
</ENUM>
<MACRO>
<NAME>UVC_H264_RATECONTROL_FIXED_FRM_FLG</NAME>
#define UVC_H264_RATECONTROL_FIXED_FRM_FLG (0x10)
</MACRO>
<MACRO>
<NAME>UVC_H264_RATECONTROL_TYPE</NAME>
#define UVC_H264_RATECONTROL_TYPE (uvc_h264_ratecontrol_get_type())
</MACRO>
<FUNCTION>
<NAME>uvc_h264_ratecontrol_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>UvcH264StreamFormat</NAME>
typedef enum {
  UVC_H264_STREAMFORMAT_ANNEXB = 0x00,
  UVC_H264_STREAMFORMAT_NAL = 0x01,
} UvcH264StreamFormat;
</ENUM>
<MACRO>
<NAME>UVC_H264_STREAMFORMAT_TYPE</NAME>
#define UVC_H264_STREAMFORMAT_TYPE (uvc_h264_streamformat_get_type())
</MACRO>
<FUNCTION>
<NAME>uvc_h264_streamformat_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>UvcH264Entropy</NAME>
typedef enum {
  UVC_H264_ENTROPY_CAVLC = 0x00,
  UVC_H264_ENTROPY_CABAC = 0x01,
} UvcH264Entropy;
</ENUM>
<MACRO>
<NAME>UVC_H264_ENTROPY_TYPE</NAME>
#define UVC_H264_ENTROPY_TYPE (uvc_h264_entropy_get_type())
</MACRO>
<FUNCTION>
<NAME>uvc_h264_entropy_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>UVC_H264_PROFILE_CONSTRAINED_BASELINE</NAME>
#define UVC_H264_PROFILE_CONSTRAINED_BASELINE 0x4240
</MACRO>
<MACRO>
<NAME>UVC_H264_PROFILE_BASELINE</NAME>
#define UVC_H264_PROFILE_BASELINE 0x4200
</MACRO>
<MACRO>
<NAME>UVC_H264_PROFILE_MAIN</NAME>
#define UVC_H264_PROFILE_MAIN 0x4D00
</MACRO>
<MACRO>
<NAME>UVC_H264_PROFILE_HIGH</NAME>
#define UVC_H264_PROFILE_HIGH 0x6400
</MACRO>
<MACRO>
<NAME>UVC_H264_TIMESTAMP_SEI_DISABLE</NAME>
#define UVC_H264_TIMESTAMP_SEI_DISABLE     (0x00)
</MACRO>
<MACRO>
<NAME>UVC_H264_TIMESTAMP_SEI_ENABLE</NAME>
#define UVC_H264_TIMESTAMP_SEI_ENABLE      (0x01)
</MACRO>
<MACRO>
<NAME>UVC_H264_PREFLIPPED_DISABLE</NAME>
#define UVC_H264_PREFLIPPED_DISABLE        (0x00)
</MACRO>
<MACRO>
<NAME>UVC_H264_PREFLIPPED_HORIZONTAL</NAME>
#define UVC_H264_PREFLIPPED_HORIZONTAL     (0x01)
</MACRO>
<MACRO>
<NAME>UVC_H264_PICTYPE_I_FRAME</NAME>
#define UVC_H264_PICTYPE_I_FRAME              (0x00)
</MACRO>
<MACRO>
<NAME>UVC_H264_PICTYPE_IDR</NAME>
#define UVC_H264_PICTYPE_IDR                  (0x01)
</MACRO>
<MACRO>
<NAME>UVC_H264_PICTYPE_IDR_WITH_PPS_SPS</NAME>
#define UVC_H264_PICTYPE_IDR_WITH_PPS_SPS     (0x02)
</MACRO>
<MACRO>
<NAME>xLayerID</NAME>
#define xLayerID(stream_id, quality_id, dependency_id, temporal_id) \
  ((((stream_id) & 7) << 10) |                                      \
      (((quality_id) & 7) << 7) |                                   \
      (((dependency_id) & 15) << 3) |                               \
      ((temporal_id) & 7))
</MACRO>
<MACRO>
<NAME>xStream_id</NAME>
#define xStream_id(layer_id)      (((layer_id) >> 10) & 7)
</MACRO>
<MACRO>
<NAME>xQuality_id</NAME>
#define xQuality_id(layer_id)     (((layer_id) >> 7) & 7)
</MACRO>
<MACRO>
<NAME>xDependency_id</NAME>
#define xDependency_id(layer_id)  (((layer_id) >> 3) & 15)
</MACRO>
<MACRO>
<NAME>xTemporal_id</NAME>
#define xTemporal_id(layer_id)    ((layer_id)&7)
</MACRO>
<ENUM>
<NAME>uvcx_control_selector_t</NAME>
typedef enum _uvcx_control_selector_t
{
	UVCX_VIDEO_CONFIG_PROBE			= 0x01,
	UVCX_VIDEO_CONFIG_COMMIT		= 0x02,
	UVCX_RATE_CONTROL_MODE			= 0x03,
	UVCX_TEMPORAL_SCALE_MODE		= 0x04,
	UVCX_SPATIAL_SCALE_MODE			= 0x05,
	UVCX_SNR_SCALE_MODE				= 0x06,
	UVCX_LTR_BUFFER_SIZE_CONTROL	= 0x07,
	UVCX_LTR_PICTURE_CONTROL		= 0x08,
	UVCX_PICTURE_TYPE_CONTROL		= 0x09,
	UVCX_VERSION					= 0x0A,
	UVCX_ENCODER_RESET				= 0x0B,
	UVCX_FRAMERATE_CONFIG			= 0x0C,
	UVCX_VIDEO_ADVANCE_CONFIG		= 0x0D,
	UVCX_BITRATE_LAYERS				= 0x0E,
	UVCX_QP_STEPS_LAYERS			= 0x0F,
} uvcx_control_selector_t;
</ENUM>
<MACRO>
<NAME>GUID_UVCX_H264_XU</NAME>
#define GUID_UVCX_H264_XU                                               \
  {0x41, 0x76, 0x9e, 0xa2, 0x04, 0xde, 0xe3, 0x47, 0x8b, 0x2b, 0xF4, 0x34, 0x1A, 0xFF, 0x00, 0x3B}
</MACRO>
<MACRO>
<NAME>GST_TYPE_DSHOWVIDEOSINK</NAME>
#define GST_TYPE_DSHOWVIDEOSINK              (gst_dshowvideosink_get_type())
</MACRO>
<MACRO>
<NAME>GST_DSHOWVIDEOSINK</NAME>
#define GST_DSHOWVIDEOSINK(obj)              (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DSHOWVIDEOSINK,GstDshowVideoSink))
</MACRO>
<MACRO>
<NAME>GST_DSHOWVIDEOSINK_CLASS</NAME>
#define GST_DSHOWVIDEOSINK_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DSHOWVIDEOSINK,GstDshowVideoSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DSHOWVIDEOSINK</NAME>
#define GST_IS_DSHOWVIDEOSINK(obj)           (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DSHOWVIDEOSINK))
</MACRO>
<MACRO>
<NAME>GST_IS_DSHOWVIDEOSINK_CLASS</NAME>
#define GST_IS_DSHOWVIDEOSINK_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DSHOWVIDEOSINK))
</MACRO>
<MACRO>
<NAME>GST_DSHOWVIDEOSINK_GRAPH_LOCK</NAME>
#define GST_DSHOWVIDEOSINK_GRAPH_LOCK(sink)	g_mutex_lock (&GST_DSHOWVIDEOSINK (sink)->graph_lock)
</MACRO>
<MACRO>
<NAME>GST_DSHOWVIDEOSINK_GRAPH_UNLOCK</NAME>
#define GST_DSHOWVIDEOSINK_GRAPH_UNLOCK(clock) g_mutex_unlock (&GST_DSHOWVIDEOSINK (sink)->graph_lock)
</MACRO>
<STRUCT>
<NAME>GstDshowVideoSink</NAME>
struct _GstDshowVideoSink
{
  GstVideoSink sink;

  /* Preferred renderer to use: VM9 or VMR */
  char *preferredrenderer;

   /* The filter graph (DirectShow equivalent to pipeline */
  IFilterGraph *filter_graph;

  IMediaEventEx *filter_media_event;

  /* Renderer wrapper (EVR, VMR9, or VMR) and support code */
  RendererSupport *renderersupport;

  /* Our fakesrc filter */
  VideoFakeSrc *fakesrc;

  /* DirectShow description of media type (equivalent of GstCaps) */
  AM_MEDIA_TYPE mediatype;

  gboolean keep_aspect_ratio;
  gboolean full_screen;

  /* If the window is closed, we set this and error out */
  gboolean window_closed;

  /* The video window set through GstXOverlay */
  HWND window_id;
  
  /* If we created the window, it needs to be closed in ::stop() */
  gboolean is_new_window;

  gboolean connected;
  gboolean graph_running;

  /* If we create our own window, we run it from another thread */
  GThread *window_thread;
  HANDLE window_created_signal;

  /* If we use an app-supplied window, we need to hook its WNDPROC */
  WNDPROC prevWndProc;

  /* Lock for transitions */
  GMutex graph_lock;

  gboolean comInitialized;
  GMutex   com_init_lock;
  GMutex   com_deinit_lock;
  GCond    com_initialized;
  GCond    com_uninitialize;
  GCond    com_uninitialized;
};
</STRUCT>
<STRUCT>
<NAME>GstDshowVideoSinkClass</NAME>
struct _GstDshowVideoSinkClass
{
  GstVideoSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_dshowvideosink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CopyToDestinationBuffer</NAME>
<RETURNS>STDMETHODIMP  </RETURNS>
byte *src, byte *dst
</FUNCTION>
<FUNCTION>
<NAME>GetMediaType</NAME>
<RETURNS>HRESULT  </RETURNS>
int iPosition, CMediaType *pMediaType
</FUNCTION>
<FUNCTION>
<NAME>Notify</NAME>
<RETURNS>STDMETHODIMP  </RETURNS>
IBaseFilter * pSender, Quality q
</FUNCTION>
<FUNCTION>
<NAME>Disconnect</NAME>
<RETURNS>STDMETHODIMP  </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>Block</NAME>
<RETURNS>STDMETHODIMP  </RETURNS>
DWORD dwBlockFlags, HANDLE hEvent
</FUNCTION>
<FUNCTION>
<NAME>GetOutputPin</NAME>
<RETURNS>VideoFakeSrcPin  *</RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>GetPinCount</NAME>
<RETURNS>int        </RETURNS>

</FUNCTION>
<FUNCTION>
<NAME>GetPin</NAME>
<RETURNS>CBasePin  *</RETURNS>
int n
</FUNCTION>
<FUNCTION>
<NAME>Run</NAME>
<RETURNS>STDMETHODIMP  </RETURNS>
REFERENCE_TIME tStart
</FUNCTION>
<FUNCTION>
<NAME>Stop</NAME>
<RETURNS>STDMETHODIMP  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>Pause</NAME>
<RETURNS>STDMETHODIMP  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>JoinFilterGraph</NAME>
<RETURNS>STDMETHODIMP  </RETURNS>
IFilterGraph* pGraph, LPCWSTR pName
</FUNCTION>
<MACRO>
<NAME>GST_CAT_DEFAULT</NAME>
#define GST_CAT_DEFAULT gst_nvenc_debug
</MACRO>
<FUNCTION>
<NAME>gst_nvenc_create_cuda_context</NAME>
<RETURNS>CUcontext                </RETURNS>
guint device_id
</FUNCTION>
<FUNCTION>
<NAME>gst_nvenc_destroy_cuda_context</NAME>
<RETURNS>gboolean                 </RETURNS>
CUcontext ctx
</FUNCTION>
<FUNCTION>
<NAME>gst_nvenc_cmp_guid</NAME>
<RETURNS>gboolean                 </RETURNS>
GUID g1, GUID g2
</FUNCTION>
<FUNCTION>
<NAME>gst_nvenc_get_nv_buffer_format</NAME>
<RETURNS>NV_ENC_BUFFER_FORMAT     </RETURNS>
GstVideoFormat fmt
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_NV_BASE_ENC</NAME>
#define GST_TYPE_NV_BASE_ENC \
  (gst_nv_base_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_NV_BASE_ENC</NAME>
#define GST_NV_BASE_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_NV_BASE_ENC,GstNvBaseEnc))
</MACRO>
<MACRO>
<NAME>GST_NV_BASE_ENC_CLASS</NAME>
#define GST_NV_BASE_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_NV_BASE_ENC,GstNvBaseEncClass))
</MACRO>
<MACRO>
<NAME>GST_NV_BASE_ENC_GET_CLASS</NAME>
#define GST_NV_BASE_ENC_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_NV_BASE_ENC,GstNvBaseEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_NV_BASE_ENC</NAME>
#define GST_IS_NV_BASE_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_NV_BASE_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_NV_BASE_ENC_CLASS</NAME>
#define GST_IS_NV_BASE_ENC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_NV_BASE_ENC))
</MACRO>
<ENUM>
<NAME>GstNvPreset</NAME>
typedef enum {
  GST_NV_PRESET_DEFAULT,
  GST_NV_PRESET_HP,
  GST_NV_PRESET_HQ,
/* FIXME: problematic GST_NV_PRESET_BD, */
  GST_NV_PRESET_LOW_LATENCY_DEFAULT,
  GST_NV_PRESET_LOW_LATENCY_HQ,
  GST_NV_PRESET_LOW_LATENCY_HP,
  GST_NV_PRESET_LOSSLESS_DEFAULT,
  GST_NV_PRESET_LOSSLESS_HP,
} GstNvPreset;
</ENUM>
<ENUM>
<NAME>GstNvRCMode</NAME>
typedef enum {
  GST_NV_RC_MODE_DEFAULT,
  GST_NV_RC_MODE_CONSTQP,
  GST_NV_RC_MODE_CBR,
  GST_NV_RC_MODE_VBR,
  GST_NV_RC_MODE_VBR_MINQP,
} GstNvRCMode;
</ENUM>
<STRUCT>
<NAME>GstNvBaseEnc</NAME>
typedef struct {
  GstVideoEncoder video_encoder;

  /* properties */
  guint           cuda_device_id;
  GstNvPreset     preset_enum;
  GUID            selected_preset;
  GstNvRCMode     rate_control_mode;
  gint            qp_min;
  gint            qp_max;
  gint            qp_const;
  guint           bitrate;

  CUcontext       cuda_ctx;
  void          * encoder;

  /* the supported input formats */
  GValue        * input_formats;                  /* OBJECT LOCK */

  GstVideoCodecState *input_state;
  gboolean            gl_input;

  /* allocated buffers */
  gpointer          *input_bufs;   /* array of n_allocs input buffers  */
  NV_ENC_OUTPUT_PTR *output_bufs;  /* array of n_allocs output buffers */
  guint              n_bufs;

  /* input and output buffers currently available */
  GAsyncQueue    *in_bufs_pool;
  GAsyncQueue    *bitstream_pool;

  /* output bufs in use (input bufs in use are tracked via the codec frames) */
  GAsyncQueue    *bitstream_queue;

  /* we spawn a thread that does the (blocking) waits for output buffers
   * to become available, so we can continue to feed data to the encoder
   * while we wait */
  GThread        *bitstream_thread;

  /* supported interlacing input modes.
   * 0 = none, 1 = fields, 2 = interleaved */
  gint            interlace_modes;

  void           *display;            /* GstGLDisplay */
  void           *other_context;      /* GstGLContext */

  /* the maximum buffer size the encoder is configured for */
  guint               max_encode_width;
  guint               max_encode_height;

  GstVideoInfo        input_info;     /* buffer configuration for buffers sent to NVENC */

  GstFlowReturn   last_flow;          /* ATOMIC */
} GstNvBaseEnc;
</STRUCT>
<STRUCT>
<NAME>GstNvBaseEncClass</NAME>
typedef struct {
  GstVideoEncoderClass video_encoder_class;

  GUID codec_id;

  gboolean (*set_src_caps)       (GstNvBaseEnc * nvenc,
                                  GstVideoCodecState * state);
  gboolean (*set_pic_params)     (GstNvBaseEnc * nvenc,
                                  GstVideoCodecFrame * frame,
                                  NV_ENC_PIC_PARAMS * pic_params);
  gboolean (*set_encoder_config) (GstNvBaseEnc * nvenc,
                                  GstVideoCodecState * state,
                                  NV_ENC_CONFIG * config);
} GstNvBaseEncClass;
</STRUCT>
<FUNCTION>
<NAME>gst_nv_base_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_nv_base_enc_get_max_encode_size</NAME>
<RETURNS>void  </RETURNS>
GstNvBaseEnc * nvenc, guint * max_width, guint * max_height
</FUNCTION>
<FUNCTION>
<NAME>gst_nv_base_enc_set_max_encode_size</NAME>
<RETURNS>void  </RETURNS>
GstNvBaseEnc * nvenc, guint max_width, guint max_height
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_NV_H264_ENC</NAME>
#define GST_TYPE_NV_H264_ENC \
  (gst_nv_h264_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_NV_H264_ENC</NAME>
#define GST_NV_H264_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_NV_H264_ENC,GstNvH264Enc))
</MACRO>
<MACRO>
<NAME>GST_NV_H264_ENC_CLASS</NAME>
#define GST_NV_H264_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_NV_H264_ENC,GstNvH264EncClass))
</MACRO>
<MACRO>
<NAME>GST_NV_H264_ENC_GET_CLASS</NAME>
#define GST_NV_H264_ENC_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS((obj),GST_TYPE_NV_H264_ENC,GstNvH264EncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_NV_H264_ENC</NAME>
#define GST_IS_NV_H264_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_NV_H264_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_NV_H264_ENC_CLASS</NAME>
#define GST_IS_NV_H264_ENC_CLASS(obj) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_NV_H264_ENC))
</MACRO>
<STRUCT>
<NAME>GstNvH264Enc</NAME>
typedef struct {
  GstNvBaseEnc base_nvenc;

  /* the supported input formats */
  GValue        * supported_profiles;             /* OBJECT LOCK */

  GstVideoCodecState *input_state;
  gboolean            gl_input;

  /* supported interlacing input modes.
   * 0 = none, 1 = fields, 2 = interleaved */
  gint            interlace_modes;
} GstNvH264Enc;
</STRUCT>
<STRUCT>
<NAME>GstNvH264EncClass</NAME>
typedef struct {
  GstNvBaseEncClass video_encoder_class;
} GstNvH264EncClass;
</STRUCT>
<FUNCTION>
<NAME>gst_nv_h264_enc_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VDP_DECODER</NAME>
#define GST_TYPE_VDP_DECODER		        (gst_vdp_decoder_get_type())
</MACRO>
<MACRO>
<NAME>GST_VDP_DECODER</NAME>
#define GST_VDP_DECODER(obj)		        (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_VDP_DECODER, GstVdpDecoder))
</MACRO>
<MACRO>
<NAME>GST_VDP_DECODER_CLASS</NAME>
#define GST_VDP_DECODER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_VDP_DECODER, GstVdpDecoderClass))
</MACRO>
<MACRO>
<NAME>GST_VDP_DECODER_GET_CLASS</NAME>
#define GST_VDP_DECODER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj), GST_TYPE_VDP_DECODER, GstVdpDecoderClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VDP_DECODER</NAME>
#define GST_IS_VDP_DECODER(obj)	        (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_VDP_DECODER))
</MACRO>
<MACRO>
<NAME>GST_IS_VDP_DECODER_CLASS</NAME>
#define GST_IS_VDP_DECODER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_VDP_DECODER))
</MACRO>
<STRUCT>
<NAME>GstVdpDecoder</NAME>
struct _GstVdpDecoder {
  GstVideoDecoder video_decoder;

  GstVdpDevice *device;
  VdpDecoder decoder;

  GstVideoInfo info;

  /* properties */
  gchar *display;
};
</STRUCT>
<STRUCT>
<NAME>GstVdpDecoderClass</NAME>
struct _GstVdpDecoderClass {
  GstVideoDecoderClass video_decoder_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vdp_decoder_post_error</NAME>
<RETURNS>void </RETURNS>
GstVdpDecoder * decoder, GError * error
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_decoder_render</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstVdpDecoder * vdp_decoder, VdpPictureInfo *info, guint n_bufs, VdpBitstreamBuffer *bufs, GstVideoCodecFrame *frame
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_decoder_init_decoder</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstVdpDecoder * vdp_decoder, VdpDecoderProfile profile, guint32 max_references, GstVideoCodecState *output_state
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_decoder_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_VDPAU_SURFACE_META_GET</NAME>
#define GST_VDPAU_SURFACE_META_GET(buf) ((GstVdpauMeta *)gst_buffer_get_meta(buf,gst_vdpau_surface_meta_api_get_type()))
</MACRO>
<MACRO>
<NAME>GST_VDPAU_SURFACE_META_ADD</NAME>
#define GST_VDPAU_SURFACE_META_ADD(buf) ((GstVdpauMeta *)gst_buffer_add_meta(buf,gst_vdpau_surface_meta_get_info(),NULL))
</MACRO>
<STRUCT>
<NAME>GstVdpauSurfaceMeta</NAME>
struct _GstVdpauSurfaceMeta {
	GstMeta meta;

	GstVdpDevice *device;
	VdpVideoSurface surface;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vdpau_surface_meta_api_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vdpau_surface_meta_get_info</NAME>
<RETURNS>const GstMetaInfo  * </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_BUFFER_POOL_OPTION_VDP_VIDEO_META</NAME>
#define GST_BUFFER_POOL_OPTION_VDP_VIDEO_META "GstBufferPoolOptionVdpVideoMeta"
</MACRO>
<MACRO>
<NAME>GST_TYPE_VDP_VIDEO_BUFFER_POOL</NAME>
#define GST_TYPE_VDP_VIDEO_BUFFER_POOL      (gst_vdp_video_buffer_pool_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_VDP_VIDEO_BUFFER_POOL</NAME>
#define GST_IS_VDP_VIDEO_BUFFER_POOL(obj)   (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_VDP_VIDEO_BUFFER_POOL))
</MACRO>
<MACRO>
<NAME>GST_VDP_VIDEO_BUFFER_POOL</NAME>
#define GST_VDP_VIDEO_BUFFER_POOL(obj)      (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_VDP_VIDEO_BUFFER_POOL, GstVdpVideoBufferPool))
</MACRO>
<MACRO>
<NAME>GST_VDP_VIDEO_BUFFER_POOL_CAST</NAME>
#define GST_VDP_VIDEO_BUFFER_POOL_CAST(obj) ((GstVdpVideoBufferPool*)(obj))
</MACRO>
<STRUCT>
<NAME>GstVdpVideoBufferPool</NAME>
struct _GstVdpVideoBufferPool
{
  GstBufferPool bufferpool;
	
  GstVdpDevice *device;

  GstVideoInfo  info;
  VdpChromaType chroma_type;
	
  gboolean      add_videometa;
  gboolean      add_vdpmeta;
};
</STRUCT>
<STRUCT>
<NAME>GstVdpVideoBufferPoolClass</NAME>
struct _GstVdpVideoBufferPoolClass
{
  GstBufferPoolClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vdp_video_buffer_pool_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_video_buffer_pool_new</NAME>
<RETURNS>GstBufferPool  *</RETURNS>
GstVdpDevice *device
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_video_buffer_get_caps</NAME>
<RETURNS>GstCaps  *</RETURNS>
gboolean filter, VdpChromaType chroma_type
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_video_buffer_get_allowed_caps</NAME>
<RETURNS>GstCaps  *</RETURNS>
GstVdpDevice * device
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_video_buffer_calculate_size</NAME>
<RETURNS>gboolean  </RETURNS>
guint32 fourcc, gint width, gint height, guint *size
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_video_buffer_download</NAME>
<RETURNS>gboolean  </RETURNS>
GstVdpVideoBuffer *inbuf, GstBuffer *outbuf, guint32 fourcc, gint width, gint height
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_video_buffer_upload</NAME>
<RETURNS>gboolean  </RETURNS>
GstVdpVideoBuffer *video_buf, GstBuffer *src_buf, guint fourcc, gint width, gint height
</FUNCTION>
<MACRO>
<NAME>MAX_PICTURES</NAME>
#define MAX_PICTURES 6
</MACRO>
<STRUCT>
<NAME>GstVdpPicture</NAME>
struct _GstVdpPicture
{
  GstBuffer *buf;
  VdpVideoMixerPictureStructure structure;
  GstClockTime timestamp;
};
</STRUCT>
<ENUM>
<NAME>GstVdpDeinterlaceModes</NAME>
typedef enum
{
  GST_VDP_DEINTERLACE_MODE_AUTO,
  GST_VDP_DEINTERLACE_MODE_INTERLACED,
  GST_VDP_DEINTERLACE_MODE_DISABLED
} GstVdpDeinterlaceModes;
</ENUM>
<ENUM>
<NAME>GstVdpDeinterlaceMethods</NAME>
typedef enum
{
  GST_VDP_DEINTERLACE_METHOD_BOB,
  GST_VDP_DEINTERLACE_METHOD_TEMPORAL,
  GST_VDP_DEINTERLACE_METHOD_TEMPORAL_SPATIAL
} GstVdpDeinterlaceMethods;
</ENUM>
<MACRO>
<NAME>GST_TYPE_VDP_VIDEO_POST_PROCESS</NAME>
#define GST_TYPE_VDP_VIDEO_POST_PROCESS            (gst_vdp_vpp_get_type())
</MACRO>
<MACRO>
<NAME>GST_VDP_VIDEO_POST_PROCESS</NAME>
#define GST_VDP_VIDEO_POST_PROCESS(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VDP_VIDEO_POST_PROCESS,GstVdpVideoPostProcess))
</MACRO>
<MACRO>
<NAME>GST_VDP_VIDEO_POST_PROCESS_CLASS</NAME>
#define GST_VDP_VIDEO_POST_PROCESS_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VDP_VIDEO_POST_PROCESS,GstVdpVideoPostProcessClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VDP_VIDEO_POST_PROCESS</NAME>
#define GST_IS_VDP_VIDEO_POST_PROCESS(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VDP_VIDEO_POST_PROCESS))
</MACRO>
<MACRO>
<NAME>GST_IS_VDP_VIDEO_POST_PROCESS_CLASS</NAME>
#define GST_IS_VDP_VIDEO_POST_PROCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VDP_VIDEO_POST_PROCESS))
</MACRO>
<STRUCT>
<NAME>GstVdpVideoPostProcess</NAME>
struct _GstVdpVideoPostProcess
{
  GstElement element;

  GstPad *sinkpad, *srcpad;
  
  gboolean native_input;
  VdpChromaType chroma_type;
  gint width, height;
  guint32 fourcc;
  GstBufferPool *vpool;

  gboolean got_par;
  gint par_n, par_d;
  
  gboolean interlaced;
  GstClockTime field_duration;

  GstSegment segment;
  GstClockTime earliest_time;
  gboolean discont;

  GstVdpDevice *device;
  VdpVideoMixer mixer;

  GstVdpPicture future_pictures[MAX_PICTURES];
  guint n_future_pictures;
  
  GstVdpPicture past_pictures[MAX_PICTURES];
  guint n_past_pictures;
  
  gboolean force_aspect_ratio;
  GstVdpDeinterlaceModes mode;
  GstVdpDeinterlaceMethods method;

  /* properties */
  gchar *display;
  gfloat noise_reduction;
  gfloat sharpening;
  gboolean inverse_telecine;
};
</STRUCT>
<STRUCT>
<NAME>GstVdpVideoPostProcessClass</NAME>
struct _GstVdpVideoPostProcessClass 
{
  GstElementClass element_class;  
};
</STRUCT>
<FUNCTION>
<NAME>gst_vdp_vpp_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VDP_VIDEO_ALLOCATOR</NAME>
#define GST_TYPE_VDP_VIDEO_ALLOCATOR (gst_vdp_video_allocator_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_vdp_video_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_IS_VDP_VIDEO_ALLOCATOR</NAME>
#define GST_IS_VDP_VIDEO_ALLOCATOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_VDP_VIDEO_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_VDP_VIDEO_ALLOCATOR_CLASS</NAME>
#define GST_IS_VDP_VIDEO_ALLOCATOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_VDP_VIDEO_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_VDP_VIDEO_ALLOCATOR_GET_CLASS</NAME>
#define GST_VDP_VIDEO_ALLOCATOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_VDP_VIDEO_ALLOCATOR, GstVdpVideoAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_VDP_VIDEO_ALLOCATOR</NAME>
#define GST_VDP_VIDEO_ALLOCATOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_VDP_VIDEO_ALLOCATOR, GstVdpVideoAllocator))
</MACRO>
<MACRO>
<NAME>GST_VDP_VIDEO_ALLOCATOR_CLASS</NAME>
#define GST_VDP_VIDEO_ALLOCATOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_VDP_VIDEO_ALLOCATOR, GstVdpVideoAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_VDP_VIDEO_ALLOCATOR_CAST</NAME>
#define GST_VDP_VIDEO_ALLOCATOR_CAST(obj)            ((GstVdpVideoAllocator *)(obj))
</MACRO>
<STRUCT>
<NAME>GstVdpVideoMemory</NAME>
struct _GstVdpVideoMemory
{
  GstMemory          mem;

  GstVdpDevice      *device;
  VdpVideoSurface    surface;

  GstVideoInfo      *info;
  VdpChromaType      chroma_type;
  VdpYCbCrFormat     ycbcr_format;

  /* Cached data for mapping */
  volatile gint      refcount;
  GstMapFlags        map_flags;
  guint		     n_planes;
  guint8            *cache;
  void *             cached_data[4];
  uint32_t           destination_pitches[4];
};
</STRUCT>
<MACRO>
<NAME>GST_VDP_VIDEO_MEMORY_ALLOCATOR</NAME>
#define GST_VDP_VIDEO_MEMORY_ALLOCATOR   "VdpVideoMemory"
</MACRO>
<MACRO>
<NAME>GST_CAPS_FEATURE_MEMORY_VDPAU</NAME>
#define GST_CAPS_FEATURE_MEMORY_VDPAU    "memory:VdpVideoSurface"
</MACRO>
<FUNCTION>
<NAME>gst_vdp_video_memory_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_video_memory_alloc</NAME>
<RETURNS>GstMemory  *</RETURNS>
GstVdpDevice * device, GstVideoInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_video_memory_map</NAME>
<RETURNS>gboolean  </RETURNS>
GstVideoMeta * meta, guint plane, GstMapInfo * info, gpointer * data, gint * stride, GstMapFlags flags
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_video_memory_unmap</NAME>
<RETURNS>gboolean  </RETURNS>
GstVideoMeta * meta, guint plane, GstMapInfo * info
</FUNCTION>
<STRUCT>
<NAME>GstVdpVideoAllocator</NAME>
struct _GstVdpVideoAllocator
{
  GstAllocator parent;
};
</STRUCT>
<STRUCT>
<NAME>GstVdpVideoAllocatorClass</NAME>
struct _GstVdpVideoAllocatorClass
{
  GstAllocatorClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_VDP_DEVICE</NAME>
#define GST_TYPE_VDP_DEVICE             (gst_vdp_device_get_type ())
</MACRO>
<MACRO>
<NAME>GST_VDP_DEVICE</NAME>
#define GST_VDP_DEVICE(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_VDP_DEVICE, GstVdpDevice))
</MACRO>
<MACRO>
<NAME>GST_VDP_DEVICE_CLASS</NAME>
#define GST_VDP_DEVICE_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_VDP_DEVICE, GstVdpDeviceClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VDP_DEVICE</NAME>
#define GST_IS_VDP_DEVICE(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_VDP_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_IS_VDP_DEVICE_CLASS</NAME>
#define GST_IS_VDP_DEVICE_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_VDP_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_VDP_DEVICE_GET_CLASS</NAME>
#define GST_VDP_DEVICE_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_VDP_DEVICE, GstVdpDeviceClass))
</MACRO>
<STRUCT>
<NAME>GstVdpDeviceClass</NAME>
struct _GstVdpDeviceClass
{
  GObjectClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GstVdpDevice</NAME>
struct _GstVdpDevice
{
  GObject object;
  
  gchar *display_name;
  Display *display;
  VdpDevice device;

  VdpDeviceDestroy                                *vdp_device_destroy;
  VdpGetProcAddress                               *vdp_get_proc_address;
  VdpGetErrorString                               *vdp_get_error_string;

  VdpVideoSurfaceCreate                           *vdp_video_surface_create;
  VdpVideoSurfaceDestroy                          *vdp_video_surface_destroy;
  VdpVideoSurfaceQueryCapabilities                *vdp_video_surface_query_capabilities;
  VdpVideoSurfaceQueryGetPutBitsYCbCrCapabilities *vdp_video_surface_query_ycbcr_capabilities;
  VdpVideoSurfaceGetParameters                    *vdp_video_surface_get_parameters;
  VdpVideoSurfaceGetBitsYCbCr                     *vdp_video_surface_get_bits_ycbcr;
  VdpVideoSurfacePutBitsYCbCr                     *vdp_video_surface_put_bits_ycbcr;

  VdpDecoderCreate                                *vdp_decoder_create;
  VdpDecoderDestroy                               *vdp_decoder_destroy;
  VdpDecoderRender                                *vdp_decoder_render;
  VdpDecoderQueryCapabilities                     *vdp_decoder_query_capabilities;
  VdpDecoderGetParameters                         *vdp_decoder_get_parameters;

  VdpVideoMixerCreate                             *vdp_video_mixer_create;
  VdpVideoMixerDestroy                            *vdp_video_mixer_destroy;
  VdpVideoMixerRender                             *vdp_video_mixer_render;
  VdpVideoMixerSetFeatureEnables                  *vdp_video_mixer_set_feature_enables;
  VdpVideoMixerSetAttributeValues                 *vdp_video_mixer_set_attribute_values;

  VdpOutputSurfaceCreate                          *vdp_output_surface_create;
  VdpOutputSurfaceDestroy                         *vdp_output_surface_destroy;
  VdpOutputSurfaceQueryCapabilities               *vdp_output_surface_query_capabilities;
  VdpOutputSurfaceGetBitsNative                   *vdp_output_surface_get_bits_native;

  VdpPresentationQueueTargetCreateX11             *vdp_presentation_queue_target_create_x11;
  VdpPresentationQueueTargetDestroy               *vdp_presentation_queue_target_destroy;
  
  VdpPresentationQueueCreate                      *vdp_presentation_queue_create;
  VdpPresentationQueueDestroy                     *vdp_presentation_queue_destroy;
  VdpPresentationQueueDisplay                     *vdp_presentation_queue_display;
  VdpPresentationQueueBlockUntilSurfaceIdle       *vdp_presentation_queue_block_until_surface_idle;
  VdpPresentationQueueSetBackgroundColor          *vdp_presentation_queue_set_background_color;
  VdpPresentationQueueQuerySurfaceStatus          *vdp_presentation_queue_query_surface_status;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vdp_device_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_get_device</NAME>
<RETURNS>GstVdpDevice  *</RETURNS>
const gchar *display_name, GError **error
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VDP_SINK</NAME>
#define GST_TYPE_VDP_SINK \
  (gst_vdp_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_VDP_SINK</NAME>
#define GST_VDP_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_VDP_SINK, VdpSink))
</MACRO>
<MACRO>
<NAME>GST_VDP_SINK_CLASS</NAME>
#define GST_VDP_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_VDP_SINK, VdpSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VDP_SINK</NAME>
#define GST_IS_VDP_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_VDP_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_VDP_SINK_CLASS</NAME>
#define GST_IS_VDP_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_VDP_SINK))
</MACRO>
<STRUCT>
<NAME>GstVdpWindow</NAME>
struct _GstVdpWindow {
  Window win;
  VdpPresentationQueueTarget target;
  VdpPresentationQueue queue;
  gint width, height;
  gboolean internal;
};
</STRUCT>
<STRUCT>
<NAME>VdpSink</NAME>
struct _VdpSink {
  /* Our element stuff */
  GstVideoSink videosink;

  char *display_name;

  GstVdpDevice *device;
  GstBufferPool *bpool;
  GstCaps *caps;
  
  GstVdpWindow *window;
  GstBuffer *cur_image;
  
  GThread *event_thread;
  gboolean running;

  /* Framerate numerator and denominator */
  gint fps_n;
  gint fps_d;

  GMutex *device_lock;
  GMutex *x_lock;
  GMutex *flow_lock;
  
  /* object-set pixel aspect ratio */
  GValue *par;

  gboolean synchronous;
  gboolean handle_events;
  gboolean handle_expose;
  
  /* stream metadata */
  gchar *media_title;
};
</STRUCT>
<STRUCT>
<NAME>VdpSinkClass</NAME>
struct _VdpSinkClass {
  GstVideoSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vdp_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstXContext</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_video_info_to_vdp_chroma_type</NAME>
<RETURNS>VdpChromaType  </RETURNS>
GstVideoInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_video_format_to_vdp_ycbcr</NAME>
<RETURNS>VdpYCbCrFormat  </RETURNS>
GstVideoFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_vdpau_output_meta_api_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vdpau_output_meta_get_info</NAME>
<RETURNS>const GstMetaInfo  * </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_VDPAU_OUTPUT_META_GET</NAME>
#define GST_VDPAU_OUTPUT_META_GET(buf) ((GstVdpauMeta *)gst_buffer_get_meta(buf,gst_vdpau_output_meta_api_get_type()))
</MACRO>
<MACRO>
<NAME>GST_VDPAU_OUTPUT_META_ADD</NAME>
#define GST_VDPAU_OUTPUT_META_ADD(buf) ((GstVdpauMeta *)gst_buffer_add_meta(buf,gst_vdpau_output_meta_get_info(),NULL))
</MACRO>
<STRUCT>
<NAME>GstVdpauOutputMeta</NAME>
struct _GstVdpauOutputMeta {
  GstMeta meta;

  /* FIXME : Check we actually need all of this */
  GstVdpDevice *device;
  VdpRGBAFormat rgba_format;
  gint width, height;
  
  VdpOutputSurface surface;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vdp_output_buffer_get_template_caps</NAME>
<RETURNS>GstCaps  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_output_buffer_get_allowed_caps</NAME>
<RETURNS>GstCaps  *</RETURNS>
GstVdpDevice *device
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_caps_to_rgba_format</NAME>
<RETURNS>gboolean  </RETURNS>
GstCaps *caps, VdpRGBAFormat *rgba_format
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_output_buffer_calculate_size</NAME>
<RETURNS>gboolean  </RETURNS>
GstVdpOutputBuffer *output_buf, guint *size
</FUNCTION>
<FUNCTION>
<NAME>gst_vdp_output_buffer_download</NAME>
<RETURNS>gboolean  </RETURNS>
GstVdpOutputBuffer *output_buf, GstBuffer *outbuf, GError **error
</FUNCTION>
<MACRO>
<NAME>GST_VDP_OUTPUT_CAPS</NAME>
#define GST_VDP_OUTPUT_CAPS \
  "video/x-vdpau-output, " \
  "rgba-format = (int)[0,4], " \
  "width = (int)[1,8192], " \
  "height = (int)[1,8192]"
</MACRO>
<STRUCT>
<NAME>GstVdpMpegStreamInfo</NAME>
struct _GstVdpMpegStreamInfo
{
  gint width, height;
  gint fps_n, fps_d;
  gint par_n, par_d;
  gboolean interlaced;
  gint version;
  VdpDecoderProfile profile;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_VDP_MPEG_DEC</NAME>
#define GST_TYPE_VDP_MPEG_DEC            (gst_vdp_mpeg_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_VDP_MPEG_DEC</NAME>
#define GST_VDP_MPEG_DEC(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VDP_MPEG_DEC,GstVdpMpegDec))
</MACRO>
<MACRO>
<NAME>GST_VDP_MPEG_DEC_CLASS</NAME>
#define GST_VDP_MPEG_DEC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VDP_MPEG_DEC,GstVdpMpegDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VDP_MPEG_DEC</NAME>
#define GST_IS_VDP_MPEG_DEC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VDP_MPEG_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_VDP_MPEG_DEC_CLASS</NAME>
#define GST_IS_VDP_MPEG_DEC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VDP_MPEG_DEC))
</MACRO>
<ENUM>
<NAME>GstVdpMpegDecState</NAME>
typedef enum {
  GST_VDP_MPEG_DEC_STATE_NEED_SEQUENCE,
  GST_VDP_MPEG_DEC_STATE_NEED_GOP,
  GST_VDP_MPEG_DEC_STATE_NEED_DATA
} GstVdpMpegDecState;
</ENUM>
<STRUCT>
<NAME>GstVdpMpegDec</NAME>
struct _GstVdpMpegDec
{
  GstVdpDecoder vdp_decoder;

  VdpDecoder decoder;

  GstVdpMpegStreamInfo stream_info;

  /* decoder state */
  GstVideoCodecState *input_state;
  GstVideoCodecState *output_state;
  GstVdpMpegDecState state;
  gint prev_packet;
  
  /* currently decoded frame info */
  VdpPictureInfoMPEG1Or2 vdp_info;
  guint64 frame_nr;

  /* frame_nr from GOP */
  guint64 gop_frame;
  
  /* forward and backward reference */
  GstVideoCodecFrame *f_frame, *b_frame;
};
</STRUCT>
<STRUCT>
<NAME>GstVdpMpegDecClass</NAME>
struct _GstVdpMpegDecClass 
{
  GstVdpDecoderClass vdp_decoder_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vdp_mpeg_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_MPEG4_FRAME_GOT_PRIMARY</NAME>
#define GST_MPEG4_FRAME_GOT_PRIMARY GST_VIDEO_FRAME_FLAG_LAST
</MACRO>
<STRUCT>
<NAME>GstMpeg4Frame</NAME>
struct _GstMpeg4Frame
{
  GstBuffer *vos_buf;
  GstBuffer *vo_buf;
  GstBuffer *vol_buf;
  GstBuffer *gov_buf;
  GstBuffer *vop_buf;
  
  guint32 vop_time;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mpeg4_frame_new</NAME>
<RETURNS>GstMpeg4Frame  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VDP_MPEG4_DEC</NAME>
#define GST_TYPE_VDP_MPEG4_DEC            (gst_vdp_mpeg4_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_VDP_MPEG4_DEC</NAME>
#define GST_VDP_MPEG4_DEC(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VDP_MPEG4_DEC,GstVdpMpeg4Dec))
</MACRO>
<MACRO>
<NAME>GST_VDP_MPEG4_DEC_CLASS</NAME>
#define GST_VDP_MPEG4_DEC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VDP_MPEG4_DEC,GstVdpMpeg4DecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VDP_MPEG4_DEC</NAME>
#define GST_IS_VDP_MPEG4_DEC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VDP_MPEG4_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_VDP_MPEG4_DEC_CLASS</NAME>
#define GST_IS_VDP_MPEG4_DEC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VDP_MPEG4_DEC))
</MACRO>
<STRUCT>
<NAME>GstVdpMpeg4Dec</NAME>
struct _GstVdpMpeg4Dec
{
  GstVdpDecoder vdp_decoder;
  
  gboolean is_configured;
  Mpeg4VideoObjectLayer vol;
  guint32 tframe;

  GstMpeg4Frame *f_frame, *b_frame;
};
</STRUCT>
<STRUCT>
<NAME>GstVdpMpeg4DecClass</NAME>
struct _GstVdpMpeg4DecClass 
{
  GstVdpDecoderClass vdp_decoder_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vdp_mpeg4_dec_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>CHECK_ALLOWED</NAME>
#define CHECK_ALLOWED(val, min, max) { \
  if (val < min || val > max) { \
    GST_WARNING ("value not in allowed range. value: %d, range %d-%d", \
                     val, min, max); \
    goto error; \
  } \
}
</MACRO>
<MACRO>
<NAME>READ_UINT8</NAME>
#define READ_UINT8(reader, val, nbits) { \
  if (!gst_bit_reader_get_bits_uint8 (reader, &val, nbits)) { \
    GST_WARNING ("failed to read uint8, nbits: %d", nbits); \
    goto error; \
  } \
}
</MACRO>
<MACRO>
<NAME>READ_UINT16</NAME>
#define READ_UINT16(reader, val, nbits) { \
  if (!gst_bit_reader_get_bits_uint16 (reader, &val, nbits)) { \
    GST_WARNING ("failed to read uint16, nbits: %d", nbits); \
    goto error; \
  } \
}
</MACRO>
<MACRO>
<NAME>READ_UINT32</NAME>
#define READ_UINT32(reader, val, nbits) { \
  if (!gst_bit_reader_get_bits_uint32 (reader, &val, nbits)) { \
    GST_WARNING ("failed to read uint32, nbits: %d", nbits); \
    goto error; \
  } \
}
</MACRO>
<MACRO>
<NAME>READ_UINT64</NAME>
#define READ_UINT64(reader, val, nbits) { \
  if (!gst_bit_reader_get_bits_uint64 (reader, &val, nbits)) { \
    GST_WARNING ("failed to read uint64, nbits: %d", nbits); \
    goto error; \
  } \
}
</MACRO>
<MACRO>
<NAME>SKIP</NAME>
#define SKIP(reader, nbits) { \
  if (!gst_bit_reader_skip (reader, nbits)) { \
    GST_WARNING ("failed to skip nbits: %d", nbits); \
    goto error; \
  } \
}
</MACRO>
<MACRO>
<NAME>MPEG4_PACKET_VOL_MIN</NAME>
#define MPEG4_PACKET_VOL_MIN 0x20
</MACRO>
<MACRO>
<NAME>MPEG4_PACKET_VOL_MAX</NAME>
#define MPEG4_PACKET_VOL_MAX 0x2f
</MACRO>
<MACRO>
<NAME>MPEG4_PACKET_VOS</NAME>
#define MPEG4_PACKET_VOS     0xb0
</MACRO>
<MACRO>
<NAME>MPEG4_PACKET_EVOS</NAME>
#define MPEG4_PACKET_EVOS    0xb1
</MACRO>
<MACRO>
<NAME>MPEG4_PACKET_GOV</NAME>
#define MPEG4_PACKET_GOV     0xb3
</MACRO>
<MACRO>
<NAME>MPEG4_PACKET_VO</NAME>
#define MPEG4_PACKET_VO      0xb5
</MACRO>
<MACRO>
<NAME>MPEG4_PACKET_VOP</NAME>
#define MPEG4_PACKET_VOP     0xb6
</MACRO>
<MACRO>
<NAME>I_VOP</NAME>
#define I_VOP 0x0
</MACRO>
<MACRO>
<NAME>P_VOP</NAME>
#define P_VOP 0x1
</MACRO>
<MACRO>
<NAME>B_VOP</NAME>
#define B_VOP 0x2
</MACRO>
<MACRO>
<NAME>S_VOP</NAME>
#define S_VOP 0x3
</MACRO>
<STRUCT>
<NAME>Mpeg4VisualObjectSequence</NAME>
struct _Mpeg4VisualObjectSequence {
  guint8 profile_and_level_indication;
};
</STRUCT>
<STRUCT>
<NAME>Mpeg4VisualObject</NAME>
struct _Mpeg4VisualObject {
  guint8 verid;
  guint8 priority;
  guint8 type;
};
</STRUCT>
<STRUCT>
<NAME>Mpeg4VideoObjectLayer</NAME>
struct _Mpeg4VideoObjectLayer {
  guint8 random_accesible_vol;
  guint8 video_object_type_indication;

  guint8 is_object_layer_identifier;
  /* if is_object_layer_identifier */
  guint8 verid;
  guint8 priority;

  guint8 par_n;
  guint8 par_d;

  guint8 chroma_format;
  guint8 low_delay;
  guint8 vbv_parameters;
  /* if vbv_parameters */
  guint32 bit_rate;
  guint32 vbv_buffer_size;

  guint8 shape;

  guint16 vop_time_increment_resolution;
  guint8 vop_time_increment_bits;
  guint8 fixed_vop_rate;
  /* if fixed_vop_rate */
  guint16 fixed_vop_time_increment;

  guint16 width;
  guint16 height;
  guint8 interlaced;
  guint8 obmc_disable;
  
  guint8 sprite_enable;

  guint8 quant_precision;
  guint8 bits_per_pixel;

  guint8 quant_type;
  guint8 intra_quant_mat[64];
  guint8 non_intra_quant_mat[64];

  guint8 quarter_sample;
  guint8 complexity_estimation_disable;
  guint8 resync_marker_disable;
};
</STRUCT>
<STRUCT>
<NAME>Mpeg4GroupofVideoObjectPlane</NAME>
struct _Mpeg4GroupofVideoObjectPlane {
  guint8 hours;
  guint8 minutes;
  guint8 seconds;
  
  guint8 closed;
  guint8 broken_link;
};
</STRUCT>
<STRUCT>
<NAME>Mpeg4VideoObjectPlane</NAME>
struct _Mpeg4VideoObjectPlane {
  guint8 coding_type;
  guint8 modulo_time_base;
  guint16 time_increment;

  guint8 coded;
  guint8 rounding_type;
  guint8 intra_dc_vlc_thr;

  guint8 top_field_first;
  guint8 alternate_vertical_scan_flag;

  guint16 quant;

  guint8 fcode_forward;
  guint8 fcode_backward;
};
</STRUCT>
<FUNCTION>
<NAME>mpeg4_util_parse_VOP</NAME>
<RETURNS>gboolean  </RETURNS>
GstBuffer *buf, Mpeg4VideoObjectLayer *vol, Mpeg4VideoObjectPlane *vop
</FUNCTION>
<FUNCTION>
<NAME>mpeg4_util_parse_GOV</NAME>
<RETURNS>gboolean  </RETURNS>
GstBuffer *buf, Mpeg4GroupofVideoObjectPlane *gov
</FUNCTION>
<FUNCTION>
<NAME>mpeg4_util_parse_VOL</NAME>
<RETURNS>gboolean  </RETURNS>
GstBuffer *buf, Mpeg4VisualObject *vo, Mpeg4VideoObjectLayer *vol
</FUNCTION>
<FUNCTION>
<NAME>mpeg4_util_parse_VO</NAME>
<RETURNS>gboolean  </RETURNS>
GstBuffer *buf, Mpeg4VisualObject *vo
</FUNCTION>
<FUNCTION>
<NAME>mpeg4_util_parse_VOS</NAME>
<RETURNS>gboolean  </RETURNS>
GstBuffer *buf, Mpeg4VisualObjectSequence *vos
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DECKLINK_VIDEO_SINK</NAME>
#define GST_TYPE_DECKLINK_VIDEO_SINK \
  (gst_decklink_video_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_DECKLINK_VIDEO_SINK</NAME>
#define GST_DECKLINK_VIDEO_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_DECKLINK_VIDEO_SINK, GstDecklinkVideoSink))
</MACRO>
<MACRO>
<NAME>GST_DECKLINK_VIDEO_SINK_CAST</NAME>
#define GST_DECKLINK_VIDEO_SINK_CAST(obj) \
  ((GstDecklinkVideoSink*)obj)
</MACRO>
<MACRO>
<NAME>GST_DECKLINK_VIDEO_SINK_CLASS</NAME>
#define GST_DECKLINK_VIDEO_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_DECKLINK_VIDEO_SINK, GstDecklinkVideoSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DECKLINK_VIDEO_SINK</NAME>
#define GST_IS_DECKLINK_VIDEO_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_DECKLINK_VIDEO_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_DECKLINK_VIDEO_SINK_CLASS</NAME>
#define GST_IS_DECKLINK_VIDEO_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_DECKLINK_VIDEO_SINK))
</MACRO>
<STRUCT>
<NAME>GstDecklinkVideoSink</NAME>
struct _GstDecklinkVideoSink
{
  GstBaseSink parent;

  GstDecklinkModeEnum mode;
  gint device_number;
  GstDecklinkVideoFormat video_format;
  BMDTimecodeFormat timecode_format;

  GstVideoInfo info;

  GstClockTime internal_base_time;
  GstClockTime external_base_time;

  GstDecklinkOutput *output;
};
</STRUCT>
<STRUCT>
<NAME>GstDecklinkVideoSinkClass</NAME>
struct _GstDecklinkVideoSinkClass
{
  GstBaseSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_decklink_video_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DECKLINK_AUDIO_SINK</NAME>
#define GST_TYPE_DECKLINK_AUDIO_SINK \
  (gst_decklink_audio_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_DECKLINK_AUDIO_SINK</NAME>
#define GST_DECKLINK_AUDIO_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_DECKLINK_AUDIO_SINK, GstDecklinkAudioSink))
</MACRO>
<MACRO>
<NAME>GST_DECKLINK_AUDIO_SINK_CAST</NAME>
#define GST_DECKLINK_AUDIO_SINK_CAST(obj) \
  ((GstDecklinkAudioSink*)obj)
</MACRO>
<MACRO>
<NAME>GST_DECKLINK_AUDIO_SINK_CLASS</NAME>
#define GST_DECKLINK_AUDIO_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_DECKLINK_AUDIO_SINK, GstDecklinkAudioSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DECKLINK_AUDIO_SINK</NAME>
#define GST_IS_DECKLINK_AUDIO_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_DECKLINK_AUDIO_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_DECKLINK_AUDIO_SINK_CLASS</NAME>
#define GST_IS_DECKLINK_AUDIO_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_DECKLINK_AUDIO_SINK))
</MACRO>
<STRUCT>
<NAME>GstDecklinkAudioSink</NAME>
struct _GstDecklinkAudioSink
{
  GstAudioBaseSink parent;

  GstDecklinkModeEnum mode;
  gint device_number;
};
</STRUCT>
<STRUCT>
<NAME>GstDecklinkAudioSinkClass</NAME>
struct _GstDecklinkAudioSinkClass
{
  GstAudioBaseSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_decklink_audio_sink_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DECKLINK_VIDEO_SRC</NAME>
#define GST_TYPE_DECKLINK_VIDEO_SRC \
  (gst_decklink_video_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_DECKLINK_VIDEO_SRC</NAME>
#define GST_DECKLINK_VIDEO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_DECKLINK_VIDEO_SRC, GstDecklinkVideoSrc))
</MACRO>
<MACRO>
<NAME>GST_DECKLINK_VIDEO_SRC_CAST</NAME>
#define GST_DECKLINK_VIDEO_SRC_CAST(obj) \
  ((GstDecklinkVideoSrc*)obj)
</MACRO>
<MACRO>
<NAME>GST_DECKLINK_VIDEO_SRC_CLASS</NAME>
#define GST_DECKLINK_VIDEO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_DECKLINK_VIDEO_SRC, GstDecklinkVideoSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DECKLINK_VIDEO_SRC</NAME>
#define GST_IS_DECKLINK_VIDEO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_DECKLINK_VIDEO_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_DECKLINK_VIDEO_SRC_CLASS</NAME>
#define GST_IS_DECKLINK_VIDEO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_DECKLINK_VIDEO_SRC))
</MACRO>
<STRUCT>
<NAME>GstDecklinkVideoSrc</NAME>
struct _GstDecklinkVideoSrc
{
  GstPushSrc parent;

  GstDecklinkModeEnum mode;
  GstDecklinkModeEnum caps_mode;
  BMDPixelFormat caps_format;
  GstDecklinkConnectionEnum connection;
  gint device_number;
  gboolean output_stream_time;
  GstClockTime skip_first_time;
  gboolean drop_no_signal_frames;

  GstVideoInfo info;
  GstDecklinkVideoFormat video_format;
  BMDTimecodeFormat timecode_format;

  GstDecklinkInput *input;

  GCond cond;
  GMutex lock;
  gboolean flushing;
  GstQueueArray *current_frames;
  gboolean no_signal;

  guint buffer_size;

  /* Protected by lock */
  GstClockTime first_time;

  GstClockTime *times;
  GstClockTime *times_temp;
  guint window_size, window_fill;
  gboolean window_filled;
  guint window_skip, window_skip_count;
  struct {
    GstClockTime xbase, b;
    GstClockTime num, den;
  } current_time_mapping;
  struct {
    GstClockTime xbase, b;
    GstClockTime num, den;
  } next_time_mapping;
  gboolean next_time_mapping_pending;
};
</STRUCT>
<STRUCT>
<NAME>GstDecklinkVideoSrcClass</NAME>
struct _GstDecklinkVideoSrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_decklink_video_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>bool</NAME>
#define bool BOOL
</MACRO>
<MACRO>
<NAME>COMSTR_T</NAME>
#define COMSTR_T BSTR
</MACRO>
<MACRO>
<NAME>CONVERT_COM_STRING</NAME>
#  define CONVERT_COM_STRING(s) BSTR _s = (BSTR)s; s = (char*) malloc(100); wcstombs(s, _s, 100); ::SysFreeString(_s);
</MACRO>
<MACRO>
<NAME>FREE_COM_STRING</NAME>
#  define FREE_COM_STRING(s) free(s);
</MACRO>
<ENUM>
<NAME>GstDecklinkModeEnum</NAME>
typedef enum {
  GST_DECKLINK_MODE_AUTO,

  GST_DECKLINK_MODE_NTSC,
  GST_DECKLINK_MODE_NTSC2398,
  GST_DECKLINK_MODE_PAL,
  GST_DECKLINK_MODE_NTSC_P,
  GST_DECKLINK_MODE_PAL_P,

  GST_DECKLINK_MODE_1080p2398,
  GST_DECKLINK_MODE_1080p24,
  GST_DECKLINK_MODE_1080p25,
  GST_DECKLINK_MODE_1080p2997,
  GST_DECKLINK_MODE_1080p30,

  GST_DECKLINK_MODE_1080i50,
  GST_DECKLINK_MODE_1080i5994,
  GST_DECKLINK_MODE_1080i60,

  GST_DECKLINK_MODE_1080p50,
  GST_DECKLINK_MODE_1080p5994,
  GST_DECKLINK_MODE_1080p60,

  GST_DECKLINK_MODE_720p50,
  GST_DECKLINK_MODE_720p5994,
  GST_DECKLINK_MODE_720p60,

  GST_DECKLINK_MODE_1556p2398,
  GST_DECKLINK_MODE_1556p24,
  GST_DECKLINK_MODE_1556p25,

  GST_DECKLINK_MODE_2160p2398,
  GST_DECKLINK_MODE_2160p24,
  GST_DECKLINK_MODE_2160p25,
  GST_DECKLINK_MODE_2160p2997,
  GST_DECKLINK_MODE_2160p30,
  GST_DECKLINK_MODE_2160p50,
  GST_DECKLINK_MODE_2160p5994,
  GST_DECKLINK_MODE_2160p60
} GstDecklinkModeEnum;
</ENUM>
<MACRO>
<NAME>GST_TYPE_DECKLINK_MODE</NAME>
#define GST_TYPE_DECKLINK_MODE (gst_decklink_mode_get_type ())
</MACRO>
<FUNCTION>
<NAME>gst_decklink_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstDecklinkConnectionEnum</NAME>
typedef enum {
  GST_DECKLINK_CONNECTION_AUTO,
  GST_DECKLINK_CONNECTION_SDI,
  GST_DECKLINK_CONNECTION_HDMI,
  GST_DECKLINK_CONNECTION_OPTICAL_SDI,
  GST_DECKLINK_CONNECTION_COMPONENT,
  GST_DECKLINK_CONNECTION_COMPOSITE,
  GST_DECKLINK_CONNECTION_SVIDEO
} GstDecklinkConnectionEnum;
</ENUM>
<MACRO>
<NAME>GST_TYPE_DECKLINK_CONNECTION</NAME>
#define GST_TYPE_DECKLINK_CONNECTION (gst_decklink_connection_get_type ())
</MACRO>
<FUNCTION>
<NAME>gst_decklink_connection_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstDecklinkAudioConnectionEnum</NAME>
typedef enum {
  GST_DECKLINK_AUDIO_CONNECTION_AUTO,
  GST_DECKLINK_AUDIO_CONNECTION_EMBEDDED,
  GST_DECKLINK_AUDIO_CONNECTION_AES_EBU,
  GST_DECKLINK_AUDIO_CONNECTION_ANALOG,
  GST_DECKLINK_AUDIO_CONNECTION_ANALOG_XLR,
  GST_DECKLINK_AUDIO_CONNECTION_ANALOG_RCA
} GstDecklinkAudioConnectionEnum;
</ENUM>
<MACRO>
<NAME>GST_TYPE_DECKLINK_AUDIO_CONNECTION</NAME>
#define GST_TYPE_DECKLINK_AUDIO_CONNECTION (gst_decklink_audio_connection_get_type ())
</MACRO>
<FUNCTION>
<NAME>gst_decklink_audio_connection_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstDecklinkAudioChannelsEnum</NAME>
typedef enum {
  GST_DECKLINK_AUDIO_CHANNELS_MAX = 0,
  GST_DECKLINK_AUDIO_CHANNELS_2 = 2,
  GST_DECKLINK_AUDIO_CHANNELS_8 = 8,
  GST_DECKLINK_AUDIO_CHANNELS_16 = 16
} GstDecklinkAudioChannelsEnum;
</ENUM>
<MACRO>
<NAME>GST_TYPE_DECKLINK_AUDIO_CHANNELS</NAME>
#define GST_TYPE_DECKLINK_AUDIO_CHANNELS (gst_decklink_audio_channels_get_type ())
</MACRO>
<FUNCTION>
<NAME>gst_decklink_audio_channels_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstDecklinkVideoFormat</NAME>
typedef enum {
  GST_DECKLINK_VIDEO_FORMAT_AUTO,
  GST_DECKLINK_VIDEO_FORMAT_8BIT_YUV, /* bmdFormat8BitYUV */
  GST_DECKLINK_VIDEO_FORMAT_10BIT_YUV, /* bmdFormat10BitYUV */
  GST_DECKLINK_VIDEO_FORMAT_8BIT_ARGB, /* bmdFormat8BitARGB */
  GST_DECKLINK_VIDEO_FORMAT_8BIT_BGRA, /* bmdFormat8BitBGRA */
  GST_DECKLINK_VIDEO_FORMAT_10BIT_RGB, /* bmdFormat10BitRGB */
  GST_DECKLINK_VIDEO_FORMAT_12BIT_RGB, /* bmdFormat12BitRGB */
  GST_DECKLINK_VIDEO_FORMAT_12BIT_RGBLE, /* bmdFormat12BitRGBLE */
  GST_DECKLINK_VIDEO_FORMAT_10BIT_RGBXLE, /* bmdFormat10BitRGBXLE */
  GST_DECKLINK_VIDEO_FORMAT_10BIT_RGBX, /* bmdFormat10BitRGBX */
} GstDecklinkVideoFormat;
</ENUM>
<MACRO>
<NAME>GST_TYPE_DECKLINK_VIDEO_FORMAT</NAME>
#define GST_TYPE_DECKLINK_VIDEO_FORMAT (gst_decklink_video_format_get_type ())
</MACRO>
<FUNCTION>
<NAME>gst_decklink_video_format_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstDecklinkTimecodeFormat</NAME>
typedef enum {
  GST_DECKLINK_TIMECODE_FORMAT_RP188VITC1, /*bmdTimecodeRP188VITC1 */
  GST_DECKLINK_TIMECODE_FORMAT_RP188VITC2, /*bmdTimecodeRP188VITC2 */
  GST_DECKLINK_TIMECODE_FORMAT_RP188LTC, /*bmdTimecodeRP188LTC */
  GST_DECKLINK_TIMECODE_FORMAT_RP188ANY, /*bmdTimecodeRP188Any */
  GST_DECKLINK_TIMECODE_FORMAT_VITC, /*bmdTimecodeVITC */
  GST_DECKLINK_TIMECODE_FORMAT_VITCFIELD2, /*bmdTimecodeVITCField2 */
  GST_DECKLINK_TIMECODE_FORMAT_SERIAL /* bmdTimecodeSerial */
} GstDecklinkTimecodeFormat;
</ENUM>
<MACRO>
<NAME>GST_TYPE_DECKLINK_TIMECODE_FORMAT</NAME>
#define GST_TYPE_DECKLINK_TIMECODE_FORMAT (gst_decklink_timecode_format_get_type ())
</MACRO>
<FUNCTION>
<NAME>gst_decklink_timecode_format_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_pixel_format_from_type</NAME>
<RETURNS>const BMDPixelFormat  </RETURNS>
GstDecklinkVideoFormat t
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_bpp_from_type</NAME>
<RETURNS>const gint  </RETURNS>
GstDecklinkVideoFormat t
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_type_from_video_format</NAME>
<RETURNS>const GstDecklinkVideoFormat  </RETURNS>
GstVideoFormat f
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_timecode_format_from_enum</NAME>
<RETURNS>const BMDTimecodeFormat  </RETURNS>
GstDecklinkTimecodeFormat f
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_timecode_format_to_enum</NAME>
<RETURNS>const GstDecklinkTimecodeFormat  </RETURNS>
BMDTimecodeFormat f
</FUNCTION>
<STRUCT>
<NAME>GstDecklinkMode</NAME>
struct _GstDecklinkMode {
  BMDDisplayMode mode;
  int width;
  int height;
  int fps_n;
  int fps_d;
  gboolean interlaced;
  int par_n;
  int par_d;
  gboolean tff;
  const gchar *colorimetry;
};
</STRUCT>
<FUNCTION>
<NAME>gst_decklink_get_mode</NAME>
<RETURNS>const GstDecklinkMode  * </RETURNS>
GstDecklinkModeEnum e
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_get_mode_enum_from_bmd</NAME>
<RETURNS>const GstDecklinkModeEnum  </RETURNS>
BMDDisplayMode mode
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_get_connection</NAME>
<RETURNS>const BMDVideoConnection  </RETURNS>
GstDecklinkConnectionEnum e
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_mode_get_caps</NAME>
<RETURNS>GstCaps  * </RETURNS>
GstDecklinkModeEnum e, BMDPixelFormat f, gboolean input
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_mode_get_template_caps</NAME>
<RETURNS>GstCaps  * </RETURNS>
gboolean input
</FUNCTION>
<STRUCT>
<NAME>GstDecklinkOutput</NAME>
struct _GstDecklinkOutput {
  IDeckLink *device;
  IDeckLinkOutput *output;
  IDeckLinkAttributes *attributes;
  GstClock *clock;
  GstClockTime clock_start_time, clock_last_time, clock_epoch;
  GstClockTimeDiff clock_offset;
  gboolean started, clock_restart;

  /* Everything below protected by mutex */
  GMutex lock;

  /* Set by the video source */
  /* Configured mode or NULL */
  const GstDecklinkMode *mode;

  /* Set by the audio sink */
  GstClock *audio_clock;

  GstElement *audiosink;
  gboolean audio_enabled;
  GstElement *videosink;
  gboolean video_enabled;
  void (*start_scheduled_playback) (GstElement *videosink);
};
</STRUCT>
<STRUCT>
<NAME>GstDecklinkInput</NAME>
struct _GstDecklinkInput {
  IDeckLink *device;
  IDeckLinkInput *input;
  IDeckLinkConfiguration *config;
  IDeckLinkAttributes *attributes;

  /* Everything below protected by mutex */
  GMutex lock;

  /* Set by the video source */
  void (*got_video_frame) (GstElement *videosrc, IDeckLinkVideoInputFrame * frame, GstDecklinkModeEnum mode, GstClockTime capture_time, GstClockTime stream_time, GstClockTime stream_duration, IDeckLinkTimecode *dtc, gboolean no_signal);
  /* Configured mode or NULL */
  const GstDecklinkMode *mode;
  BMDPixelFormat format;

  /* Set by the audio source */
  void (*got_audio_packet) (GstElement *videosrc, IDeckLinkAudioInputPacket * packet, GstClockTime capture_time, GstClockTime packet_time, gboolean no_signal);

  GstElement *audiosrc;
  gboolean audio_enabled;
  GstElement *videosrc;
  gboolean video_enabled;
  void (*start_streams) (GstElement *videosrc);
};
</STRUCT>
<FUNCTION>
<NAME>gst_decklink_acquire_nth_output</NAME>
<RETURNS>GstDecklinkOutput  * </RETURNS>
gint n, GstElement * sink, gboolean is_audio
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_release_nth_output</NAME>
<RETURNS>void                 </RETURNS>
gint n, GstElement * sink, gboolean is_audio
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_output_set_audio_clock</NAME>
<RETURNS>void                 </RETURNS>
GstDecklinkOutput * output, GstClock * clock
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_output_get_audio_clock</NAME>
<RETURNS>GstClock  *          </RETURNS>
GstDecklinkOutput * output
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_acquire_nth_input</NAME>
<RETURNS>GstDecklinkInput  *  </RETURNS>
gint n, GstElement * src, gboolean is_audio
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_release_nth_input</NAME>
<RETURNS>void                 </RETURNS>
gint n, GstElement * src, gboolean is_audio
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_find_mode_for_caps</NAME>
<RETURNS>const GstDecklinkMode  * </RETURNS>
GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_find_mode_and_format_for_caps</NAME>
<RETURNS>const GstDecklinkMode  * </RETURNS>
GstCaps * caps, BMDPixelFormat * format
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_mode_get_caps_all_formats</NAME>
<RETURNS>GstCaps  * </RETURNS>
GstDecklinkModeEnum e, gboolean input
</FUNCTION>
<FUNCTION>
<NAME>gst_decklink_pixel_format_get_caps</NAME>
<RETURNS>GstCaps  * </RETURNS>
BMDPixelFormat f, gboolean input
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DECKLINK_AUDIO_SRC</NAME>
#define GST_TYPE_DECKLINK_AUDIO_SRC \
  (gst_decklink_audio_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_DECKLINK_AUDIO_SRC</NAME>
#define GST_DECKLINK_AUDIO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_DECKLINK_AUDIO_SRC, GstDecklinkAudioSrc))
</MACRO>
<MACRO>
<NAME>GST_DECKLINK_AUDIO_SRC_CAST</NAME>
#define GST_DECKLINK_AUDIO_SRC_CAST(obj) \
  ((GstDecklinkAudioSrc*)obj)
</MACRO>
<MACRO>
<NAME>GST_DECKLINK_AUDIO_SRC_CLASS</NAME>
#define GST_DECKLINK_AUDIO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_DECKLINK_AUDIO_SRC, GstDecklinkAudioSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DECKLINK_AUDIO_SRC</NAME>
#define GST_IS_DECKLINK_AUDIO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_DECKLINK_AUDIO_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_DECKLINK_AUDIO_SRC_CLASS</NAME>
#define GST_IS_DECKLINK_AUDIO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_DECKLINK_AUDIO_SRC))
</MACRO>
<STRUCT>
<NAME>GstDecklinkAudioSrc</NAME>
struct _GstDecklinkAudioSrc
{
  GstPushSrc parent;

  GstDecklinkModeEnum mode;
  GstDecklinkAudioConnectionEnum connection;
  gint device_number;
  GstDecklinkAudioChannelsEnum channels;
  gint64 channels_found;

  GstAudioInfo info;

  GstDecklinkInput *input;

  GCond cond;
  GMutex lock;
  gboolean flushing;
  GstQueueArray *current_packets;

  /* properties for handling jittery timestamps */
  GstClockTime alignment_threshold;
  GstClockTime discont_wait;

  /* counter to keep track of timestamps */
  guint64 next_offset;

  /* Last time we noticed a discont */
  GstClockTime discont_time;

  guint buffer_size;
};
</STRUCT>
<STRUCT>
<NAME>GstDecklinkAudioSrcClass</NAME>
struct _GstDecklinkAudioSrcClass
{
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_decklink_audio_src_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<TYPEDEF>
<NAME>IDeckLinkTimecode</NAME>
typedef interface IDeckLinkTimecode IDeckLinkTimecode;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkDisplayModeIterator</NAME>
typedef interface IDeckLinkDisplayModeIterator IDeckLinkDisplayModeIterator;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkDisplayMode</NAME>
typedef interface IDeckLinkDisplayMode IDeckLinkDisplayMode;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLink</NAME>
typedef interface IDeckLink IDeckLink;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkConfiguration</NAME>
typedef interface IDeckLinkConfiguration IDeckLinkConfiguration;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkEncoderConfiguration</NAME>
typedef interface IDeckLinkEncoderConfiguration IDeckLinkEncoderConfiguration;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkDeckControlStatusCallback</NAME>
typedef interface IDeckLinkDeckControlStatusCallback IDeckLinkDeckControlStatusCallback;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkDeckControl</NAME>
typedef interface IDeckLinkDeckControl IDeckLinkDeckControl;
</TYPEDEF>
<TYPEDEF>
<NAME>IBMDStreamingDeviceNotificationCallback</NAME>
typedef interface IBMDStreamingDeviceNotificationCallback IBMDStreamingDeviceNotificationCallback;
</TYPEDEF>
<TYPEDEF>
<NAME>IBMDStreamingH264InputCallback</NAME>
typedef interface IBMDStreamingH264InputCallback IBMDStreamingH264InputCallback;
</TYPEDEF>
<TYPEDEF>
<NAME>IBMDStreamingDiscovery</NAME>
typedef interface IBMDStreamingDiscovery IBMDStreamingDiscovery;
</TYPEDEF>
<TYPEDEF>
<NAME>IBMDStreamingVideoEncodingMode</NAME>
typedef interface IBMDStreamingVideoEncodingMode IBMDStreamingVideoEncodingMode;
</TYPEDEF>
<TYPEDEF>
<NAME>IBMDStreamingMutableVideoEncodingMode</NAME>
typedef interface IBMDStreamingMutableVideoEncodingMode IBMDStreamingMutableVideoEncodingMode;
</TYPEDEF>
<TYPEDEF>
<NAME>IBMDStreamingVideoEncodingModePresetIterator</NAME>
typedef interface IBMDStreamingVideoEncodingModePresetIterator IBMDStreamingVideoEncodingModePresetIterator;
</TYPEDEF>
<TYPEDEF>
<NAME>IBMDStreamingDeviceInput</NAME>
typedef interface IBMDStreamingDeviceInput IBMDStreamingDeviceInput;
</TYPEDEF>
<TYPEDEF>
<NAME>IBMDStreamingH264NALPacket</NAME>
typedef interface IBMDStreamingH264NALPacket IBMDStreamingH264NALPacket;
</TYPEDEF>
<TYPEDEF>
<NAME>IBMDStreamingAudioPacket</NAME>
typedef interface IBMDStreamingAudioPacket IBMDStreamingAudioPacket;
</TYPEDEF>
<TYPEDEF>
<NAME>IBMDStreamingMPEG2TSPacket</NAME>
typedef interface IBMDStreamingMPEG2TSPacket IBMDStreamingMPEG2TSPacket;
</TYPEDEF>
<TYPEDEF>
<NAME>IBMDStreamingH264NALParser</NAME>
typedef interface IBMDStreamingH264NALParser IBMDStreamingH264NALParser;
</TYPEDEF>
<TYPEDEF>
<NAME>CBMDStreamingDiscovery</NAME>
typedef class CBMDStreamingDiscovery CBMDStreamingDiscovery;
</TYPEDEF>
<TYPEDEF>
<NAME>CBMDStreamingH264NALParser</NAME>
typedef class CBMDStreamingH264NALParser CBMDStreamingH264NALParser;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoOutputCallback</NAME>
typedef interface IDeckLinkVideoOutputCallback IDeckLinkVideoOutputCallback;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkInputCallback</NAME>
typedef interface IDeckLinkInputCallback IDeckLinkInputCallback;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkEncoderInputCallback</NAME>
typedef interface IDeckLinkEncoderInputCallback IDeckLinkEncoderInputCallback;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkMemoryAllocator</NAME>
typedef interface IDeckLinkMemoryAllocator IDeckLinkMemoryAllocator;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkAudioOutputCallback</NAME>
typedef interface IDeckLinkAudioOutputCallback IDeckLinkAudioOutputCallback;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkIterator</NAME>
typedef interface IDeckLinkIterator IDeckLinkIterator;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkAPIInformation</NAME>
typedef interface IDeckLinkAPIInformation IDeckLinkAPIInformation;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkOutput</NAME>
typedef interface IDeckLinkOutput IDeckLinkOutput;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkInput</NAME>
typedef interface IDeckLinkInput IDeckLinkInput;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkEncoderInput</NAME>
typedef interface IDeckLinkEncoderInput IDeckLinkEncoderInput;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoFrame</NAME>
typedef interface IDeckLinkVideoFrame IDeckLinkVideoFrame;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkMutableVideoFrame</NAME>
typedef interface IDeckLinkMutableVideoFrame IDeckLinkMutableVideoFrame;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoFrame3DExtensions</NAME>
typedef interface IDeckLinkVideoFrame3DExtensions IDeckLinkVideoFrame3DExtensions;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoFrameMetadataExtensions</NAME>
typedef interface IDeckLinkVideoFrameMetadataExtensions IDeckLinkVideoFrameMetadataExtensions;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoInputFrame</NAME>
typedef interface IDeckLinkVideoInputFrame IDeckLinkVideoInputFrame;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoFrameAncillary</NAME>
typedef interface IDeckLinkVideoFrameAncillary IDeckLinkVideoFrameAncillary;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkEncoderPacket</NAME>
typedef interface IDeckLinkEncoderPacket IDeckLinkEncoderPacket;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkEncoderVideoPacket</NAME>
typedef interface IDeckLinkEncoderVideoPacket IDeckLinkEncoderVideoPacket;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkEncoderAudioPacket</NAME>
typedef interface IDeckLinkEncoderAudioPacket IDeckLinkEncoderAudioPacket;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkH265NALPacket</NAME>
typedef interface IDeckLinkH265NALPacket IDeckLinkH265NALPacket;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkAudioInputPacket</NAME>
typedef interface IDeckLinkAudioInputPacket IDeckLinkAudioInputPacket;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkScreenPreviewCallback</NAME>
typedef interface IDeckLinkScreenPreviewCallback IDeckLinkScreenPreviewCallback;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkGLScreenPreviewHelper</NAME>
typedef interface IDeckLinkGLScreenPreviewHelper IDeckLinkGLScreenPreviewHelper;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkDX9ScreenPreviewHelper</NAME>
typedef interface IDeckLinkDX9ScreenPreviewHelper IDeckLinkDX9ScreenPreviewHelper;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkNotificationCallback</NAME>
typedef interface IDeckLinkNotificationCallback IDeckLinkNotificationCallback;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkNotification</NAME>
typedef interface IDeckLinkNotification IDeckLinkNotification;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkAttributes</NAME>
typedef interface IDeckLinkAttributes IDeckLinkAttributes;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkStatus</NAME>
typedef interface IDeckLinkStatus IDeckLinkStatus;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkKeyer</NAME>
typedef interface IDeckLinkKeyer IDeckLinkKeyer;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoConversion</NAME>
typedef interface IDeckLinkVideoConversion IDeckLinkVideoConversion;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkDeviceNotificationCallback</NAME>
typedef interface IDeckLinkDeviceNotificationCallback IDeckLinkDeviceNotificationCallback;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkDiscovery</NAME>
typedef interface IDeckLinkDiscovery IDeckLinkDiscovery;
</TYPEDEF>
<TYPEDEF>
<NAME>CDeckLinkIterator</NAME>
typedef class CDeckLinkIterator CDeckLinkIterator;
</TYPEDEF>
<TYPEDEF>
<NAME>CDeckLinkAPIInformation</NAME>
typedef class CDeckLinkAPIInformation CDeckLinkAPIInformation;
</TYPEDEF>
<TYPEDEF>
<NAME>CDeckLinkGLScreenPreviewHelper</NAME>
typedef class CDeckLinkGLScreenPreviewHelper CDeckLinkGLScreenPreviewHelper;
</TYPEDEF>
<TYPEDEF>
<NAME>CDeckLinkDX9ScreenPreviewHelper</NAME>
typedef class CDeckLinkDX9ScreenPreviewHelper CDeckLinkDX9ScreenPreviewHelper;
</TYPEDEF>
<TYPEDEF>
<NAME>CDeckLinkVideoConversion</NAME>
typedef class CDeckLinkVideoConversion CDeckLinkVideoConversion;
</TYPEDEF>
<TYPEDEF>
<NAME>CDeckLinkDiscovery</NAME>
typedef class CDeckLinkDiscovery CDeckLinkDiscovery;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkEncoderConfiguration_v10_5</NAME>
typedef interface IDeckLinkEncoderConfiguration_v10_5 IDeckLinkEncoderConfiguration_v10_5;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkConfiguration_v10_4</NAME>
typedef interface IDeckLinkConfiguration_v10_4 IDeckLinkConfiguration_v10_4;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkConfiguration_v10_2</NAME>
typedef interface IDeckLinkConfiguration_v10_2 IDeckLinkConfiguration_v10_2;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkOutput_v9_9</NAME>
typedef interface IDeckLinkOutput_v9_9 IDeckLinkOutput_v9_9;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkInput_v9_2</NAME>
typedef interface IDeckLinkInput_v9_2 IDeckLinkInput_v9_2;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkDeckControlStatusCallback_v8_1</NAME>
typedef interface IDeckLinkDeckControlStatusCallback_v8_1 IDeckLinkDeckControlStatusCallback_v8_1;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkDeckControl_v8_1</NAME>
typedef interface IDeckLinkDeckControl_v8_1 IDeckLinkDeckControl_v8_1;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLink_v8_0</NAME>
typedef interface IDeckLink_v8_0 IDeckLink_v8_0;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkIterator_v8_0</NAME>
typedef interface IDeckLinkIterator_v8_0 IDeckLinkIterator_v8_0;
</TYPEDEF>
<TYPEDEF>
<NAME>CDeckLinkIterator_v8_0</NAME>
typedef class CDeckLinkIterator_v8_0 CDeckLinkIterator_v8_0;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkDeckControl_v7_9</NAME>
typedef interface IDeckLinkDeckControl_v7_9 IDeckLinkDeckControl_v7_9;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkDisplayModeIterator_v7_6</NAME>
typedef interface IDeckLinkDisplayModeIterator_v7_6 IDeckLinkDisplayModeIterator_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkDisplayMode_v7_6</NAME>
typedef interface IDeckLinkDisplayMode_v7_6 IDeckLinkDisplayMode_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkOutput_v7_6</NAME>
typedef interface IDeckLinkOutput_v7_6 IDeckLinkOutput_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkInput_v7_6</NAME>
typedef interface IDeckLinkInput_v7_6 IDeckLinkInput_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkTimecode_v7_6</NAME>
typedef interface IDeckLinkTimecode_v7_6 IDeckLinkTimecode_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoFrame_v7_6</NAME>
typedef interface IDeckLinkVideoFrame_v7_6 IDeckLinkVideoFrame_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkMutableVideoFrame_v7_6</NAME>
typedef interface IDeckLinkMutableVideoFrame_v7_6 IDeckLinkMutableVideoFrame_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoInputFrame_v7_6</NAME>
typedef interface IDeckLinkVideoInputFrame_v7_6 IDeckLinkVideoInputFrame_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkScreenPreviewCallback_v7_6</NAME>
typedef interface IDeckLinkScreenPreviewCallback_v7_6 IDeckLinkScreenPreviewCallback_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkGLScreenPreviewHelper_v7_6</NAME>
typedef interface IDeckLinkGLScreenPreviewHelper_v7_6 IDeckLinkGLScreenPreviewHelper_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoConversion_v7_6</NAME>
typedef interface IDeckLinkVideoConversion_v7_6 IDeckLinkVideoConversion_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkConfiguration_v7_6</NAME>
typedef interface IDeckLinkConfiguration_v7_6 IDeckLinkConfiguration_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoOutputCallback_v7_6</NAME>
typedef interface IDeckLinkVideoOutputCallback_v7_6 IDeckLinkVideoOutputCallback_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkInputCallback_v7_6</NAME>
typedef interface IDeckLinkInputCallback_v7_6 IDeckLinkInputCallback_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>CDeckLinkGLScreenPreviewHelper_v7_6</NAME>
typedef class CDeckLinkGLScreenPreviewHelper_v7_6 CDeckLinkGLScreenPreviewHelper_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>CDeckLinkVideoConversion_v7_6</NAME>
typedef class CDeckLinkVideoConversion_v7_6 CDeckLinkVideoConversion_v7_6;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkInputCallback_v7_3</NAME>
typedef interface IDeckLinkInputCallback_v7_3 IDeckLinkInputCallback_v7_3;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkOutput_v7_3</NAME>
typedef interface IDeckLinkOutput_v7_3 IDeckLinkOutput_v7_3;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkInput_v7_3</NAME>
typedef interface IDeckLinkInput_v7_3 IDeckLinkInput_v7_3;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoInputFrame_v7_3</NAME>
typedef interface IDeckLinkVideoInputFrame_v7_3 IDeckLinkVideoInputFrame_v7_3;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkDisplayModeIterator_v7_1</NAME>
typedef interface IDeckLinkDisplayModeIterator_v7_1 IDeckLinkDisplayModeIterator_v7_1;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkDisplayMode_v7_1</NAME>
typedef interface IDeckLinkDisplayMode_v7_1 IDeckLinkDisplayMode_v7_1;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoFrame_v7_1</NAME>
typedef interface IDeckLinkVideoFrame_v7_1 IDeckLinkVideoFrame_v7_1;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoInputFrame_v7_1</NAME>
typedef interface IDeckLinkVideoInputFrame_v7_1 IDeckLinkVideoInputFrame_v7_1;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkAudioInputPacket_v7_1</NAME>
typedef interface IDeckLinkAudioInputPacket_v7_1 IDeckLinkAudioInputPacket_v7_1;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkVideoOutputCallback_v7_1</NAME>
typedef interface IDeckLinkVideoOutputCallback_v7_1 IDeckLinkVideoOutputCallback_v7_1;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkInputCallback_v7_1</NAME>
typedef interface IDeckLinkInputCallback_v7_1 IDeckLinkInputCallback_v7_1;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkOutput_v7_1</NAME>
typedef interface IDeckLinkOutput_v7_1 IDeckLinkOutput_v7_1;
</TYPEDEF>
<TYPEDEF>
<NAME>IDeckLinkInput_v7_1</NAME>
typedef interface IDeckLinkInput_v7_1 IDeckLinkInput_v7_1;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimeValue</NAME>
typedef LONGLONG BMDTimeValue;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimeScale</NAME>
typedef LONGLONG BMDTimeScale;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimecodeBCD</NAME>
typedef unsigned int BMDTimecodeBCD;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimecodeUserBits</NAME>
typedef unsigned int BMDTimecodeUserBits;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimecodeFlags</NAME>
typedef unsigned int BMDTimecodeFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDisplayModeFlags</NAME>
typedef unsigned int BMDDisplayModeFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckControlStatusFlags</NAME>
typedef unsigned int BMDDeckControlStatusFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckControlExportModeOpsFlags</NAME>
typedef unsigned int BMDDeckControlExportModeOpsFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDFrameFlags</NAME>
typedef unsigned int BMDFrameFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoInputFlags</NAME>
typedef unsigned int BMDVideoInputFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoInputFormatChangedEvents</NAME>
typedef unsigned int BMDVideoInputFormatChangedEvents;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDetectedVideoInputFormatFlags</NAME>
typedef unsigned int BMDDetectedVideoInputFormatFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkCapturePassthroughMode</NAME>
typedef unsigned int BMDDeckLinkCapturePassthroughMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAnalogVideoFlags</NAME>
typedef unsigned int BMDAnalogVideoFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeviceBusyState</NAME>
typedef unsigned int BMDDeviceBusyState;
</TYPEDEF>
<MACRO>
<NAME>IDeckLinkTimecode_QueryInterface</NAME>
#define IDeckLinkTimecode_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkTimecode_AddRef</NAME>
#define IDeckLinkTimecode_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkTimecode_Release</NAME>
#define IDeckLinkTimecode_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkTimecode_GetBCD</NAME>
#define IDeckLinkTimecode_GetBCD(This)	\
    ( (This)->lpVtbl -> GetBCD(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkTimecode_GetComponents</NAME>
#define IDeckLinkTimecode_GetComponents(This,hours,minutes,seconds,frames)	\
    ( (This)->lpVtbl -> GetComponents(This,hours,minutes,seconds,frames) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkTimecode_GetString</NAME>
#define IDeckLinkTimecode_GetString(This,timecode)	\
    ( (This)->lpVtbl -> GetString(This,timecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkTimecode_GetFlags</NAME>
#define IDeckLinkTimecode_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkTimecode_GetTimecodeUserBits</NAME>
#define IDeckLinkTimecode_GetTimecodeUserBits(This,userBits)	\
    ( (This)->lpVtbl -> GetTimecodeUserBits(This,userBits) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayModeIterator_QueryInterface</NAME>
#define IDeckLinkDisplayModeIterator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayModeIterator_AddRef</NAME>
#define IDeckLinkDisplayModeIterator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayModeIterator_Release</NAME>
#define IDeckLinkDisplayModeIterator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayModeIterator_Next</NAME>
#define IDeckLinkDisplayModeIterator_Next(This,deckLinkDisplayMode)	\
    ( (This)->lpVtbl -> Next(This,deckLinkDisplayMode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_QueryInterface</NAME>
#define IDeckLinkDisplayMode_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_AddRef</NAME>
#define IDeckLinkDisplayMode_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_Release</NAME>
#define IDeckLinkDisplayMode_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_GetName</NAME>
#define IDeckLinkDisplayMode_GetName(This,name)	\
    ( (This)->lpVtbl -> GetName(This,name) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_GetDisplayMode</NAME>
#define IDeckLinkDisplayMode_GetDisplayMode(This)	\
    ( (This)->lpVtbl -> GetDisplayMode(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_GetWidth</NAME>
#define IDeckLinkDisplayMode_GetWidth(This)	\
    ( (This)->lpVtbl -> GetWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_GetHeight</NAME>
#define IDeckLinkDisplayMode_GetHeight(This)	\
    ( (This)->lpVtbl -> GetHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_GetFrameRate</NAME>
#define IDeckLinkDisplayMode_GetFrameRate(This,frameDuration,timeScale)	\
    ( (This)->lpVtbl -> GetFrameRate(This,frameDuration,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_GetFieldDominance</NAME>
#define IDeckLinkDisplayMode_GetFieldDominance(This)	\
    ( (This)->lpVtbl -> GetFieldDominance(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_GetFlags</NAME>
#define IDeckLinkDisplayMode_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLink_QueryInterface</NAME>
#define IDeckLink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLink_AddRef</NAME>
#define IDeckLink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLink_Release</NAME>
#define IDeckLink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLink_GetModelName</NAME>
#define IDeckLink_GetModelName(This,modelName)	\
    ( (This)->lpVtbl -> GetModelName(This,modelName) ) 
</MACRO>
<MACRO>
<NAME>IDeckLink_GetDisplayName</NAME>
#define IDeckLink_GetDisplayName(This,displayName)	\
    ( (This)->lpVtbl -> GetDisplayName(This,displayName) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_QueryInterface</NAME>
#define IDeckLinkConfiguration_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_AddRef</NAME>
#define IDeckLinkConfiguration_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_Release</NAME>
#define IDeckLinkConfiguration_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_SetFlag</NAME>
#define IDeckLinkConfiguration_SetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_GetFlag</NAME>
#define IDeckLinkConfiguration_GetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_SetInt</NAME>
#define IDeckLinkConfiguration_SetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_GetInt</NAME>
#define IDeckLinkConfiguration_GetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_SetFloat</NAME>
#define IDeckLinkConfiguration_SetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_GetFloat</NAME>
#define IDeckLinkConfiguration_GetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_SetString</NAME>
#define IDeckLinkConfiguration_SetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_GetString</NAME>
#define IDeckLinkConfiguration_GetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_WriteConfigurationToPreferences</NAME>
#define IDeckLinkConfiguration_WriteConfigurationToPreferences(This)	\
    ( (This)->lpVtbl -> WriteConfigurationToPreferences(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_QueryInterface</NAME>
#define IDeckLinkEncoderConfiguration_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_AddRef</NAME>
#define IDeckLinkEncoderConfiguration_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_Release</NAME>
#define IDeckLinkEncoderConfiguration_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_SetFlag</NAME>
#define IDeckLinkEncoderConfiguration_SetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_GetFlag</NAME>
#define IDeckLinkEncoderConfiguration_GetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_SetInt</NAME>
#define IDeckLinkEncoderConfiguration_SetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_GetInt</NAME>
#define IDeckLinkEncoderConfiguration_GetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_SetFloat</NAME>
#define IDeckLinkEncoderConfiguration_SetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_GetFloat</NAME>
#define IDeckLinkEncoderConfiguration_GetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_SetString</NAME>
#define IDeckLinkEncoderConfiguration_SetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_GetString</NAME>
#define IDeckLinkEncoderConfiguration_GetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_GetBytes</NAME>
#define IDeckLinkEncoderConfiguration_GetBytes(This,cfgID,buffer,bufferSize)	\
    ( (This)->lpVtbl -> GetBytes(This,cfgID,buffer,bufferSize) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControlStatusCallback_QueryInterface</NAME>
#define IDeckLinkDeckControlStatusCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControlStatusCallback_AddRef</NAME>
#define IDeckLinkDeckControlStatusCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControlStatusCallback_Release</NAME>
#define IDeckLinkDeckControlStatusCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControlStatusCallback_TimecodeUpdate</NAME>
#define IDeckLinkDeckControlStatusCallback_TimecodeUpdate(This,currentTimecode)	\
    ( (This)->lpVtbl -> TimecodeUpdate(This,currentTimecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControlStatusCallback_VTRControlStateChanged</NAME>
#define IDeckLinkDeckControlStatusCallback_VTRControlStateChanged(This,newState,error)	\
    ( (This)->lpVtbl -> VTRControlStateChanged(This,newState,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControlStatusCallback_DeckControlEventReceived</NAME>
#define IDeckLinkDeckControlStatusCallback_DeckControlEventReceived(This,event,error)	\
    ( (This)->lpVtbl -> DeckControlEventReceived(This,event,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControlStatusCallback_DeckControlStatusChanged</NAME>
#define IDeckLinkDeckControlStatusCallback_DeckControlStatusChanged(This,flags,mask)	\
    ( (This)->lpVtbl -> DeckControlStatusChanged(This,flags,mask) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_QueryInterface</NAME>
#define IDeckLinkDeckControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_AddRef</NAME>
#define IDeckLinkDeckControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_Release</NAME>
#define IDeckLinkDeckControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_Open</NAME>
#define IDeckLinkDeckControl_Open(This,timeScale,timeValue,timecodeIsDropFrame,error)	\
    ( (This)->lpVtbl -> Open(This,timeScale,timeValue,timecodeIsDropFrame,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_Close</NAME>
#define IDeckLinkDeckControl_Close(This,standbyOn)	\
    ( (This)->lpVtbl -> Close(This,standbyOn) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_GetCurrentState</NAME>
#define IDeckLinkDeckControl_GetCurrentState(This,mode,vtrControlState,flags)	\
    ( (This)->lpVtbl -> GetCurrentState(This,mode,vtrControlState,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_SetStandby</NAME>
#define IDeckLinkDeckControl_SetStandby(This,standbyOn)	\
    ( (This)->lpVtbl -> SetStandby(This,standbyOn) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_SendCommand</NAME>
#define IDeckLinkDeckControl_SendCommand(This,inBuffer,inBufferSize,outBuffer,outDataSize,outBufferSize,error)	\
    ( (This)->lpVtbl -> SendCommand(This,inBuffer,inBufferSize,outBuffer,outDataSize,outBufferSize,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_Play</NAME>
#define IDeckLinkDeckControl_Play(This,error)	\
    ( (This)->lpVtbl -> Play(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_Stop</NAME>
#define IDeckLinkDeckControl_Stop(This,error)	\
    ( (This)->lpVtbl -> Stop(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_TogglePlayStop</NAME>
#define IDeckLinkDeckControl_TogglePlayStop(This,error)	\
    ( (This)->lpVtbl -> TogglePlayStop(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_Eject</NAME>
#define IDeckLinkDeckControl_Eject(This,error)	\
    ( (This)->lpVtbl -> Eject(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_GoToTimecode</NAME>
#define IDeckLinkDeckControl_GoToTimecode(This,timecode,error)	\
    ( (This)->lpVtbl -> GoToTimecode(This,timecode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_FastForward</NAME>
#define IDeckLinkDeckControl_FastForward(This,viewTape,error)	\
    ( (This)->lpVtbl -> FastForward(This,viewTape,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_Rewind</NAME>
#define IDeckLinkDeckControl_Rewind(This,viewTape,error)	\
    ( (This)->lpVtbl -> Rewind(This,viewTape,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_StepForward</NAME>
#define IDeckLinkDeckControl_StepForward(This,error)	\
    ( (This)->lpVtbl -> StepForward(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_StepBack</NAME>
#define IDeckLinkDeckControl_StepBack(This,error)	\
    ( (This)->lpVtbl -> StepBack(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_Jog</NAME>
#define IDeckLinkDeckControl_Jog(This,rate,error)	\
    ( (This)->lpVtbl -> Jog(This,rate,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_Shuttle</NAME>
#define IDeckLinkDeckControl_Shuttle(This,rate,error)	\
    ( (This)->lpVtbl -> Shuttle(This,rate,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_GetTimecodeString</NAME>
#define IDeckLinkDeckControl_GetTimecodeString(This,currentTimeCode,error)	\
    ( (This)->lpVtbl -> GetTimecodeString(This,currentTimeCode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_GetTimecode</NAME>
#define IDeckLinkDeckControl_GetTimecode(This,currentTimecode,error)	\
    ( (This)->lpVtbl -> GetTimecode(This,currentTimecode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_GetTimecodeBCD</NAME>
#define IDeckLinkDeckControl_GetTimecodeBCD(This,currentTimecode,error)	\
    ( (This)->lpVtbl -> GetTimecodeBCD(This,currentTimecode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_SetPreroll</NAME>
#define IDeckLinkDeckControl_SetPreroll(This,prerollSeconds)	\
    ( (This)->lpVtbl -> SetPreroll(This,prerollSeconds) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_GetPreroll</NAME>
#define IDeckLinkDeckControl_GetPreroll(This,prerollSeconds)	\
    ( (This)->lpVtbl -> GetPreroll(This,prerollSeconds) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_SetExportOffset</NAME>
#define IDeckLinkDeckControl_SetExportOffset(This,exportOffsetFields)	\
    ( (This)->lpVtbl -> SetExportOffset(This,exportOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_GetExportOffset</NAME>
#define IDeckLinkDeckControl_GetExportOffset(This,exportOffsetFields)	\
    ( (This)->lpVtbl -> GetExportOffset(This,exportOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_GetManualExportOffset</NAME>
#define IDeckLinkDeckControl_GetManualExportOffset(This,deckManualExportOffsetFields)	\
    ( (This)->lpVtbl -> GetManualExportOffset(This,deckManualExportOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_SetCaptureOffset</NAME>
#define IDeckLinkDeckControl_SetCaptureOffset(This,captureOffsetFields)	\
    ( (This)->lpVtbl -> SetCaptureOffset(This,captureOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_GetCaptureOffset</NAME>
#define IDeckLinkDeckControl_GetCaptureOffset(This,captureOffsetFields)	\
    ( (This)->lpVtbl -> GetCaptureOffset(This,captureOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_StartExport</NAME>
#define IDeckLinkDeckControl_StartExport(This,inTimecode,outTimecode,exportModeOps,error)	\
    ( (This)->lpVtbl -> StartExport(This,inTimecode,outTimecode,exportModeOps,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_StartCapture</NAME>
#define IDeckLinkDeckControl_StartCapture(This,useVITC,inTimecode,outTimecode,error)	\
    ( (This)->lpVtbl -> StartCapture(This,useVITC,inTimecode,outTimecode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_GetDeviceID</NAME>
#define IDeckLinkDeckControl_GetDeviceID(This,deviceId,error)	\
    ( (This)->lpVtbl -> GetDeviceID(This,deviceId,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_Abort</NAME>
#define IDeckLinkDeckControl_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_CrashRecordStart</NAME>
#define IDeckLinkDeckControl_CrashRecordStart(This,error)	\
    ( (This)->lpVtbl -> CrashRecordStart(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_CrashRecordStop</NAME>
#define IDeckLinkDeckControl_CrashRecordStop(This,error)	\
    ( (This)->lpVtbl -> CrashRecordStop(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_SetCallback</NAME>
#define IDeckLinkDeckControl_SetCallback(This,callback)	\
    ( (This)->lpVtbl -> SetCallback(This,callback) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceNotificationCallback_QueryInterface</NAME>
#define IBMDStreamingDeviceNotificationCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceNotificationCallback_AddRef</NAME>
#define IBMDStreamingDeviceNotificationCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceNotificationCallback_Release</NAME>
#define IBMDStreamingDeviceNotificationCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceNotificationCallback_StreamingDeviceArrived</NAME>
#define IBMDStreamingDeviceNotificationCallback_StreamingDeviceArrived(This,device)	\
    ( (This)->lpVtbl -> StreamingDeviceArrived(This,device) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceNotificationCallback_StreamingDeviceRemoved</NAME>
#define IBMDStreamingDeviceNotificationCallback_StreamingDeviceRemoved(This,device)	\
    ( (This)->lpVtbl -> StreamingDeviceRemoved(This,device) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceNotificationCallback_StreamingDeviceModeChanged</NAME>
#define IBMDStreamingDeviceNotificationCallback_StreamingDeviceModeChanged(This,device,mode)	\
    ( (This)->lpVtbl -> StreamingDeviceModeChanged(This,device,mode) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264InputCallback_QueryInterface</NAME>
#define IBMDStreamingH264InputCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264InputCallback_AddRef</NAME>
#define IBMDStreamingH264InputCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264InputCallback_Release</NAME>
#define IBMDStreamingH264InputCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264InputCallback_H264NALPacketArrived</NAME>
#define IBMDStreamingH264InputCallback_H264NALPacketArrived(This,nalPacket)	\
    ( (This)->lpVtbl -> H264NALPacketArrived(This,nalPacket) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264InputCallback_H264AudioPacketArrived</NAME>
#define IBMDStreamingH264InputCallback_H264AudioPacketArrived(This,audioPacket)	\
    ( (This)->lpVtbl -> H264AudioPacketArrived(This,audioPacket) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264InputCallback_MPEG2TSPacketArrived</NAME>
#define IBMDStreamingH264InputCallback_MPEG2TSPacketArrived(This,tsPacket)	\
    ( (This)->lpVtbl -> MPEG2TSPacketArrived(This,tsPacket) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264InputCallback_H264VideoInputConnectorScanningChanged</NAME>
#define IBMDStreamingH264InputCallback_H264VideoInputConnectorScanningChanged(This)	\
    ( (This)->lpVtbl -> H264VideoInputConnectorScanningChanged(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264InputCallback_H264VideoInputConnectorChanged</NAME>
#define IBMDStreamingH264InputCallback_H264VideoInputConnectorChanged(This)	\
    ( (This)->lpVtbl -> H264VideoInputConnectorChanged(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264InputCallback_H264VideoInputModeChanged</NAME>
#define IBMDStreamingH264InputCallback_H264VideoInputModeChanged(This)	\
    ( (This)->lpVtbl -> H264VideoInputModeChanged(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDiscovery_QueryInterface</NAME>
#define IBMDStreamingDiscovery_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDiscovery_AddRef</NAME>
#define IBMDStreamingDiscovery_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDiscovery_Release</NAME>
#define IBMDStreamingDiscovery_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDiscovery_InstallDeviceNotifications</NAME>
#define IBMDStreamingDiscovery_InstallDeviceNotifications(This,theCallback)	\
    ( (This)->lpVtbl -> InstallDeviceNotifications(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDiscovery_UninstallDeviceNotifications</NAME>
#define IBMDStreamingDiscovery_UninstallDeviceNotifications(This)	\
    ( (This)->lpVtbl -> UninstallDeviceNotifications(This) ) 
</MACRO>
<FUNCTION>
<NAME>int</NAME>
<RETURNS>unsigned  </RETURNS>
 STDMETHODCALLTYPE *GetPresetID )( IBMDStreamingVideoEncodingMode * This
</FUNCTION>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_QueryInterface</NAME>
#define IBMDStreamingVideoEncodingMode_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_AddRef</NAME>
#define IBMDStreamingVideoEncodingMode_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_Release</NAME>
#define IBMDStreamingVideoEncodingMode_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_GetName</NAME>
#define IBMDStreamingVideoEncodingMode_GetName(This,name)	\
    ( (This)->lpVtbl -> GetName(This,name) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_GetPresetID</NAME>
#define IBMDStreamingVideoEncodingMode_GetPresetID(This)	\
    ( (This)->lpVtbl -> GetPresetID(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_GetSourcePositionX</NAME>
#define IBMDStreamingVideoEncodingMode_GetSourcePositionX(This)	\
    ( (This)->lpVtbl -> GetSourcePositionX(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_GetSourcePositionY</NAME>
#define IBMDStreamingVideoEncodingMode_GetSourcePositionY(This)	\
    ( (This)->lpVtbl -> GetSourcePositionY(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_GetSourceWidth</NAME>
#define IBMDStreamingVideoEncodingMode_GetSourceWidth(This)	\
    ( (This)->lpVtbl -> GetSourceWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_GetSourceHeight</NAME>
#define IBMDStreamingVideoEncodingMode_GetSourceHeight(This)	\
    ( (This)->lpVtbl -> GetSourceHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_GetDestWidth</NAME>
#define IBMDStreamingVideoEncodingMode_GetDestWidth(This)	\
    ( (This)->lpVtbl -> GetDestWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_GetDestHeight</NAME>
#define IBMDStreamingVideoEncodingMode_GetDestHeight(This)	\
    ( (This)->lpVtbl -> GetDestHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_GetFlag</NAME>
#define IBMDStreamingVideoEncodingMode_GetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_GetInt</NAME>
#define IBMDStreamingVideoEncodingMode_GetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_GetFloat</NAME>
#define IBMDStreamingVideoEncodingMode_GetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_GetString</NAME>
#define IBMDStreamingVideoEncodingMode_GetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingMode_CreateMutableVideoEncodingMode</NAME>
#define IBMDStreamingVideoEncodingMode_CreateMutableVideoEncodingMode(This,newEncodingMode)	\
    ( (This)->lpVtbl -> CreateMutableVideoEncodingMode(This,newEncodingMode) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_QueryInterface</NAME>
#define IBMDStreamingMutableVideoEncodingMode_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_AddRef</NAME>
#define IBMDStreamingMutableVideoEncodingMode_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_Release</NAME>
#define IBMDStreamingMutableVideoEncodingMode_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_GetName</NAME>
#define IBMDStreamingMutableVideoEncodingMode_GetName(This,name)	\
    ( (This)->lpVtbl -> GetName(This,name) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_GetPresetID</NAME>
#define IBMDStreamingMutableVideoEncodingMode_GetPresetID(This)	\
    ( (This)->lpVtbl -> GetPresetID(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_GetSourcePositionX</NAME>
#define IBMDStreamingMutableVideoEncodingMode_GetSourcePositionX(This)	\
    ( (This)->lpVtbl -> GetSourcePositionX(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_GetSourcePositionY</NAME>
#define IBMDStreamingMutableVideoEncodingMode_GetSourcePositionY(This)	\
    ( (This)->lpVtbl -> GetSourcePositionY(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_GetSourceWidth</NAME>
#define IBMDStreamingMutableVideoEncodingMode_GetSourceWidth(This)	\
    ( (This)->lpVtbl -> GetSourceWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_GetSourceHeight</NAME>
#define IBMDStreamingMutableVideoEncodingMode_GetSourceHeight(This)	\
    ( (This)->lpVtbl -> GetSourceHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_GetDestWidth</NAME>
#define IBMDStreamingMutableVideoEncodingMode_GetDestWidth(This)	\
    ( (This)->lpVtbl -> GetDestWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_GetDestHeight</NAME>
#define IBMDStreamingMutableVideoEncodingMode_GetDestHeight(This)	\
    ( (This)->lpVtbl -> GetDestHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_GetFlag</NAME>
#define IBMDStreamingMutableVideoEncodingMode_GetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_GetInt</NAME>
#define IBMDStreamingMutableVideoEncodingMode_GetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_GetFloat</NAME>
#define IBMDStreamingMutableVideoEncodingMode_GetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_GetString</NAME>
#define IBMDStreamingMutableVideoEncodingMode_GetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_CreateMutableVideoEncodingMode</NAME>
#define IBMDStreamingMutableVideoEncodingMode_CreateMutableVideoEncodingMode(This,newEncodingMode)	\
    ( (This)->lpVtbl -> CreateMutableVideoEncodingMode(This,newEncodingMode) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_SetSourceRect</NAME>
#define IBMDStreamingMutableVideoEncodingMode_SetSourceRect(This,posX,posY,width,height)	\
    ( (This)->lpVtbl -> SetSourceRect(This,posX,posY,width,height) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_SetDestSize</NAME>
#define IBMDStreamingMutableVideoEncodingMode_SetDestSize(This,width,height)	\
    ( (This)->lpVtbl -> SetDestSize(This,width,height) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_SetFlag</NAME>
#define IBMDStreamingMutableVideoEncodingMode_SetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_SetInt</NAME>
#define IBMDStreamingMutableVideoEncodingMode_SetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_SetFloat</NAME>
#define IBMDStreamingMutableVideoEncodingMode_SetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMutableVideoEncodingMode_SetString</NAME>
#define IBMDStreamingMutableVideoEncodingMode_SetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingModePresetIterator_QueryInterface</NAME>
#define IBMDStreamingVideoEncodingModePresetIterator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingModePresetIterator_AddRef</NAME>
#define IBMDStreamingVideoEncodingModePresetIterator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingModePresetIterator_Release</NAME>
#define IBMDStreamingVideoEncodingModePresetIterator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingVideoEncodingModePresetIterator_Next</NAME>
#define IBMDStreamingVideoEncodingModePresetIterator_Next(This,videoEncodingMode)	\
    ( (This)->lpVtbl -> Next(This,videoEncodingMode) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceInput_QueryInterface</NAME>
#define IBMDStreamingDeviceInput_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceInput_AddRef</NAME>
#define IBMDStreamingDeviceInput_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceInput_Release</NAME>
#define IBMDStreamingDeviceInput_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceInput_DoesSupportVideoInputMode</NAME>
#define IBMDStreamingDeviceInput_DoesSupportVideoInputMode(This,inputMode,result)	\
    ( (This)->lpVtbl -> DoesSupportVideoInputMode(This,inputMode,result) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceInput_GetVideoInputModeIterator</NAME>
#define IBMDStreamingDeviceInput_GetVideoInputModeIterator(This,iterator)	\
    ( (This)->lpVtbl -> GetVideoInputModeIterator(This,iterator) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceInput_SetVideoInputMode</NAME>
#define IBMDStreamingDeviceInput_SetVideoInputMode(This,inputMode)	\
    ( (This)->lpVtbl -> SetVideoInputMode(This,inputMode) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceInput_GetCurrentDetectedVideoInputMode</NAME>
#define IBMDStreamingDeviceInput_GetCurrentDetectedVideoInputMode(This,detectedMode)	\
    ( (This)->lpVtbl -> GetCurrentDetectedVideoInputMode(This,detectedMode) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceInput_GetVideoEncodingMode</NAME>
#define IBMDStreamingDeviceInput_GetVideoEncodingMode(This,encodingMode)	\
    ( (This)->lpVtbl -> GetVideoEncodingMode(This,encodingMode) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceInput_GetVideoEncodingModePresetIterator</NAME>
#define IBMDStreamingDeviceInput_GetVideoEncodingModePresetIterator(This,inputMode,iterator)	\
    ( (This)->lpVtbl -> GetVideoEncodingModePresetIterator(This,inputMode,iterator) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceInput_DoesSupportVideoEncodingMode</NAME>
#define IBMDStreamingDeviceInput_DoesSupportVideoEncodingMode(This,inputMode,encodingMode,result,changedEncodingMode)	\
    ( (This)->lpVtbl -> DoesSupportVideoEncodingMode(This,inputMode,encodingMode,result,changedEncodingMode) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceInput_SetVideoEncodingMode</NAME>
#define IBMDStreamingDeviceInput_SetVideoEncodingMode(This,encodingMode)	\
    ( (This)->lpVtbl -> SetVideoEncodingMode(This,encodingMode) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceInput_StartCapture</NAME>
#define IBMDStreamingDeviceInput_StartCapture(This)	\
    ( (This)->lpVtbl -> StartCapture(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceInput_StopCapture</NAME>
#define IBMDStreamingDeviceInput_StopCapture(This)	\
    ( (This)->lpVtbl -> StopCapture(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingDeviceInput_SetCallback</NAME>
#define IBMDStreamingDeviceInput_SetCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264NALPacket_QueryInterface</NAME>
#define IBMDStreamingH264NALPacket_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264NALPacket_AddRef</NAME>
#define IBMDStreamingH264NALPacket_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264NALPacket_Release</NAME>
#define IBMDStreamingH264NALPacket_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264NALPacket_GetPayloadSize</NAME>
#define IBMDStreamingH264NALPacket_GetPayloadSize(This)	\
    ( (This)->lpVtbl -> GetPayloadSize(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264NALPacket_GetBytes</NAME>
#define IBMDStreamingH264NALPacket_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264NALPacket_GetBytesWithSizePrefix</NAME>
#define IBMDStreamingH264NALPacket_GetBytesWithSizePrefix(This,buffer)	\
    ( (This)->lpVtbl -> GetBytesWithSizePrefix(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264NALPacket_GetDisplayTime</NAME>
#define IBMDStreamingH264NALPacket_GetDisplayTime(This,requestedTimeScale,displayTime)	\
    ( (This)->lpVtbl -> GetDisplayTime(This,requestedTimeScale,displayTime) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264NALPacket_GetPacketIndex</NAME>
#define IBMDStreamingH264NALPacket_GetPacketIndex(This,packetIndex)	\
    ( (This)->lpVtbl -> GetPacketIndex(This,packetIndex) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingAudioPacket_QueryInterface</NAME>
#define IBMDStreamingAudioPacket_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingAudioPacket_AddRef</NAME>
#define IBMDStreamingAudioPacket_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingAudioPacket_Release</NAME>
#define IBMDStreamingAudioPacket_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingAudioPacket_GetCodec</NAME>
#define IBMDStreamingAudioPacket_GetCodec(This)	\
    ( (This)->lpVtbl -> GetCodec(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingAudioPacket_GetPayloadSize</NAME>
#define IBMDStreamingAudioPacket_GetPayloadSize(This)	\
    ( (This)->lpVtbl -> GetPayloadSize(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingAudioPacket_GetBytes</NAME>
#define IBMDStreamingAudioPacket_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingAudioPacket_GetPlayTime</NAME>
#define IBMDStreamingAudioPacket_GetPlayTime(This,requestedTimeScale,playTime)	\
    ( (This)->lpVtbl -> GetPlayTime(This,requestedTimeScale,playTime) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingAudioPacket_GetPacketIndex</NAME>
#define IBMDStreamingAudioPacket_GetPacketIndex(This,packetIndex)	\
    ( (This)->lpVtbl -> GetPacketIndex(This,packetIndex) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMPEG2TSPacket_QueryInterface</NAME>
#define IBMDStreamingMPEG2TSPacket_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMPEG2TSPacket_AddRef</NAME>
#define IBMDStreamingMPEG2TSPacket_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMPEG2TSPacket_Release</NAME>
#define IBMDStreamingMPEG2TSPacket_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMPEG2TSPacket_GetPayloadSize</NAME>
#define IBMDStreamingMPEG2TSPacket_GetPayloadSize(This)	\
    ( (This)->lpVtbl -> GetPayloadSize(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingMPEG2TSPacket_GetBytes</NAME>
#define IBMDStreamingMPEG2TSPacket_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264NALParser_QueryInterface</NAME>
#define IBMDStreamingH264NALParser_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264NALParser_AddRef</NAME>
#define IBMDStreamingH264NALParser_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264NALParser_Release</NAME>
#define IBMDStreamingH264NALParser_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264NALParser_IsNALSequenceParameterSet</NAME>
#define IBMDStreamingH264NALParser_IsNALSequenceParameterSet(This,nal)	\
    ( (This)->lpVtbl -> IsNALSequenceParameterSet(This,nal) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264NALParser_IsNALPictureParameterSet</NAME>
#define IBMDStreamingH264NALParser_IsNALPictureParameterSet(This,nal)	\
    ( (This)->lpVtbl -> IsNALPictureParameterSet(This,nal) ) 
</MACRO>
<MACRO>
<NAME>IBMDStreamingH264NALParser_GetProfileAndLevelFromSPS</NAME>
#define IBMDStreamingH264NALParser_GetProfileAndLevelFromSPS(This,nal,profileIdc,profileCompatability,levelIdc)	\
    ( (This)->lpVtbl -> GetProfileAndLevelFromSPS(This,nal,profileIdc,profileCompatability,levelIdc) ) 
</MACRO>
<FUNCTION>
<NAME>DECLSPEC_UUID</NAME>
<RETURNS>class  </RETURNS>
"0CAA31F6-8A26-40B0-86A4-BF58DCCA710C") CBMDStreamingDiscovery; #endif EXTERN_C const CLSID CLSID_CBMDStreamingH264NALParser; #ifdef __cplusplus class DECLSPEC_UUID("7753EFBD-951C-407C-97A5-23C737B73B52") CBMDStreamingH264NALParser; #endif #ifndef __IDeckLinkVideoOutputCallback_INTERFACE_DEFINED__ #define __IDeckLinkVideoOutputCallback_INTERFACE_DEFINED__ EXTERN_C const IID IID_IDeckLinkVideoOutputCallback; #if defined(__cplusplus) && !defined(CINTERFACE) MIDL_INTERFACE("20AA5225-1958-47CB-820B-80A8D521A6EE") IDeckLinkVideoOutputCallback : public IUnknown { public: virtual HRESULT STDMETHODCALLTYPE ScheduledFrameCompleted( IDeckLinkVideoFrame *completedFrame, BMDOutputFrameCompletionResult result) = 0; virtual HRESULT STDMETHODCALLTYPE ScheduledPlaybackHasStopped( void) = 0; }; #else typedef struct IDeckLinkVideoOutputCallbackVtbl { BEGIN_INTERFACE HRESULT ( STDMETHODCALLTYPE *QueryInterface )( IDeckLinkVideoOutputCallback * This, REFIID riid, _COM_Outptr_  void **ppvObject
</FUNCTION>
<MACRO>
<NAME>IDeckLinkVideoOutputCallback_QueryInterface</NAME>
#define IDeckLinkVideoOutputCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoOutputCallback_AddRef</NAME>
#define IDeckLinkVideoOutputCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoOutputCallback_Release</NAME>
#define IDeckLinkVideoOutputCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoOutputCallback_ScheduledFrameCompleted</NAME>
#define IDeckLinkVideoOutputCallback_ScheduledFrameCompleted(This,completedFrame,result)	\
    ( (This)->lpVtbl -> ScheduledFrameCompleted(This,completedFrame,result) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoOutputCallback_ScheduledPlaybackHasStopped</NAME>
#define IDeckLinkVideoOutputCallback_ScheduledPlaybackHasStopped(This)	\
    ( (This)->lpVtbl -> ScheduledPlaybackHasStopped(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_QueryInterface</NAME>
#define IDeckLinkInputCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_AddRef</NAME>
#define IDeckLinkInputCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_Release</NAME>
#define IDeckLinkInputCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_VideoInputFormatChanged</NAME>
#define IDeckLinkInputCallback_VideoInputFormatChanged(This,notificationEvents,newDisplayMode,detectedSignalFlags)	\
    ( (This)->lpVtbl -> VideoInputFormatChanged(This,notificationEvents,newDisplayMode,detectedSignalFlags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_VideoInputFrameArrived</NAME>
#define IDeckLinkInputCallback_VideoInputFrameArrived(This,videoFrame,audioPacket)	\
    ( (This)->lpVtbl -> VideoInputFrameArrived(This,videoFrame,audioPacket) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInputCallback_QueryInterface</NAME>
#define IDeckLinkEncoderInputCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInputCallback_AddRef</NAME>
#define IDeckLinkEncoderInputCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInputCallback_Release</NAME>
#define IDeckLinkEncoderInputCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInputCallback_VideoInputSignalChanged</NAME>
#define IDeckLinkEncoderInputCallback_VideoInputSignalChanged(This,notificationEvents,newDisplayMode,detectedSignalFlags)	\
    ( (This)->lpVtbl -> VideoInputSignalChanged(This,notificationEvents,newDisplayMode,detectedSignalFlags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInputCallback_VideoPacketArrived</NAME>
#define IDeckLinkEncoderInputCallback_VideoPacketArrived(This,videoPacket)	\
    ( (This)->lpVtbl -> VideoPacketArrived(This,videoPacket) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInputCallback_AudioPacketArrived</NAME>
#define IDeckLinkEncoderInputCallback_AudioPacketArrived(This,audioPacket)	\
    ( (This)->lpVtbl -> AudioPacketArrived(This,audioPacket) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMemoryAllocator_QueryInterface</NAME>
#define IDeckLinkMemoryAllocator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMemoryAllocator_AddRef</NAME>
#define IDeckLinkMemoryAllocator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMemoryAllocator_Release</NAME>
#define IDeckLinkMemoryAllocator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMemoryAllocator_AllocateBuffer</NAME>
#define IDeckLinkMemoryAllocator_AllocateBuffer(This,bufferSize,allocatedBuffer)	\
    ( (This)->lpVtbl -> AllocateBuffer(This,bufferSize,allocatedBuffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMemoryAllocator_ReleaseBuffer</NAME>
#define IDeckLinkMemoryAllocator_ReleaseBuffer(This,buffer)	\
    ( (This)->lpVtbl -> ReleaseBuffer(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMemoryAllocator_Commit</NAME>
#define IDeckLinkMemoryAllocator_Commit(This)	\
    ( (This)->lpVtbl -> Commit(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMemoryAllocator_Decommit</NAME>
#define IDeckLinkMemoryAllocator_Decommit(This)	\
    ( (This)->lpVtbl -> Decommit(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioOutputCallback_QueryInterface</NAME>
#define IDeckLinkAudioOutputCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioOutputCallback_AddRef</NAME>
#define IDeckLinkAudioOutputCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioOutputCallback_Release</NAME>
#define IDeckLinkAudioOutputCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioOutputCallback_RenderAudioSamples</NAME>
#define IDeckLinkAudioOutputCallback_RenderAudioSamples(This,preroll)	\
    ( (This)->lpVtbl -> RenderAudioSamples(This,preroll) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkIterator_QueryInterface</NAME>
#define IDeckLinkIterator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkIterator_AddRef</NAME>
#define IDeckLinkIterator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkIterator_Release</NAME>
#define IDeckLinkIterator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkIterator_Next</NAME>
#define IDeckLinkIterator_Next(This,deckLinkInstance)	\
    ( (This)->lpVtbl -> Next(This,deckLinkInstance) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAPIInformation_QueryInterface</NAME>
#define IDeckLinkAPIInformation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAPIInformation_AddRef</NAME>
#define IDeckLinkAPIInformation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAPIInformation_Release</NAME>
#define IDeckLinkAPIInformation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAPIInformation_GetFlag</NAME>
#define IDeckLinkAPIInformation_GetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAPIInformation_GetInt</NAME>
#define IDeckLinkAPIInformation_GetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAPIInformation_GetFloat</NAME>
#define IDeckLinkAPIInformation_GetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAPIInformation_GetString</NAME>
#define IDeckLinkAPIInformation_GetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_QueryInterface</NAME>
#define IDeckLinkOutput_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_AddRef</NAME>
#define IDeckLinkOutput_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_Release</NAME>
#define IDeckLinkOutput_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_DoesSupportVideoMode</NAME>
#define IDeckLinkOutput_DoesSupportVideoMode(This,displayMode,pixelFormat,flags,result,resultDisplayMode)	\
    ( (This)->lpVtbl -> DoesSupportVideoMode(This,displayMode,pixelFormat,flags,result,resultDisplayMode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_GetDisplayModeIterator</NAME>
#define IDeckLinkOutput_GetDisplayModeIterator(This,iterator)	\
    ( (This)->lpVtbl -> GetDisplayModeIterator(This,iterator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_SetScreenPreviewCallback</NAME>
#define IDeckLinkOutput_SetScreenPreviewCallback(This,previewCallback)	\
    ( (This)->lpVtbl -> SetScreenPreviewCallback(This,previewCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_EnableVideoOutput</NAME>
#define IDeckLinkOutput_EnableVideoOutput(This,displayMode,flags)	\
    ( (This)->lpVtbl -> EnableVideoOutput(This,displayMode,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_DisableVideoOutput</NAME>
#define IDeckLinkOutput_DisableVideoOutput(This)	\
    ( (This)->lpVtbl -> DisableVideoOutput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_SetVideoOutputFrameMemoryAllocator</NAME>
#define IDeckLinkOutput_SetVideoOutputFrameMemoryAllocator(This,theAllocator)	\
    ( (This)->lpVtbl -> SetVideoOutputFrameMemoryAllocator(This,theAllocator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_CreateVideoFrame</NAME>
#define IDeckLinkOutput_CreateVideoFrame(This,width,height,rowBytes,pixelFormat,flags,outFrame)	\
    ( (This)->lpVtbl -> CreateVideoFrame(This,width,height,rowBytes,pixelFormat,flags,outFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_CreateAncillaryData</NAME>
#define IDeckLinkOutput_CreateAncillaryData(This,pixelFormat,outBuffer)	\
    ( (This)->lpVtbl -> CreateAncillaryData(This,pixelFormat,outBuffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_DisplayVideoFrameSync</NAME>
#define IDeckLinkOutput_DisplayVideoFrameSync(This,theFrame)	\
    ( (This)->lpVtbl -> DisplayVideoFrameSync(This,theFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_ScheduleVideoFrame</NAME>
#define IDeckLinkOutput_ScheduleVideoFrame(This,theFrame,displayTime,displayDuration,timeScale)	\
    ( (This)->lpVtbl -> ScheduleVideoFrame(This,theFrame,displayTime,displayDuration,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_SetScheduledFrameCompletionCallback</NAME>
#define IDeckLinkOutput_SetScheduledFrameCompletionCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetScheduledFrameCompletionCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_GetBufferedVideoFrameCount</NAME>
#define IDeckLinkOutput_GetBufferedVideoFrameCount(This,bufferedFrameCount)	\
    ( (This)->lpVtbl -> GetBufferedVideoFrameCount(This,bufferedFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_EnableAudioOutput</NAME>
#define IDeckLinkOutput_EnableAudioOutput(This,sampleRate,sampleType,channelCount,streamType)	\
    ( (This)->lpVtbl -> EnableAudioOutput(This,sampleRate,sampleType,channelCount,streamType) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_DisableAudioOutput</NAME>
#define IDeckLinkOutput_DisableAudioOutput(This)	\
    ( (This)->lpVtbl -> DisableAudioOutput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_WriteAudioSamplesSync</NAME>
#define IDeckLinkOutput_WriteAudioSamplesSync(This,buffer,sampleFrameCount,sampleFramesWritten)	\
    ( (This)->lpVtbl -> WriteAudioSamplesSync(This,buffer,sampleFrameCount,sampleFramesWritten) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_BeginAudioPreroll</NAME>
#define IDeckLinkOutput_BeginAudioPreroll(This)	\
    ( (This)->lpVtbl -> BeginAudioPreroll(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_EndAudioPreroll</NAME>
#define IDeckLinkOutput_EndAudioPreroll(This)	\
    ( (This)->lpVtbl -> EndAudioPreroll(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_ScheduleAudioSamples</NAME>
#define IDeckLinkOutput_ScheduleAudioSamples(This,buffer,sampleFrameCount,streamTime,timeScale,sampleFramesWritten)	\
    ( (This)->lpVtbl -> ScheduleAudioSamples(This,buffer,sampleFrameCount,streamTime,timeScale,sampleFramesWritten) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_GetBufferedAudioSampleFrameCount</NAME>
#define IDeckLinkOutput_GetBufferedAudioSampleFrameCount(This,bufferedSampleFrameCount)	\
    ( (This)->lpVtbl -> GetBufferedAudioSampleFrameCount(This,bufferedSampleFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_FlushBufferedAudioSamples</NAME>
#define IDeckLinkOutput_FlushBufferedAudioSamples(This)	\
    ( (This)->lpVtbl -> FlushBufferedAudioSamples(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_SetAudioCallback</NAME>
#define IDeckLinkOutput_SetAudioCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetAudioCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_StartScheduledPlayback</NAME>
#define IDeckLinkOutput_StartScheduledPlayback(This,playbackStartTime,timeScale,playbackSpeed)	\
    ( (This)->lpVtbl -> StartScheduledPlayback(This,playbackStartTime,timeScale,playbackSpeed) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_StopScheduledPlayback</NAME>
#define IDeckLinkOutput_StopScheduledPlayback(This,stopPlaybackAtTime,actualStopTime,timeScale)	\
    ( (This)->lpVtbl -> StopScheduledPlayback(This,stopPlaybackAtTime,actualStopTime,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_IsScheduledPlaybackRunning</NAME>
#define IDeckLinkOutput_IsScheduledPlaybackRunning(This,active)	\
    ( (This)->lpVtbl -> IsScheduledPlaybackRunning(This,active) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_GetScheduledStreamTime</NAME>
#define IDeckLinkOutput_GetScheduledStreamTime(This,desiredTimeScale,streamTime,playbackSpeed)	\
    ( (This)->lpVtbl -> GetScheduledStreamTime(This,desiredTimeScale,streamTime,playbackSpeed) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_GetReferenceStatus</NAME>
#define IDeckLinkOutput_GetReferenceStatus(This,referenceStatus)	\
    ( (This)->lpVtbl -> GetReferenceStatus(This,referenceStatus) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_GetHardwareReferenceClock</NAME>
#define IDeckLinkOutput_GetHardwareReferenceClock(This,desiredTimeScale,hardwareTime,timeInFrame,ticksPerFrame)	\
    ( (This)->lpVtbl -> GetHardwareReferenceClock(This,desiredTimeScale,hardwareTime,timeInFrame,ticksPerFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_GetFrameCompletionReferenceTimestamp</NAME>
#define IDeckLinkOutput_GetFrameCompletionReferenceTimestamp(This,theFrame,desiredTimeScale,frameCompletionTimestamp)	\
    ( (This)->lpVtbl -> GetFrameCompletionReferenceTimestamp(This,theFrame,desiredTimeScale,frameCompletionTimestamp) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_QueryInterface</NAME>
#define IDeckLinkInput_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_AddRef</NAME>
#define IDeckLinkInput_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_Release</NAME>
#define IDeckLinkInput_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_DoesSupportVideoMode</NAME>
#define IDeckLinkInput_DoesSupportVideoMode(This,displayMode,pixelFormat,flags,result,resultDisplayMode)	\
    ( (This)->lpVtbl -> DoesSupportVideoMode(This,displayMode,pixelFormat,flags,result,resultDisplayMode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_GetDisplayModeIterator</NAME>
#define IDeckLinkInput_GetDisplayModeIterator(This,iterator)	\
    ( (This)->lpVtbl -> GetDisplayModeIterator(This,iterator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_SetScreenPreviewCallback</NAME>
#define IDeckLinkInput_SetScreenPreviewCallback(This,previewCallback)	\
    ( (This)->lpVtbl -> SetScreenPreviewCallback(This,previewCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_EnableVideoInput</NAME>
#define IDeckLinkInput_EnableVideoInput(This,displayMode,pixelFormat,flags)	\
    ( (This)->lpVtbl -> EnableVideoInput(This,displayMode,pixelFormat,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_DisableVideoInput</NAME>
#define IDeckLinkInput_DisableVideoInput(This)	\
    ( (This)->lpVtbl -> DisableVideoInput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_GetAvailableVideoFrameCount</NAME>
#define IDeckLinkInput_GetAvailableVideoFrameCount(This,availableFrameCount)	\
    ( (This)->lpVtbl -> GetAvailableVideoFrameCount(This,availableFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_SetVideoInputFrameMemoryAllocator</NAME>
#define IDeckLinkInput_SetVideoInputFrameMemoryAllocator(This,theAllocator)	\
    ( (This)->lpVtbl -> SetVideoInputFrameMemoryAllocator(This,theAllocator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_EnableAudioInput</NAME>
#define IDeckLinkInput_EnableAudioInput(This,sampleRate,sampleType,channelCount)	\
    ( (This)->lpVtbl -> EnableAudioInput(This,sampleRate,sampleType,channelCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_DisableAudioInput</NAME>
#define IDeckLinkInput_DisableAudioInput(This)	\
    ( (This)->lpVtbl -> DisableAudioInput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_GetAvailableAudioSampleFrameCount</NAME>
#define IDeckLinkInput_GetAvailableAudioSampleFrameCount(This,availableSampleFrameCount)	\
    ( (This)->lpVtbl -> GetAvailableAudioSampleFrameCount(This,availableSampleFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_StartStreams</NAME>
#define IDeckLinkInput_StartStreams(This)	\
    ( (This)->lpVtbl -> StartStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_StopStreams</NAME>
#define IDeckLinkInput_StopStreams(This)	\
    ( (This)->lpVtbl -> StopStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_PauseStreams</NAME>
#define IDeckLinkInput_PauseStreams(This)	\
    ( (This)->lpVtbl -> PauseStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_FlushStreams</NAME>
#define IDeckLinkInput_FlushStreams(This)	\
    ( (This)->lpVtbl -> FlushStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_SetCallback</NAME>
#define IDeckLinkInput_SetCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_GetHardwareReferenceClock</NAME>
#define IDeckLinkInput_GetHardwareReferenceClock(This,desiredTimeScale,hardwareTime,timeInFrame,ticksPerFrame)	\
    ( (This)->lpVtbl -> GetHardwareReferenceClock(This,desiredTimeScale,hardwareTime,timeInFrame,ticksPerFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_QueryInterface</NAME>
#define IDeckLinkEncoderInput_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_AddRef</NAME>
#define IDeckLinkEncoderInput_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_Release</NAME>
#define IDeckLinkEncoderInput_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_DoesSupportVideoMode</NAME>
#define IDeckLinkEncoderInput_DoesSupportVideoMode(This,displayMode,pixelFormat,flags,result,resultDisplayMode)	\
    ( (This)->lpVtbl -> DoesSupportVideoMode(This,displayMode,pixelFormat,flags,result,resultDisplayMode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_GetDisplayModeIterator</NAME>
#define IDeckLinkEncoderInput_GetDisplayModeIterator(This,iterator)	\
    ( (This)->lpVtbl -> GetDisplayModeIterator(This,iterator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_EnableVideoInput</NAME>
#define IDeckLinkEncoderInput_EnableVideoInput(This,displayMode,pixelFormat,flags)	\
    ( (This)->lpVtbl -> EnableVideoInput(This,displayMode,pixelFormat,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_DisableVideoInput</NAME>
#define IDeckLinkEncoderInput_DisableVideoInput(This)	\
    ( (This)->lpVtbl -> DisableVideoInput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_GetAvailablePacketsCount</NAME>
#define IDeckLinkEncoderInput_GetAvailablePacketsCount(This,availablePacketsCount)	\
    ( (This)->lpVtbl -> GetAvailablePacketsCount(This,availablePacketsCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_SetMemoryAllocator</NAME>
#define IDeckLinkEncoderInput_SetMemoryAllocator(This,theAllocator)	\
    ( (This)->lpVtbl -> SetMemoryAllocator(This,theAllocator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_EnableAudioInput</NAME>
#define IDeckLinkEncoderInput_EnableAudioInput(This,audioFormat,sampleRate,sampleType,channelCount)	\
    ( (This)->lpVtbl -> EnableAudioInput(This,audioFormat,sampleRate,sampleType,channelCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_DisableAudioInput</NAME>
#define IDeckLinkEncoderInput_DisableAudioInput(This)	\
    ( (This)->lpVtbl -> DisableAudioInput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_GetAvailableAudioSampleFrameCount</NAME>
#define IDeckLinkEncoderInput_GetAvailableAudioSampleFrameCount(This,availableSampleFrameCount)	\
    ( (This)->lpVtbl -> GetAvailableAudioSampleFrameCount(This,availableSampleFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_StartStreams</NAME>
#define IDeckLinkEncoderInput_StartStreams(This)	\
    ( (This)->lpVtbl -> StartStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_StopStreams</NAME>
#define IDeckLinkEncoderInput_StopStreams(This)	\
    ( (This)->lpVtbl -> StopStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_PauseStreams</NAME>
#define IDeckLinkEncoderInput_PauseStreams(This)	\
    ( (This)->lpVtbl -> PauseStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_FlushStreams</NAME>
#define IDeckLinkEncoderInput_FlushStreams(This)	\
    ( (This)->lpVtbl -> FlushStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_SetCallback</NAME>
#define IDeckLinkEncoderInput_SetCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderInput_GetHardwareReferenceClock</NAME>
#define IDeckLinkEncoderInput_GetHardwareReferenceClock(This,desiredTimeScale,hardwareTime,timeInFrame,ticksPerFrame)	\
    ( (This)->lpVtbl -> GetHardwareReferenceClock(This,desiredTimeScale,hardwareTime,timeInFrame,ticksPerFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_QueryInterface</NAME>
#define IDeckLinkVideoFrame_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_AddRef</NAME>
#define IDeckLinkVideoFrame_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_Release</NAME>
#define IDeckLinkVideoFrame_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_GetWidth</NAME>
#define IDeckLinkVideoFrame_GetWidth(This)	\
    ( (This)->lpVtbl -> GetWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_GetHeight</NAME>
#define IDeckLinkVideoFrame_GetHeight(This)	\
    ( (This)->lpVtbl -> GetHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_GetRowBytes</NAME>
#define IDeckLinkVideoFrame_GetRowBytes(This)	\
    ( (This)->lpVtbl -> GetRowBytes(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_GetPixelFormat</NAME>
#define IDeckLinkVideoFrame_GetPixelFormat(This)	\
    ( (This)->lpVtbl -> GetPixelFormat(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_GetFlags</NAME>
#define IDeckLinkVideoFrame_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_GetBytes</NAME>
#define IDeckLinkVideoFrame_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_GetTimecode</NAME>
#define IDeckLinkVideoFrame_GetTimecode(This,format,timecode)	\
    ( (This)->lpVtbl -> GetTimecode(This,format,timecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_GetAncillaryData</NAME>
#define IDeckLinkVideoFrame_GetAncillaryData(This,ancillary)	\
    ( (This)->lpVtbl -> GetAncillaryData(This,ancillary) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_QueryInterface</NAME>
#define IDeckLinkMutableVideoFrame_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_AddRef</NAME>
#define IDeckLinkMutableVideoFrame_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_Release</NAME>
#define IDeckLinkMutableVideoFrame_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_GetWidth</NAME>
#define IDeckLinkMutableVideoFrame_GetWidth(This)	\
    ( (This)->lpVtbl -> GetWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_GetHeight</NAME>
#define IDeckLinkMutableVideoFrame_GetHeight(This)	\
    ( (This)->lpVtbl -> GetHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_GetRowBytes</NAME>
#define IDeckLinkMutableVideoFrame_GetRowBytes(This)	\
    ( (This)->lpVtbl -> GetRowBytes(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_GetPixelFormat</NAME>
#define IDeckLinkMutableVideoFrame_GetPixelFormat(This)	\
    ( (This)->lpVtbl -> GetPixelFormat(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_GetFlags</NAME>
#define IDeckLinkMutableVideoFrame_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_GetBytes</NAME>
#define IDeckLinkMutableVideoFrame_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_GetTimecode</NAME>
#define IDeckLinkMutableVideoFrame_GetTimecode(This,format,timecode)	\
    ( (This)->lpVtbl -> GetTimecode(This,format,timecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_GetAncillaryData</NAME>
#define IDeckLinkMutableVideoFrame_GetAncillaryData(This,ancillary)	\
    ( (This)->lpVtbl -> GetAncillaryData(This,ancillary) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_SetFlags</NAME>
#define IDeckLinkMutableVideoFrame_SetFlags(This,newFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,newFlags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_SetTimecode</NAME>
#define IDeckLinkMutableVideoFrame_SetTimecode(This,format,timecode)	\
    ( (This)->lpVtbl -> SetTimecode(This,format,timecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_SetTimecodeFromComponents</NAME>
#define IDeckLinkMutableVideoFrame_SetTimecodeFromComponents(This,format,hours,minutes,seconds,frames,flags)	\
    ( (This)->lpVtbl -> SetTimecodeFromComponents(This,format,hours,minutes,seconds,frames,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_SetAncillaryData</NAME>
#define IDeckLinkMutableVideoFrame_SetAncillaryData(This,ancillary)	\
    ( (This)->lpVtbl -> SetAncillaryData(This,ancillary) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_SetTimecodeUserBits</NAME>
#define IDeckLinkMutableVideoFrame_SetTimecodeUserBits(This,format,userBits)	\
    ( (This)->lpVtbl -> SetTimecodeUserBits(This,format,userBits) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame3DExtensions_QueryInterface</NAME>
#define IDeckLinkVideoFrame3DExtensions_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame3DExtensions_AddRef</NAME>
#define IDeckLinkVideoFrame3DExtensions_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame3DExtensions_Release</NAME>
#define IDeckLinkVideoFrame3DExtensions_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame3DExtensions_Get3DPackingFormat</NAME>
#define IDeckLinkVideoFrame3DExtensions_Get3DPackingFormat(This)	\
    ( (This)->lpVtbl -> Get3DPackingFormat(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame3DExtensions_GetFrameForRightEye</NAME>
#define IDeckLinkVideoFrame3DExtensions_GetFrameForRightEye(This,rightEyeFrame)	\
    ( (This)->lpVtbl -> GetFrameForRightEye(This,rightEyeFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrameMetadataExtensions_QueryInterface</NAME>
#define IDeckLinkVideoFrameMetadataExtensions_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrameMetadataExtensions_AddRef</NAME>
#define IDeckLinkVideoFrameMetadataExtensions_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrameMetadataExtensions_Release</NAME>
#define IDeckLinkVideoFrameMetadataExtensions_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrameMetadataExtensions_GetInt</NAME>
#define IDeckLinkVideoFrameMetadataExtensions_GetInt(This,metadataID,value)	\
    ( (This)->lpVtbl -> GetInt(This,metadataID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrameMetadataExtensions_GetFloat</NAME>
#define IDeckLinkVideoFrameMetadataExtensions_GetFloat(This,metadataID,value)	\
    ( (This)->lpVtbl -> GetFloat(This,metadataID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrameMetadataExtensions_GetFlag</NAME>
#define IDeckLinkVideoFrameMetadataExtensions_GetFlag(This,metadataID,value)	\
    ( (This)->lpVtbl -> GetFlag(This,metadataID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrameMetadataExtensions_GetString</NAME>
#define IDeckLinkVideoFrameMetadataExtensions_GetString(This,metadataID,value)	\
    ( (This)->lpVtbl -> GetString(This,metadataID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_QueryInterface</NAME>
#define IDeckLinkVideoInputFrame_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_AddRef</NAME>
#define IDeckLinkVideoInputFrame_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_Release</NAME>
#define IDeckLinkVideoInputFrame_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_GetWidth</NAME>
#define IDeckLinkVideoInputFrame_GetWidth(This)	\
    ( (This)->lpVtbl -> GetWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_GetHeight</NAME>
#define IDeckLinkVideoInputFrame_GetHeight(This)	\
    ( (This)->lpVtbl -> GetHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_GetRowBytes</NAME>
#define IDeckLinkVideoInputFrame_GetRowBytes(This)	\
    ( (This)->lpVtbl -> GetRowBytes(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_GetPixelFormat</NAME>
#define IDeckLinkVideoInputFrame_GetPixelFormat(This)	\
    ( (This)->lpVtbl -> GetPixelFormat(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_GetFlags</NAME>
#define IDeckLinkVideoInputFrame_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_GetBytes</NAME>
#define IDeckLinkVideoInputFrame_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_GetTimecode</NAME>
#define IDeckLinkVideoInputFrame_GetTimecode(This,format,timecode)	\
    ( (This)->lpVtbl -> GetTimecode(This,format,timecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_GetAncillaryData</NAME>
#define IDeckLinkVideoInputFrame_GetAncillaryData(This,ancillary)	\
    ( (This)->lpVtbl -> GetAncillaryData(This,ancillary) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_GetStreamTime</NAME>
#define IDeckLinkVideoInputFrame_GetStreamTime(This,frameTime,frameDuration,timeScale)	\
    ( (This)->lpVtbl -> GetStreamTime(This,frameTime,frameDuration,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_GetHardwareReferenceTimestamp</NAME>
#define IDeckLinkVideoInputFrame_GetHardwareReferenceTimestamp(This,timeScale,frameTime,frameDuration)	\
    ( (This)->lpVtbl -> GetHardwareReferenceTimestamp(This,timeScale,frameTime,frameDuration) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrameAncillary_QueryInterface</NAME>
#define IDeckLinkVideoFrameAncillary_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrameAncillary_AddRef</NAME>
#define IDeckLinkVideoFrameAncillary_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrameAncillary_Release</NAME>
#define IDeckLinkVideoFrameAncillary_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrameAncillary_GetBufferForVerticalBlankingLine</NAME>
#define IDeckLinkVideoFrameAncillary_GetBufferForVerticalBlankingLine(This,lineNumber,buffer)	\
    ( (This)->lpVtbl -> GetBufferForVerticalBlankingLine(This,lineNumber,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrameAncillary_GetPixelFormat</NAME>
#define IDeckLinkVideoFrameAncillary_GetPixelFormat(This)	\
    ( (This)->lpVtbl -> GetPixelFormat(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrameAncillary_GetDisplayMode</NAME>
#define IDeckLinkVideoFrameAncillary_GetDisplayMode(This)	\
    ( (This)->lpVtbl -> GetDisplayMode(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderPacket_QueryInterface</NAME>
#define IDeckLinkEncoderPacket_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderPacket_AddRef</NAME>
#define IDeckLinkEncoderPacket_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderPacket_Release</NAME>
#define IDeckLinkEncoderPacket_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderPacket_GetBytes</NAME>
#define IDeckLinkEncoderPacket_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderPacket_GetSize</NAME>
#define IDeckLinkEncoderPacket_GetSize(This)	\
    ( (This)->lpVtbl -> GetSize(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderPacket_GetStreamTime</NAME>
#define IDeckLinkEncoderPacket_GetStreamTime(This,frameTime,timeScale)	\
    ( (This)->lpVtbl -> GetStreamTime(This,frameTime,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderPacket_GetPacketType</NAME>
#define IDeckLinkEncoderPacket_GetPacketType(This)	\
    ( (This)->lpVtbl -> GetPacketType(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderVideoPacket_QueryInterface</NAME>
#define IDeckLinkEncoderVideoPacket_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderVideoPacket_AddRef</NAME>
#define IDeckLinkEncoderVideoPacket_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderVideoPacket_Release</NAME>
#define IDeckLinkEncoderVideoPacket_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderVideoPacket_GetBytes</NAME>
#define IDeckLinkEncoderVideoPacket_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderVideoPacket_GetSize</NAME>
#define IDeckLinkEncoderVideoPacket_GetSize(This)	\
    ( (This)->lpVtbl -> GetSize(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderVideoPacket_GetStreamTime</NAME>
#define IDeckLinkEncoderVideoPacket_GetStreamTime(This,frameTime,timeScale)	\
    ( (This)->lpVtbl -> GetStreamTime(This,frameTime,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderVideoPacket_GetPacketType</NAME>
#define IDeckLinkEncoderVideoPacket_GetPacketType(This)	\
    ( (This)->lpVtbl -> GetPacketType(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderVideoPacket_GetPixelFormat</NAME>
#define IDeckLinkEncoderVideoPacket_GetPixelFormat(This)	\
    ( (This)->lpVtbl -> GetPixelFormat(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderVideoPacket_GetHardwareReferenceTimestamp</NAME>
#define IDeckLinkEncoderVideoPacket_GetHardwareReferenceTimestamp(This,timeScale,frameTime,frameDuration)	\
    ( (This)->lpVtbl -> GetHardwareReferenceTimestamp(This,timeScale,frameTime,frameDuration) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderVideoPacket_GetTimecode</NAME>
#define IDeckLinkEncoderVideoPacket_GetTimecode(This,format,timecode)	\
    ( (This)->lpVtbl -> GetTimecode(This,format,timecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderAudioPacket_QueryInterface</NAME>
#define IDeckLinkEncoderAudioPacket_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderAudioPacket_AddRef</NAME>
#define IDeckLinkEncoderAudioPacket_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderAudioPacket_Release</NAME>
#define IDeckLinkEncoderAudioPacket_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderAudioPacket_GetBytes</NAME>
#define IDeckLinkEncoderAudioPacket_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderAudioPacket_GetSize</NAME>
#define IDeckLinkEncoderAudioPacket_GetSize(This)	\
    ( (This)->lpVtbl -> GetSize(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderAudioPacket_GetStreamTime</NAME>
#define IDeckLinkEncoderAudioPacket_GetStreamTime(This,frameTime,timeScale)	\
    ( (This)->lpVtbl -> GetStreamTime(This,frameTime,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderAudioPacket_GetPacketType</NAME>
#define IDeckLinkEncoderAudioPacket_GetPacketType(This)	\
    ( (This)->lpVtbl -> GetPacketType(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderAudioPacket_GetAudioFormat</NAME>
#define IDeckLinkEncoderAudioPacket_GetAudioFormat(This)	\
    ( (This)->lpVtbl -> GetAudioFormat(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkH265NALPacket_QueryInterface</NAME>
#define IDeckLinkH265NALPacket_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkH265NALPacket_AddRef</NAME>
#define IDeckLinkH265NALPacket_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkH265NALPacket_Release</NAME>
#define IDeckLinkH265NALPacket_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkH265NALPacket_GetBytes</NAME>
#define IDeckLinkH265NALPacket_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkH265NALPacket_GetSize</NAME>
#define IDeckLinkH265NALPacket_GetSize(This)	\
    ( (This)->lpVtbl -> GetSize(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkH265NALPacket_GetStreamTime</NAME>
#define IDeckLinkH265NALPacket_GetStreamTime(This,frameTime,timeScale)	\
    ( (This)->lpVtbl -> GetStreamTime(This,frameTime,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkH265NALPacket_GetPacketType</NAME>
#define IDeckLinkH265NALPacket_GetPacketType(This)	\
    ( (This)->lpVtbl -> GetPacketType(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkH265NALPacket_GetPixelFormat</NAME>
#define IDeckLinkH265NALPacket_GetPixelFormat(This)	\
    ( (This)->lpVtbl -> GetPixelFormat(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkH265NALPacket_GetHardwareReferenceTimestamp</NAME>
#define IDeckLinkH265NALPacket_GetHardwareReferenceTimestamp(This,timeScale,frameTime,frameDuration)	\
    ( (This)->lpVtbl -> GetHardwareReferenceTimestamp(This,timeScale,frameTime,frameDuration) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkH265NALPacket_GetTimecode</NAME>
#define IDeckLinkH265NALPacket_GetTimecode(This,format,timecode)	\
    ( (This)->lpVtbl -> GetTimecode(This,format,timecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkH265NALPacket_GetUnitType</NAME>
#define IDeckLinkH265NALPacket_GetUnitType(This,unitType)	\
    ( (This)->lpVtbl -> GetUnitType(This,unitType) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkH265NALPacket_GetBytesNoPrefix</NAME>
#define IDeckLinkH265NALPacket_GetBytesNoPrefix(This,buffer)	\
    ( (This)->lpVtbl -> GetBytesNoPrefix(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkH265NALPacket_GetSizeNoPrefix</NAME>
#define IDeckLinkH265NALPacket_GetSizeNoPrefix(This)	\
    ( (This)->lpVtbl -> GetSizeNoPrefix(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioInputPacket_QueryInterface</NAME>
#define IDeckLinkAudioInputPacket_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioInputPacket_AddRef</NAME>
#define IDeckLinkAudioInputPacket_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioInputPacket_Release</NAME>
#define IDeckLinkAudioInputPacket_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioInputPacket_GetSampleFrameCount</NAME>
#define IDeckLinkAudioInputPacket_GetSampleFrameCount(This)	\
    ( (This)->lpVtbl -> GetSampleFrameCount(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioInputPacket_GetBytes</NAME>
#define IDeckLinkAudioInputPacket_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioInputPacket_GetPacketTime</NAME>
#define IDeckLinkAudioInputPacket_GetPacketTime(This,packetTime,timeScale)	\
    ( (This)->lpVtbl -> GetPacketTime(This,packetTime,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkScreenPreviewCallback_QueryInterface</NAME>
#define IDeckLinkScreenPreviewCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkScreenPreviewCallback_AddRef</NAME>
#define IDeckLinkScreenPreviewCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkScreenPreviewCallback_Release</NAME>
#define IDeckLinkScreenPreviewCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkScreenPreviewCallback_DrawFrame</NAME>
#define IDeckLinkScreenPreviewCallback_DrawFrame(This,theFrame)	\
    ( (This)->lpVtbl -> DrawFrame(This,theFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkGLScreenPreviewHelper_QueryInterface</NAME>
#define IDeckLinkGLScreenPreviewHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkGLScreenPreviewHelper_AddRef</NAME>
#define IDeckLinkGLScreenPreviewHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkGLScreenPreviewHelper_Release</NAME>
#define IDeckLinkGLScreenPreviewHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkGLScreenPreviewHelper_InitializeGL</NAME>
#define IDeckLinkGLScreenPreviewHelper_InitializeGL(This)	\
    ( (This)->lpVtbl -> InitializeGL(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkGLScreenPreviewHelper_PaintGL</NAME>
#define IDeckLinkGLScreenPreviewHelper_PaintGL(This)	\
    ( (This)->lpVtbl -> PaintGL(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkGLScreenPreviewHelper_SetFrame</NAME>
#define IDeckLinkGLScreenPreviewHelper_SetFrame(This,theFrame)	\
    ( (This)->lpVtbl -> SetFrame(This,theFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkGLScreenPreviewHelper_Set3DPreviewFormat</NAME>
#define IDeckLinkGLScreenPreviewHelper_Set3DPreviewFormat(This,previewFormat)	\
    ( (This)->lpVtbl -> Set3DPreviewFormat(This,previewFormat) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDX9ScreenPreviewHelper_QueryInterface</NAME>
#define IDeckLinkDX9ScreenPreviewHelper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDX9ScreenPreviewHelper_AddRef</NAME>
#define IDeckLinkDX9ScreenPreviewHelper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDX9ScreenPreviewHelper_Release</NAME>
#define IDeckLinkDX9ScreenPreviewHelper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDX9ScreenPreviewHelper_Initialize</NAME>
#define IDeckLinkDX9ScreenPreviewHelper_Initialize(This,device)	\
    ( (This)->lpVtbl -> Initialize(This,device) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDX9ScreenPreviewHelper_Render</NAME>
#define IDeckLinkDX9ScreenPreviewHelper_Render(This,rc)	\
    ( (This)->lpVtbl -> Render(This,rc) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDX9ScreenPreviewHelper_SetFrame</NAME>
#define IDeckLinkDX9ScreenPreviewHelper_SetFrame(This,theFrame)	\
    ( (This)->lpVtbl -> SetFrame(This,theFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDX9ScreenPreviewHelper_Set3DPreviewFormat</NAME>
#define IDeckLinkDX9ScreenPreviewHelper_Set3DPreviewFormat(This,previewFormat)	\
    ( (This)->lpVtbl -> Set3DPreviewFormat(This,previewFormat) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkNotificationCallback_QueryInterface</NAME>
#define IDeckLinkNotificationCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkNotificationCallback_AddRef</NAME>
#define IDeckLinkNotificationCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkNotificationCallback_Release</NAME>
#define IDeckLinkNotificationCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkNotificationCallback_Notify</NAME>
#define IDeckLinkNotificationCallback_Notify(This,topic,param1,param2)	\
    ( (This)->lpVtbl -> Notify(This,topic,param1,param2) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkNotification_QueryInterface</NAME>
#define IDeckLinkNotification_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkNotification_AddRef</NAME>
#define IDeckLinkNotification_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkNotification_Release</NAME>
#define IDeckLinkNotification_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkNotification_Subscribe</NAME>
#define IDeckLinkNotification_Subscribe(This,topic,theCallback)	\
    ( (This)->lpVtbl -> Subscribe(This,topic,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkNotification_Unsubscribe</NAME>
#define IDeckLinkNotification_Unsubscribe(This,topic,theCallback)	\
    ( (This)->lpVtbl -> Unsubscribe(This,topic,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAttributes_QueryInterface</NAME>
#define IDeckLinkAttributes_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAttributes_AddRef</NAME>
#define IDeckLinkAttributes_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAttributes_Release</NAME>
#define IDeckLinkAttributes_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAttributes_GetFlag</NAME>
#define IDeckLinkAttributes_GetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAttributes_GetInt</NAME>
#define IDeckLinkAttributes_GetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAttributes_GetFloat</NAME>
#define IDeckLinkAttributes_GetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAttributes_GetString</NAME>
#define IDeckLinkAttributes_GetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkStatus_QueryInterface</NAME>
#define IDeckLinkStatus_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkStatus_AddRef</NAME>
#define IDeckLinkStatus_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkStatus_Release</NAME>
#define IDeckLinkStatus_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkStatus_GetFlag</NAME>
#define IDeckLinkStatus_GetFlag(This,statusID,value)	\
    ( (This)->lpVtbl -> GetFlag(This,statusID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkStatus_GetInt</NAME>
#define IDeckLinkStatus_GetInt(This,statusID,value)	\
    ( (This)->lpVtbl -> GetInt(This,statusID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkStatus_GetFloat</NAME>
#define IDeckLinkStatus_GetFloat(This,statusID,value)	\
    ( (This)->lpVtbl -> GetFloat(This,statusID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkStatus_GetString</NAME>
#define IDeckLinkStatus_GetString(This,statusID,value)	\
    ( (This)->lpVtbl -> GetString(This,statusID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkStatus_GetBytes</NAME>
#define IDeckLinkStatus_GetBytes(This,statusID,buffer,bufferSize)	\
    ( (This)->lpVtbl -> GetBytes(This,statusID,buffer,bufferSize) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkKeyer_QueryInterface</NAME>
#define IDeckLinkKeyer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkKeyer_AddRef</NAME>
#define IDeckLinkKeyer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkKeyer_Release</NAME>
#define IDeckLinkKeyer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkKeyer_Enable</NAME>
#define IDeckLinkKeyer_Enable(This,isExternal)	\
    ( (This)->lpVtbl -> Enable(This,isExternal) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkKeyer_SetLevel</NAME>
#define IDeckLinkKeyer_SetLevel(This,level)	\
    ( (This)->lpVtbl -> SetLevel(This,level) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkKeyer_RampUp</NAME>
#define IDeckLinkKeyer_RampUp(This,numberOfFrames)	\
    ( (This)->lpVtbl -> RampUp(This,numberOfFrames) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkKeyer_RampDown</NAME>
#define IDeckLinkKeyer_RampDown(This,numberOfFrames)	\
    ( (This)->lpVtbl -> RampDown(This,numberOfFrames) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkKeyer_Disable</NAME>
#define IDeckLinkKeyer_Disable(This)	\
    ( (This)->lpVtbl -> Disable(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoConversion_QueryInterface</NAME>
#define IDeckLinkVideoConversion_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoConversion_AddRef</NAME>
#define IDeckLinkVideoConversion_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoConversion_Release</NAME>
#define IDeckLinkVideoConversion_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoConversion_ConvertFrame</NAME>
#define IDeckLinkVideoConversion_ConvertFrame(This,srcFrame,dstFrame)	\
    ( (This)->lpVtbl -> ConvertFrame(This,srcFrame,dstFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeviceNotificationCallback_QueryInterface</NAME>
#define IDeckLinkDeviceNotificationCallback_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeviceNotificationCallback_AddRef</NAME>
#define IDeckLinkDeviceNotificationCallback_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeviceNotificationCallback_Release</NAME>
#define IDeckLinkDeviceNotificationCallback_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeviceNotificationCallback_DeckLinkDeviceArrived</NAME>
#define IDeckLinkDeviceNotificationCallback_DeckLinkDeviceArrived(This,deckLinkDevice)	\
    ( (This)->lpVtbl -> DeckLinkDeviceArrived(This,deckLinkDevice) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeviceNotificationCallback_DeckLinkDeviceRemoved</NAME>
#define IDeckLinkDeviceNotificationCallback_DeckLinkDeviceRemoved(This,deckLinkDevice)	\
    ( (This)->lpVtbl -> DeckLinkDeviceRemoved(This,deckLinkDevice) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDiscovery_QueryInterface</NAME>
#define IDeckLinkDiscovery_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDiscovery_AddRef</NAME>
#define IDeckLinkDiscovery_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDiscovery_Release</NAME>
#define IDeckLinkDiscovery_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDiscovery_InstallDeviceNotifications</NAME>
#define IDeckLinkDiscovery_InstallDeviceNotifications(This,deviceNotificationCallback)	\
    ( (This)->lpVtbl -> InstallDeviceNotifications(This,deviceNotificationCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDiscovery_UninstallDeviceNotifications</NAME>
#define IDeckLinkDiscovery_UninstallDeviceNotifications(This)	\
    ( (This)->lpVtbl -> UninstallDeviceNotifications(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_v10_5_QueryInterface</NAME>
#define IDeckLinkEncoderConfiguration_v10_5_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_v10_5_AddRef</NAME>
#define IDeckLinkEncoderConfiguration_v10_5_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_v10_5_Release</NAME>
#define IDeckLinkEncoderConfiguration_v10_5_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_v10_5_SetFlag</NAME>
#define IDeckLinkEncoderConfiguration_v10_5_SetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_v10_5_GetFlag</NAME>
#define IDeckLinkEncoderConfiguration_v10_5_GetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_v10_5_SetInt</NAME>
#define IDeckLinkEncoderConfiguration_v10_5_SetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_v10_5_GetInt</NAME>
#define IDeckLinkEncoderConfiguration_v10_5_GetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_v10_5_SetFloat</NAME>
#define IDeckLinkEncoderConfiguration_v10_5_SetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_v10_5_GetFloat</NAME>
#define IDeckLinkEncoderConfiguration_v10_5_GetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_v10_5_SetString</NAME>
#define IDeckLinkEncoderConfiguration_v10_5_SetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_v10_5_GetString</NAME>
#define IDeckLinkEncoderConfiguration_v10_5_GetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkEncoderConfiguration_v10_5_GetDecoderConfigurationInfo</NAME>
#define IDeckLinkEncoderConfiguration_v10_5_GetDecoderConfigurationInfo(This,buffer,bufferSize,returnedSize)	\
    ( (This)->lpVtbl -> GetDecoderConfigurationInfo(This,buffer,bufferSize,returnedSize) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_4_QueryInterface</NAME>
#define IDeckLinkConfiguration_v10_4_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_4_AddRef</NAME>
#define IDeckLinkConfiguration_v10_4_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_4_Release</NAME>
#define IDeckLinkConfiguration_v10_4_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_4_SetFlag</NAME>
#define IDeckLinkConfiguration_v10_4_SetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_4_GetFlag</NAME>
#define IDeckLinkConfiguration_v10_4_GetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_4_SetInt</NAME>
#define IDeckLinkConfiguration_v10_4_SetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_4_GetInt</NAME>
#define IDeckLinkConfiguration_v10_4_GetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_4_SetFloat</NAME>
#define IDeckLinkConfiguration_v10_4_SetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_4_GetFloat</NAME>
#define IDeckLinkConfiguration_v10_4_GetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_4_SetString</NAME>
#define IDeckLinkConfiguration_v10_4_SetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_4_GetString</NAME>
#define IDeckLinkConfiguration_v10_4_GetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_4_WriteConfigurationToPreferences</NAME>
#define IDeckLinkConfiguration_v10_4_WriteConfigurationToPreferences(This)	\
    ( (This)->lpVtbl -> WriteConfigurationToPreferences(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_2_QueryInterface</NAME>
#define IDeckLinkConfiguration_v10_2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_2_AddRef</NAME>
#define IDeckLinkConfiguration_v10_2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_2_Release</NAME>
#define IDeckLinkConfiguration_v10_2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_2_SetFlag</NAME>
#define IDeckLinkConfiguration_v10_2_SetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_2_GetFlag</NAME>
#define IDeckLinkConfiguration_v10_2_GetFlag(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFlag(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_2_SetInt</NAME>
#define IDeckLinkConfiguration_v10_2_SetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_2_GetInt</NAME>
#define IDeckLinkConfiguration_v10_2_GetInt(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetInt(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_2_SetFloat</NAME>
#define IDeckLinkConfiguration_v10_2_SetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_2_GetFloat</NAME>
#define IDeckLinkConfiguration_v10_2_GetFloat(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetFloat(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_2_SetString</NAME>
#define IDeckLinkConfiguration_v10_2_SetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> SetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_2_GetString</NAME>
#define IDeckLinkConfiguration_v10_2_GetString(This,cfgID,value)	\
    ( (This)->lpVtbl -> GetString(This,cfgID,value) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v10_2_WriteConfigurationToPreferences</NAME>
#define IDeckLinkConfiguration_v10_2_WriteConfigurationToPreferences(This)	\
    ( (This)->lpVtbl -> WriteConfigurationToPreferences(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_QueryInterface</NAME>
#define IDeckLinkOutput_v9_9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_AddRef</NAME>
#define IDeckLinkOutput_v9_9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_Release</NAME>
#define IDeckLinkOutput_v9_9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_DoesSupportVideoMode</NAME>
#define IDeckLinkOutput_v9_9_DoesSupportVideoMode(This,displayMode,pixelFormat,flags,result,resultDisplayMode)	\
    ( (This)->lpVtbl -> DoesSupportVideoMode(This,displayMode,pixelFormat,flags,result,resultDisplayMode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_GetDisplayModeIterator</NAME>
#define IDeckLinkOutput_v9_9_GetDisplayModeIterator(This,iterator)	\
    ( (This)->lpVtbl -> GetDisplayModeIterator(This,iterator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_SetScreenPreviewCallback</NAME>
#define IDeckLinkOutput_v9_9_SetScreenPreviewCallback(This,previewCallback)	\
    ( (This)->lpVtbl -> SetScreenPreviewCallback(This,previewCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_EnableVideoOutput</NAME>
#define IDeckLinkOutput_v9_9_EnableVideoOutput(This,displayMode,flags)	\
    ( (This)->lpVtbl -> EnableVideoOutput(This,displayMode,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_DisableVideoOutput</NAME>
#define IDeckLinkOutput_v9_9_DisableVideoOutput(This)	\
    ( (This)->lpVtbl -> DisableVideoOutput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_SetVideoOutputFrameMemoryAllocator</NAME>
#define IDeckLinkOutput_v9_9_SetVideoOutputFrameMemoryAllocator(This,theAllocator)	\
    ( (This)->lpVtbl -> SetVideoOutputFrameMemoryAllocator(This,theAllocator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_CreateVideoFrame</NAME>
#define IDeckLinkOutput_v9_9_CreateVideoFrame(This,width,height,rowBytes,pixelFormat,flags,outFrame)	\
    ( (This)->lpVtbl -> CreateVideoFrame(This,width,height,rowBytes,pixelFormat,flags,outFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_CreateAncillaryData</NAME>
#define IDeckLinkOutput_v9_9_CreateAncillaryData(This,pixelFormat,outBuffer)	\
    ( (This)->lpVtbl -> CreateAncillaryData(This,pixelFormat,outBuffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_DisplayVideoFrameSync</NAME>
#define IDeckLinkOutput_v9_9_DisplayVideoFrameSync(This,theFrame)	\
    ( (This)->lpVtbl -> DisplayVideoFrameSync(This,theFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_ScheduleVideoFrame</NAME>
#define IDeckLinkOutput_v9_9_ScheduleVideoFrame(This,theFrame,displayTime,displayDuration,timeScale)	\
    ( (This)->lpVtbl -> ScheduleVideoFrame(This,theFrame,displayTime,displayDuration,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_SetScheduledFrameCompletionCallback</NAME>
#define IDeckLinkOutput_v9_9_SetScheduledFrameCompletionCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetScheduledFrameCompletionCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_GetBufferedVideoFrameCount</NAME>
#define IDeckLinkOutput_v9_9_GetBufferedVideoFrameCount(This,bufferedFrameCount)	\
    ( (This)->lpVtbl -> GetBufferedVideoFrameCount(This,bufferedFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_EnableAudioOutput</NAME>
#define IDeckLinkOutput_v9_9_EnableAudioOutput(This,sampleRate,sampleType,channelCount,streamType)	\
    ( (This)->lpVtbl -> EnableAudioOutput(This,sampleRate,sampleType,channelCount,streamType) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_DisableAudioOutput</NAME>
#define IDeckLinkOutput_v9_9_DisableAudioOutput(This)	\
    ( (This)->lpVtbl -> DisableAudioOutput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_WriteAudioSamplesSync</NAME>
#define IDeckLinkOutput_v9_9_WriteAudioSamplesSync(This,buffer,sampleFrameCount,sampleFramesWritten)	\
    ( (This)->lpVtbl -> WriteAudioSamplesSync(This,buffer,sampleFrameCount,sampleFramesWritten) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_BeginAudioPreroll</NAME>
#define IDeckLinkOutput_v9_9_BeginAudioPreroll(This)	\
    ( (This)->lpVtbl -> BeginAudioPreroll(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_EndAudioPreroll</NAME>
#define IDeckLinkOutput_v9_9_EndAudioPreroll(This)	\
    ( (This)->lpVtbl -> EndAudioPreroll(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_ScheduleAudioSamples</NAME>
#define IDeckLinkOutput_v9_9_ScheduleAudioSamples(This,buffer,sampleFrameCount,streamTime,timeScale,sampleFramesWritten)	\
    ( (This)->lpVtbl -> ScheduleAudioSamples(This,buffer,sampleFrameCount,streamTime,timeScale,sampleFramesWritten) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_GetBufferedAudioSampleFrameCount</NAME>
#define IDeckLinkOutput_v9_9_GetBufferedAudioSampleFrameCount(This,bufferedSampleFrameCount)	\
    ( (This)->lpVtbl -> GetBufferedAudioSampleFrameCount(This,bufferedSampleFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_FlushBufferedAudioSamples</NAME>
#define IDeckLinkOutput_v9_9_FlushBufferedAudioSamples(This)	\
    ( (This)->lpVtbl -> FlushBufferedAudioSamples(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_SetAudioCallback</NAME>
#define IDeckLinkOutput_v9_9_SetAudioCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetAudioCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_StartScheduledPlayback</NAME>
#define IDeckLinkOutput_v9_9_StartScheduledPlayback(This,playbackStartTime,timeScale,playbackSpeed)	\
    ( (This)->lpVtbl -> StartScheduledPlayback(This,playbackStartTime,timeScale,playbackSpeed) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_StopScheduledPlayback</NAME>
#define IDeckLinkOutput_v9_9_StopScheduledPlayback(This,stopPlaybackAtTime,actualStopTime,timeScale)	\
    ( (This)->lpVtbl -> StopScheduledPlayback(This,stopPlaybackAtTime,actualStopTime,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_IsScheduledPlaybackRunning</NAME>
#define IDeckLinkOutput_v9_9_IsScheduledPlaybackRunning(This,active)	\
    ( (This)->lpVtbl -> IsScheduledPlaybackRunning(This,active) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_GetScheduledStreamTime</NAME>
#define IDeckLinkOutput_v9_9_GetScheduledStreamTime(This,desiredTimeScale,streamTime,playbackSpeed)	\
    ( (This)->lpVtbl -> GetScheduledStreamTime(This,desiredTimeScale,streamTime,playbackSpeed) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_GetReferenceStatus</NAME>
#define IDeckLinkOutput_v9_9_GetReferenceStatus(This,referenceStatus)	\
    ( (This)->lpVtbl -> GetReferenceStatus(This,referenceStatus) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v9_9_GetHardwareReferenceClock</NAME>
#define IDeckLinkOutput_v9_9_GetHardwareReferenceClock(This,desiredTimeScale,hardwareTime,timeInFrame,ticksPerFrame)	\
    ( (This)->lpVtbl -> GetHardwareReferenceClock(This,desiredTimeScale,hardwareTime,timeInFrame,ticksPerFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_QueryInterface</NAME>
#define IDeckLinkInput_v9_2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_AddRef</NAME>
#define IDeckLinkInput_v9_2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_Release</NAME>
#define IDeckLinkInput_v9_2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_DoesSupportVideoMode</NAME>
#define IDeckLinkInput_v9_2_DoesSupportVideoMode(This,displayMode,pixelFormat,flags,result,resultDisplayMode)	\
    ( (This)->lpVtbl -> DoesSupportVideoMode(This,displayMode,pixelFormat,flags,result,resultDisplayMode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_GetDisplayModeIterator</NAME>
#define IDeckLinkInput_v9_2_GetDisplayModeIterator(This,iterator)	\
    ( (This)->lpVtbl -> GetDisplayModeIterator(This,iterator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_SetScreenPreviewCallback</NAME>
#define IDeckLinkInput_v9_2_SetScreenPreviewCallback(This,previewCallback)	\
    ( (This)->lpVtbl -> SetScreenPreviewCallback(This,previewCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_EnableVideoInput</NAME>
#define IDeckLinkInput_v9_2_EnableVideoInput(This,displayMode,pixelFormat,flags)	\
    ( (This)->lpVtbl -> EnableVideoInput(This,displayMode,pixelFormat,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_DisableVideoInput</NAME>
#define IDeckLinkInput_v9_2_DisableVideoInput(This)	\
    ( (This)->lpVtbl -> DisableVideoInput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_GetAvailableVideoFrameCount</NAME>
#define IDeckLinkInput_v9_2_GetAvailableVideoFrameCount(This,availableFrameCount)	\
    ( (This)->lpVtbl -> GetAvailableVideoFrameCount(This,availableFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_EnableAudioInput</NAME>
#define IDeckLinkInput_v9_2_EnableAudioInput(This,sampleRate,sampleType,channelCount)	\
    ( (This)->lpVtbl -> EnableAudioInput(This,sampleRate,sampleType,channelCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_DisableAudioInput</NAME>
#define IDeckLinkInput_v9_2_DisableAudioInput(This)	\
    ( (This)->lpVtbl -> DisableAudioInput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_GetAvailableAudioSampleFrameCount</NAME>
#define IDeckLinkInput_v9_2_GetAvailableAudioSampleFrameCount(This,availableSampleFrameCount)	\
    ( (This)->lpVtbl -> GetAvailableAudioSampleFrameCount(This,availableSampleFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_StartStreams</NAME>
#define IDeckLinkInput_v9_2_StartStreams(This)	\
    ( (This)->lpVtbl -> StartStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_StopStreams</NAME>
#define IDeckLinkInput_v9_2_StopStreams(This)	\
    ( (This)->lpVtbl -> StopStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_PauseStreams</NAME>
#define IDeckLinkInput_v9_2_PauseStreams(This)	\
    ( (This)->lpVtbl -> PauseStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_FlushStreams</NAME>
#define IDeckLinkInput_v9_2_FlushStreams(This)	\
    ( (This)->lpVtbl -> FlushStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_SetCallback</NAME>
#define IDeckLinkInput_v9_2_SetCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v9_2_GetHardwareReferenceClock</NAME>
#define IDeckLinkInput_v9_2_GetHardwareReferenceClock(This,desiredTimeScale,hardwareTime,timeInFrame,ticksPerFrame)	\
    ( (This)->lpVtbl -> GetHardwareReferenceClock(This,desiredTimeScale,hardwareTime,timeInFrame,ticksPerFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControlStatusCallback_v8_1_QueryInterface</NAME>
#define IDeckLinkDeckControlStatusCallback_v8_1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControlStatusCallback_v8_1_AddRef</NAME>
#define IDeckLinkDeckControlStatusCallback_v8_1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControlStatusCallback_v8_1_Release</NAME>
#define IDeckLinkDeckControlStatusCallback_v8_1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControlStatusCallback_v8_1_TimecodeUpdate</NAME>
#define IDeckLinkDeckControlStatusCallback_v8_1_TimecodeUpdate(This,currentTimecode)	\
    ( (This)->lpVtbl -> TimecodeUpdate(This,currentTimecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControlStatusCallback_v8_1_VTRControlStateChanged</NAME>
#define IDeckLinkDeckControlStatusCallback_v8_1_VTRControlStateChanged(This,newState,error)	\
    ( (This)->lpVtbl -> VTRControlStateChanged(This,newState,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControlStatusCallback_v8_1_DeckControlEventReceived</NAME>
#define IDeckLinkDeckControlStatusCallback_v8_1_DeckControlEventReceived(This,event,error)	\
    ( (This)->lpVtbl -> DeckControlEventReceived(This,event,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControlStatusCallback_v8_1_DeckControlStatusChanged</NAME>
#define IDeckLinkDeckControlStatusCallback_v8_1_DeckControlStatusChanged(This,flags,mask)	\
    ( (This)->lpVtbl -> DeckControlStatusChanged(This,flags,mask) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_QueryInterface</NAME>
#define IDeckLinkDeckControl_v8_1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_AddRef</NAME>
#define IDeckLinkDeckControl_v8_1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_Release</NAME>
#define IDeckLinkDeckControl_v8_1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_Open</NAME>
#define IDeckLinkDeckControl_v8_1_Open(This,timeScale,timeValue,timecodeIsDropFrame,error)	\
    ( (This)->lpVtbl -> Open(This,timeScale,timeValue,timecodeIsDropFrame,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_Close</NAME>
#define IDeckLinkDeckControl_v8_1_Close(This,standbyOn)	\
    ( (This)->lpVtbl -> Close(This,standbyOn) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_GetCurrentState</NAME>
#define IDeckLinkDeckControl_v8_1_GetCurrentState(This,mode,vtrControlState,flags)	\
    ( (This)->lpVtbl -> GetCurrentState(This,mode,vtrControlState,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_SetStandby</NAME>
#define IDeckLinkDeckControl_v8_1_SetStandby(This,standbyOn)	\
    ( (This)->lpVtbl -> SetStandby(This,standbyOn) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_SendCommand</NAME>
#define IDeckLinkDeckControl_v8_1_SendCommand(This,inBuffer,inBufferSize,outBuffer,outDataSize,outBufferSize,error)	\
    ( (This)->lpVtbl -> SendCommand(This,inBuffer,inBufferSize,outBuffer,outDataSize,outBufferSize,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_Play</NAME>
#define IDeckLinkDeckControl_v8_1_Play(This,error)	\
    ( (This)->lpVtbl -> Play(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_Stop</NAME>
#define IDeckLinkDeckControl_v8_1_Stop(This,error)	\
    ( (This)->lpVtbl -> Stop(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_TogglePlayStop</NAME>
#define IDeckLinkDeckControl_v8_1_TogglePlayStop(This,error)	\
    ( (This)->lpVtbl -> TogglePlayStop(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_Eject</NAME>
#define IDeckLinkDeckControl_v8_1_Eject(This,error)	\
    ( (This)->lpVtbl -> Eject(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_GoToTimecode</NAME>
#define IDeckLinkDeckControl_v8_1_GoToTimecode(This,timecode,error)	\
    ( (This)->lpVtbl -> GoToTimecode(This,timecode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_FastForward</NAME>
#define IDeckLinkDeckControl_v8_1_FastForward(This,viewTape,error)	\
    ( (This)->lpVtbl -> FastForward(This,viewTape,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_Rewind</NAME>
#define IDeckLinkDeckControl_v8_1_Rewind(This,viewTape,error)	\
    ( (This)->lpVtbl -> Rewind(This,viewTape,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_StepForward</NAME>
#define IDeckLinkDeckControl_v8_1_StepForward(This,error)	\
    ( (This)->lpVtbl -> StepForward(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_StepBack</NAME>
#define IDeckLinkDeckControl_v8_1_StepBack(This,error)	\
    ( (This)->lpVtbl -> StepBack(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_Jog</NAME>
#define IDeckLinkDeckControl_v8_1_Jog(This,rate,error)	\
    ( (This)->lpVtbl -> Jog(This,rate,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_Shuttle</NAME>
#define IDeckLinkDeckControl_v8_1_Shuttle(This,rate,error)	\
    ( (This)->lpVtbl -> Shuttle(This,rate,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_GetTimecodeString</NAME>
#define IDeckLinkDeckControl_v8_1_GetTimecodeString(This,currentTimeCode,error)	\
    ( (This)->lpVtbl -> GetTimecodeString(This,currentTimeCode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_GetTimecode</NAME>
#define IDeckLinkDeckControl_v8_1_GetTimecode(This,currentTimecode,error)	\
    ( (This)->lpVtbl -> GetTimecode(This,currentTimecode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_GetTimecodeBCD</NAME>
#define IDeckLinkDeckControl_v8_1_GetTimecodeBCD(This,currentTimecode,error)	\
    ( (This)->lpVtbl -> GetTimecodeBCD(This,currentTimecode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_SetPreroll</NAME>
#define IDeckLinkDeckControl_v8_1_SetPreroll(This,prerollSeconds)	\
    ( (This)->lpVtbl -> SetPreroll(This,prerollSeconds) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_GetPreroll</NAME>
#define IDeckLinkDeckControl_v8_1_GetPreroll(This,prerollSeconds)	\
    ( (This)->lpVtbl -> GetPreroll(This,prerollSeconds) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_SetExportOffset</NAME>
#define IDeckLinkDeckControl_v8_1_SetExportOffset(This,exportOffsetFields)	\
    ( (This)->lpVtbl -> SetExportOffset(This,exportOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_GetExportOffset</NAME>
#define IDeckLinkDeckControl_v8_1_GetExportOffset(This,exportOffsetFields)	\
    ( (This)->lpVtbl -> GetExportOffset(This,exportOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_GetManualExportOffset</NAME>
#define IDeckLinkDeckControl_v8_1_GetManualExportOffset(This,deckManualExportOffsetFields)	\
    ( (This)->lpVtbl -> GetManualExportOffset(This,deckManualExportOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_SetCaptureOffset</NAME>
#define IDeckLinkDeckControl_v8_1_SetCaptureOffset(This,captureOffsetFields)	\
    ( (This)->lpVtbl -> SetCaptureOffset(This,captureOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_GetCaptureOffset</NAME>
#define IDeckLinkDeckControl_v8_1_GetCaptureOffset(This,captureOffsetFields)	\
    ( (This)->lpVtbl -> GetCaptureOffset(This,captureOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_StartExport</NAME>
#define IDeckLinkDeckControl_v8_1_StartExport(This,inTimecode,outTimecode,exportModeOps,error)	\
    ( (This)->lpVtbl -> StartExport(This,inTimecode,outTimecode,exportModeOps,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_StartCapture</NAME>
#define IDeckLinkDeckControl_v8_1_StartCapture(This,useVITC,inTimecode,outTimecode,error)	\
    ( (This)->lpVtbl -> StartCapture(This,useVITC,inTimecode,outTimecode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_GetDeviceID</NAME>
#define IDeckLinkDeckControl_v8_1_GetDeviceID(This,deviceId,error)	\
    ( (This)->lpVtbl -> GetDeviceID(This,deviceId,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_Abort</NAME>
#define IDeckLinkDeckControl_v8_1_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_CrashRecordStart</NAME>
#define IDeckLinkDeckControl_v8_1_CrashRecordStart(This,error)	\
    ( (This)->lpVtbl -> CrashRecordStart(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_CrashRecordStop</NAME>
#define IDeckLinkDeckControl_v8_1_CrashRecordStop(This,error)	\
    ( (This)->lpVtbl -> CrashRecordStop(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v8_1_SetCallback</NAME>
#define IDeckLinkDeckControl_v8_1_SetCallback(This,callback)	\
    ( (This)->lpVtbl -> SetCallback(This,callback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLink_v8_0_QueryInterface</NAME>
#define IDeckLink_v8_0_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLink_v8_0_AddRef</NAME>
#define IDeckLink_v8_0_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLink_v8_0_Release</NAME>
#define IDeckLink_v8_0_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLink_v8_0_GetModelName</NAME>
#define IDeckLink_v8_0_GetModelName(This,modelName)	\
    ( (This)->lpVtbl -> GetModelName(This,modelName) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkIterator_v8_0_QueryInterface</NAME>
#define IDeckLinkIterator_v8_0_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkIterator_v8_0_AddRef</NAME>
#define IDeckLinkIterator_v8_0_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkIterator_v8_0_Release</NAME>
#define IDeckLinkIterator_v8_0_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkIterator_v8_0_Next</NAME>
#define IDeckLinkIterator_v8_0_Next(This,deckLinkInstance)	\
    ( (This)->lpVtbl -> Next(This,deckLinkInstance) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_QueryInterface</NAME>
#define IDeckLinkDeckControl_v7_9_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_AddRef</NAME>
#define IDeckLinkDeckControl_v7_9_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_Release</NAME>
#define IDeckLinkDeckControl_v7_9_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_Open</NAME>
#define IDeckLinkDeckControl_v7_9_Open(This,timeScale,timeValue,timecodeIsDropFrame,error)	\
    ( (This)->lpVtbl -> Open(This,timeScale,timeValue,timecodeIsDropFrame,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_Close</NAME>
#define IDeckLinkDeckControl_v7_9_Close(This,standbyOn)	\
    ( (This)->lpVtbl -> Close(This,standbyOn) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_GetCurrentState</NAME>
#define IDeckLinkDeckControl_v7_9_GetCurrentState(This,mode,vtrControlState,flags)	\
    ( (This)->lpVtbl -> GetCurrentState(This,mode,vtrControlState,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_SetStandby</NAME>
#define IDeckLinkDeckControl_v7_9_SetStandby(This,standbyOn)	\
    ( (This)->lpVtbl -> SetStandby(This,standbyOn) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_Play</NAME>
#define IDeckLinkDeckControl_v7_9_Play(This,error)	\
    ( (This)->lpVtbl -> Play(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_Stop</NAME>
#define IDeckLinkDeckControl_v7_9_Stop(This,error)	\
    ( (This)->lpVtbl -> Stop(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_TogglePlayStop</NAME>
#define IDeckLinkDeckControl_v7_9_TogglePlayStop(This,error)	\
    ( (This)->lpVtbl -> TogglePlayStop(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_Eject</NAME>
#define IDeckLinkDeckControl_v7_9_Eject(This,error)	\
    ( (This)->lpVtbl -> Eject(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_GoToTimecode</NAME>
#define IDeckLinkDeckControl_v7_9_GoToTimecode(This,timecode,error)	\
    ( (This)->lpVtbl -> GoToTimecode(This,timecode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_FastForward</NAME>
#define IDeckLinkDeckControl_v7_9_FastForward(This,viewTape,error)	\
    ( (This)->lpVtbl -> FastForward(This,viewTape,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_Rewind</NAME>
#define IDeckLinkDeckControl_v7_9_Rewind(This,viewTape,error)	\
    ( (This)->lpVtbl -> Rewind(This,viewTape,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_StepForward</NAME>
#define IDeckLinkDeckControl_v7_9_StepForward(This,error)	\
    ( (This)->lpVtbl -> StepForward(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_StepBack</NAME>
#define IDeckLinkDeckControl_v7_9_StepBack(This,error)	\
    ( (This)->lpVtbl -> StepBack(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_Jog</NAME>
#define IDeckLinkDeckControl_v7_9_Jog(This,rate,error)	\
    ( (This)->lpVtbl -> Jog(This,rate,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_Shuttle</NAME>
#define IDeckLinkDeckControl_v7_9_Shuttle(This,rate,error)	\
    ( (This)->lpVtbl -> Shuttle(This,rate,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_GetTimecodeString</NAME>
#define IDeckLinkDeckControl_v7_9_GetTimecodeString(This,currentTimeCode,error)	\
    ( (This)->lpVtbl -> GetTimecodeString(This,currentTimeCode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_GetTimecode</NAME>
#define IDeckLinkDeckControl_v7_9_GetTimecode(This,currentTimecode,error)	\
    ( (This)->lpVtbl -> GetTimecode(This,currentTimecode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_GetTimecodeBCD</NAME>
#define IDeckLinkDeckControl_v7_9_GetTimecodeBCD(This,currentTimecode,error)	\
    ( (This)->lpVtbl -> GetTimecodeBCD(This,currentTimecode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_SetPreroll</NAME>
#define IDeckLinkDeckControl_v7_9_SetPreroll(This,prerollSeconds)	\
    ( (This)->lpVtbl -> SetPreroll(This,prerollSeconds) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_GetPreroll</NAME>
#define IDeckLinkDeckControl_v7_9_GetPreroll(This,prerollSeconds)	\
    ( (This)->lpVtbl -> GetPreroll(This,prerollSeconds) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_SetExportOffset</NAME>
#define IDeckLinkDeckControl_v7_9_SetExportOffset(This,exportOffsetFields)	\
    ( (This)->lpVtbl -> SetExportOffset(This,exportOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_GetExportOffset</NAME>
#define IDeckLinkDeckControl_v7_9_GetExportOffset(This,exportOffsetFields)	\
    ( (This)->lpVtbl -> GetExportOffset(This,exportOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_GetManualExportOffset</NAME>
#define IDeckLinkDeckControl_v7_9_GetManualExportOffset(This,deckManualExportOffsetFields)	\
    ( (This)->lpVtbl -> GetManualExportOffset(This,deckManualExportOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_SetCaptureOffset</NAME>
#define IDeckLinkDeckControl_v7_9_SetCaptureOffset(This,captureOffsetFields)	\
    ( (This)->lpVtbl -> SetCaptureOffset(This,captureOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_GetCaptureOffset</NAME>
#define IDeckLinkDeckControl_v7_9_GetCaptureOffset(This,captureOffsetFields)	\
    ( (This)->lpVtbl -> GetCaptureOffset(This,captureOffsetFields) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_StartExport</NAME>
#define IDeckLinkDeckControl_v7_9_StartExport(This,inTimecode,outTimecode,exportModeOps,error)	\
    ( (This)->lpVtbl -> StartExport(This,inTimecode,outTimecode,exportModeOps,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_StartCapture</NAME>
#define IDeckLinkDeckControl_v7_9_StartCapture(This,useVITC,inTimecode,outTimecode,error)	\
    ( (This)->lpVtbl -> StartCapture(This,useVITC,inTimecode,outTimecode,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_GetDeviceID</NAME>
#define IDeckLinkDeckControl_v7_9_GetDeviceID(This,deviceId,error)	\
    ( (This)->lpVtbl -> GetDeviceID(This,deviceId,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_Abort</NAME>
#define IDeckLinkDeckControl_v7_9_Abort(This)	\
    ( (This)->lpVtbl -> Abort(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_CrashRecordStart</NAME>
#define IDeckLinkDeckControl_v7_9_CrashRecordStart(This,error)	\
    ( (This)->lpVtbl -> CrashRecordStart(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_CrashRecordStop</NAME>
#define IDeckLinkDeckControl_v7_9_CrashRecordStop(This,error)	\
    ( (This)->lpVtbl -> CrashRecordStop(This,error) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDeckControl_v7_9_SetCallback</NAME>
#define IDeckLinkDeckControl_v7_9_SetCallback(This,callback)	\
    ( (This)->lpVtbl -> SetCallback(This,callback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayModeIterator_v7_6_QueryInterface</NAME>
#define IDeckLinkDisplayModeIterator_v7_6_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayModeIterator_v7_6_AddRef</NAME>
#define IDeckLinkDisplayModeIterator_v7_6_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayModeIterator_v7_6_Release</NAME>
#define IDeckLinkDisplayModeIterator_v7_6_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayModeIterator_v7_6_Next</NAME>
#define IDeckLinkDisplayModeIterator_v7_6_Next(This,deckLinkDisplayMode)	\
    ( (This)->lpVtbl -> Next(This,deckLinkDisplayMode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_6_QueryInterface</NAME>
#define IDeckLinkDisplayMode_v7_6_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_6_AddRef</NAME>
#define IDeckLinkDisplayMode_v7_6_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_6_Release</NAME>
#define IDeckLinkDisplayMode_v7_6_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_6_GetName</NAME>
#define IDeckLinkDisplayMode_v7_6_GetName(This,name)	\
    ( (This)->lpVtbl -> GetName(This,name) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_6_GetDisplayMode</NAME>
#define IDeckLinkDisplayMode_v7_6_GetDisplayMode(This)	\
    ( (This)->lpVtbl -> GetDisplayMode(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_6_GetWidth</NAME>
#define IDeckLinkDisplayMode_v7_6_GetWidth(This)	\
    ( (This)->lpVtbl -> GetWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_6_GetHeight</NAME>
#define IDeckLinkDisplayMode_v7_6_GetHeight(This)	\
    ( (This)->lpVtbl -> GetHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_6_GetFrameRate</NAME>
#define IDeckLinkDisplayMode_v7_6_GetFrameRate(This,frameDuration,timeScale)	\
    ( (This)->lpVtbl -> GetFrameRate(This,frameDuration,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_6_GetFieldDominance</NAME>
#define IDeckLinkDisplayMode_v7_6_GetFieldDominance(This)	\
    ( (This)->lpVtbl -> GetFieldDominance(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_QueryInterface</NAME>
#define IDeckLinkOutput_v7_6_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_AddRef</NAME>
#define IDeckLinkOutput_v7_6_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_Release</NAME>
#define IDeckLinkOutput_v7_6_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_DoesSupportVideoMode</NAME>
#define IDeckLinkOutput_v7_6_DoesSupportVideoMode(This,displayMode,pixelFormat,result)	\
    ( (This)->lpVtbl -> DoesSupportVideoMode(This,displayMode,pixelFormat,result) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_GetDisplayModeIterator</NAME>
#define IDeckLinkOutput_v7_6_GetDisplayModeIterator(This,iterator)	\
    ( (This)->lpVtbl -> GetDisplayModeIterator(This,iterator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_SetScreenPreviewCallback</NAME>
#define IDeckLinkOutput_v7_6_SetScreenPreviewCallback(This,previewCallback)	\
    ( (This)->lpVtbl -> SetScreenPreviewCallback(This,previewCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_EnableVideoOutput</NAME>
#define IDeckLinkOutput_v7_6_EnableVideoOutput(This,displayMode,flags)	\
    ( (This)->lpVtbl -> EnableVideoOutput(This,displayMode,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_DisableVideoOutput</NAME>
#define IDeckLinkOutput_v7_6_DisableVideoOutput(This)	\
    ( (This)->lpVtbl -> DisableVideoOutput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_SetVideoOutputFrameMemoryAllocator</NAME>
#define IDeckLinkOutput_v7_6_SetVideoOutputFrameMemoryAllocator(This,theAllocator)	\
    ( (This)->lpVtbl -> SetVideoOutputFrameMemoryAllocator(This,theAllocator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_CreateVideoFrame</NAME>
#define IDeckLinkOutput_v7_6_CreateVideoFrame(This,width,height,rowBytes,pixelFormat,flags,outFrame)	\
    ( (This)->lpVtbl -> CreateVideoFrame(This,width,height,rowBytes,pixelFormat,flags,outFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_CreateAncillaryData</NAME>
#define IDeckLinkOutput_v7_6_CreateAncillaryData(This,pixelFormat,outBuffer)	\
    ( (This)->lpVtbl -> CreateAncillaryData(This,pixelFormat,outBuffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_DisplayVideoFrameSync</NAME>
#define IDeckLinkOutput_v7_6_DisplayVideoFrameSync(This,theFrame)	\
    ( (This)->lpVtbl -> DisplayVideoFrameSync(This,theFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_ScheduleVideoFrame</NAME>
#define IDeckLinkOutput_v7_6_ScheduleVideoFrame(This,theFrame,displayTime,displayDuration,timeScale)	\
    ( (This)->lpVtbl -> ScheduleVideoFrame(This,theFrame,displayTime,displayDuration,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_SetScheduledFrameCompletionCallback</NAME>
#define IDeckLinkOutput_v7_6_SetScheduledFrameCompletionCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetScheduledFrameCompletionCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_GetBufferedVideoFrameCount</NAME>
#define IDeckLinkOutput_v7_6_GetBufferedVideoFrameCount(This,bufferedFrameCount)	\
    ( (This)->lpVtbl -> GetBufferedVideoFrameCount(This,bufferedFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_EnableAudioOutput</NAME>
#define IDeckLinkOutput_v7_6_EnableAudioOutput(This,sampleRate,sampleType,channelCount,streamType)	\
    ( (This)->lpVtbl -> EnableAudioOutput(This,sampleRate,sampleType,channelCount,streamType) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_DisableAudioOutput</NAME>
#define IDeckLinkOutput_v7_6_DisableAudioOutput(This)	\
    ( (This)->lpVtbl -> DisableAudioOutput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_WriteAudioSamplesSync</NAME>
#define IDeckLinkOutput_v7_6_WriteAudioSamplesSync(This,buffer,sampleFrameCount,sampleFramesWritten)	\
    ( (This)->lpVtbl -> WriteAudioSamplesSync(This,buffer,sampleFrameCount,sampleFramesWritten) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_BeginAudioPreroll</NAME>
#define IDeckLinkOutput_v7_6_BeginAudioPreroll(This)	\
    ( (This)->lpVtbl -> BeginAudioPreroll(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_EndAudioPreroll</NAME>
#define IDeckLinkOutput_v7_6_EndAudioPreroll(This)	\
    ( (This)->lpVtbl -> EndAudioPreroll(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_ScheduleAudioSamples</NAME>
#define IDeckLinkOutput_v7_6_ScheduleAudioSamples(This,buffer,sampleFrameCount,streamTime,timeScale,sampleFramesWritten)	\
    ( (This)->lpVtbl -> ScheduleAudioSamples(This,buffer,sampleFrameCount,streamTime,timeScale,sampleFramesWritten) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_GetBufferedAudioSampleFrameCount</NAME>
#define IDeckLinkOutput_v7_6_GetBufferedAudioSampleFrameCount(This,bufferedSampleFrameCount)	\
    ( (This)->lpVtbl -> GetBufferedAudioSampleFrameCount(This,bufferedSampleFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_FlushBufferedAudioSamples</NAME>
#define IDeckLinkOutput_v7_6_FlushBufferedAudioSamples(This)	\
    ( (This)->lpVtbl -> FlushBufferedAudioSamples(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_SetAudioCallback</NAME>
#define IDeckLinkOutput_v7_6_SetAudioCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetAudioCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_StartScheduledPlayback</NAME>
#define IDeckLinkOutput_v7_6_StartScheduledPlayback(This,playbackStartTime,timeScale,playbackSpeed)	\
    ( (This)->lpVtbl -> StartScheduledPlayback(This,playbackStartTime,timeScale,playbackSpeed) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_StopScheduledPlayback</NAME>
#define IDeckLinkOutput_v7_6_StopScheduledPlayback(This,stopPlaybackAtTime,actualStopTime,timeScale)	\
    ( (This)->lpVtbl -> StopScheduledPlayback(This,stopPlaybackAtTime,actualStopTime,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_IsScheduledPlaybackRunning</NAME>
#define IDeckLinkOutput_v7_6_IsScheduledPlaybackRunning(This,active)	\
    ( (This)->lpVtbl -> IsScheduledPlaybackRunning(This,active) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_GetScheduledStreamTime</NAME>
#define IDeckLinkOutput_v7_6_GetScheduledStreamTime(This,desiredTimeScale,streamTime,playbackSpeed)	\
    ( (This)->lpVtbl -> GetScheduledStreamTime(This,desiredTimeScale,streamTime,playbackSpeed) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_6_GetHardwareReferenceClock</NAME>
#define IDeckLinkOutput_v7_6_GetHardwareReferenceClock(This,desiredTimeScale,hardwareTime,timeInFrame,ticksPerFrame)	\
    ( (This)->lpVtbl -> GetHardwareReferenceClock(This,desiredTimeScale,hardwareTime,timeInFrame,ticksPerFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_QueryInterface</NAME>
#define IDeckLinkInput_v7_6_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_AddRef</NAME>
#define IDeckLinkInput_v7_6_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_Release</NAME>
#define IDeckLinkInput_v7_6_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_DoesSupportVideoMode</NAME>
#define IDeckLinkInput_v7_6_DoesSupportVideoMode(This,displayMode,pixelFormat,result)	\
    ( (This)->lpVtbl -> DoesSupportVideoMode(This,displayMode,pixelFormat,result) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_GetDisplayModeIterator</NAME>
#define IDeckLinkInput_v7_6_GetDisplayModeIterator(This,iterator)	\
    ( (This)->lpVtbl -> GetDisplayModeIterator(This,iterator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_SetScreenPreviewCallback</NAME>
#define IDeckLinkInput_v7_6_SetScreenPreviewCallback(This,previewCallback)	\
    ( (This)->lpVtbl -> SetScreenPreviewCallback(This,previewCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_EnableVideoInput</NAME>
#define IDeckLinkInput_v7_6_EnableVideoInput(This,displayMode,pixelFormat,flags)	\
    ( (This)->lpVtbl -> EnableVideoInput(This,displayMode,pixelFormat,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_DisableVideoInput</NAME>
#define IDeckLinkInput_v7_6_DisableVideoInput(This)	\
    ( (This)->lpVtbl -> DisableVideoInput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_GetAvailableVideoFrameCount</NAME>
#define IDeckLinkInput_v7_6_GetAvailableVideoFrameCount(This,availableFrameCount)	\
    ( (This)->lpVtbl -> GetAvailableVideoFrameCount(This,availableFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_EnableAudioInput</NAME>
#define IDeckLinkInput_v7_6_EnableAudioInput(This,sampleRate,sampleType,channelCount)	\
    ( (This)->lpVtbl -> EnableAudioInput(This,sampleRate,sampleType,channelCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_DisableAudioInput</NAME>
#define IDeckLinkInput_v7_6_DisableAudioInput(This)	\
    ( (This)->lpVtbl -> DisableAudioInput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_GetAvailableAudioSampleFrameCount</NAME>
#define IDeckLinkInput_v7_6_GetAvailableAudioSampleFrameCount(This,availableSampleFrameCount)	\
    ( (This)->lpVtbl -> GetAvailableAudioSampleFrameCount(This,availableSampleFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_StartStreams</NAME>
#define IDeckLinkInput_v7_6_StartStreams(This)	\
    ( (This)->lpVtbl -> StartStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_StopStreams</NAME>
#define IDeckLinkInput_v7_6_StopStreams(This)	\
    ( (This)->lpVtbl -> StopStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_PauseStreams</NAME>
#define IDeckLinkInput_v7_6_PauseStreams(This)	\
    ( (This)->lpVtbl -> PauseStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_FlushStreams</NAME>
#define IDeckLinkInput_v7_6_FlushStreams(This)	\
    ( (This)->lpVtbl -> FlushStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_SetCallback</NAME>
#define IDeckLinkInput_v7_6_SetCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_6_GetHardwareReferenceClock</NAME>
#define IDeckLinkInput_v7_6_GetHardwareReferenceClock(This,desiredTimeScale,hardwareTime,timeInFrame,ticksPerFrame)	\
    ( (This)->lpVtbl -> GetHardwareReferenceClock(This,desiredTimeScale,hardwareTime,timeInFrame,ticksPerFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkTimecode_v7_6_QueryInterface</NAME>
#define IDeckLinkTimecode_v7_6_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkTimecode_v7_6_AddRef</NAME>
#define IDeckLinkTimecode_v7_6_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkTimecode_v7_6_Release</NAME>
#define IDeckLinkTimecode_v7_6_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkTimecode_v7_6_GetBCD</NAME>
#define IDeckLinkTimecode_v7_6_GetBCD(This)	\
    ( (This)->lpVtbl -> GetBCD(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkTimecode_v7_6_GetComponents</NAME>
#define IDeckLinkTimecode_v7_6_GetComponents(This,hours,minutes,seconds,frames)	\
    ( (This)->lpVtbl -> GetComponents(This,hours,minutes,seconds,frames) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkTimecode_v7_6_GetString</NAME>
#define IDeckLinkTimecode_v7_6_GetString(This,timecode)	\
    ( (This)->lpVtbl -> GetString(This,timecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkTimecode_v7_6_GetFlags</NAME>
#define IDeckLinkTimecode_v7_6_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_6_QueryInterface</NAME>
#define IDeckLinkVideoFrame_v7_6_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_6_AddRef</NAME>
#define IDeckLinkVideoFrame_v7_6_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_6_Release</NAME>
#define IDeckLinkVideoFrame_v7_6_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_6_GetWidth</NAME>
#define IDeckLinkVideoFrame_v7_6_GetWidth(This)	\
    ( (This)->lpVtbl -> GetWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_6_GetHeight</NAME>
#define IDeckLinkVideoFrame_v7_6_GetHeight(This)	\
    ( (This)->lpVtbl -> GetHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_6_GetRowBytes</NAME>
#define IDeckLinkVideoFrame_v7_6_GetRowBytes(This)	\
    ( (This)->lpVtbl -> GetRowBytes(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_6_GetPixelFormat</NAME>
#define IDeckLinkVideoFrame_v7_6_GetPixelFormat(This)	\
    ( (This)->lpVtbl -> GetPixelFormat(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_6_GetFlags</NAME>
#define IDeckLinkVideoFrame_v7_6_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_6_GetBytes</NAME>
#define IDeckLinkVideoFrame_v7_6_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_6_GetTimecode</NAME>
#define IDeckLinkVideoFrame_v7_6_GetTimecode(This,format,timecode)	\
    ( (This)->lpVtbl -> GetTimecode(This,format,timecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_6_GetAncillaryData</NAME>
#define IDeckLinkVideoFrame_v7_6_GetAncillaryData(This,ancillary)	\
    ( (This)->lpVtbl -> GetAncillaryData(This,ancillary) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_QueryInterface</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_AddRef</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_Release</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_GetWidth</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_GetWidth(This)	\
    ( (This)->lpVtbl -> GetWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_GetHeight</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_GetHeight(This)	\
    ( (This)->lpVtbl -> GetHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_GetRowBytes</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_GetRowBytes(This)	\
    ( (This)->lpVtbl -> GetRowBytes(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_GetPixelFormat</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_GetPixelFormat(This)	\
    ( (This)->lpVtbl -> GetPixelFormat(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_GetFlags</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_GetBytes</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_GetTimecode</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_GetTimecode(This,format,timecode)	\
    ( (This)->lpVtbl -> GetTimecode(This,format,timecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_GetAncillaryData</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_GetAncillaryData(This,ancillary)	\
    ( (This)->lpVtbl -> GetAncillaryData(This,ancillary) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_SetFlags</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_SetFlags(This,newFlags)	\
    ( (This)->lpVtbl -> SetFlags(This,newFlags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_SetTimecode</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_SetTimecode(This,format,timecode)	\
    ( (This)->lpVtbl -> SetTimecode(This,format,timecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_SetTimecodeFromComponents</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_SetTimecodeFromComponents(This,format,hours,minutes,seconds,frames,flags)	\
    ( (This)->lpVtbl -> SetTimecodeFromComponents(This,format,hours,minutes,seconds,frames,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkMutableVideoFrame_v7_6_SetAncillaryData</NAME>
#define IDeckLinkMutableVideoFrame_v7_6_SetAncillaryData(This,ancillary)	\
    ( (This)->lpVtbl -> SetAncillaryData(This,ancillary) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_6_QueryInterface</NAME>
#define IDeckLinkVideoInputFrame_v7_6_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_6_AddRef</NAME>
#define IDeckLinkVideoInputFrame_v7_6_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_6_Release</NAME>
#define IDeckLinkVideoInputFrame_v7_6_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_6_GetWidth</NAME>
#define IDeckLinkVideoInputFrame_v7_6_GetWidth(This)	\
    ( (This)->lpVtbl -> GetWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_6_GetHeight</NAME>
#define IDeckLinkVideoInputFrame_v7_6_GetHeight(This)	\
    ( (This)->lpVtbl -> GetHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_6_GetRowBytes</NAME>
#define IDeckLinkVideoInputFrame_v7_6_GetRowBytes(This)	\
    ( (This)->lpVtbl -> GetRowBytes(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_6_GetPixelFormat</NAME>
#define IDeckLinkVideoInputFrame_v7_6_GetPixelFormat(This)	\
    ( (This)->lpVtbl -> GetPixelFormat(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_6_GetFlags</NAME>
#define IDeckLinkVideoInputFrame_v7_6_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_6_GetBytes</NAME>
#define IDeckLinkVideoInputFrame_v7_6_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_6_GetTimecode</NAME>
#define IDeckLinkVideoInputFrame_v7_6_GetTimecode(This,format,timecode)	\
    ( (This)->lpVtbl -> GetTimecode(This,format,timecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_6_GetAncillaryData</NAME>
#define IDeckLinkVideoInputFrame_v7_6_GetAncillaryData(This,ancillary)	\
    ( (This)->lpVtbl -> GetAncillaryData(This,ancillary) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_6_GetStreamTime</NAME>
#define IDeckLinkVideoInputFrame_v7_6_GetStreamTime(This,frameTime,frameDuration,timeScale)	\
    ( (This)->lpVtbl -> GetStreamTime(This,frameTime,frameDuration,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_6_GetHardwareReferenceTimestamp</NAME>
#define IDeckLinkVideoInputFrame_v7_6_GetHardwareReferenceTimestamp(This,timeScale,frameTime,frameDuration)	\
    ( (This)->lpVtbl -> GetHardwareReferenceTimestamp(This,timeScale,frameTime,frameDuration) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkScreenPreviewCallback_v7_6_QueryInterface</NAME>
#define IDeckLinkScreenPreviewCallback_v7_6_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkScreenPreviewCallback_v7_6_AddRef</NAME>
#define IDeckLinkScreenPreviewCallback_v7_6_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkScreenPreviewCallback_v7_6_Release</NAME>
#define IDeckLinkScreenPreviewCallback_v7_6_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkScreenPreviewCallback_v7_6_DrawFrame</NAME>
#define IDeckLinkScreenPreviewCallback_v7_6_DrawFrame(This,theFrame)	\
    ( (This)->lpVtbl -> DrawFrame(This,theFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkGLScreenPreviewHelper_v7_6_QueryInterface</NAME>
#define IDeckLinkGLScreenPreviewHelper_v7_6_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkGLScreenPreviewHelper_v7_6_AddRef</NAME>
#define IDeckLinkGLScreenPreviewHelper_v7_6_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkGLScreenPreviewHelper_v7_6_Release</NAME>
#define IDeckLinkGLScreenPreviewHelper_v7_6_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkGLScreenPreviewHelper_v7_6_InitializeGL</NAME>
#define IDeckLinkGLScreenPreviewHelper_v7_6_InitializeGL(This)	\
    ( (This)->lpVtbl -> InitializeGL(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkGLScreenPreviewHelper_v7_6_PaintGL</NAME>
#define IDeckLinkGLScreenPreviewHelper_v7_6_PaintGL(This)	\
    ( (This)->lpVtbl -> PaintGL(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkGLScreenPreviewHelper_v7_6_SetFrame</NAME>
#define IDeckLinkGLScreenPreviewHelper_v7_6_SetFrame(This,theFrame)	\
    ( (This)->lpVtbl -> SetFrame(This,theFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoConversion_v7_6_QueryInterface</NAME>
#define IDeckLinkVideoConversion_v7_6_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoConversion_v7_6_AddRef</NAME>
#define IDeckLinkVideoConversion_v7_6_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoConversion_v7_6_Release</NAME>
#define IDeckLinkVideoConversion_v7_6_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoConversion_v7_6_ConvertFrame</NAME>
#define IDeckLinkVideoConversion_v7_6_ConvertFrame(This,srcFrame,dstFrame)	\
    ( (This)->lpVtbl -> ConvertFrame(This,srcFrame,dstFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_QueryInterface</NAME>
#define IDeckLinkConfiguration_v7_6_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_AddRef</NAME>
#define IDeckLinkConfiguration_v7_6_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_Release</NAME>
#define IDeckLinkConfiguration_v7_6_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_GetConfigurationValidator</NAME>
#define IDeckLinkConfiguration_v7_6_GetConfigurationValidator(This,configObject)	\
    ( (This)->lpVtbl -> GetConfigurationValidator(This,configObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_WriteConfigurationToPreferences</NAME>
#define IDeckLinkConfiguration_v7_6_WriteConfigurationToPreferences(This)	\
    ( (This)->lpVtbl -> WriteConfigurationToPreferences(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_SetVideoOutputFormat</NAME>
#define IDeckLinkConfiguration_v7_6_SetVideoOutputFormat(This,videoOutputConnection)	\
    ( (This)->lpVtbl -> SetVideoOutputFormat(This,videoOutputConnection) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_IsVideoOutputActive</NAME>
#define IDeckLinkConfiguration_v7_6_IsVideoOutputActive(This,videoOutputConnection,active)	\
    ( (This)->lpVtbl -> IsVideoOutputActive(This,videoOutputConnection,active) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_SetAnalogVideoOutputFlags</NAME>
#define IDeckLinkConfiguration_v7_6_SetAnalogVideoOutputFlags(This,analogVideoFlags)	\
    ( (This)->lpVtbl -> SetAnalogVideoOutputFlags(This,analogVideoFlags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_GetAnalogVideoOutputFlags</NAME>
#define IDeckLinkConfiguration_v7_6_GetAnalogVideoOutputFlags(This,analogVideoFlags)	\
    ( (This)->lpVtbl -> GetAnalogVideoOutputFlags(This,analogVideoFlags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_EnableFieldFlickerRemovalWhenPaused</NAME>
#define IDeckLinkConfiguration_v7_6_EnableFieldFlickerRemovalWhenPaused(This,enable)	\
    ( (This)->lpVtbl -> EnableFieldFlickerRemovalWhenPaused(This,enable) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_IsEnabledFieldFlickerRemovalWhenPaused</NAME>
#define IDeckLinkConfiguration_v7_6_IsEnabledFieldFlickerRemovalWhenPaused(This,enabled)	\
    ( (This)->lpVtbl -> IsEnabledFieldFlickerRemovalWhenPaused(This,enabled) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_Set444And3GBpsVideoOutput</NAME>
#define IDeckLinkConfiguration_v7_6_Set444And3GBpsVideoOutput(This,enable444VideoOutput,enable3GbsOutput)	\
    ( (This)->lpVtbl -> Set444And3GBpsVideoOutput(This,enable444VideoOutput,enable3GbsOutput) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_Get444And3GBpsVideoOutput</NAME>
#define IDeckLinkConfiguration_v7_6_Get444And3GBpsVideoOutput(This,is444VideoOutputEnabled,threeGbsOutputEnabled)	\
    ( (This)->lpVtbl -> Get444And3GBpsVideoOutput(This,is444VideoOutputEnabled,threeGbsOutputEnabled) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_SetVideoOutputConversionMode</NAME>
#define IDeckLinkConfiguration_v7_6_SetVideoOutputConversionMode(This,conversionMode)	\
    ( (This)->lpVtbl -> SetVideoOutputConversionMode(This,conversionMode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_GetVideoOutputConversionMode</NAME>
#define IDeckLinkConfiguration_v7_6_GetVideoOutputConversionMode(This,conversionMode)	\
    ( (This)->lpVtbl -> GetVideoOutputConversionMode(This,conversionMode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_Set_HD1080p24_to_HD1080i5994_Conversion</NAME>
#define IDeckLinkConfiguration_v7_6_Set_HD1080p24_to_HD1080i5994_Conversion(This,enable)	\
    ( (This)->lpVtbl -> Set_HD1080p24_to_HD1080i5994_Conversion(This,enable) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_Get_HD1080p24_to_HD1080i5994_Conversion</NAME>
#define IDeckLinkConfiguration_v7_6_Get_HD1080p24_to_HD1080i5994_Conversion(This,enabled)	\
    ( (This)->lpVtbl -> Get_HD1080p24_to_HD1080i5994_Conversion(This,enabled) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_SetVideoInputFormat</NAME>
#define IDeckLinkConfiguration_v7_6_SetVideoInputFormat(This,videoInputFormat)	\
    ( (This)->lpVtbl -> SetVideoInputFormat(This,videoInputFormat) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_GetVideoInputFormat</NAME>
#define IDeckLinkConfiguration_v7_6_GetVideoInputFormat(This,videoInputFormat)	\
    ( (This)->lpVtbl -> GetVideoInputFormat(This,videoInputFormat) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_SetAnalogVideoInputFlags</NAME>
#define IDeckLinkConfiguration_v7_6_SetAnalogVideoInputFlags(This,analogVideoFlags)	\
    ( (This)->lpVtbl -> SetAnalogVideoInputFlags(This,analogVideoFlags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_GetAnalogVideoInputFlags</NAME>
#define IDeckLinkConfiguration_v7_6_GetAnalogVideoInputFlags(This,analogVideoFlags)	\
    ( (This)->lpVtbl -> GetAnalogVideoInputFlags(This,analogVideoFlags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_SetVideoInputConversionMode</NAME>
#define IDeckLinkConfiguration_v7_6_SetVideoInputConversionMode(This,conversionMode)	\
    ( (This)->lpVtbl -> SetVideoInputConversionMode(This,conversionMode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_GetVideoInputConversionMode</NAME>
#define IDeckLinkConfiguration_v7_6_GetVideoInputConversionMode(This,conversionMode)	\
    ( (This)->lpVtbl -> GetVideoInputConversionMode(This,conversionMode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_SetBlackVideoOutputDuringCapture</NAME>
#define IDeckLinkConfiguration_v7_6_SetBlackVideoOutputDuringCapture(This,blackOutInCapture)	\
    ( (This)->lpVtbl -> SetBlackVideoOutputDuringCapture(This,blackOutInCapture) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_GetBlackVideoOutputDuringCapture</NAME>
#define IDeckLinkConfiguration_v7_6_GetBlackVideoOutputDuringCapture(This,blackOutInCapture)	\
    ( (This)->lpVtbl -> GetBlackVideoOutputDuringCapture(This,blackOutInCapture) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_Set32PulldownSequenceInitialTimecodeFrame</NAME>
#define IDeckLinkConfiguration_v7_6_Set32PulldownSequenceInitialTimecodeFrame(This,aFrameTimecode)	\
    ( (This)->lpVtbl -> Set32PulldownSequenceInitialTimecodeFrame(This,aFrameTimecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_Get32PulldownSequenceInitialTimecodeFrame</NAME>
#define IDeckLinkConfiguration_v7_6_Get32PulldownSequenceInitialTimecodeFrame(This,aFrameTimecode)	\
    ( (This)->lpVtbl -> Get32PulldownSequenceInitialTimecodeFrame(This,aFrameTimecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_SetVancSourceLineMapping</NAME>
#define IDeckLinkConfiguration_v7_6_SetVancSourceLineMapping(This,activeLine1VANCsource,activeLine2VANCsource,activeLine3VANCsource)	\
    ( (This)->lpVtbl -> SetVancSourceLineMapping(This,activeLine1VANCsource,activeLine2VANCsource,activeLine3VANCsource) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_GetVancSourceLineMapping</NAME>
#define IDeckLinkConfiguration_v7_6_GetVancSourceLineMapping(This,activeLine1VANCsource,activeLine2VANCsource,activeLine3VANCsource)	\
    ( (This)->lpVtbl -> GetVancSourceLineMapping(This,activeLine1VANCsource,activeLine2VANCsource,activeLine3VANCsource) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_SetAudioInputFormat</NAME>
#define IDeckLinkConfiguration_v7_6_SetAudioInputFormat(This,audioInputFormat)	\
    ( (This)->lpVtbl -> SetAudioInputFormat(This,audioInputFormat) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkConfiguration_v7_6_GetAudioInputFormat</NAME>
#define IDeckLinkConfiguration_v7_6_GetAudioInputFormat(This,audioInputFormat)	\
    ( (This)->lpVtbl -> GetAudioInputFormat(This,audioInputFormat) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoOutputCallback_v7_6_QueryInterface</NAME>
#define IDeckLinkVideoOutputCallback_v7_6_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoOutputCallback_v7_6_AddRef</NAME>
#define IDeckLinkVideoOutputCallback_v7_6_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoOutputCallback_v7_6_Release</NAME>
#define IDeckLinkVideoOutputCallback_v7_6_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoOutputCallback_v7_6_ScheduledFrameCompleted</NAME>
#define IDeckLinkVideoOutputCallback_v7_6_ScheduledFrameCompleted(This,completedFrame,result)	\
    ( (This)->lpVtbl -> ScheduledFrameCompleted(This,completedFrame,result) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoOutputCallback_v7_6_ScheduledPlaybackHasStopped</NAME>
#define IDeckLinkVideoOutputCallback_v7_6_ScheduledPlaybackHasStopped(This)	\
    ( (This)->lpVtbl -> ScheduledPlaybackHasStopped(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_v7_6_QueryInterface</NAME>
#define IDeckLinkInputCallback_v7_6_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_v7_6_AddRef</NAME>
#define IDeckLinkInputCallback_v7_6_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_v7_6_Release</NAME>
#define IDeckLinkInputCallback_v7_6_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_v7_6_VideoInputFormatChanged</NAME>
#define IDeckLinkInputCallback_v7_6_VideoInputFormatChanged(This,notificationEvents,newDisplayMode,detectedSignalFlags)	\
    ( (This)->lpVtbl -> VideoInputFormatChanged(This,notificationEvents,newDisplayMode,detectedSignalFlags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_v7_6_VideoInputFrameArrived</NAME>
#define IDeckLinkInputCallback_v7_6_VideoInputFrameArrived(This,videoFrame,audioPacket)	\
    ( (This)->lpVtbl -> VideoInputFrameArrived(This,videoFrame,audioPacket) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_v7_3_QueryInterface</NAME>
#define IDeckLinkInputCallback_v7_3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_v7_3_AddRef</NAME>
#define IDeckLinkInputCallback_v7_3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_v7_3_Release</NAME>
#define IDeckLinkInputCallback_v7_3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_v7_3_VideoInputFormatChanged</NAME>
#define IDeckLinkInputCallback_v7_3_VideoInputFormatChanged(This,notificationEvents,newDisplayMode,detectedSignalFlags)	\
    ( (This)->lpVtbl -> VideoInputFormatChanged(This,notificationEvents,newDisplayMode,detectedSignalFlags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_v7_3_VideoInputFrameArrived</NAME>
#define IDeckLinkInputCallback_v7_3_VideoInputFrameArrived(This,videoFrame,audioPacket)	\
    ( (This)->lpVtbl -> VideoInputFrameArrived(This,videoFrame,audioPacket) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_QueryInterface</NAME>
#define IDeckLinkOutput_v7_3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_AddRef</NAME>
#define IDeckLinkOutput_v7_3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_Release</NAME>
#define IDeckLinkOutput_v7_3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_DoesSupportVideoMode</NAME>
#define IDeckLinkOutput_v7_3_DoesSupportVideoMode(This,displayMode,pixelFormat,result)	\
    ( (This)->lpVtbl -> DoesSupportVideoMode(This,displayMode,pixelFormat,result) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_GetDisplayModeIterator</NAME>
#define IDeckLinkOutput_v7_3_GetDisplayModeIterator(This,iterator)	\
    ( (This)->lpVtbl -> GetDisplayModeIterator(This,iterator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_SetScreenPreviewCallback</NAME>
#define IDeckLinkOutput_v7_3_SetScreenPreviewCallback(This,previewCallback)	\
    ( (This)->lpVtbl -> SetScreenPreviewCallback(This,previewCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_EnableVideoOutput</NAME>
#define IDeckLinkOutput_v7_3_EnableVideoOutput(This,displayMode,flags)	\
    ( (This)->lpVtbl -> EnableVideoOutput(This,displayMode,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_DisableVideoOutput</NAME>
#define IDeckLinkOutput_v7_3_DisableVideoOutput(This)	\
    ( (This)->lpVtbl -> DisableVideoOutput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_SetVideoOutputFrameMemoryAllocator</NAME>
#define IDeckLinkOutput_v7_3_SetVideoOutputFrameMemoryAllocator(This,theAllocator)	\
    ( (This)->lpVtbl -> SetVideoOutputFrameMemoryAllocator(This,theAllocator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_CreateVideoFrame</NAME>
#define IDeckLinkOutput_v7_3_CreateVideoFrame(This,width,height,rowBytes,pixelFormat,flags,outFrame)	\
    ( (This)->lpVtbl -> CreateVideoFrame(This,width,height,rowBytes,pixelFormat,flags,outFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_CreateAncillaryData</NAME>
#define IDeckLinkOutput_v7_3_CreateAncillaryData(This,pixelFormat,outBuffer)	\
    ( (This)->lpVtbl -> CreateAncillaryData(This,pixelFormat,outBuffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_DisplayVideoFrameSync</NAME>
#define IDeckLinkOutput_v7_3_DisplayVideoFrameSync(This,theFrame)	\
    ( (This)->lpVtbl -> DisplayVideoFrameSync(This,theFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_ScheduleVideoFrame</NAME>
#define IDeckLinkOutput_v7_3_ScheduleVideoFrame(This,theFrame,displayTime,displayDuration,timeScale)	\
    ( (This)->lpVtbl -> ScheduleVideoFrame(This,theFrame,displayTime,displayDuration,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_SetScheduledFrameCompletionCallback</NAME>
#define IDeckLinkOutput_v7_3_SetScheduledFrameCompletionCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetScheduledFrameCompletionCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_GetBufferedVideoFrameCount</NAME>
#define IDeckLinkOutput_v7_3_GetBufferedVideoFrameCount(This,bufferedFrameCount)	\
    ( (This)->lpVtbl -> GetBufferedVideoFrameCount(This,bufferedFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_EnableAudioOutput</NAME>
#define IDeckLinkOutput_v7_3_EnableAudioOutput(This,sampleRate,sampleType,channelCount,streamType)	\
    ( (This)->lpVtbl -> EnableAudioOutput(This,sampleRate,sampleType,channelCount,streamType) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_DisableAudioOutput</NAME>
#define IDeckLinkOutput_v7_3_DisableAudioOutput(This)	\
    ( (This)->lpVtbl -> DisableAudioOutput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_WriteAudioSamplesSync</NAME>
#define IDeckLinkOutput_v7_3_WriteAudioSamplesSync(This,buffer,sampleFrameCount,sampleFramesWritten)	\
    ( (This)->lpVtbl -> WriteAudioSamplesSync(This,buffer,sampleFrameCount,sampleFramesWritten) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_BeginAudioPreroll</NAME>
#define IDeckLinkOutput_v7_3_BeginAudioPreroll(This)	\
    ( (This)->lpVtbl -> BeginAudioPreroll(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_EndAudioPreroll</NAME>
#define IDeckLinkOutput_v7_3_EndAudioPreroll(This)	\
    ( (This)->lpVtbl -> EndAudioPreroll(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_ScheduleAudioSamples</NAME>
#define IDeckLinkOutput_v7_3_ScheduleAudioSamples(This,buffer,sampleFrameCount,streamTime,timeScale,sampleFramesWritten)	\
    ( (This)->lpVtbl -> ScheduleAudioSamples(This,buffer,sampleFrameCount,streamTime,timeScale,sampleFramesWritten) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_GetBufferedAudioSampleFrameCount</NAME>
#define IDeckLinkOutput_v7_3_GetBufferedAudioSampleFrameCount(This,bufferedSampleFrameCount)	\
    ( (This)->lpVtbl -> GetBufferedAudioSampleFrameCount(This,bufferedSampleFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_FlushBufferedAudioSamples</NAME>
#define IDeckLinkOutput_v7_3_FlushBufferedAudioSamples(This)	\
    ( (This)->lpVtbl -> FlushBufferedAudioSamples(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_SetAudioCallback</NAME>
#define IDeckLinkOutput_v7_3_SetAudioCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetAudioCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_StartScheduledPlayback</NAME>
#define IDeckLinkOutput_v7_3_StartScheduledPlayback(This,playbackStartTime,timeScale,playbackSpeed)	\
    ( (This)->lpVtbl -> StartScheduledPlayback(This,playbackStartTime,timeScale,playbackSpeed) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_StopScheduledPlayback</NAME>
#define IDeckLinkOutput_v7_3_StopScheduledPlayback(This,stopPlaybackAtTime,actualStopTime,timeScale)	\
    ( (This)->lpVtbl -> StopScheduledPlayback(This,stopPlaybackAtTime,actualStopTime,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_IsScheduledPlaybackRunning</NAME>
#define IDeckLinkOutput_v7_3_IsScheduledPlaybackRunning(This,active)	\
    ( (This)->lpVtbl -> IsScheduledPlaybackRunning(This,active) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_3_GetHardwareReferenceClock</NAME>
#define IDeckLinkOutput_v7_3_GetHardwareReferenceClock(This,desiredTimeScale,elapsedTimeSinceSchedulerBegan)	\
    ( (This)->lpVtbl -> GetHardwareReferenceClock(This,desiredTimeScale,elapsedTimeSinceSchedulerBegan) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_QueryInterface</NAME>
#define IDeckLinkInput_v7_3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_AddRef</NAME>
#define IDeckLinkInput_v7_3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_Release</NAME>
#define IDeckLinkInput_v7_3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_DoesSupportVideoMode</NAME>
#define IDeckLinkInput_v7_3_DoesSupportVideoMode(This,displayMode,pixelFormat,result)	\
    ( (This)->lpVtbl -> DoesSupportVideoMode(This,displayMode,pixelFormat,result) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_GetDisplayModeIterator</NAME>
#define IDeckLinkInput_v7_3_GetDisplayModeIterator(This,iterator)	\
    ( (This)->lpVtbl -> GetDisplayModeIterator(This,iterator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_SetScreenPreviewCallback</NAME>
#define IDeckLinkInput_v7_3_SetScreenPreviewCallback(This,previewCallback)	\
    ( (This)->lpVtbl -> SetScreenPreviewCallback(This,previewCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_EnableVideoInput</NAME>
#define IDeckLinkInput_v7_3_EnableVideoInput(This,displayMode,pixelFormat,flags)	\
    ( (This)->lpVtbl -> EnableVideoInput(This,displayMode,pixelFormat,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_DisableVideoInput</NAME>
#define IDeckLinkInput_v7_3_DisableVideoInput(This)	\
    ( (This)->lpVtbl -> DisableVideoInput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_GetAvailableVideoFrameCount</NAME>
#define IDeckLinkInput_v7_3_GetAvailableVideoFrameCount(This,availableFrameCount)	\
    ( (This)->lpVtbl -> GetAvailableVideoFrameCount(This,availableFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_EnableAudioInput</NAME>
#define IDeckLinkInput_v7_3_EnableAudioInput(This,sampleRate,sampleType,channelCount)	\
    ( (This)->lpVtbl -> EnableAudioInput(This,sampleRate,sampleType,channelCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_DisableAudioInput</NAME>
#define IDeckLinkInput_v7_3_DisableAudioInput(This)	\
    ( (This)->lpVtbl -> DisableAudioInput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_GetAvailableAudioSampleFrameCount</NAME>
#define IDeckLinkInput_v7_3_GetAvailableAudioSampleFrameCount(This,availableSampleFrameCount)	\
    ( (This)->lpVtbl -> GetAvailableAudioSampleFrameCount(This,availableSampleFrameCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_StartStreams</NAME>
#define IDeckLinkInput_v7_3_StartStreams(This)	\
    ( (This)->lpVtbl -> StartStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_StopStreams</NAME>
#define IDeckLinkInput_v7_3_StopStreams(This)	\
    ( (This)->lpVtbl -> StopStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_PauseStreams</NAME>
#define IDeckLinkInput_v7_3_PauseStreams(This)	\
    ( (This)->lpVtbl -> PauseStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_FlushStreams</NAME>
#define IDeckLinkInput_v7_3_FlushStreams(This)	\
    ( (This)->lpVtbl -> FlushStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_3_SetCallback</NAME>
#define IDeckLinkInput_v7_3_SetCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_3_QueryInterface</NAME>
#define IDeckLinkVideoInputFrame_v7_3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_3_AddRef</NAME>
#define IDeckLinkVideoInputFrame_v7_3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_3_Release</NAME>
#define IDeckLinkVideoInputFrame_v7_3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_3_GetWidth</NAME>
#define IDeckLinkVideoInputFrame_v7_3_GetWidth(This)	\
    ( (This)->lpVtbl -> GetWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_3_GetHeight</NAME>
#define IDeckLinkVideoInputFrame_v7_3_GetHeight(This)	\
    ( (This)->lpVtbl -> GetHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_3_GetRowBytes</NAME>
#define IDeckLinkVideoInputFrame_v7_3_GetRowBytes(This)	\
    ( (This)->lpVtbl -> GetRowBytes(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_3_GetPixelFormat</NAME>
#define IDeckLinkVideoInputFrame_v7_3_GetPixelFormat(This)	\
    ( (This)->lpVtbl -> GetPixelFormat(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_3_GetFlags</NAME>
#define IDeckLinkVideoInputFrame_v7_3_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_3_GetBytes</NAME>
#define IDeckLinkVideoInputFrame_v7_3_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_3_GetTimecode</NAME>
#define IDeckLinkVideoInputFrame_v7_3_GetTimecode(This,format,timecode)	\
    ( (This)->lpVtbl -> GetTimecode(This,format,timecode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_3_GetAncillaryData</NAME>
#define IDeckLinkVideoInputFrame_v7_3_GetAncillaryData(This,ancillary)	\
    ( (This)->lpVtbl -> GetAncillaryData(This,ancillary) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_3_GetStreamTime</NAME>
#define IDeckLinkVideoInputFrame_v7_3_GetStreamTime(This,frameTime,frameDuration,timeScale)	\
    ( (This)->lpVtbl -> GetStreamTime(This,frameTime,frameDuration,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayModeIterator_v7_1_QueryInterface</NAME>
#define IDeckLinkDisplayModeIterator_v7_1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayModeIterator_v7_1_AddRef</NAME>
#define IDeckLinkDisplayModeIterator_v7_1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayModeIterator_v7_1_Release</NAME>
#define IDeckLinkDisplayModeIterator_v7_1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayModeIterator_v7_1_Next</NAME>
#define IDeckLinkDisplayModeIterator_v7_1_Next(This,deckLinkDisplayMode)	\
    ( (This)->lpVtbl -> Next(This,deckLinkDisplayMode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_1_QueryInterface</NAME>
#define IDeckLinkDisplayMode_v7_1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_1_AddRef</NAME>
#define IDeckLinkDisplayMode_v7_1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_1_Release</NAME>
#define IDeckLinkDisplayMode_v7_1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_1_GetName</NAME>
#define IDeckLinkDisplayMode_v7_1_GetName(This,name)	\
    ( (This)->lpVtbl -> GetName(This,name) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_1_GetDisplayMode</NAME>
#define IDeckLinkDisplayMode_v7_1_GetDisplayMode(This)	\
    ( (This)->lpVtbl -> GetDisplayMode(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_1_GetWidth</NAME>
#define IDeckLinkDisplayMode_v7_1_GetWidth(This)	\
    ( (This)->lpVtbl -> GetWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_1_GetHeight</NAME>
#define IDeckLinkDisplayMode_v7_1_GetHeight(This)	\
    ( (This)->lpVtbl -> GetHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkDisplayMode_v7_1_GetFrameRate</NAME>
#define IDeckLinkDisplayMode_v7_1_GetFrameRate(This,frameDuration,timeScale)	\
    ( (This)->lpVtbl -> GetFrameRate(This,frameDuration,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_1_QueryInterface</NAME>
#define IDeckLinkVideoFrame_v7_1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_1_AddRef</NAME>
#define IDeckLinkVideoFrame_v7_1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_1_Release</NAME>
#define IDeckLinkVideoFrame_v7_1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_1_GetWidth</NAME>
#define IDeckLinkVideoFrame_v7_1_GetWidth(This)	\
    ( (This)->lpVtbl -> GetWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_1_GetHeight</NAME>
#define IDeckLinkVideoFrame_v7_1_GetHeight(This)	\
    ( (This)->lpVtbl -> GetHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_1_GetRowBytes</NAME>
#define IDeckLinkVideoFrame_v7_1_GetRowBytes(This)	\
    ( (This)->lpVtbl -> GetRowBytes(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_1_GetPixelFormat</NAME>
#define IDeckLinkVideoFrame_v7_1_GetPixelFormat(This)	\
    ( (This)->lpVtbl -> GetPixelFormat(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_1_GetFlags</NAME>
#define IDeckLinkVideoFrame_v7_1_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoFrame_v7_1_GetBytes</NAME>
#define IDeckLinkVideoFrame_v7_1_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_1_QueryInterface</NAME>
#define IDeckLinkVideoInputFrame_v7_1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_1_AddRef</NAME>
#define IDeckLinkVideoInputFrame_v7_1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_1_Release</NAME>
#define IDeckLinkVideoInputFrame_v7_1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_1_GetWidth</NAME>
#define IDeckLinkVideoInputFrame_v7_1_GetWidth(This)	\
    ( (This)->lpVtbl -> GetWidth(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_1_GetHeight</NAME>
#define IDeckLinkVideoInputFrame_v7_1_GetHeight(This)	\
    ( (This)->lpVtbl -> GetHeight(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_1_GetRowBytes</NAME>
#define IDeckLinkVideoInputFrame_v7_1_GetRowBytes(This)	\
    ( (This)->lpVtbl -> GetRowBytes(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_1_GetPixelFormat</NAME>
#define IDeckLinkVideoInputFrame_v7_1_GetPixelFormat(This)	\
    ( (This)->lpVtbl -> GetPixelFormat(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_1_GetFlags</NAME>
#define IDeckLinkVideoInputFrame_v7_1_GetFlags(This)	\
    ( (This)->lpVtbl -> GetFlags(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_1_GetBytes</NAME>
#define IDeckLinkVideoInputFrame_v7_1_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoInputFrame_v7_1_GetFrameTime</NAME>
#define IDeckLinkVideoInputFrame_v7_1_GetFrameTime(This,frameTime,frameDuration,timeScale)	\
    ( (This)->lpVtbl -> GetFrameTime(This,frameTime,frameDuration,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioInputPacket_v7_1_QueryInterface</NAME>
#define IDeckLinkAudioInputPacket_v7_1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioInputPacket_v7_1_AddRef</NAME>
#define IDeckLinkAudioInputPacket_v7_1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioInputPacket_v7_1_Release</NAME>
#define IDeckLinkAudioInputPacket_v7_1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioInputPacket_v7_1_GetSampleCount</NAME>
#define IDeckLinkAudioInputPacket_v7_1_GetSampleCount(This)	\
    ( (This)->lpVtbl -> GetSampleCount(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioInputPacket_v7_1_GetBytes</NAME>
#define IDeckLinkAudioInputPacket_v7_1_GetBytes(This,buffer)	\
    ( (This)->lpVtbl -> GetBytes(This,buffer) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkAudioInputPacket_v7_1_GetAudioPacketTime</NAME>
#define IDeckLinkAudioInputPacket_v7_1_GetAudioPacketTime(This,packetTime,timeScale)	\
    ( (This)->lpVtbl -> GetAudioPacketTime(This,packetTime,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoOutputCallback_v7_1_QueryInterface</NAME>
#define IDeckLinkVideoOutputCallback_v7_1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoOutputCallback_v7_1_AddRef</NAME>
#define IDeckLinkVideoOutputCallback_v7_1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoOutputCallback_v7_1_Release</NAME>
#define IDeckLinkVideoOutputCallback_v7_1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkVideoOutputCallback_v7_1_ScheduledFrameCompleted</NAME>
#define IDeckLinkVideoOutputCallback_v7_1_ScheduledFrameCompleted(This,completedFrame,result)	\
    ( (This)->lpVtbl -> ScheduledFrameCompleted(This,completedFrame,result) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_v7_1_QueryInterface</NAME>
#define IDeckLinkInputCallback_v7_1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_v7_1_AddRef</NAME>
#define IDeckLinkInputCallback_v7_1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_v7_1_Release</NAME>
#define IDeckLinkInputCallback_v7_1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInputCallback_v7_1_VideoInputFrameArrived</NAME>
#define IDeckLinkInputCallback_v7_1_VideoInputFrameArrived(This,videoFrame,audioPacket)	\
    ( (This)->lpVtbl -> VideoInputFrameArrived(This,videoFrame,audioPacket) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_QueryInterface</NAME>
#define IDeckLinkOutput_v7_1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_AddRef</NAME>
#define IDeckLinkOutput_v7_1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_Release</NAME>
#define IDeckLinkOutput_v7_1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_DoesSupportVideoMode</NAME>
#define IDeckLinkOutput_v7_1_DoesSupportVideoMode(This,displayMode,pixelFormat,result)	\
    ( (This)->lpVtbl -> DoesSupportVideoMode(This,displayMode,pixelFormat,result) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_GetDisplayModeIterator</NAME>
#define IDeckLinkOutput_v7_1_GetDisplayModeIterator(This,iterator)	\
    ( (This)->lpVtbl -> GetDisplayModeIterator(This,iterator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_EnableVideoOutput</NAME>
#define IDeckLinkOutput_v7_1_EnableVideoOutput(This,displayMode)	\
    ( (This)->lpVtbl -> EnableVideoOutput(This,displayMode) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_DisableVideoOutput</NAME>
#define IDeckLinkOutput_v7_1_DisableVideoOutput(This)	\
    ( (This)->lpVtbl -> DisableVideoOutput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_SetVideoOutputFrameMemoryAllocator</NAME>
#define IDeckLinkOutput_v7_1_SetVideoOutputFrameMemoryAllocator(This,theAllocator)	\
    ( (This)->lpVtbl -> SetVideoOutputFrameMemoryAllocator(This,theAllocator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_CreateVideoFrame</NAME>
#define IDeckLinkOutput_v7_1_CreateVideoFrame(This,width,height,rowBytes,pixelFormat,flags,outFrame)	\
    ( (This)->lpVtbl -> CreateVideoFrame(This,width,height,rowBytes,pixelFormat,flags,outFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_CreateVideoFrameFromBuffer</NAME>
#define IDeckLinkOutput_v7_1_CreateVideoFrameFromBuffer(This,buffer,width,height,rowBytes,pixelFormat,flags,outFrame)	\
    ( (This)->lpVtbl -> CreateVideoFrameFromBuffer(This,buffer,width,height,rowBytes,pixelFormat,flags,outFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_DisplayVideoFrameSync</NAME>
#define IDeckLinkOutput_v7_1_DisplayVideoFrameSync(This,theFrame)	\
    ( (This)->lpVtbl -> DisplayVideoFrameSync(This,theFrame) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_ScheduleVideoFrame</NAME>
#define IDeckLinkOutput_v7_1_ScheduleVideoFrame(This,theFrame,displayTime,displayDuration,timeScale)	\
    ( (This)->lpVtbl -> ScheduleVideoFrame(This,theFrame,displayTime,displayDuration,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_SetScheduledFrameCompletionCallback</NAME>
#define IDeckLinkOutput_v7_1_SetScheduledFrameCompletionCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetScheduledFrameCompletionCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_EnableAudioOutput</NAME>
#define IDeckLinkOutput_v7_1_EnableAudioOutput(This,sampleRate,sampleType,channelCount)	\
    ( (This)->lpVtbl -> EnableAudioOutput(This,sampleRate,sampleType,channelCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_DisableAudioOutput</NAME>
#define IDeckLinkOutput_v7_1_DisableAudioOutput(This)	\
    ( (This)->lpVtbl -> DisableAudioOutput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_WriteAudioSamplesSync</NAME>
#define IDeckLinkOutput_v7_1_WriteAudioSamplesSync(This,buffer,sampleFrameCount,sampleFramesWritten)	\
    ( (This)->lpVtbl -> WriteAudioSamplesSync(This,buffer,sampleFrameCount,sampleFramesWritten) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_BeginAudioPreroll</NAME>
#define IDeckLinkOutput_v7_1_BeginAudioPreroll(This)	\
    ( (This)->lpVtbl -> BeginAudioPreroll(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_EndAudioPreroll</NAME>
#define IDeckLinkOutput_v7_1_EndAudioPreroll(This)	\
    ( (This)->lpVtbl -> EndAudioPreroll(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_ScheduleAudioSamples</NAME>
#define IDeckLinkOutput_v7_1_ScheduleAudioSamples(This,buffer,sampleFrameCount,streamTime,timeScale,sampleFramesWritten)	\
    ( (This)->lpVtbl -> ScheduleAudioSamples(This,buffer,sampleFrameCount,streamTime,timeScale,sampleFramesWritten) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_GetBufferedAudioSampleFrameCount</NAME>
#define IDeckLinkOutput_v7_1_GetBufferedAudioSampleFrameCount(This,bufferedSampleCount)	\
    ( (This)->lpVtbl -> GetBufferedAudioSampleFrameCount(This,bufferedSampleCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_FlushBufferedAudioSamples</NAME>
#define IDeckLinkOutput_v7_1_FlushBufferedAudioSamples(This)	\
    ( (This)->lpVtbl -> FlushBufferedAudioSamples(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_SetAudioCallback</NAME>
#define IDeckLinkOutput_v7_1_SetAudioCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetAudioCallback(This,theCallback) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_StartScheduledPlayback</NAME>
#define IDeckLinkOutput_v7_1_StartScheduledPlayback(This,playbackStartTime,timeScale,playbackSpeed)	\
    ( (This)->lpVtbl -> StartScheduledPlayback(This,playbackStartTime,timeScale,playbackSpeed) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_StopScheduledPlayback</NAME>
#define IDeckLinkOutput_v7_1_StopScheduledPlayback(This,stopPlaybackAtTime,actualStopTime,timeScale)	\
    ( (This)->lpVtbl -> StopScheduledPlayback(This,stopPlaybackAtTime,actualStopTime,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkOutput_v7_1_GetHardwareReferenceClock</NAME>
#define IDeckLinkOutput_v7_1_GetHardwareReferenceClock(This,desiredTimeScale,elapsedTimeSinceSchedulerBegan)	\
    ( (This)->lpVtbl -> GetHardwareReferenceClock(This,desiredTimeScale,elapsedTimeSinceSchedulerBegan) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_QueryInterface</NAME>
#define IDeckLinkInput_v7_1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_AddRef</NAME>
#define IDeckLinkInput_v7_1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_Release</NAME>
#define IDeckLinkInput_v7_1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_DoesSupportVideoMode</NAME>
#define IDeckLinkInput_v7_1_DoesSupportVideoMode(This,displayMode,pixelFormat,result)	\
    ( (This)->lpVtbl -> DoesSupportVideoMode(This,displayMode,pixelFormat,result) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_GetDisplayModeIterator</NAME>
#define IDeckLinkInput_v7_1_GetDisplayModeIterator(This,iterator)	\
    ( (This)->lpVtbl -> GetDisplayModeIterator(This,iterator) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_EnableVideoInput</NAME>
#define IDeckLinkInput_v7_1_EnableVideoInput(This,displayMode,pixelFormat,flags)	\
    ( (This)->lpVtbl -> EnableVideoInput(This,displayMode,pixelFormat,flags) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_DisableVideoInput</NAME>
#define IDeckLinkInput_v7_1_DisableVideoInput(This)	\
    ( (This)->lpVtbl -> DisableVideoInput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_EnableAudioInput</NAME>
#define IDeckLinkInput_v7_1_EnableAudioInput(This,sampleRate,sampleType,channelCount)	\
    ( (This)->lpVtbl -> EnableAudioInput(This,sampleRate,sampleType,channelCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_DisableAudioInput</NAME>
#define IDeckLinkInput_v7_1_DisableAudioInput(This)	\
    ( (This)->lpVtbl -> DisableAudioInput(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_ReadAudioSamples</NAME>
#define IDeckLinkInput_v7_1_ReadAudioSamples(This,buffer,sampleFrameCount,sampleFramesRead,audioPacketTime,timeScale)	\
    ( (This)->lpVtbl -> ReadAudioSamples(This,buffer,sampleFrameCount,sampleFramesRead,audioPacketTime,timeScale) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_GetBufferedAudioSampleFrameCount</NAME>
#define IDeckLinkInput_v7_1_GetBufferedAudioSampleFrameCount(This,bufferedSampleCount)	\
    ( (This)->lpVtbl -> GetBufferedAudioSampleFrameCount(This,bufferedSampleCount) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_StartStreams</NAME>
#define IDeckLinkInput_v7_1_StartStreams(This)	\
    ( (This)->lpVtbl -> StartStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_StopStreams</NAME>
#define IDeckLinkInput_v7_1_StopStreams(This)	\
    ( (This)->lpVtbl -> StopStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_PauseStreams</NAME>
#define IDeckLinkInput_v7_1_PauseStreams(This)	\
    ( (This)->lpVtbl -> PauseStreams(This) ) 
</MACRO>
<MACRO>
<NAME>IDeckLinkInput_v7_1_SetCallback</NAME>
#define IDeckLinkInput_v7_1_SetCallback(This,theCallback)	\
    ( (This)->lpVtbl -> SetCallback(This,theCallback) ) 
</MACRO>
<FUNCTION>
<NAME>CreateDeckLinkIteratorInstance</NAME>
<RETURNS>IDeckLinkIterator * </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BMD_CONST</NAME>
        #define BMD_CONST __declspec(selectany) static const
</MACRO>
<TYPEDEF>
<NAME>BMDDeckControlMode</NAME>
typedef uint32_t BMDDeckControlMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckControlEvent</NAME>
typedef uint32_t BMDDeckControlEvent;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckControlVTRControlState</NAME>
typedef uint32_t BMDDeckControlVTRControlState;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckControlStatusFlags</NAME>
typedef uint32_t BMDDeckControlStatusFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckControlExportModeOpsFlags</NAME>
typedef uint32_t BMDDeckControlExportModeOpsFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckControlError</NAME>
typedef uint32_t BMDDeckControlError;
</TYPEDEF>
<MACRO>
<NAME>BMD_CONST</NAME>
        #define BMD_CONST __declspec(selectany) static const
</MACRO>
<MACRO>
<NAME>BLACKMAGIC_DECKLINK_API_MAGIC</NAME>
#define BLACKMAGIC_DECKLINK_API_MAGIC	1
</MACRO>
<TYPEDEF>
<NAME>BMDVideoOutputFlags</NAME>
typedef uint32_t BMDVideoOutputFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDPacketType</NAME>
typedef uint32_t BMDPacketType;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDFrameFlags</NAME>
typedef uint32_t BMDFrameFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoInputFlags</NAME>
typedef uint32_t BMDVideoInputFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoInputFormatChangedEvents</NAME>
typedef uint32_t BMDVideoInputFormatChangedEvents;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDetectedVideoInputFormatFlags</NAME>
typedef uint32_t BMDDetectedVideoInputFormatFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkCapturePassthroughMode</NAME>
typedef uint32_t BMDDeckLinkCapturePassthroughMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDOutputFrameCompletionResult</NAME>
typedef uint32_t BMDOutputFrameCompletionResult;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDReferenceStatus</NAME>
typedef uint32_t BMDReferenceStatus;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAudioFormat</NAME>
typedef uint32_t BMDAudioFormat;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAudioSampleRate</NAME>
typedef uint32_t BMDAudioSampleRate;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAudioSampleType</NAME>
typedef uint32_t BMDAudioSampleType;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAudioOutputStreamType</NAME>
typedef uint32_t BMDAudioOutputStreamType;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDisplayModeSupport</NAME>
typedef uint32_t BMDDisplayModeSupport;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimecodeFormat</NAME>
typedef uint32_t BMDTimecodeFormat;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAnalogVideoFlags</NAME>
typedef uint32_t BMDAnalogVideoFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAudioOutputAnalogAESSwitch</NAME>
typedef uint32_t BMDAudioOutputAnalogAESSwitch;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoOutputConversionMode</NAME>
typedef uint32_t BMDVideoOutputConversionMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoInputConversionMode</NAME>
typedef uint32_t BMDVideoInputConversionMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideo3DPackingFormat</NAME>
typedef uint32_t BMDVideo3DPackingFormat;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDIdleVideoOutputOperation</NAME>
typedef uint32_t BMDIdleVideoOutputOperation;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoEncoderFrameCodingMode</NAME>
typedef uint32_t BMDVideoEncoderFrameCodingMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDNxHRLevel</NAME>
typedef uint32_t BMDDNxHRLevel;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDLinkConfiguration</NAME>
typedef uint32_t BMDLinkConfiguration;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeviceInterface</NAME>
typedef uint32_t BMDDeviceInterface;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkFrameMetadataID</NAME>
typedef uint32_t BMDDeckLinkFrameMetadataID;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDuplexMode</NAME>
typedef uint32_t BMDDuplexMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkAttributeID</NAME>
typedef uint32_t BMDDeckLinkAttributeID;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkAPIInformationID</NAME>
typedef uint32_t BMDDeckLinkAPIInformationID;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkStatusID</NAME>
typedef uint32_t BMDDeckLinkStatusID;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkVideoStatusFlags</NAME>
typedef uint32_t BMDDeckLinkVideoStatusFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDuplexStatus</NAME>
typedef uint32_t BMDDuplexStatus;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeviceBusyState</NAME>
typedef uint32_t BMDDeviceBusyState;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoIOSupport</NAME>
typedef uint32_t BMDVideoIOSupport;
</TYPEDEF>
<TYPEDEF>
<NAME>BMD3DPreviewFormat</NAME>
typedef uint32_t BMD3DPreviewFormat;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDNotifications</NAME>
typedef uint32_t BMDNotifications;
</TYPEDEF>
<FUNCTION>
<NAME>CreateDeckLinkIteratorInstance</NAME>
<RETURNS>IDeckLinkIterator * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CreateDeckLinkDiscoveryInstance</NAME>
<RETURNS>IDeckLinkDiscovery * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CreateDeckLinkAPIInformationInstance</NAME>
<RETURNS>IDeckLinkAPIInformation * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CreateOpenGLScreenPreviewHelper</NAME>
<RETURNS>IDeckLinkGLScreenPreviewHelper * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CreateCocoaScreenPreview</NAME>
<RETURNS>IDeckLinkCocoaScreenPreviewCallback * </RETURNS>
void*  parentView
</FUNCTION>
<FUNCTION>
<NAME>CreateVideoConversionInstance</NAME>
<RETURNS>IDeckLinkVideoConversion * </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BLACKMAGIC_DECKLINK_API_VERSION</NAME>
#define BLACKMAGIC_DECKLINK_API_VERSION					0x0a080000
</MACRO>
<MACRO>
<NAME>BLACKMAGIC_DECKLINK_API_VERSION_STRING</NAME>
#define BLACKMAGIC_DECKLINK_API_VERSION_STRING			"10.8"
</MACRO>
<MACRO>
<NAME>BMD_CONST</NAME>
        #define BMD_CONST __declspec(selectany) static const
</MACRO>
<TYPEDEF>
<NAME>BMDDisplayMode</NAME>
typedef uint32_t BMDDisplayMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDFieldDominance</NAME>
typedef uint32_t BMDFieldDominance;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDPixelFormat</NAME>
typedef uint32_t BMDPixelFormat;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDisplayModeFlags</NAME>
typedef uint32_t BMDDisplayModeFlags;
</TYPEDEF>
<MACRO>
<NAME>BMD_CONST</NAME>
        #define BMD_CONST __declspec(selectany) static const
</MACRO>
<TYPEDEF>
<NAME>BMDTimeValue</NAME>
typedef int64_t BMDTimeValue;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimeScale</NAME>
typedef int64_t BMDTimeScale;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimecodeBCD</NAME>
typedef uint32_t BMDTimecodeBCD;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimecodeUserBits</NAME>
typedef uint32_t BMDTimecodeUserBits;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimecodeFlags</NAME>
typedef uint32_t BMDTimecodeFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoConnection</NAME>
typedef uint32_t BMDVideoConnection;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAudioConnection</NAME>
typedef uint32_t BMDAudioConnection;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckControlConnection</NAME>
typedef uint32_t BMDDeckControlConnection;
</TYPEDEF>
<MACRO>
<NAME>BMD_CONST</NAME>
        #define BMD_CONST __declspec(selectany) static const
</MACRO>
<TYPEDEF>
<NAME>BMDStreamingDeviceMode</NAME>
typedef uint32_t BMDStreamingDeviceMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDStreamingEncodingFrameRate</NAME>
typedef uint32_t BMDStreamingEncodingFrameRate;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDStreamingEncodingSupport</NAME>
typedef uint32_t BMDStreamingEncodingSupport;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDStreamingVideoCodec</NAME>
typedef uint32_t BMDStreamingVideoCodec;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDStreamingH264Profile</NAME>
typedef uint32_t BMDStreamingH264Profile;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDStreamingH264Level</NAME>
typedef uint32_t BMDStreamingH264Level;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDStreamingH264EntropyCoding</NAME>
typedef uint32_t BMDStreamingH264EntropyCoding;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDStreamingAudioCodec</NAME>
typedef uint32_t BMDStreamingAudioCodec;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDStreamingEncodingModePropertyID</NAME>
typedef uint32_t BMDStreamingEncodingModePropertyID;
</TYPEDEF>
<FUNCTION>
<NAME>CreateBMDStreamingDiscoveryInstance</NAME>
<RETURNS>IBMDStreamingDiscovery * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CreateBMDStreamingH264NALParser</NAME>
<RETURNS>IBMDStreamingH264NALParser * </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BMD_CONST</NAME>
        #define BMD_CONST __declspec(selectany) static const
</MACRO>
<TYPEDEF>
<NAME>BMDDeckLinkConfigurationID</NAME>
typedef uint32_t BMDDeckLinkConfigurationID;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkEncoderConfigurationID</NAME>
typedef uint32_t BMDDeckLinkEncoderConfigurationID;
</TYPEDEF>
<MACRO>
<NAME>BMD_CONST</NAME>
        #define BMD_CONST __declspec(selectany) static const
</MACRO>
<MACRO>
<NAME>BMD_CONST</NAME>
        #define BMD_CONST __declspec(selectany) static const
</MACRO>
<TYPEDEF>
<NAME>BMDDeckControlMode</NAME>
typedef uint32_t BMDDeckControlMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckControlEvent</NAME>
typedef uint32_t BMDDeckControlEvent;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckControlVTRControlState</NAME>
typedef uint32_t BMDDeckControlVTRControlState;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckControlStatusFlags</NAME>
typedef uint32_t BMDDeckControlStatusFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckControlExportModeOpsFlags</NAME>
typedef uint32_t BMDDeckControlExportModeOpsFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckControlError</NAME>
typedef uint32_t BMDDeckControlError;
</TYPEDEF>
<MACRO>
<NAME>BMD_CONST</NAME>
        #define BMD_CONST __declspec(selectany) static const
</MACRO>
<MACRO>
<NAME>BLACKMAGIC_DECKLINK_API_MAGIC</NAME>
#define BLACKMAGIC_DECKLINK_API_MAGIC	1
</MACRO>
<TYPEDEF>
<NAME>BMDVideoOutputFlags</NAME>
typedef uint32_t BMDVideoOutputFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDPacketType</NAME>
typedef uint32_t BMDPacketType;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDFrameFlags</NAME>
typedef uint32_t BMDFrameFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoInputFlags</NAME>
typedef uint32_t BMDVideoInputFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoInputFormatChangedEvents</NAME>
typedef uint32_t BMDVideoInputFormatChangedEvents;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDetectedVideoInputFormatFlags</NAME>
typedef uint32_t BMDDetectedVideoInputFormatFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkCapturePassthroughMode</NAME>
typedef uint32_t BMDDeckLinkCapturePassthroughMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDOutputFrameCompletionResult</NAME>
typedef uint32_t BMDOutputFrameCompletionResult;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDReferenceStatus</NAME>
typedef uint32_t BMDReferenceStatus;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAudioFormat</NAME>
typedef uint32_t BMDAudioFormat;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAudioSampleRate</NAME>
typedef uint32_t BMDAudioSampleRate;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAudioSampleType</NAME>
typedef uint32_t BMDAudioSampleType;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAudioOutputStreamType</NAME>
typedef uint32_t BMDAudioOutputStreamType;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDisplayModeSupport</NAME>
typedef uint32_t BMDDisplayModeSupport;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimecodeFormat</NAME>
typedef uint32_t BMDTimecodeFormat;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAnalogVideoFlags</NAME>
typedef uint32_t BMDAnalogVideoFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAudioOutputAnalogAESSwitch</NAME>
typedef uint32_t BMDAudioOutputAnalogAESSwitch;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoOutputConversionMode</NAME>
typedef uint32_t BMDVideoOutputConversionMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoInputConversionMode</NAME>
typedef uint32_t BMDVideoInputConversionMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideo3DPackingFormat</NAME>
typedef uint32_t BMDVideo3DPackingFormat;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDIdleVideoOutputOperation</NAME>
typedef uint32_t BMDIdleVideoOutputOperation;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoEncoderFrameCodingMode</NAME>
typedef uint32_t BMDVideoEncoderFrameCodingMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDNxHRLevel</NAME>
typedef uint32_t BMDDNxHRLevel;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDLinkConfiguration</NAME>
typedef uint32_t BMDLinkConfiguration;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeviceInterface</NAME>
typedef uint32_t BMDDeviceInterface;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkFrameMetadataID</NAME>
typedef uint32_t BMDDeckLinkFrameMetadataID;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDuplexMode</NAME>
typedef uint32_t BMDDuplexMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkAttributeID</NAME>
typedef uint32_t BMDDeckLinkAttributeID;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkAPIInformationID</NAME>
typedef uint32_t BMDDeckLinkAPIInformationID;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkStatusID</NAME>
typedef uint32_t BMDDeckLinkStatusID;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkVideoStatusFlags</NAME>
typedef uint32_t BMDDeckLinkVideoStatusFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDuplexStatus</NAME>
typedef uint32_t BMDDuplexStatus;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeviceBusyState</NAME>
typedef uint32_t BMDDeviceBusyState;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoIOSupport</NAME>
typedef uint32_t BMDVideoIOSupport;
</TYPEDEF>
<TYPEDEF>
<NAME>BMD3DPreviewFormat</NAME>
typedef uint32_t BMD3DPreviewFormat;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDNotifications</NAME>
typedef uint32_t BMDNotifications;
</TYPEDEF>
<FUNCTION>
<NAME>CreateDeckLinkIteratorInstance</NAME>
<RETURNS>IDeckLinkIterator * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CreateDeckLinkDiscoveryInstance</NAME>
<RETURNS>IDeckLinkDiscovery * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CreateDeckLinkAPIInformationInstance</NAME>
<RETURNS>IDeckLinkAPIInformation * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CreateOpenGLScreenPreviewHelper</NAME>
<RETURNS>IDeckLinkGLScreenPreviewHelper * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>CreateVideoConversionInstance</NAME>
<RETURNS>IDeckLinkVideoConversion * </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>BMD_CONST</NAME>
        #define BMD_CONST __declspec(selectany) static const
</MACRO>
<TYPEDEF>
<NAME>BMDDisplayMode</NAME>
typedef uint32_t BMDDisplayMode;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDFieldDominance</NAME>
typedef uint32_t BMDFieldDominance;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDPixelFormat</NAME>
typedef uint32_t BMDPixelFormat;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDisplayModeFlags</NAME>
typedef uint32_t BMDDisplayModeFlags;
</TYPEDEF>
<MACRO>
<NAME>BMD_CONST</NAME>
        #define BMD_CONST __declspec(selectany) static const
</MACRO>
<TYPEDEF>
<NAME>BMDTimeValue</NAME>
typedef int64_t BMDTimeValue;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimeScale</NAME>
typedef int64_t BMDTimeScale;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimecodeBCD</NAME>
typedef uint32_t BMDTimecodeBCD;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimecodeUserBits</NAME>
typedef uint32_t BMDTimecodeUserBits;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDTimecodeFlags</NAME>
typedef uint32_t BMDTimecodeFlags;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDVideoConnection</NAME>
typedef uint32_t BMDVideoConnection;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDAudioConnection</NAME>
typedef uint32_t BMDAudioConnection;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckControlConnection</NAME>
typedef uint32_t BMDDeckControlConnection;
</TYPEDEF>
<STRUCT>
<NAME>REFIID</NAME>
struct REFIID
{	
	unsigned char byte0;
	unsigned char byte1;
	unsigned char byte2;
	unsigned char byte3;
	unsigned char byte4;
	unsigned char byte5;
	unsigned char byte6;
	unsigned char byte7;
	unsigned char byte8;
	unsigned char byte9;
	unsigned char byte10;
	unsigned char byte11;
	unsigned char byte12;
	unsigned char byte13;
	unsigned char byte14;
	unsigned char byte15;
};
</STRUCT>
<TYPEDEF>
<NAME>CFUUIDBytes</NAME>
typedef REFIID CFUUIDBytes;
</TYPEDEF>
<MACRO>
<NAME>CFUUIDGetUUIDBytes</NAME>
#define CFUUIDGetUUIDBytes(x)	x
</MACRO>
<TYPEDEF>
<NAME>HRESULT</NAME>
typedef int HRESULT;
</TYPEDEF>
<TYPEDEF>
<NAME>ULONG</NAME>
typedef unsigned long ULONG;
</TYPEDEF>
<TYPEDEF>
<NAME>LPVOID</NAME>
typedef void *LPVOID;
</TYPEDEF>
<MACRO>
<NAME>SUCCEEDED</NAME>
#define SUCCEEDED(Status) ((HRESULT)(Status) >= 0)
</MACRO>
<MACRO>
<NAME>FAILED</NAME>
#define FAILED(Status) ((HRESULT)(Status)<0)
</MACRO>
<MACRO>
<NAME>IS_ERROR</NAME>
#define IS_ERROR(Status) ((unsigned long)(Status) >> 31 == SEVERITY_ERROR)
</MACRO>
<MACRO>
<NAME>HRESULT_CODE</NAME>
#define HRESULT_CODE(hr) ((hr) & 0xFFFF)
</MACRO>
<MACRO>
<NAME>HRESULT_FACILITY</NAME>
#define HRESULT_FACILITY(hr) (((hr) >> 16) & 0x1fff)
</MACRO>
<MACRO>
<NAME>HRESULT_SEVERITY</NAME>
#define HRESULT_SEVERITY(hr) (((hr) >> 31) & 0x1)
</MACRO>
<MACRO>
<NAME>SEVERITY_SUCCESS</NAME>
#define SEVERITY_SUCCESS 0
</MACRO>
<MACRO>
<NAME>SEVERITY_ERROR</NAME>
#define SEVERITY_ERROR 1
</MACRO>
<MACRO>
<NAME>MAKE_HRESULT</NAME>
#define MAKE_HRESULT(sev,fac,code) ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
</MACRO>
<MACRO>
<NAME>S_OK</NAME>
#define S_OK ((HRESULT)0x00000000L)
</MACRO>
<MACRO>
<NAME>S_FALSE</NAME>
#define S_FALSE ((HRESULT)0x00000001L)
</MACRO>
<MACRO>
<NAME>E_UNEXPECTED</NAME>
#define E_UNEXPECTED ((HRESULT)0x8000FFFFL)
</MACRO>
<MACRO>
<NAME>E_NOTIMPL</NAME>
#define E_NOTIMPL ((HRESULT)0x80000001L)
</MACRO>
<MACRO>
<NAME>E_OUTOFMEMORY</NAME>
#define E_OUTOFMEMORY ((HRESULT)0x80000002L)
</MACRO>
<MACRO>
<NAME>E_INVALIDARG</NAME>
#define E_INVALIDARG ((HRESULT)0x80000003L)
</MACRO>
<MACRO>
<NAME>E_NOINTERFACE</NAME>
#define E_NOINTERFACE ((HRESULT)0x80000004L)
</MACRO>
<MACRO>
<NAME>E_POINTER</NAME>
#define E_POINTER ((HRESULT)0x80000005L)
</MACRO>
<MACRO>
<NAME>E_HANDLE</NAME>
#define E_HANDLE ((HRESULT)0x80000006L)
</MACRO>
<MACRO>
<NAME>E_ABORT</NAME>
#define E_ABORT ((HRESULT)0x80000007L)
</MACRO>
<MACRO>
<NAME>E_FAIL</NAME>
#define E_FAIL ((HRESULT)0x80000008L)
</MACRO>
<MACRO>
<NAME>E_ACCESSDENIED</NAME>
#define E_ACCESSDENIED ((HRESULT)0x80000009L)
</MACRO>
<MACRO>
<NAME>STDMETHODCALLTYPE</NAME>
#define STDMETHODCALLTYPE
</MACRO>
<MACRO>
<NAME>IID_IUnknown</NAME>
#define IID_IUnknown		(REFIID){0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}
</MACRO>
<MACRO>
<NAME>IUnknownUUID</NAME>
#define IUnknownUUID		IID_IUnknown
</MACRO>
<MACRO>
<NAME>BMD_CONST</NAME>
        #define BMD_CONST __declspec(selectany) static const
</MACRO>
<TYPEDEF>
<NAME>BMDDeckLinkConfigurationID</NAME>
typedef uint32_t BMDDeckLinkConfigurationID;
</TYPEDEF>
<TYPEDEF>
<NAME>BMDDeckLinkEncoderConfigurationID</NAME>
typedef uint32_t BMDDeckLinkEncoderConfigurationID;
</TYPEDEF>
<MACRO>
<NAME>BMD_CONST</NAME>
        #define BMD_CONST __declspec(selectany) static const
</MACRO>
